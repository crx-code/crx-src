# Crex Engine

## Crex memory manager

### General

The goal of the new memory manager (available since CRX 5.2) is to reduce memory
allocation overhead and speedup memory management.

### Debugging

Normal:

```bash
sapi/cli/crx -r 'leak();'
```

Crex MM disabled:

```bash
USE_CREX_ALLOC=0 valgrind --leak-check=full sapi/cli/crx -r 'leak();'
```

### Shared extensions

Since CRX 5.3.11 it is possible to prevent shared extensions from unloading so
that valgrind can correctly track the memory leaks in shared extensions. For
this there is the `CREX_DONT_UNLOAD_MODULES` environment variable. If set, then
`DL_UNLOAD()` is skipped during the shutdown of shared extensions.

## CREX_VM

`CREX_VM` architecture allows specializing opcode handlers according to
`op_type` fields and using different execution methods (call threading, switch
threading and direct threading). As a result ZE2 got more than 20% speedup on
raw CRX code execution (with specialized executor and direct threading execution
method). As in most CRX applications raw execution speed isn't the limiting
factor but system calls and database calls are, your mileage with this patch
will vary.

Most parts of the old crex_execute.c go into `crex_vm_def.h`. Here you can find
opcode handlers and helpers. The typical opcode handler template looks like
this:

```c
CREX_VM_HANDLER(<OPCODE-NUMBER>, <OPCODE>, <OP1_TYPES>, <OP2_TYPES>)
{
    <HANDLER'S CODE>
}
```

`<OPCODE-NUMBER>` is a opcode number (0, 1, ...)
`<OPCODE>` is an opcode name (ZEN_NOP, CREX_ADD, :)
`<OP1_TYPES>` and `<OP2_TYPES>` are masks for allowed operand op_types.
Specializer will generate code only for defined combination of types. You can
use any combination of the following op_types UNUSED, CONST, VAR, TMP and CV
also you can use ANY mask to disable specialization according operand's op_type.
`<HANDLER'S CODE>` is a handler's code itself. For most handlers it stills the
same as in old `crex_execute.c`, but now it uses macros to access opcode
operands and some internal executor data.

You can see the conformity of new macros to old code in the following list:

```c
EXECUTE_DATA
    execute_data
CREX_VM_DISPATCH_TO_HANDLER(<OP>)
    return <OP>_helper(CREX_OPCODE_HANDLER_ARGS_PASSTHRU)
CREX_VM_DISPATCH_TO_HELPER(<NAME>)
    return <NAME>(CREX_OPCODE_HANDLER_ARGS_PASSTHRU)
CREX_VM_DISPATCH_TO_HELPER_EX(<NAME>,<PARAM>,<VAL>)
    return <NAME>(<VAL>, CREX_OPCODE_HANDLER_ARGS_PASSTHRU)
CREX_VM_CONTINUE()
    return 0
CREX_VM_NEXT_OPCODE()
    NEXT_OPCODE()
CREX_VM_SET_OPCODE(<TARGET>
    SET_OPCODE(<TARGET>
CREX_VM_INC_OPCODE()
    INC_OPCOD()
CREX_VM_RETURN_FROM_EXECUTE_LOOP()
    RETURN_FROM_EXECUTE_LOOP()
CREX_VM_C_LABEL(<LABEL>):
    <LABEL>:
CREX_VM_C_GOTO(<LABEL>)
    goto <LABEL>
OP<X>_TYPE
    opline->op<X>.op_type
GET_OP<X>_ZVAL_PTR(<TYPE>)
    get_zval_ptr(&opline->op<X>, EX(Ts), &free_op<X>, <TYPE>)
GET_OP<X>_ZVAL_PTR_PTR(<TYPE>)
    get_zval_ptr_ptr(&opline->op<X>, EX(Ts), &free_op<X>, <TYPE>)
GET_OP<X>_OBJ_ZVAL_PTR(<TYPE>)
    get_obj_zval_ptr(&opline->op<X>, EX(Ts), &free_op<X>, <TYPE>)
GET_OP<X>_OBJ_ZVAL_PTR_PTR(<TYPE>)
    get_obj_zval_ptr_ptr(&opline->op<X>, EX(Ts), &free_op<X>, <TYPE>)
IS_OP<X>_TMP_FREE()
    IS_TMP_FREE(free_op<X>)
FREE_OP<X>()
    FREE_OP(free_op<X>)
FREE_OP<X>_IF_VAR()
    FREE_VAR(free_op<X>)
FREE_OP<X>_VAR_PTR()
    FREE_VAR_PTR(free_op<X>)
```

Executor's helpers can be defined without parameters or with one parameter. This
is done with the following constructs:

```c
CREX_VM_HELPER(<HELPER-NAME>, <OP1_TYPES>, <OP2_TYPES>)
{
    <HELPER'S CODE>
}

CREX_VM_HELPER_EX(<HELPER-NAME>, <OP1_TYPES>, <OP2_TYPES>, <PARAM_SPEC>)
{
    <HELPER'S CODE>
}
```

The executors code is generated by the CRX script `crex_vm_gen.crx`. It uses
`crex_vm_def.h` and `crex_vm_execute.skl` as input and produces
`crex_vm_opcodes.h` and `crex_vm_execute.h`. The first file is a list of opcode
definitions. It is included from `crex_compile.h`. The second one is an executor
code itself. It is included from `crex_execute.c`.

`crex_vm_gen.crx` can produce different kind of executors. You can select a
different opcode threading model using `--with-vm-kind=CALL|SWITCH|GOTO|HYBRID`.
You can disable opcode specialization using `--without-specializer`.
At last you can debug the executor using the original `crex_vm_def.h` or the
generated `crex_vm_execute.h` file. Debugging with the original file requires
the `--with-lines` option. By default, Crex Engine uses the following
command to generate the executor:

```bash
# Default VM kind is HYBRID
crx crex_vm_gen.crx --with-vm-kind=HYBRID
```
