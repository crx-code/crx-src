/*
   +----------------------------------------------------------------------+
   | Crex Engine                                                          |
   +----------------------------------------------------------------------+
   | Copyright (c) Crex Technologies Ltd. (http://www.crex.com)           |
   +----------------------------------------------------------------------+
   | This source file is subject to version 2.00 of the Crex license,     |
   | that is bundled with this package in the file LICENSE, and is        |
   | available through the world-wide-web at the following url:           |
   | http://www.crex.com/license/2_00.txt.                                |
   | If you did not receive a copy of the Crex license and are unable to  |
   | obtain it through the world-wide-web, please send a note to          |
   | license@crex.com so we can mail you a copy immediately.              |
   +----------------------------------------------------------------------+
   | Authors: Andi Gutmans <andi@crx.net>                                 |
   |          Zeev Suraski <zeev@crx.net>                                 |
   |          Dmitry Stogov <dmitry@crx.net>                              |
   +----------------------------------------------------------------------+
*/

#ifdef CREX_WIN32
# pragma warning(disable : 4101)
# pragma warning(once : 6235)
# pragma warning(once : 6237)
# pragma warning(once : 6239)
# pragma warning(once : 6240)
# pragma warning(once : 6285)
# pragma warning(once : 6286)
# pragma warning(once : 6326)
#endif
static user_opcode_handler_t crex_user_opcode_handlers[256] = {
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL
};

static uint8_t crex_user_opcodes[256] = {0,
	1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,
	17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,
	33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,
	49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,
	65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,
	81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,
	97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,
	113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,
	129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,
	145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,
	161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,
	177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,
	193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,
	209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,
	225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,
	241,242,243,244,245,246,247,248,249,250,251,252,253,254,255
};

#define SPEC_START_MASK        0x0000ffff
#define SPEC_EXTRA_MASK        0xfffc0000
#define SPEC_RULE_OP1          0x00010000
#define SPEC_RULE_OP2          0x00020000
#define SPEC_RULE_OP_DATA      0x00040000
#define SPEC_RULE_RETVAL       0x00080000
#define SPEC_RULE_QUICK_ARG    0x00100000
#define SPEC_RULE_SMART_BRANCH 0x00200000
#define SPEC_RULE_COMMUTATIVE  0x00800000
#define SPEC_RULE_ISSET        0x01000000
#define SPEC_RULE_OBSERVER     0x02000000

static const uint32_t *crex_spec_handlers;
static const void * const *crex_opcode_handlers;
static int crex_handlers_count;
#if (CREX_VM_KIND == CREX_VM_KIND_HYBRID)
static const void * const * crex_opcode_handler_funcs;
static crex_op hybrid_halt_op;
#endif
#if (CREX_VM_KIND != CREX_VM_KIND_HYBRID) || !CREX_VM_SPEC
static const void *crex_vm_get_opcode_handler(uint8_t opcode, const crex_op* op);
#endif

#if (CREX_VM_KIND == CREX_VM_KIND_HYBRID)
static const void *crex_vm_get_opcode_handler_func(uint8_t opcode, const crex_op* op);
#else
# define crex_vm_get_opcode_handler_func crex_vm_get_opcode_handler
#endif

#ifndef VM_TRACE
# define VM_TRACE(op)
#endif
#ifndef VM_TRACE_START
# define VM_TRACE_START()
#endif
#ifndef VM_TRACE_END
# define VM_TRACE_END()
#endif
#if (CREX_VM_KIND == CREX_VM_KIND_HYBRID)
#define HYBRID_NEXT()     goto *(void**)(OPLINE->handler)
#define HYBRID_SWITCH()   HYBRID_NEXT();
#define HYBRID_CASE(op)   op ## _LABEL
#define HYBRID_BREAK()    HYBRID_NEXT()
#define HYBRID_DEFAULT    CREX_NULL_LABEL
#endif

#ifdef CREX_VM_FP_GLOBAL_REG
# define CREX_OPCODE_HANDLER_ARGS void
# define CREX_OPCODE_HANDLER_ARGS_PASSTHRU
# define CREX_OPCODE_HANDLER_ARGS_DC
# define CREX_OPCODE_HANDLER_ARGS_PASSTHRU_CC
#else
# define CREX_OPCODE_HANDLER_ARGS crex_execute_data *execute_data
# define CREX_OPCODE_HANDLER_ARGS_PASSTHRU execute_data
# define CREX_OPCODE_HANDLER_ARGS_DC , CREX_OPCODE_HANDLER_ARGS
# define CREX_OPCODE_HANDLER_ARGS_PASSTHRU_CC , CREX_OPCODE_HANDLER_ARGS_PASSTHRU
#endif

#if defined(CREX_VM_FP_GLOBAL_REG) && defined(CREX_VM_IP_GLOBAL_REG)
# define CREX_OPCODE_HANDLER_RET void
# define CREX_VM_TAIL_CALL(call) call; return
# ifdef CREX_VM_TAIL_CALL_DISPATCH
#  define CREX_VM_CONTINUE()     ((opcode_handler_t)OPLINE->handler)(CREX_OPCODE_HANDLER_ARGS_PASSTHRU); return
# else
#  define CREX_VM_CONTINUE()     return
# endif
# if (CREX_VM_KIND == CREX_VM_KIND_HYBRID)
#  define CREX_VM_RETURN()        opline = &hybrid_halt_op; return
#  define CREX_VM_HOT             crex_always_inline CREX_COLD CREX_OPT_SIZE
#  define CREX_VM_COLD            CREX_COLD CREX_OPT_SIZE
# else
#  define CREX_VM_RETURN()        opline = NULL; return
#  define CREX_VM_HOT
#  define CREX_VM_COLD            CREX_COLD CREX_OPT_SIZE
# endif
#else
# define CREX_OPCODE_HANDLER_RET int
# define CREX_VM_TAIL_CALL(call) return call
# define CREX_VM_CONTINUE()      return  0
# define CREX_VM_RETURN()        return -1
# define CREX_VM_HOT
# define CREX_VM_COLD            CREX_COLD CREX_OPT_SIZE
#endif

typedef CREX_OPCODE_HANDLER_RET (CREX_FASTCALL *opcode_handler_t) (CREX_OPCODE_HANDLER_ARGS);

#define DCL_OPLINE
#ifdef CREX_VM_IP_GLOBAL_REG
# define OPLINE opline
# define USE_OPLINE
# define LOAD_OPLINE() opline = EX(opline)
# define LOAD_OPLINE_EX()
# define LOAD_NEXT_OPLINE() opline = EX(opline) + 1
# define SAVE_OPLINE() EX(opline) = opline
# define SAVE_OPLINE_EX() SAVE_OPLINE()
#else
# define OPLINE EX(opline)
# define USE_OPLINE const crex_op *opline = EX(opline);
# define LOAD_OPLINE()
# define LOAD_OPLINE_EX()
# define LOAD_NEXT_OPLINE() CREX_VM_INC_OPCODE()
# define SAVE_OPLINE()
# define SAVE_OPLINE_EX()
#endif
#define HANDLE_EXCEPTION() CREX_ASSERT(EG(exception)); LOAD_OPLINE(); CREX_VM_CONTINUE()
#define HANDLE_EXCEPTION_LEAVE() CREX_ASSERT(EG(exception)); LOAD_OPLINE(); CREX_VM_LEAVE()
#if defined(CREX_VM_FP_GLOBAL_REG)
# define CREX_VM_ENTER_EX()        CREX_VM_INTERRUPT_CHECK(); CREX_VM_CONTINUE()
# define CREX_VM_ENTER()           execute_data = EG(current_execute_data); LOAD_OPLINE(); CREX_VM_ENTER_EX()
# define CREX_VM_LEAVE()           CREX_VM_CONTINUE()
#elif defined(CREX_VM_IP_GLOBAL_REG)
# define CREX_VM_ENTER_EX()        return  1
# define CREX_VM_ENTER()           opline = EG(current_execute_data)->opline; CREX_VM_ENTER_EX()
# define CREX_VM_LEAVE()           return  2
#else
# define CREX_VM_ENTER_EX()        return  1
# define CREX_VM_ENTER()           return  1
# define CREX_VM_LEAVE()           return  2
#endif
#define CREX_VM_INTERRUPT()      CREX_VM_TAIL_CALL(crex_interrupt_helper_SPEC(CREX_OPCODE_HANDLER_ARGS_PASSTHRU));
#define CREX_VM_LOOP_INTERRUPT() crex_interrupt_helper_SPEC(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
#define CREX_VM_DISPATCH(opcode, opline) CREX_VM_TAIL_CALL(((opcode_handler_t)crex_vm_get_opcode_handler_func(opcode, opline))(CREX_OPCODE_HANDLER_ARGS_PASSTHRU));

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL crex_interrupt_helper_SPEC(CREX_OPCODE_HANDLER_ARGS);
static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_NULL_HANDLER(CREX_OPCODE_HANDLER_ARGS);

static crex_never_inline CREX_OPCODE_HANDLER_RET CREX_FASTCALL crex_add_helper_SPEC(zval *op_1, zval *op_2 CREX_OPCODE_HANDLER_ARGS_DC)
{
	USE_OPLINE

	SAVE_OPLINE();
	if (UNEXPECTED(C_TYPE_INFO_P(op_1) == IS_UNDEF)) {
		op_1 = ZVAL_UNDEFINED_OP1();
	}
	if (UNEXPECTED(C_TYPE_INFO_P(op_2) == IS_UNDEF)) {
		op_2 = ZVAL_UNDEFINED_OP2();
	}
	add_function(EX_VAR(opline->result.var), op_1, op_2);
	if (opline->op1_type & (IS_TMP_VAR|IS_VAR)) {
		zval_ptr_dtor_nogc(op_1);
	}
	if (opline->op2_type & (IS_TMP_VAR|IS_VAR)) {
		zval_ptr_dtor_nogc(op_2);
	}
	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static crex_never_inline CREX_OPCODE_HANDLER_RET CREX_FASTCALL crex_sub_helper_SPEC(zval *op_1, zval *op_2 CREX_OPCODE_HANDLER_ARGS_DC)
{
	USE_OPLINE

	SAVE_OPLINE();
	if (UNEXPECTED(C_TYPE_INFO_P(op_1) == IS_UNDEF)) {
		op_1 = ZVAL_UNDEFINED_OP1();
	}
	if (UNEXPECTED(C_TYPE_INFO_P(op_2) == IS_UNDEF)) {
		op_2 = ZVAL_UNDEFINED_OP2();
	}
	sub_function(EX_VAR(opline->result.var), op_1, op_2);
	if (opline->op1_type & (IS_TMP_VAR|IS_VAR)) {
		zval_ptr_dtor_nogc(op_1);
	}
	if (opline->op2_type & (IS_TMP_VAR|IS_VAR)) {
		zval_ptr_dtor_nogc(op_2);
	}
	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static crex_never_inline CREX_OPCODE_HANDLER_RET CREX_FASTCALL crex_mul_helper_SPEC(zval *op_1, zval *op_2 CREX_OPCODE_HANDLER_ARGS_DC)
{
	USE_OPLINE

	SAVE_OPLINE();
	if (UNEXPECTED(C_TYPE_INFO_P(op_1) == IS_UNDEF)) {
		op_1 = ZVAL_UNDEFINED_OP1();
	}
	if (UNEXPECTED(C_TYPE_INFO_P(op_2) == IS_UNDEF)) {
		op_2 = ZVAL_UNDEFINED_OP2();
	}
	mul_function(EX_VAR(opline->result.var), op_1, op_2);
	if (opline->op1_type & (IS_TMP_VAR|IS_VAR)) {
		zval_ptr_dtor_nogc(op_1);
	}
	if (opline->op2_type & (IS_TMP_VAR|IS_VAR)) {
		zval_ptr_dtor_nogc(op_2);
	}
	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static crex_never_inline CREX_COLD CREX_OPCODE_HANDLER_RET CREX_FASTCALL crex_mod_by_zero_helper_SPEC(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	SAVE_OPLINE();
	crex_throw_exception_ex(crex_ce_division_by_zero_error, 0, "Modulo by zero");
	ZVAL_UNDEF(EX_VAR(opline->result.var));
	HANDLE_EXCEPTION();
}

static crex_never_inline CREX_OPCODE_HANDLER_RET CREX_FASTCALL crex_mod_helper_SPEC(zval *op_1, zval *op_2 CREX_OPCODE_HANDLER_ARGS_DC)
{
	USE_OPLINE

	SAVE_OPLINE();
	if (UNEXPECTED(C_TYPE_INFO_P(op_1) == IS_UNDEF)) {
		op_1 = ZVAL_UNDEFINED_OP1();
	}
	if (UNEXPECTED(C_TYPE_INFO_P(op_2) == IS_UNDEF)) {
		op_2 = ZVAL_UNDEFINED_OP2();
	}
	mod_function(EX_VAR(opline->result.var), op_1, op_2);
	if (opline->op1_type & (IS_TMP_VAR|IS_VAR)) {
		zval_ptr_dtor_nogc(op_1);
	}
	if (opline->op2_type & (IS_TMP_VAR|IS_VAR)) {
		zval_ptr_dtor_nogc(op_2);
	}
	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static crex_never_inline CREX_OPCODE_HANDLER_RET CREX_FASTCALL crex_shift_left_helper_SPEC(zval *op_1, zval *op_2 CREX_OPCODE_HANDLER_ARGS_DC)
{
	USE_OPLINE

	SAVE_OPLINE();
	if (UNEXPECTED(C_TYPE_INFO_P(op_1) == IS_UNDEF)) {
		op_1 = ZVAL_UNDEFINED_OP1();
	}
	if (UNEXPECTED(C_TYPE_INFO_P(op_2) == IS_UNDEF)) {
		op_2 = ZVAL_UNDEFINED_OP2();
	}
	shift_left_function(EX_VAR(opline->result.var), op_1, op_2);
	if (opline->op1_type & (IS_TMP_VAR|IS_VAR)) {
		zval_ptr_dtor_nogc(op_1);
	}
	if (opline->op2_type & (IS_TMP_VAR|IS_VAR)) {
		zval_ptr_dtor_nogc(op_2);
	}
	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static crex_never_inline CREX_OPCODE_HANDLER_RET CREX_FASTCALL crex_shift_right_helper_SPEC(zval *op_1, zval *op_2 CREX_OPCODE_HANDLER_ARGS_DC)
{
	USE_OPLINE

	SAVE_OPLINE();
	if (UNEXPECTED(C_TYPE_INFO_P(op_1) == IS_UNDEF)) {
		op_1 = ZVAL_UNDEFINED_OP1();
	}
	if (UNEXPECTED(C_TYPE_INFO_P(op_2) == IS_UNDEF)) {
		op_2 = ZVAL_UNDEFINED_OP2();
	}
	shift_right_function(EX_VAR(opline->result.var), op_1, op_2);
	if (opline->op1_type & (IS_TMP_VAR|IS_VAR)) {
		zval_ptr_dtor_nogc(op_1);
	}
	if (opline->op2_type & (IS_TMP_VAR|IS_VAR)) {
		zval_ptr_dtor_nogc(op_2);
	}
	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static crex_never_inline CREX_OPCODE_HANDLER_RET CREX_FASTCALL crex_is_equal_helper_SPEC(zval *op_1, zval *op_2 CREX_OPCODE_HANDLER_ARGS_DC)
{
	int ret;
	USE_OPLINE

	SAVE_OPLINE();
	if (UNEXPECTED(C_TYPE_INFO_P(op_1) == IS_UNDEF)) {
		op_1 = ZVAL_UNDEFINED_OP1();
	}
	if (UNEXPECTED(C_TYPE_INFO_P(op_2) == IS_UNDEF)) {
		op_2 = ZVAL_UNDEFINED_OP2();
	}
	ret = crex_compare(op_1, op_2);
	if (opline->op1_type & (IS_TMP_VAR|IS_VAR)) {
		zval_ptr_dtor_nogc(op_1);
	}
	if (opline->op2_type & (IS_TMP_VAR|IS_VAR)) {
		zval_ptr_dtor_nogc(op_2);
	}
	CREX_VM_SMART_BRANCH(ret == 0, 1);
}

static crex_never_inline CREX_OPCODE_HANDLER_RET CREX_FASTCALL crex_is_not_equal_helper_SPEC(zval *op_1, zval *op_2 CREX_OPCODE_HANDLER_ARGS_DC)
{
	int ret;
	USE_OPLINE

	SAVE_OPLINE();
	if (UNEXPECTED(C_TYPE_INFO_P(op_1) == IS_UNDEF)) {
		op_1 = ZVAL_UNDEFINED_OP1();
	}
	if (UNEXPECTED(C_TYPE_INFO_P(op_2) == IS_UNDEF)) {
		op_2 = ZVAL_UNDEFINED_OP2();
	}
	ret = crex_compare(op_1, op_2);
	if (opline->op1_type & (IS_TMP_VAR|IS_VAR)) {
		zval_ptr_dtor_nogc(op_1);
	}
	if (opline->op2_type & (IS_TMP_VAR|IS_VAR)) {
		zval_ptr_dtor_nogc(op_2);
	}
	CREX_VM_SMART_BRANCH(ret != 0, 1);
}

static crex_never_inline CREX_OPCODE_HANDLER_RET CREX_FASTCALL crex_is_smaller_helper_SPEC(zval *op_1, zval *op_2 CREX_OPCODE_HANDLER_ARGS_DC)
{
	int ret;
	USE_OPLINE

	SAVE_OPLINE();
	if (UNEXPECTED(C_TYPE_INFO_P(op_1) == IS_UNDEF)) {
		op_1 = ZVAL_UNDEFINED_OP1();
	}
	if (UNEXPECTED(C_TYPE_INFO_P(op_2) == IS_UNDEF)) {
		op_2 = ZVAL_UNDEFINED_OP2();
	}
	ret = crex_compare(op_1, op_2);
	if (opline->op1_type & (IS_TMP_VAR|IS_VAR)) {
		zval_ptr_dtor_nogc(op_1);
	}
	if (opline->op2_type & (IS_TMP_VAR|IS_VAR)) {
		zval_ptr_dtor_nogc(op_2);
	}
	CREX_VM_SMART_BRANCH(ret < 0, 1);
}

static crex_never_inline CREX_OPCODE_HANDLER_RET CREX_FASTCALL crex_is_smaller_or_equal_helper_SPEC(zval *op_1, zval *op_2 CREX_OPCODE_HANDLER_ARGS_DC)
{
	int ret;
	USE_OPLINE

	SAVE_OPLINE();
	if (UNEXPECTED(C_TYPE_INFO_P(op_1) == IS_UNDEF)) {
		op_1 = ZVAL_UNDEFINED_OP1();
	}
	if (UNEXPECTED(C_TYPE_INFO_P(op_2) == IS_UNDEF)) {
		op_2 = ZVAL_UNDEFINED_OP2();
	}
	ret = crex_compare(op_1, op_2);
	if (opline->op1_type & (IS_TMP_VAR|IS_VAR)) {
		zval_ptr_dtor_nogc(op_1);
	}
	if (opline->op2_type & (IS_TMP_VAR|IS_VAR)) {
		zval_ptr_dtor_nogc(op_2);
	}
	CREX_VM_SMART_BRANCH(ret <= 0, 1);
}

static crex_never_inline CREX_OPCODE_HANDLER_RET CREX_FASTCALL crex_bw_or_helper_SPEC(zval *op_1, zval *op_2 CREX_OPCODE_HANDLER_ARGS_DC)
{
	USE_OPLINE

	SAVE_OPLINE();
	if (UNEXPECTED(C_TYPE_INFO_P(op_1) == IS_UNDEF)) {
		op_1 = ZVAL_UNDEFINED_OP1();
	}
	if (UNEXPECTED(C_TYPE_INFO_P(op_2) == IS_UNDEF)) {
		op_2 = ZVAL_UNDEFINED_OP2();
	}
	bitwise_or_function(EX_VAR(opline->result.var), op_1, op_2);
	if (opline->op1_type & (IS_TMP_VAR|IS_VAR)) {
		zval_ptr_dtor_nogc(op_1);
	}
	if (opline->op2_type & (IS_TMP_VAR|IS_VAR)) {
		zval_ptr_dtor_nogc(op_2);
	}
	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static crex_never_inline CREX_OPCODE_HANDLER_RET CREX_FASTCALL crex_bw_and_helper_SPEC(zval *op_1, zval *op_2 CREX_OPCODE_HANDLER_ARGS_DC)
{
	USE_OPLINE

	SAVE_OPLINE();
	if (UNEXPECTED(C_TYPE_INFO_P(op_1) == IS_UNDEF)) {
		op_1 = ZVAL_UNDEFINED_OP1();
	}
	if (UNEXPECTED(C_TYPE_INFO_P(op_2) == IS_UNDEF)) {
		op_2 = ZVAL_UNDEFINED_OP2();
	}
	bitwise_and_function(EX_VAR(opline->result.var), op_1, op_2);
	if (opline->op1_type & (IS_TMP_VAR|IS_VAR)) {
		zval_ptr_dtor_nogc(op_1);
	}
	if (opline->op2_type & (IS_TMP_VAR|IS_VAR)) {
		zval_ptr_dtor_nogc(op_2);
	}
	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static crex_never_inline CREX_OPCODE_HANDLER_RET CREX_FASTCALL crex_bw_xor_helper_SPEC(zval *op_1, zval *op_2 CREX_OPCODE_HANDLER_ARGS_DC)
{
	USE_OPLINE

	SAVE_OPLINE();
	if (UNEXPECTED(C_TYPE_INFO_P(op_1) == IS_UNDEF)) {
		op_1 = ZVAL_UNDEFINED_OP1();
	}
	if (UNEXPECTED(C_TYPE_INFO_P(op_2) == IS_UNDEF)) {
		op_2 = ZVAL_UNDEFINED_OP2();
	}
	bitwise_xor_function(EX_VAR(opline->result.var), op_1, op_2);
	if (opline->op1_type & (IS_TMP_VAR|IS_VAR)) {
		zval_ptr_dtor_nogc(op_1);
	}
	if (opline->op2_type & (IS_TMP_VAR|IS_VAR)) {
		zval_ptr_dtor_nogc(op_2);
	}
	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static crex_never_inline CREX_OPCODE_HANDLER_RET CREX_FASTCALL crex_bw_not_helper_SPEC(zval *op_1 CREX_OPCODE_HANDLER_ARGS_DC)
{
	USE_OPLINE

	SAVE_OPLINE();
	if (UNEXPECTED(C_TYPE_P(op_1) == IS_UNDEF)) {
		op_1 = ZVAL_UNDEFINED_OP1();
	}
	bitwise_not_function(EX_VAR(opline->result.var), op_1);
	FREE_OP(opline->op1_type, opline->op1.var);
	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static crex_never_inline CREX_COLD CREX_OPCODE_HANDLER_RET CREX_FASTCALL crex_this_not_in_object_context_helper_SPEC(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	SAVE_OPLINE();
	crex_throw_error(NULL, "Using $this when not in object context");
	UNDEF_RESULT();
	HANDLE_EXCEPTION();
}

static crex_never_inline CREX_COLD CREX_OPCODE_HANDLER_RET CREX_FASTCALL crex_undefined_function_helper_SPEC(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *function_name;

	SAVE_OPLINE();
	function_name = RT_CONSTANT(opline, opline->op2);
	crex_throw_error(NULL, "Call to undefined function %s()", C_STRVAL_P(function_name));
	HANDLE_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ASSIGN_STATIC_PROP_OP_SPEC_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	/* This helper actually never will receive IS_VAR as second op, and has the same handling for VAR and TMP in the first op, but for interoperability with the other binary_assign_op helpers, it is necessary to "include" it */

	USE_OPLINE
	zval *prop, *value;
	crex_property_info *prop_info;
	crex_reference *ref;

	SAVE_OPLINE();

	if (UNEXPECTED(crex_fetch_static_property_address(&prop, &prop_info, (opline+1)->extended_value, BP_VAR_RW, 0 OPLINE_CC EXECUTE_DATA_CC) != SUCCESS)) {
		UNDEF_RESULT();
		FREE_OP((opline+1)->op1_type, (opline+1)->op1.var);
		HANDLE_EXCEPTION();
	}

	value = get_op_data_zval_ptr_r((opline+1)->op1_type, (opline+1)->op1);

	do {
		if (UNEXPECTED(C_ISREF_P(prop))) {
			ref = C_REF_P(prop);
			prop = C_REFVAL_P(prop);
			if (UNEXPECTED(CREX_REF_HAS_TYPE_SOURCES(ref))) {
				crex_binary_assign_op_typed_ref(ref, value OPLINE_CC EXECUTE_DATA_CC);
				break;
			}
		}

		if (UNEXPECTED(CREX_TYPE_IS_SET(prop_info->type))) {
			/* special case for typed properties */
			crex_binary_assign_op_typed_prop(prop_info, prop, value OPLINE_CC EXECUTE_DATA_CC);
		} else {
			crex_binary_op(prop, prop, value OPLINE_CC);
		}
	} while (0);

	if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
		ZVAL_COPY(EX_VAR(opline->result.var), prop);
	}

	FREE_OP((opline+1)->op1_type, (opline+1)->op1.var);
	/* assign_static_prop has two opcodes! */
	CREX_VM_NEXT_OPCODE_EX(1, 2);
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_PRE_INC_STATIC_PROP_SPEC_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *prop;
	crex_property_info *prop_info;

	SAVE_OPLINE();

	if (crex_fetch_static_property_address(&prop, &prop_info, opline->extended_value, BP_VAR_RW, 0 OPLINE_CC EXECUTE_DATA_CC) != SUCCESS) {
		UNDEF_RESULT();
		HANDLE_EXCEPTION();
	}

	crex_pre_incdec_property_zval(prop,
		CREX_TYPE_IS_SET(prop_info->type) ? prop_info : NULL OPLINE_CC EXECUTE_DATA_CC);

	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

/* No specialization for op_types (CONST|TMPVAR|CV, UNUSED|CONST|VAR) */
static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_POST_INC_STATIC_PROP_SPEC_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *prop;
	crex_property_info *prop_info;

	SAVE_OPLINE();

	if (crex_fetch_static_property_address(&prop, &prop_info, opline->extended_value, BP_VAR_RW, 0 OPLINE_CC EXECUTE_DATA_CC) != SUCCESS) {
		UNDEF_RESULT();
		HANDLE_EXCEPTION();
	}

	crex_post_incdec_property_zval(prop,
		CREX_TYPE_IS_SET(prop_info->type) ? prop_info : NULL OPLINE_CC EXECUTE_DATA_CC);

	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

/* No specialization for op_types (CONST|TMPVAR|CV, UNUSED|CONST|VAR) */
static crex_never_inline CREX_OPCODE_HANDLER_RET CREX_FASTCALL crex_fetch_static_prop_helper_SPEC(int type CREX_OPCODE_HANDLER_ARGS_DC)
{
	USE_OPLINE
	zval *prop;

	SAVE_OPLINE();

	if (UNEXPECTED(crex_fetch_static_property_address(&prop, NULL, opline->extended_value & ~CREX_FETCH_OBJ_FLAGS, type, opline->extended_value OPLINE_CC EXECUTE_DATA_CC) != SUCCESS)) {
		CREX_ASSERT(EG(exception) || (type == BP_VAR_IS));
		prop = &EG(uninitialized_zval);
	}

	if (type == BP_VAR_R || type == BP_VAR_IS) {
		ZVAL_COPY_DEREF(EX_VAR(opline->result.var), prop);
	} else {
		ZVAL_INDIRECT(EX_VAR(opline->result.var), prop);
	}
	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

/* No specialization for op_types (CONST|TMPVAR|CV, UNUSED|CLASS_FETCH|CONST|VAR) */
static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FETCH_STATIC_PROP_R_SPEC_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	CREX_VM_TAIL_CALL(crex_fetch_static_prop_helper_SPEC(BP_VAR_R CREX_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

/* No specialization for op_types (CONST|TMPVAR|CV, UNUSED|CLASS_FETCH|CONST|VAR) */
static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FETCH_STATIC_PROP_W_SPEC_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	CREX_VM_TAIL_CALL(crex_fetch_static_prop_helper_SPEC(BP_VAR_W CREX_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

/* No specialization for op_types (CONST|TMPVAR|CV, UNUSED|CLASS_FETCH|CONST|VAR) */
static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FETCH_STATIC_PROP_RW_SPEC_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	CREX_VM_TAIL_CALL(crex_fetch_static_prop_helper_SPEC(BP_VAR_RW CREX_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

/* No specialization for op_types (CONST|TMPVAR|CV, UNUSED|CLASS_FETCH|CONST|VAR) */
static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FETCH_STATIC_PROP_FUNC_ARG_SPEC_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	int fetch_type =
		(UNEXPECTED(CREX_CALL_INFO(EX(call)) & CREX_CALL_SEND_ARG_BY_REF)) ?
			BP_VAR_W : BP_VAR_R;
	CREX_VM_TAIL_CALL(crex_fetch_static_prop_helper_SPEC(fetch_type CREX_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

/* No specialization for op_types (CONST|TMPVAR|CV, UNUSED|CLASS_FETCH|CONST|VAR) */
static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FETCH_STATIC_PROP_UNSET_SPEC_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	CREX_VM_TAIL_CALL(crex_fetch_static_prop_helper_SPEC(BP_VAR_UNSET CREX_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

/* No specialization for op_types (CONST|TMPVAR|CV, UNUSED|CLASS_FETCH|CONST|VAR) */
static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FETCH_STATIC_PROP_IS_SPEC_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	CREX_VM_TAIL_CALL(crex_fetch_static_prop_helper_SPEC(BP_VAR_IS CREX_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static crex_never_inline CREX_COLD CREX_OPCODE_HANDLER_RET CREX_FASTCALL crex_use_tmp_in_write_context_helper_SPEC(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	SAVE_OPLINE();
	crex_throw_error(NULL, "Cannot use temporary expression in write context");
	FREE_OP(opline->op2_type, opline->op2.var);
	FREE_OP(opline->op1_type, opline->op1.var);
	ZVAL_UNDEF(EX_VAR(opline->result.var));
	HANDLE_EXCEPTION();
}

static crex_never_inline CREX_COLD CREX_OPCODE_HANDLER_RET CREX_FASTCALL crex_use_undef_in_read_context_helper_SPEC(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	SAVE_OPLINE();
	crex_throw_error(NULL, "Cannot use [] for reading");
	FREE_OP(opline->op2_type, opline->op2.var);
	FREE_OP(opline->op1_type, opline->op1.var);
	ZVAL_UNDEF(EX_VAR(opline->result.var));
	HANDLE_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ASSIGN_STATIC_PROP_SPEC_OP_DATA_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *prop, *value;
	crex_property_info *prop_info;
	crex_refcounted *garbage = NULL;

	SAVE_OPLINE();

	if (crex_fetch_static_property_address(&prop, &prop_info, opline->extended_value, BP_VAR_W, 0 OPLINE_CC EXECUTE_DATA_CC) != SUCCESS) {

		UNDEF_RESULT();
		HANDLE_EXCEPTION();
	}

	value = RT_CONSTANT((opline+1), (opline+1)->op1);

	if (UNEXPECTED(CREX_TYPE_IS_SET(prop_info->type))) {
		value = crex_assign_to_typed_prop(prop_info, prop, value, &garbage EXECUTE_DATA_CC);

	} else {
		value = crex_assign_to_variable_ex(prop, value, IS_CONST, EX_USES_STRICT_TYPES(), &garbage);
	}

	if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
		ZVAL_COPY(EX_VAR(opline->result.var), value);
	}

	if (garbage) {
		GC_DTOR_NO_REF(garbage);
	}

	/* assign_static_prop has two opcodes! */
	CREX_VM_NEXT_OPCODE_EX(1, 2);
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ASSIGN_STATIC_PROP_SPEC_OP_DATA_TMP_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *prop, *value;
	crex_property_info *prop_info;
	crex_refcounted *garbage = NULL;

	SAVE_OPLINE();

	if (crex_fetch_static_property_address(&prop, &prop_info, opline->extended_value, BP_VAR_W, 0 OPLINE_CC EXECUTE_DATA_CC) != SUCCESS) {
		zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
		UNDEF_RESULT();
		HANDLE_EXCEPTION();
	}

	value = _get_zval_ptr_tmp((opline+1)->op1.var EXECUTE_DATA_CC);

	if (UNEXPECTED(CREX_TYPE_IS_SET(prop_info->type))) {
		value = crex_assign_to_typed_prop(prop_info, prop, value, &garbage EXECUTE_DATA_CC);
		zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
	} else {
		value = crex_assign_to_variable_ex(prop, value, IS_TMP_VAR, EX_USES_STRICT_TYPES(), &garbage);
	}

	if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
		ZVAL_COPY(EX_VAR(opline->result.var), value);
	}

	if (garbage) {
		GC_DTOR_NO_REF(garbage);
	}

	/* assign_static_prop has two opcodes! */
	CREX_VM_NEXT_OPCODE_EX(1, 2);
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ASSIGN_STATIC_PROP_SPEC_OP_DATA_VAR_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *prop, *value;
	crex_property_info *prop_info;
	crex_refcounted *garbage = NULL;

	SAVE_OPLINE();

	if (crex_fetch_static_property_address(&prop, &prop_info, opline->extended_value, BP_VAR_W, 0 OPLINE_CC EXECUTE_DATA_CC) != SUCCESS) {
		zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
		UNDEF_RESULT();
		HANDLE_EXCEPTION();
	}

	value = _get_zval_ptr_var((opline+1)->op1.var EXECUTE_DATA_CC);

	if (UNEXPECTED(CREX_TYPE_IS_SET(prop_info->type))) {
		value = crex_assign_to_typed_prop(prop_info, prop, value, &garbage EXECUTE_DATA_CC);
		zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
	} else {
		value = crex_assign_to_variable_ex(prop, value, IS_VAR, EX_USES_STRICT_TYPES(), &garbage);
	}

	if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
		ZVAL_COPY(EX_VAR(opline->result.var), value);
	}

	if (garbage) {
		GC_DTOR_NO_REF(garbage);
	}

	/* assign_static_prop has two opcodes! */
	CREX_VM_NEXT_OPCODE_EX(1, 2);
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ASSIGN_STATIC_PROP_SPEC_OP_DATA_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *prop, *value;
	crex_property_info *prop_info;
	crex_refcounted *garbage = NULL;

	SAVE_OPLINE();

	if (crex_fetch_static_property_address(&prop, &prop_info, opline->extended_value, BP_VAR_W, 0 OPLINE_CC EXECUTE_DATA_CC) != SUCCESS) {

		UNDEF_RESULT();
		HANDLE_EXCEPTION();
	}

	value = _get_zval_ptr_cv_BP_VAR_R((opline+1)->op1.var EXECUTE_DATA_CC);

	if (UNEXPECTED(CREX_TYPE_IS_SET(prop_info->type))) {
		value = crex_assign_to_typed_prop(prop_info, prop, value, &garbage EXECUTE_DATA_CC);

	} else {
		value = crex_assign_to_variable_ex(prop, value, IS_CV, EX_USES_STRICT_TYPES(), &garbage);
	}

	if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
		ZVAL_COPY(EX_VAR(opline->result.var), value);
	}

	if (garbage) {
		GC_DTOR_NO_REF(garbage);
	}

	/* assign_static_prop has two opcodes! */
	CREX_VM_NEXT_OPCODE_EX(1, 2);
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ASSIGN_STATIC_PROP_REF_SPEC_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *prop, *value_ptr;
	crex_property_info *prop_info;
	crex_refcounted *garbage = NULL;

	SAVE_OPLINE();

	if (crex_fetch_static_property_address(&prop, &prop_info, opline->extended_value & ~CREX_RETURNS_FUNCTION, BP_VAR_W, 0 OPLINE_CC EXECUTE_DATA_CC) != SUCCESS) {
		FREE_OP((opline+1)->op1_type, (opline+1)->op1.var);
		UNDEF_RESULT();
		HANDLE_EXCEPTION();
	}

	value_ptr = get_zval_ptr_ptr((opline+1)->op1_type, (opline+1)->op1, BP_VAR_W);

	if ((opline+1)->op1_type == IS_VAR && (opline->extended_value & CREX_RETURNS_FUNCTION) && UNEXPECTED(!C_ISREF_P(value_ptr))) {
		if (UNEXPECTED(!crex_wrong_assign_to_variable_reference(prop, value_ptr, &garbage OPLINE_CC EXECUTE_DATA_CC))) {
			prop = &EG(uninitialized_zval);
		}
	} else if (UNEXPECTED(CREX_TYPE_IS_SET(prop_info->type))) {
		prop = crex_assign_to_typed_property_reference(prop_info, prop, value_ptr, &garbage EXECUTE_DATA_CC);
	} else {
		crex_assign_to_variable_reference(prop, value_ptr, &garbage);
	}

	if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
		ZVAL_COPY(EX_VAR(opline->result.var), prop);
	}

	if (garbage) {
		GC_DTOR(garbage);
	}

	FREE_OP((opline+1)->op1_type, (opline+1)->op1.var);
	CREX_VM_NEXT_OPCODE_EX(1, 2);
}

static crex_never_inline CREX_OPCODE_HANDLER_RET CREX_FASTCALL crex_leave_helper_SPEC(CREX_OPCODE_HANDLER_ARGS)
{
	crex_execute_data *old_execute_data;
	uint32_t call_info = EX_CALL_INFO();
	SAVE_OPLINE();

	if (EXPECTED((call_info & (CREX_CALL_CODE|CREX_CALL_TOP|CREX_CALL_HAS_SYMBOL_TABLE|CREX_CALL_FREE_EXTRA_ARGS|CREX_CALL_ALLOCATED|CREX_CALL_HAS_EXTRA_NAMED_PARAMS)) == 0)) {
		EG(current_execute_data) = EX(prev_execute_data);
		i_free_compiled_variables(execute_data);

#ifdef CREX_PREFER_RELOAD
		call_info = EX_CALL_INFO();
#endif
		if (UNEXPECTED(call_info & CREX_CALL_RELEASE_THIS)) {
			OBJ_RELEASE(C_OBJ(execute_data->This));
		} else if (UNEXPECTED(call_info & CREX_CALL_CLOSURE)) {
			OBJ_RELEASE(CREX_CLOSURE_OBJECT(EX(func)));
		}
		EG(vm_stack_top) = (zval*)execute_data;
		execute_data = EX(prev_execute_data);

		if (UNEXPECTED(EG(exception) != NULL)) {
			crex_rethrow_exception(execute_data);
			HANDLE_EXCEPTION_LEAVE();
		}

		LOAD_NEXT_OPLINE();
		CREX_VM_LEAVE();
	} else if (EXPECTED((call_info & (CREX_CALL_CODE|CREX_CALL_TOP)) == 0)) {
		EG(current_execute_data) = EX(prev_execute_data);
		i_free_compiled_variables(execute_data);

#ifdef CREX_PREFER_RELOAD
		call_info = EX_CALL_INFO();
#endif
		if (UNEXPECTED(call_info & CREX_CALL_HAS_SYMBOL_TABLE)) {
			crex_clean_and_cache_symbol_table(EX(symbol_table));
		}

		if (UNEXPECTED(call_info & CREX_CALL_HAS_EXTRA_NAMED_PARAMS)) {
			crex_free_extra_named_params(EX(extra_named_params));
		}

		/* Free extra args before releasing the closure,
		 * as that may free the op_array. */
		crex_vm_stack_free_extra_args_ex(call_info, execute_data);

		if (UNEXPECTED(call_info & CREX_CALL_RELEASE_THIS)) {
			OBJ_RELEASE(C_OBJ(execute_data->This));
		} else if (UNEXPECTED(call_info & CREX_CALL_CLOSURE)) {
			OBJ_RELEASE(CREX_CLOSURE_OBJECT(EX(func)));
		}

		old_execute_data = execute_data;
		execute_data = EX(prev_execute_data);
		crex_vm_stack_free_call_frame_ex(call_info, old_execute_data);

		if (UNEXPECTED(EG(exception) != NULL)) {
			crex_rethrow_exception(execute_data);
			HANDLE_EXCEPTION_LEAVE();
		}

		LOAD_NEXT_OPLINE();
		CREX_VM_LEAVE();
	} else if (EXPECTED((call_info & CREX_CALL_TOP) == 0)) {
		if (EX(func)->op_array.last_var > 0) {
			crex_detach_symbol_table(execute_data);
			call_info |= CREX_CALL_NEEDS_REATTACH;
		}
		crex_destroy_static_vars(&EX(func)->op_array);
		destroy_op_array(&EX(func)->op_array);
		efree_size(EX(func), sizeof(crex_op_array));
		old_execute_data = execute_data;
		execute_data = EG(current_execute_data) = EX(prev_execute_data);
		crex_vm_stack_free_call_frame_ex(call_info, old_execute_data);

		if (call_info & CREX_CALL_NEEDS_REATTACH) {
			if (EX(func)->op_array.last_var > 0) {
				crex_attach_symbol_table(execute_data);
			} else {
				CREX_ADD_CALL_FLAG(execute_data, CREX_CALL_NEEDS_REATTACH);
			}
		}
		if (UNEXPECTED(EG(exception) != NULL)) {
			crex_rethrow_exception(execute_data);
			HANDLE_EXCEPTION_LEAVE();
		}

		LOAD_NEXT_OPLINE();
		CREX_VM_LEAVE();
	} else {
		if (EXPECTED((call_info & CREX_CALL_CODE) == 0)) {
			EG(current_execute_data) = EX(prev_execute_data);
			i_free_compiled_variables(execute_data);
#ifdef CREX_PREFER_RELOAD
			call_info = EX_CALL_INFO();
#endif
			if (UNEXPECTED(call_info & (CREX_CALL_HAS_SYMBOL_TABLE|CREX_CALL_FREE_EXTRA_ARGS|CREX_CALL_HAS_EXTRA_NAMED_PARAMS))) {
				if (UNEXPECTED(call_info & CREX_CALL_HAS_SYMBOL_TABLE)) {
					crex_clean_and_cache_symbol_table(EX(symbol_table));
				}
				crex_vm_stack_free_extra_args_ex(call_info, execute_data);
				if (UNEXPECTED(call_info & CREX_CALL_HAS_EXTRA_NAMED_PARAMS)) {
					crex_free_extra_named_params(EX(extra_named_params));
				}
			}
			if (UNEXPECTED(call_info & CREX_CALL_CLOSURE)) {
				OBJ_RELEASE(CREX_CLOSURE_OBJECT(EX(func)));
			}
			CREX_VM_RETURN();
		} else /* if (call_kind == CREX_CALL_TOP_CODE) */ {
			crex_array *symbol_table = EX(symbol_table);

			if (EX(func)->op_array.last_var > 0) {
				crex_detach_symbol_table(execute_data);
				call_info |= CREX_CALL_NEEDS_REATTACH;
			}
			if (call_info & CREX_CALL_NEEDS_REATTACH) {
				old_execute_data = EX(prev_execute_data);
				while (old_execute_data) {
					if (old_execute_data->func && (CREX_CALL_INFO(old_execute_data) & CREX_CALL_HAS_SYMBOL_TABLE)) {
						if (old_execute_data->symbol_table == symbol_table) {
							if (old_execute_data->func->op_array.last_var > 0) {
								crex_attach_symbol_table(old_execute_data);
							} else {
								CREX_ADD_CALL_FLAG(old_execute_data, CREX_CALL_NEEDS_REATTACH);
							}
						}
						break;
					}
					old_execute_data = old_execute_data->prev_execute_data;
				}
			}
			EG(current_execute_data) = EX(prev_execute_data);
			CREX_VM_RETURN();
		}
	}
}

static CREX_VM_HOT CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_JMP_SPEC_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	CREX_VM_JMP_EX(OP_JMP_ADDR(opline, opline->op1), 0);
}

static CREX_VM_HOT CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_DO_ICALL_SPEC_RETVAL_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	crex_execute_data *call = EX(call);
	crex_function *fbc = call->func;
	zval *ret;
	zval retval;

	SAVE_OPLINE();
	EX(call) = call->prev_execute_data;

	call->prev_execute_data = execute_data;
	EG(current_execute_data) = call;

#if CREX_DEBUG
	bool should_throw = crex_internal_call_should_throw(fbc, call);
#endif

	ret = 0 ? EX_VAR(opline->result.var) : &retval;
	ZVAL_NULL(ret);

	fbc->internal_function.handler(call, ret);

#if CREX_DEBUG
	if (!EG(exception) && call->func) {
		if (should_throw) {
			crex_internal_call_arginfo_violation(call->func);
		}
		CREX_ASSERT(!(call->func->common.fn_flags & CREX_ACC_HAS_RETURN_TYPE) ||
			crex_verify_internal_return_type(call->func, ret));
		CREX_ASSERT((call->func->common.fn_flags & CREX_ACC_RETURN_REFERENCE)
			? C_ISREF_P(ret) : !C_ISREF_P(ret));
		crex_verify_internal_func_info(call->func, ret);
	}
#endif

	EG(current_execute_data) = execute_data;
	crex_vm_stack_free_args(call);

	uint32_t call_info = CREX_CALL_INFO(call);
	if (UNEXPECTED(call_info & (CREX_CALL_HAS_EXTRA_NAMED_PARAMS|CREX_CALL_ALLOCATED))) {
		if (call_info & CREX_CALL_HAS_EXTRA_NAMED_PARAMS) {
			crex_free_extra_named_params(call->extra_named_params);
		}
		crex_vm_stack_free_call_frame_ex(call_info, call);
	} else {
		EG(vm_stack_top) = (zval*)call;
	}

	if (!0) {
		i_zval_ptr_dtor(ret);
	}

	if (UNEXPECTED(EG(exception) != NULL)) {
		crex_rethrow_exception(execute_data);
		HANDLE_EXCEPTION();
	}

	CREX_VM_SET_OPCODE(opline + 1);
	CREX_VM_CONTINUE();
}

static CREX_VM_HOT CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_DO_ICALL_SPEC_RETVAL_USED_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	crex_execute_data *call = EX(call);
	crex_function *fbc = call->func;
	zval *ret;
	zval retval;

	SAVE_OPLINE();
	EX(call) = call->prev_execute_data;

	call->prev_execute_data = execute_data;
	EG(current_execute_data) = call;

#if CREX_DEBUG
	bool should_throw = crex_internal_call_should_throw(fbc, call);
#endif

	ret = 1 ? EX_VAR(opline->result.var) : &retval;
	ZVAL_NULL(ret);

	fbc->internal_function.handler(call, ret);

#if CREX_DEBUG
	if (!EG(exception) && call->func) {
		if (should_throw) {
			crex_internal_call_arginfo_violation(call->func);
		}
		CREX_ASSERT(!(call->func->common.fn_flags & CREX_ACC_HAS_RETURN_TYPE) ||
			crex_verify_internal_return_type(call->func, ret));
		CREX_ASSERT((call->func->common.fn_flags & CREX_ACC_RETURN_REFERENCE)
			? C_ISREF_P(ret) : !C_ISREF_P(ret));
		crex_verify_internal_func_info(call->func, ret);
	}
#endif

	EG(current_execute_data) = execute_data;
	crex_vm_stack_free_args(call);

	uint32_t call_info = CREX_CALL_INFO(call);
	if (UNEXPECTED(call_info & (CREX_CALL_HAS_EXTRA_NAMED_PARAMS|CREX_CALL_ALLOCATED))) {
		if (call_info & CREX_CALL_HAS_EXTRA_NAMED_PARAMS) {
			crex_free_extra_named_params(call->extra_named_params);
		}
		crex_vm_stack_free_call_frame_ex(call_info, call);
	} else {
		EG(vm_stack_top) = (zval*)call;
	}

	if (!1) {
		i_zval_ptr_dtor(ret);
	}

	if (UNEXPECTED(EG(exception) != NULL)) {
		crex_rethrow_exception(execute_data);
		HANDLE_EXCEPTION();
	}

	CREX_VM_SET_OPCODE(opline + 1);
	CREX_VM_CONTINUE();
}

static CREX_VM_COLD CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_DO_ICALL_SPEC_OBSERVER_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	crex_execute_data *call = EX(call);
	crex_function *fbc = call->func;
	zval *ret;
	zval retval;

	SAVE_OPLINE();
	EX(call) = call->prev_execute_data;

	call->prev_execute_data = execute_data;
	EG(current_execute_data) = call;

#if CREX_DEBUG
	bool should_throw = crex_internal_call_should_throw(fbc, call);
#endif

	ret = RETURN_VALUE_USED(opline) ? EX_VAR(opline->result.var) : &retval;
	ZVAL_NULL(ret);

	crex_observer_fcall_begin(call);
	fbc->internal_function.handler(call, ret);

#if CREX_DEBUG
	if (!EG(exception) && call->func) {
		if (should_throw) {
			crex_internal_call_arginfo_violation(call->func);
		}
		CREX_ASSERT(!(call->func->common.fn_flags & CREX_ACC_HAS_RETURN_TYPE) ||
			crex_verify_internal_return_type(call->func, ret));
		CREX_ASSERT((call->func->common.fn_flags & CREX_ACC_RETURN_REFERENCE)
			? C_ISREF_P(ret) : !C_ISREF_P(ret));
		crex_verify_internal_func_info(call->func, ret);
	}
#endif
	crex_observer_fcall_end(call, EG(exception) ? NULL : ret);

	EG(current_execute_data) = execute_data;
	crex_vm_stack_free_args(call);

	uint32_t call_info = CREX_CALL_INFO(call);
	if (UNEXPECTED(call_info & (CREX_CALL_HAS_EXTRA_NAMED_PARAMS|CREX_CALL_ALLOCATED))) {
		if (call_info & CREX_CALL_HAS_EXTRA_NAMED_PARAMS) {
			crex_free_extra_named_params(call->extra_named_params);
		}
		crex_vm_stack_free_call_frame_ex(call_info, call);
	} else {
		EG(vm_stack_top) = (zval*)call;
	}

	if (!RETURN_VALUE_USED(opline)) {
		i_zval_ptr_dtor(ret);
	}

	if (UNEXPECTED(EG(exception) != NULL)) {
		crex_rethrow_exception(execute_data);
		HANDLE_EXCEPTION();
	}

	CREX_VM_SET_OPCODE(opline + 1);
	CREX_VM_CONTINUE();
}

static CREX_VM_HOT CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_DO_UCALL_SPEC_RETVAL_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	crex_execute_data *call = EX(call);
	crex_function *fbc = call->func;
	zval *ret;

	SAVE_OPLINE();
	EX(call) = call->prev_execute_data;

	ret = NULL;
	if (0) {
		ret = EX_VAR(opline->result.var);
	}

	call->prev_execute_data = execute_data;
	execute_data = call;
	i_init_func_execute_data(&fbc->op_array, ret, 0 EXECUTE_DATA_CC);
	LOAD_OPLINE_EX();


	CREX_VM_ENTER_EX();
}

static CREX_VM_HOT CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_DO_UCALL_SPEC_RETVAL_USED_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	crex_execute_data *call = EX(call);
	crex_function *fbc = call->func;
	zval *ret;

	SAVE_OPLINE();
	EX(call) = call->prev_execute_data;

	ret = NULL;
	if (1) {
		ret = EX_VAR(opline->result.var);
	}

	call->prev_execute_data = execute_data;
	execute_data = call;
	i_init_func_execute_data(&fbc->op_array, ret, 0 EXECUTE_DATA_CC);
	LOAD_OPLINE_EX();


	CREX_VM_ENTER_EX();
}

static CREX_VM_COLD CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_DO_UCALL_SPEC_OBSERVER_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	crex_execute_data *call = EX(call);
	crex_function *fbc = call->func;
	zval *ret;

	SAVE_OPLINE();
	EX(call) = call->prev_execute_data;

	ret = NULL;
	if (RETURN_VALUE_USED(opline)) {
		ret = EX_VAR(opline->result.var);
	}

	call->prev_execute_data = execute_data;
	execute_data = call;
	i_init_func_execute_data(&fbc->op_array, ret, 0 EXECUTE_DATA_CC);
	LOAD_OPLINE_EX();
	SAVE_OPLINE();
	crex_observer_fcall_begin(execute_data);

	CREX_VM_ENTER_EX();
}

static CREX_VM_HOT CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_DO_FCALL_BY_NAME_SPEC_RETVAL_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	crex_execute_data *call = EX(call);
	crex_function *fbc = call->func;
	zval *ret;

	SAVE_OPLINE();
	EX(call) = call->prev_execute_data;

	if (EXPECTED(fbc->type == CREX_USER_FUNCTION)) {
		ret = NULL;
		if (0) {
			ret = EX_VAR(opline->result.var);
		}

		call->prev_execute_data = execute_data;
		execute_data = call;
		i_init_func_execute_data(&fbc->op_array, ret, 0 EXECUTE_DATA_CC);
		LOAD_OPLINE_EX();


		CREX_VM_ENTER_EX();
	} else {
		zval retval;
		CREX_ASSERT(fbc->type == CREX_INTERNAL_FUNCTION);
		if (0) {
			ret = NULL;
		}

		if (UNEXPECTED((fbc->common.fn_flags & CREX_ACC_DEPRECATED) != 0)) {
			crex_deprecated_function(fbc);
			if (UNEXPECTED(EG(exception) != NULL)) {
				UNDEF_RESULT();
				if (!0) {
					ret = &retval;
					ZVAL_UNDEF(ret);
				}
				goto fcall_by_name_end;
			}
		}

		call->prev_execute_data = execute_data;
		EG(current_execute_data) = call;

#if CREX_DEBUG
		bool should_throw = crex_internal_call_should_throw(fbc, call);
#endif

		ret = 0 ? EX_VAR(opline->result.var) : &retval;
		ZVAL_NULL(ret);

		fbc->internal_function.handler(call, ret);

#if CREX_DEBUG
		if (!EG(exception) && call->func) {
			if (should_throw) {
				crex_internal_call_arginfo_violation(call->func);
			}
			CREX_ASSERT(!(call->func->common.fn_flags & CREX_ACC_HAS_RETURN_TYPE) ||
				crex_verify_internal_return_type(call->func, ret));
			CREX_ASSERT((call->func->common.fn_flags & CREX_ACC_RETURN_REFERENCE)
				? C_ISREF_P(ret) : !C_ISREF_P(ret));
			crex_verify_internal_func_info(call->func, ret);
		}
#endif

		EG(current_execute_data) = execute_data;

fcall_by_name_end:
		crex_vm_stack_free_args(call);

		uint32_t call_info = CREX_CALL_INFO(call);
		if (UNEXPECTED(call_info & (CREX_CALL_HAS_EXTRA_NAMED_PARAMS|CREX_CALL_ALLOCATED))) {
			if (call_info & CREX_CALL_HAS_EXTRA_NAMED_PARAMS) {
				crex_free_extra_named_params(call->extra_named_params);
			}
			crex_vm_stack_free_call_frame_ex(call_info, call);
		} else {
			EG(vm_stack_top) = (zval*)call;
		}

		if (!0) {
			i_zval_ptr_dtor(ret);
		}
	}

	if (UNEXPECTED(EG(exception) != NULL)) {
		crex_rethrow_exception(execute_data);
		HANDLE_EXCEPTION();
	}
	CREX_VM_SET_OPCODE(opline + 1);
	CREX_VM_CONTINUE();
}

static CREX_VM_HOT CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_DO_FCALL_BY_NAME_SPEC_RETVAL_USED_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	crex_execute_data *call = EX(call);
	crex_function *fbc = call->func;
	zval *ret;

	SAVE_OPLINE();
	EX(call) = call->prev_execute_data;

	if (EXPECTED(fbc->type == CREX_USER_FUNCTION)) {
		ret = NULL;
		if (1) {
			ret = EX_VAR(opline->result.var);
		}

		call->prev_execute_data = execute_data;
		execute_data = call;
		i_init_func_execute_data(&fbc->op_array, ret, 0 EXECUTE_DATA_CC);
		LOAD_OPLINE_EX();


		CREX_VM_ENTER_EX();
	} else {
		zval retval;
		CREX_ASSERT(fbc->type == CREX_INTERNAL_FUNCTION);
		if (0) {
			ret = NULL;
		}

		if (UNEXPECTED((fbc->common.fn_flags & CREX_ACC_DEPRECATED) != 0)) {
			crex_deprecated_function(fbc);
			if (UNEXPECTED(EG(exception) != NULL)) {
				UNDEF_RESULT();
				if (!1) {
					ret = &retval;
					ZVAL_UNDEF(ret);
				}
				goto fcall_by_name_end;
			}
		}

		call->prev_execute_data = execute_data;
		EG(current_execute_data) = call;

#if CREX_DEBUG
		bool should_throw = crex_internal_call_should_throw(fbc, call);
#endif

		ret = 1 ? EX_VAR(opline->result.var) : &retval;
		ZVAL_NULL(ret);

		fbc->internal_function.handler(call, ret);

#if CREX_DEBUG
		if (!EG(exception) && call->func) {
			if (should_throw) {
				crex_internal_call_arginfo_violation(call->func);
			}
			CREX_ASSERT(!(call->func->common.fn_flags & CREX_ACC_HAS_RETURN_TYPE) ||
				crex_verify_internal_return_type(call->func, ret));
			CREX_ASSERT((call->func->common.fn_flags & CREX_ACC_RETURN_REFERENCE)
				? C_ISREF_P(ret) : !C_ISREF_P(ret));
			crex_verify_internal_func_info(call->func, ret);
		}
#endif

		EG(current_execute_data) = execute_data;

fcall_by_name_end:
		crex_vm_stack_free_args(call);

		uint32_t call_info = CREX_CALL_INFO(call);
		if (UNEXPECTED(call_info & (CREX_CALL_HAS_EXTRA_NAMED_PARAMS|CREX_CALL_ALLOCATED))) {
			if (call_info & CREX_CALL_HAS_EXTRA_NAMED_PARAMS) {
				crex_free_extra_named_params(call->extra_named_params);
			}
			crex_vm_stack_free_call_frame_ex(call_info, call);
		} else {
			EG(vm_stack_top) = (zval*)call;
		}

		if (!1) {
			i_zval_ptr_dtor(ret);
		}
	}

	if (UNEXPECTED(EG(exception) != NULL)) {
		crex_rethrow_exception(execute_data);
		HANDLE_EXCEPTION();
	}
	CREX_VM_SET_OPCODE(opline + 1);
	CREX_VM_CONTINUE();
}

static CREX_VM_COLD CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_DO_FCALL_BY_NAME_SPEC_OBSERVER_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	crex_execute_data *call = EX(call);
	crex_function *fbc = call->func;
	zval *ret;

	SAVE_OPLINE();
	EX(call) = call->prev_execute_data;

	if (EXPECTED(fbc->type == CREX_USER_FUNCTION)) {
		ret = NULL;
		if (RETURN_VALUE_USED(opline)) {
			ret = EX_VAR(opline->result.var);
		}

		call->prev_execute_data = execute_data;
		execute_data = call;
		i_init_func_execute_data(&fbc->op_array, ret, 0 EXECUTE_DATA_CC);
		LOAD_OPLINE_EX();
		SAVE_OPLINE();
		crex_observer_fcall_begin(execute_data);

		CREX_VM_ENTER_EX();
	} else {
		zval retval;
		CREX_ASSERT(fbc->type == CREX_INTERNAL_FUNCTION);
		if (1) {
			ret = NULL;
		}

		if (UNEXPECTED((fbc->common.fn_flags & CREX_ACC_DEPRECATED) != 0)) {
			crex_deprecated_function(fbc);
			if (UNEXPECTED(EG(exception) != NULL)) {
				UNDEF_RESULT();
				if (!RETURN_VALUE_USED(opline)) {
					ret = &retval;
					ZVAL_UNDEF(ret);
				}
				goto fcall_by_name_end;
			}
		}

		call->prev_execute_data = execute_data;
		EG(current_execute_data) = call;

#if CREX_DEBUG
		bool should_throw = crex_internal_call_should_throw(fbc, call);
#endif

		ret = RETURN_VALUE_USED(opline) ? EX_VAR(opline->result.var) : &retval;
		ZVAL_NULL(ret);

		crex_observer_fcall_begin(call);
		fbc->internal_function.handler(call, ret);

#if CREX_DEBUG
		if (!EG(exception) && call->func) {
			if (should_throw) {
				crex_internal_call_arginfo_violation(call->func);
			}
			CREX_ASSERT(!(call->func->common.fn_flags & CREX_ACC_HAS_RETURN_TYPE) ||
				crex_verify_internal_return_type(call->func, ret));
			CREX_ASSERT((call->func->common.fn_flags & CREX_ACC_RETURN_REFERENCE)
				? C_ISREF_P(ret) : !C_ISREF_P(ret));
			crex_verify_internal_func_info(call->func, ret);
		}
#endif
		crex_observer_fcall_end(call, EG(exception) ? NULL : ret);

		EG(current_execute_data) = execute_data;

fcall_by_name_end:
		crex_vm_stack_free_args(call);

		uint32_t call_info = CREX_CALL_INFO(call);
		if (UNEXPECTED(call_info & (CREX_CALL_HAS_EXTRA_NAMED_PARAMS|CREX_CALL_ALLOCATED))) {
			if (call_info & CREX_CALL_HAS_EXTRA_NAMED_PARAMS) {
				crex_free_extra_named_params(call->extra_named_params);
			}
			crex_vm_stack_free_call_frame_ex(call_info, call);
		} else {
			EG(vm_stack_top) = (zval*)call;
		}

		if (!RETURN_VALUE_USED(opline)) {
			i_zval_ptr_dtor(ret);
		}
	}

	if (UNEXPECTED(EG(exception) != NULL)) {
		crex_rethrow_exception(execute_data);
		HANDLE_EXCEPTION();
	}
	CREX_VM_SET_OPCODE(opline + 1);
	CREX_VM_CONTINUE();
}

static CREX_VM_HOT CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_DO_FCALL_SPEC_RETVAL_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	crex_execute_data *call = EX(call);
	crex_function *fbc = call->func;
	zval *ret;

	SAVE_OPLINE();
	EX(call) = call->prev_execute_data;

	if (EXPECTED(fbc->type == CREX_USER_FUNCTION)) {
		ret = NULL;
		if (0) {
			ret = EX_VAR(opline->result.var);
		}

		call->prev_execute_data = execute_data;
		execute_data = call;
		i_init_func_execute_data(&fbc->op_array, ret, 1 EXECUTE_DATA_CC);

		if (EXPECTED(crex_execute_ex == execute_ex)) {
			LOAD_OPLINE_EX();


			CREX_VM_ENTER_EX();
		} else {
			SAVE_OPLINE_EX();

			execute_data = EX(prev_execute_data);
			LOAD_OPLINE();
			CREX_ADD_CALL_FLAG(call, CREX_CALL_TOP);
			crex_execute_ex(call);
		}
	} else {
		zval retval;
		CREX_ASSERT(fbc->type == CREX_INTERNAL_FUNCTION);
		if (0) {
			ret = NULL;
		}

		if (UNEXPECTED((fbc->common.fn_flags & CREX_ACC_DEPRECATED) != 0)) {
			crex_deprecated_function(fbc);
			if (UNEXPECTED(EG(exception) != NULL)) {
				UNDEF_RESULT();
				if (!0) {
					ret = &retval;
					ZVAL_UNDEF(ret);
				}
				goto fcall_end;
			}
		}

		call->prev_execute_data = execute_data;
		EG(current_execute_data) = call;

#if CREX_DEBUG
		bool should_throw = crex_internal_call_should_throw(fbc, call);
#endif

		ret = 0 ? EX_VAR(opline->result.var) : &retval;
		ZVAL_NULL(ret);

		if (!crex_execute_internal) {
			/* saves one function call if crex_execute_internal is not used */
			fbc->internal_function.handler(call, ret);
		} else {
			crex_execute_internal(call, ret);
		}

#if CREX_DEBUG
		if (!EG(exception) && call->func && !(call->func->common.fn_flags & CREX_ACC_FAKE_CLOSURE)) {
			if (should_throw) {
				crex_internal_call_arginfo_violation(call->func);
			}
			CREX_ASSERT(!(call->func->common.fn_flags & CREX_ACC_HAS_RETURN_TYPE) ||
				crex_verify_internal_return_type(call->func, ret));
			CREX_ASSERT((call->func->common.fn_flags & CREX_ACC_RETURN_REFERENCE)
				? C_ISREF_P(ret) : !C_ISREF_P(ret));
			crex_verify_internal_func_info(call->func, ret);
		}
#endif

		EG(current_execute_data) = execute_data;

fcall_end:
		crex_vm_stack_free_args(call);
		if (UNEXPECTED(CREX_CALL_INFO(call) & CREX_CALL_HAS_EXTRA_NAMED_PARAMS)) {
			crex_free_extra_named_params(call->extra_named_params);
		}

		if (!0) {
			i_zval_ptr_dtor(ret);
		}
	}

	if (UNEXPECTED(CREX_CALL_INFO(call) & CREX_CALL_RELEASE_THIS)) {
		OBJ_RELEASE(C_OBJ(call->This));
	}

	crex_vm_stack_free_call_frame(call);
	if (UNEXPECTED(EG(exception) != NULL)) {
		crex_rethrow_exception(execute_data);
		HANDLE_EXCEPTION();
	}

	CREX_VM_SET_OPCODE(opline + 1);
	CREX_VM_CONTINUE();
}

static CREX_VM_HOT CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_DO_FCALL_SPEC_RETVAL_USED_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	crex_execute_data *call = EX(call);
	crex_function *fbc = call->func;
	zval *ret;

	SAVE_OPLINE();
	EX(call) = call->prev_execute_data;

	if (EXPECTED(fbc->type == CREX_USER_FUNCTION)) {
		ret = NULL;
		if (1) {
			ret = EX_VAR(opline->result.var);
		}

		call->prev_execute_data = execute_data;
		execute_data = call;
		i_init_func_execute_data(&fbc->op_array, ret, 1 EXECUTE_DATA_CC);

		if (EXPECTED(crex_execute_ex == execute_ex)) {
			LOAD_OPLINE_EX();


			CREX_VM_ENTER_EX();
		} else {
			SAVE_OPLINE_EX();

			execute_data = EX(prev_execute_data);
			LOAD_OPLINE();
			CREX_ADD_CALL_FLAG(call, CREX_CALL_TOP);
			crex_execute_ex(call);
		}
	} else {
		zval retval;
		CREX_ASSERT(fbc->type == CREX_INTERNAL_FUNCTION);
		if (0) {
			ret = NULL;
		}

		if (UNEXPECTED((fbc->common.fn_flags & CREX_ACC_DEPRECATED) != 0)) {
			crex_deprecated_function(fbc);
			if (UNEXPECTED(EG(exception) != NULL)) {
				UNDEF_RESULT();
				if (!1) {
					ret = &retval;
					ZVAL_UNDEF(ret);
				}
				goto fcall_end;
			}
		}

		call->prev_execute_data = execute_data;
		EG(current_execute_data) = call;

#if CREX_DEBUG
		bool should_throw = crex_internal_call_should_throw(fbc, call);
#endif

		ret = 1 ? EX_VAR(opline->result.var) : &retval;
		ZVAL_NULL(ret);

		if (!crex_execute_internal) {
			/* saves one function call if crex_execute_internal is not used */
			fbc->internal_function.handler(call, ret);
		} else {
			crex_execute_internal(call, ret);
		}

#if CREX_DEBUG
		if (!EG(exception) && call->func && !(call->func->common.fn_flags & CREX_ACC_FAKE_CLOSURE)) {
			if (should_throw) {
				crex_internal_call_arginfo_violation(call->func);
			}
			CREX_ASSERT(!(call->func->common.fn_flags & CREX_ACC_HAS_RETURN_TYPE) ||
				crex_verify_internal_return_type(call->func, ret));
			CREX_ASSERT((call->func->common.fn_flags & CREX_ACC_RETURN_REFERENCE)
				? C_ISREF_P(ret) : !C_ISREF_P(ret));
			crex_verify_internal_func_info(call->func, ret);
		}
#endif

		EG(current_execute_data) = execute_data;

fcall_end:
		crex_vm_stack_free_args(call);
		if (UNEXPECTED(CREX_CALL_INFO(call) & CREX_CALL_HAS_EXTRA_NAMED_PARAMS)) {
			crex_free_extra_named_params(call->extra_named_params);
		}

		if (!1) {
			i_zval_ptr_dtor(ret);
		}
	}

	if (UNEXPECTED(CREX_CALL_INFO(call) & CREX_CALL_RELEASE_THIS)) {
		OBJ_RELEASE(C_OBJ(call->This));
	}

	crex_vm_stack_free_call_frame(call);
	if (UNEXPECTED(EG(exception) != NULL)) {
		crex_rethrow_exception(execute_data);
		HANDLE_EXCEPTION();
	}

	CREX_VM_SET_OPCODE(opline + 1);
	CREX_VM_CONTINUE();
}

static CREX_VM_COLD CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_DO_FCALL_SPEC_OBSERVER_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	crex_execute_data *call = EX(call);
	crex_function *fbc = call->func;
	zval *ret;

	SAVE_OPLINE();
	EX(call) = call->prev_execute_data;

	if (EXPECTED(fbc->type == CREX_USER_FUNCTION)) {
		ret = NULL;
		if (RETURN_VALUE_USED(opline)) {
			ret = EX_VAR(opline->result.var);
		}

		call->prev_execute_data = execute_data;
		execute_data = call;
		i_init_func_execute_data(&fbc->op_array, ret, 1 EXECUTE_DATA_CC);

		if (EXPECTED(crex_execute_ex == execute_ex)) {
			LOAD_OPLINE_EX();
			SAVE_OPLINE();
			crex_observer_fcall_begin(execute_data);
			CREX_VM_ENTER_EX();
		} else {
			SAVE_OPLINE_EX();
			crex_observer_fcall_begin(execute_data);
			execute_data = EX(prev_execute_data);
			LOAD_OPLINE();
			CREX_ADD_CALL_FLAG(call, CREX_CALL_TOP);
			crex_execute_ex(call);
		}
	} else {
		zval retval;
		CREX_ASSERT(fbc->type == CREX_INTERNAL_FUNCTION);
		if (1) {
			ret = NULL;
		}

		if (UNEXPECTED((fbc->common.fn_flags & CREX_ACC_DEPRECATED) != 0)) {
			crex_deprecated_function(fbc);
			if (UNEXPECTED(EG(exception) != NULL)) {
				UNDEF_RESULT();
				if (!RETURN_VALUE_USED(opline)) {
					ret = &retval;
					ZVAL_UNDEF(ret);
				}
				goto fcall_end;
			}
		}

		call->prev_execute_data = execute_data;
		EG(current_execute_data) = call;

#if CREX_DEBUG
		bool should_throw = crex_internal_call_should_throw(fbc, call);
#endif

		ret = RETURN_VALUE_USED(opline) ? EX_VAR(opline->result.var) : &retval;
		ZVAL_NULL(ret);

		crex_observer_fcall_begin(call);
		if (!crex_execute_internal) {
			/* saves one function call if crex_execute_internal is not used */
			fbc->internal_function.handler(call, ret);
		} else {
			crex_execute_internal(call, ret);
		}

#if CREX_DEBUG
		if (!EG(exception) && call->func && !(call->func->common.fn_flags & CREX_ACC_FAKE_CLOSURE)) {
			if (should_throw) {
				crex_internal_call_arginfo_violation(call->func);
			}
			CREX_ASSERT(!(call->func->common.fn_flags & CREX_ACC_HAS_RETURN_TYPE) ||
				crex_verify_internal_return_type(call->func, ret));
			CREX_ASSERT((call->func->common.fn_flags & CREX_ACC_RETURN_REFERENCE)
				? C_ISREF_P(ret) : !C_ISREF_P(ret));
			crex_verify_internal_func_info(call->func, ret);
		}
#endif
		crex_observer_fcall_end(call, EG(exception) ? NULL : ret);

		EG(current_execute_data) = execute_data;

fcall_end:
		crex_vm_stack_free_args(call);
		if (UNEXPECTED(CREX_CALL_INFO(call) & CREX_CALL_HAS_EXTRA_NAMED_PARAMS)) {
			crex_free_extra_named_params(call->extra_named_params);
		}

		if (!RETURN_VALUE_USED(opline)) {
			i_zval_ptr_dtor(ret);
		}
	}

	if (UNEXPECTED(CREX_CALL_INFO(call) & CREX_CALL_RELEASE_THIS)) {
		OBJ_RELEASE(C_OBJ(call->This));
	}

	crex_vm_stack_free_call_frame(call);
	if (UNEXPECTED(EG(exception) != NULL)) {
		crex_rethrow_exception(execute_data);
		HANDLE_EXCEPTION();
	}

	CREX_VM_SET_OPCODE(opline + 1);
	CREX_VM_CONTINUE();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_GENERATOR_CREATE_SPEC_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	zval *return_value = EX(return_value);

	if (EXPECTED(return_value)) {
		USE_OPLINE
		crex_generator *generator;
		crex_execute_data *gen_execute_data;
		uint32_t num_args, used_stack, call_info;

		SAVE_OPLINE();
		object_init_ex(return_value, crex_ce_generator);

		/*
		 * Normally the execute_data is allocated on the VM stack (because it does
		 * not actually do any allocation and thus is faster). For generators
		 * though this behavior would be suboptimal, because the (rather large)
		 * structure would have to be copied back and forth every time execution is
		 * suspended or resumed. That's why for generators the execution context
		 * is allocated on heap.
		 */
		num_args = EX_NUM_ARGS();
		if (EXPECTED(num_args <= EX(func)->op_array.num_args)) {
			used_stack = (CREX_CALL_FRAME_SLOT + EX(func)->op_array.last_var + EX(func)->op_array.T) * sizeof(zval);
			gen_execute_data = (crex_execute_data*)emalloc(used_stack);
			used_stack = (CREX_CALL_FRAME_SLOT + EX(func)->op_array.last_var) * sizeof(zval);
		} else {
			used_stack = (CREX_CALL_FRAME_SLOT + num_args + EX(func)->op_array.last_var + EX(func)->op_array.T - EX(func)->op_array.num_args) * sizeof(zval);
			gen_execute_data = (crex_execute_data*)emalloc(used_stack);
		}
		memcpy(gen_execute_data, execute_data, used_stack);

		/* Save execution context in generator object. */
		generator = (crex_generator *) C_OBJ_P(EX(return_value));
		generator->execute_data = gen_execute_data;
		generator->frozen_call_stack = NULL;
		generator->execute_fake.opline = NULL;
		generator->execute_fake.func = NULL;
		generator->execute_fake.prev_execute_data = NULL;
		ZVAL_OBJ(&generator->execute_fake.This, (crex_object *) generator);

		gen_execute_data->opline = opline + 1;
		/* EX(return_value) keeps pointer to crex_object (not a real zval) */
		gen_execute_data->return_value = (zval*)generator;
		call_info = C_TYPE_INFO(EX(This));
		if ((call_info & C_TYPE_MASK) == IS_OBJECT
		 && (!(call_info & (CREX_CALL_CLOSURE|CREX_CALL_RELEASE_THIS))
			 /* Bug #72523 */
			|| UNEXPECTED(crex_execute_ex != execute_ex))) {
			CREX_ADD_CALL_FLAG_EX(call_info, CREX_CALL_RELEASE_THIS);
			C_ADDREF(gen_execute_data->This);
		}
		CREX_ADD_CALL_FLAG_EX(call_info, (CREX_CALL_TOP_FUNCTION | CREX_CALL_ALLOCATED | CREX_CALL_GENERATOR));
		C_TYPE_INFO(gen_execute_data->This) = call_info;
		gen_execute_data->prev_execute_data = NULL;

		call_info = EX_CALL_INFO();
		EG(current_execute_data) = EX(prev_execute_data);
		if (EXPECTED(!(call_info & (CREX_CALL_TOP|CREX_CALL_ALLOCATED)))) {
			EG(vm_stack_top) = (zval*)execute_data;
			execute_data = EX(prev_execute_data);
			LOAD_NEXT_OPLINE();
			CREX_VM_LEAVE();
		} else if (EXPECTED(!(call_info & CREX_CALL_TOP))) {
			crex_execute_data *old_execute_data = execute_data;
			execute_data = EX(prev_execute_data);
			crex_vm_stack_free_call_frame_ex(call_info, old_execute_data);
			LOAD_NEXT_OPLINE();
			CREX_VM_LEAVE();
		} else {
			CREX_VM_RETURN();
		}
	} else {
		CREX_VM_TAIL_CALL(crex_leave_helper_SPEC(CREX_OPCODE_HANDLER_ARGS_PASSTHRU));
	}
}

static crex_never_inline CREX_COLD CREX_OPCODE_HANDLER_RET CREX_FASTCALL crex_cannot_pass_by_ref_helper_SPEC(uint32_t _arg_num, zval *_arg CREX_OPCODE_HANDLER_ARGS_DC)
{
	USE_OPLINE

	SAVE_OPLINE();

	crex_cannot_pass_by_reference(_arg_num);
	FREE_OP(opline->op1_type, opline->op1.var);
	ZVAL_UNDEF(_arg);
	HANDLE_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_SEND_UNPACK_SPEC_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *args;
	uint32_t arg_num;

	SAVE_OPLINE();
	args = get_zval_ptr_undef(opline->op1_type, opline->op1, BP_VAR_R);
	arg_num = CREX_CALL_NUM_ARGS(EX(call)) + 1;

send_again:
	if (EXPECTED(C_TYPE_P(args) == IS_ARRAY)) {
		HashTable *ht = C_ARRVAL_P(args);
		zval *arg, *top;
		crex_string *name;
		bool have_named_params = 0;

		crex_vm_stack_extend_call_frame(&EX(call), arg_num - 1, crex_hash_num_elements(ht));

		// TODO: Speed this up using a flag that specifies whether there are any ref parameters.
		if ((opline->op1_type & (IS_VAR|IS_CV)) && C_REFCOUNT_P(args) > 1) {
			uint32_t tmp_arg_num = arg_num;
			bool separate = 0;

			/* check if any of arguments are going to be passed by reference */
			CREX_HASH_FOREACH_STR_KEY_VAL(ht, name, arg) {
				if (UNEXPECTED(name)) {
					void *cache_slot[2] = {NULL, NULL};
					tmp_arg_num = crex_get_arg_offset_by_name(
						EX(call)->func, name, cache_slot) + 1;
				}
				if (ARG_SHOULD_BE_SENT_BY_REF(EX(call)->func, tmp_arg_num)) {
					separate = 1;
					break;
				}
				tmp_arg_num++;
			} CREX_HASH_FOREACH_END();
			if (separate) {
				SEPARATE_ARRAY(args);
				ht = C_ARRVAL_P(args);
			}
		}

		CREX_HASH_FOREACH_STR_KEY_VAL(ht, name, arg) {
			if (UNEXPECTED(name)) {
				void *cache_slot[2] = {NULL, NULL};
				have_named_params = 1;
				top = crex_handle_named_arg(&EX(call), name, &arg_num, cache_slot);
				if (UNEXPECTED(!top)) {
					FREE_OP(opline->op1_type, opline->op1.var);
					HANDLE_EXCEPTION();
				}
			} else {
				if (have_named_params) {
					crex_throw_error(NULL,
						"Cannot use positional argument after named argument during unpacking");
					FREE_OP(opline->op1_type, opline->op1.var);
					HANDLE_EXCEPTION();
				}

				top = CREX_CALL_ARG(EX(call), arg_num);
				CREX_CALL_NUM_ARGS(EX(call))++;
			}

			if (ARG_SHOULD_BE_SENT_BY_REF(EX(call)->func, arg_num)) {
				if (C_ISREF_P(arg)) {
					C_ADDREF_P(arg);
					ZVAL_REF(top, C_REF_P(arg));
				} else if (opline->op1_type & (IS_VAR|IS_CV)) {
					/* array is already separated above */
					ZVAL_MAKE_REF_EX(arg, 2);
					ZVAL_REF(top, C_REF_P(arg));
				} else {
					C_TRY_ADDREF_P(arg);
					ZVAL_NEW_REF(top, arg);
				}
			} else {
				ZVAL_COPY_DEREF(top, arg);
			}

			arg_num++;
		} CREX_HASH_FOREACH_END();

	} else if (EXPECTED(C_TYPE_P(args) == IS_OBJECT)) {
		crex_class_entry *ce = C_OBJCE_P(args);
		crex_object_iterator *iter;
		bool have_named_params = 0;

		if (!ce || !ce->get_iterator) {
			crex_type_error("Only arrays and Traversables can be unpacked");
		} else {

			iter = ce->get_iterator(ce, args, 0);
			if (UNEXPECTED(!iter)) {
				FREE_OP(opline->op1_type, opline->op1.var);
				if (!EG(exception)) {
					crex_throw_exception_ex(
						NULL, 0, "Object of type %s did not create an Iterator", ZSTR_VAL(ce->name)
					);
				}
				HANDLE_EXCEPTION();
			}

			const crex_object_iterator_funcs *funcs = iter->funcs;
			if (funcs->rewind) {
				funcs->rewind(iter);
			}

			for (; funcs->valid(iter) == SUCCESS; ++arg_num) {
				zval *arg, *top;

				if (UNEXPECTED(EG(exception) != NULL)) {
					break;
				}

				arg = funcs->get_current_data(iter);
				if (UNEXPECTED(EG(exception) != NULL)) {
					break;
				}

				crex_string *name = NULL;
				if (funcs->get_current_key) {
					zval key;
					funcs->get_current_key(iter, &key);
					if (UNEXPECTED(EG(exception) != NULL)) {
						break;
					}

					if (UNEXPECTED(C_TYPE(key) != IS_LONG)) {
						if (UNEXPECTED(C_TYPE(key) != IS_STRING)) {
							crex_throw_error(NULL,
								"Keys must be of type int|string during argument unpacking");
							zval_ptr_dtor(&key);
							break;
						}

						name = C_STR_P(&key);
					}
				}

				if (UNEXPECTED(name)) {
					void *cache_slot[2] = {NULL, NULL};
					have_named_params = 1;
					top = crex_handle_named_arg(&EX(call), name, &arg_num, cache_slot);
					if (UNEXPECTED(!top)) {
						crex_string_release(name);
						break;
					}

					ZVAL_DEREF(arg);
					C_TRY_ADDREF_P(arg);

					if (ARG_MUST_BE_SENT_BY_REF(EX(call)->func, arg_num)) {
						crex_error(
							E_WARNING, "Cannot pass by-reference argument %d of %s%s%s()"
							" by unpacking a Traversable, passing by-value instead", arg_num,
							EX(call)->func->common.scope ? ZSTR_VAL(EX(call)->func->common.scope->name) : "",
							EX(call)->func->common.scope ? "::" : "",
							ZSTR_VAL(EX(call)->func->common.function_name)
						);
						ZVAL_NEW_REF(top, arg);
					} else {
						ZVAL_COPY_VALUE(top, arg);
					}

					crex_string_release(name);
				} else {
					if (have_named_params) {
						crex_throw_error(NULL,
							"Cannot use positional argument after named argument during unpacking");
						break;
					}

					crex_vm_stack_extend_call_frame(&EX(call), arg_num - 1, 1);
					top = CREX_CALL_ARG(EX(call), arg_num);
					ZVAL_DEREF(arg);
					C_TRY_ADDREF_P(arg);

					if (ARG_MUST_BE_SENT_BY_REF(EX(call)->func, arg_num)) {
						crex_error(
							E_WARNING, "Cannot pass by-reference argument %d of %s%s%s()"
							" by unpacking a Traversable, passing by-value instead", arg_num,
							EX(call)->func->common.scope ? ZSTR_VAL(EX(call)->func->common.scope->name) : "",
							EX(call)->func->common.scope ? "::" : "",
							ZSTR_VAL(EX(call)->func->common.function_name)
						);
						ZVAL_NEW_REF(top, arg);
					} else {
						ZVAL_COPY_VALUE(top, arg);
					}

					CREX_CALL_NUM_ARGS(EX(call))++;
				}

				funcs->move_forward(iter);
			}

			crex_iterator_dtor(iter);
		}
	} else if (EXPECTED(C_ISREF_P(args))) {
		args = C_REFVAL_P(args);
		goto send_again;
	} else {
		if (opline->op1_type == IS_CV && UNEXPECTED(C_TYPE_P(args) == IS_UNDEF)) {
			ZVAL_UNDEFINED_OP1();
		}
		crex_type_error("Only arrays and Traversables can be unpacked");
	}

	FREE_OP(opline->op1_type, opline->op1.var);
	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_SEND_ARRAY_SPEC_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *args;

	SAVE_OPLINE();
	args = get_zval_ptr(opline->op1_type, opline->op1, BP_VAR_R);

	if (UNEXPECTED(C_TYPE_P(args) != IS_ARRAY)) {
		if ((opline->op1_type & (IS_VAR|IS_CV)) && C_ISREF_P(args)) {
			args = C_REFVAL_P(args);
			if (EXPECTED(C_TYPE_P(args) == IS_ARRAY)) {
				goto send_array;
			}
		}
		crex_type_error("call_user_func_array(): Argument #2 ($args) must be of type array, %s given", crex_zval_value_name(args));
		FREE_OP(opline->op2_type, opline->op2.var);
		FREE_OP(opline->op1_type, opline->op1.var);
		HANDLE_EXCEPTION();
	} else {
		uint32_t arg_num;
		HashTable *ht;
		zval *arg, *param;

send_array:
		ht = C_ARRVAL_P(args);
		if (opline->op2_type != IS_UNUSED) {
			/* We don't need to handle named params in this case,
			 * because array_slice() is called with $preserve_keys == false. */
			zval *op2 = get_zval_ptr_deref(opline->op2_type, opline->op2, BP_VAR_R);
			uint32_t skip = opline->extended_value;
			uint32_t count = crex_hash_num_elements(ht);
			crex_long len;
			if (EXPECTED(C_TYPE_P(op2) == IS_LONG)) {
				len = C_LVAL_P(op2);
			} else if (C_TYPE_P(op2) == IS_NULL) {
				len = count - skip;
			} else if (EX_USES_STRICT_TYPES()
					|| !crex_parse_arg_long_weak(op2, &len, /* arg_num */ 3)) {
				crex_type_error(
					"array_slice(): Argument #3 ($length) must be of type ?int, %s given",
					crex_zval_value_name(op2));
				FREE_OP(opline->op2_type, opline->op2.var);
				FREE_OP(opline->op1_type, opline->op1.var);
				HANDLE_EXCEPTION();
			}

			if (len < 0) {
				len += (crex_long)(count - skip);
			}
			if (skip < count && len > 0) {
				if (len > (crex_long)(count - skip)) {
					len = (crex_long)(count - skip);
				}
				crex_vm_stack_extend_call_frame(&EX(call), 0, len);
				arg_num = 1;
				param = CREX_CALL_ARG(EX(call), 1);
				CREX_HASH_FOREACH_VAL(ht, arg) {
					bool must_wrap = 0;
					if (skip > 0) {
						skip--;
						continue;
					} else if ((crex_long)(arg_num - 1) >= len) {
						break;
					} else if (ARG_SHOULD_BE_SENT_BY_REF(EX(call)->func, arg_num)) {
						if (UNEXPECTED(!C_ISREF_P(arg))) {
							if (!ARG_MAY_BE_SENT_BY_REF(EX(call)->func, arg_num)) {
								/* By-value send is not allowed -- emit a warning,
								 * but still perform the call. */
								crex_param_must_be_ref(EX(call)->func, arg_num);
								must_wrap = 1;
							}
						}
					} else {
						if (C_ISREF_P(arg) &&
						    !(EX(call)->func->common.fn_flags & CREX_ACC_CALL_VIA_TRAMPOLINE)) {
							/* don't separate references for __call */
							arg = C_REFVAL_P(arg);
						}
					}
					if (EXPECTED(!must_wrap)) {
						ZVAL_COPY(param, arg);
					} else {
						C_TRY_ADDREF_P(arg);
						ZVAL_NEW_REF(param, arg);
					}
					CREX_CALL_NUM_ARGS(EX(call))++;
					arg_num++;
					param++;
				} CREX_HASH_FOREACH_END();
			}
			FREE_OP(opline->op2_type, opline->op2.var);
		} else {
			crex_string *name;
			bool have_named_params;
			crex_vm_stack_extend_call_frame(&EX(call), 0, crex_hash_num_elements(ht));
			arg_num = 1;
			param = CREX_CALL_ARG(EX(call), 1);
			have_named_params = 0;
			CREX_HASH_FOREACH_STR_KEY_VAL(ht, name, arg) {
				if (name) {
					void *cache_slot[2] = {NULL, NULL};
					have_named_params = 1;
					param = crex_handle_named_arg(&EX(call), name, &arg_num, cache_slot);
					if (!param) {
						FREE_OP(opline->op1_type, opline->op1.var);
						HANDLE_EXCEPTION();
					}
				} else if (have_named_params) {
					crex_throw_error(NULL,
						"Cannot use positional argument after named argument");
					FREE_OP(opline->op1_type, opline->op1.var);
					HANDLE_EXCEPTION();
				}

				bool must_wrap = 0;
				if (ARG_SHOULD_BE_SENT_BY_REF(EX(call)->func, arg_num)) {
					if (UNEXPECTED(!C_ISREF_P(arg))) {
						if (!ARG_MAY_BE_SENT_BY_REF(EX(call)->func, arg_num)) {
							/* By-value send is not allowed -- emit a warning,
							 * but still perform the call. */
							crex_param_must_be_ref(EX(call)->func, arg_num);
							must_wrap = 1;
						}
					}
				} else {
					if (C_ISREF_P(arg) &&
					    !(EX(call)->func->common.fn_flags & CREX_ACC_CALL_VIA_TRAMPOLINE)) {
						/* don't separate references for __call */
						arg = C_REFVAL_P(arg);
					}
				}

				if (EXPECTED(!must_wrap)) {
					ZVAL_COPY(param, arg);
				} else {
					C_TRY_ADDREF_P(arg);
					ZVAL_NEW_REF(param, arg);
				}
				if (!name) {
					CREX_CALL_NUM_ARGS(EX(call))++;
					arg_num++;
					param++;
				}
			} CREX_HASH_FOREACH_END();
		}
	}
	FREE_OP(opline->op1_type, opline->op1.var);
	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static crex_never_inline CREX_COLD CREX_OPCODE_HANDLER_RET CREX_FASTCALL crex_missing_arg_helper_SPEC(CREX_OPCODE_HANDLER_ARGS)
{
#ifdef CREX_VM_IP_GLOBAL_REG
	USE_OPLINE

	SAVE_OPLINE();
#endif
	crex_missing_arg_error(execute_data);
	HANDLE_EXCEPTION();
}

static crex_never_inline CREX_OPCODE_HANDLER_RET CREX_FASTCALL crex_verify_recv_arg_type_helper_SPEC(zval *op_1 CREX_OPCODE_HANDLER_ARGS_DC)
{
	USE_OPLINE

	SAVE_OPLINE();
	if (UNEXPECTED(!crex_verify_recv_arg_type(EX(func), opline->op1.num, op_1, CACHE_ADDR(opline->extended_value)))) {
		HANDLE_EXCEPTION();
	}

	CREX_VM_NEXT_OPCODE();
}

static CREX_VM_HOT CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_RECV_NOTYPE_SPEC_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	uint32_t arg_num = opline->op1.num;

	if (UNEXPECTED(arg_num > EX_NUM_ARGS())) {
		CREX_VM_TAIL_CALL(crex_missing_arg_helper_SPEC(CREX_OPCODE_HANDLER_ARGS_PASSTHRU));
	}

	CREX_VM_NEXT_OPCODE();
}

static crex_never_inline CREX_OPCODE_HANDLER_RET CREX_FASTCALL crex_case_helper_SPEC(zval *op_1, zval *op_2 CREX_OPCODE_HANDLER_ARGS_DC)
{
	int ret;
	USE_OPLINE

	SAVE_OPLINE();
	if (UNEXPECTED(C_TYPE_INFO_P(op_1) == IS_UNDEF)) {
		op_1 = ZVAL_UNDEFINED_OP1();
	}
	if (UNEXPECTED(C_TYPE_INFO_P(op_2) == IS_UNDEF)) {
		op_2 = ZVAL_UNDEFINED_OP2();
	}
	ret = crex_compare(op_1, op_2);
	if (opline->op2_type & (IS_TMP_VAR|IS_VAR)) {
		zval_ptr_dtor_nogc(op_2);
	}
	CREX_VM_SMART_BRANCH(ret == 0, 1);
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ADD_ARRAY_UNPACK_SPEC_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1;
	HashTable *result_ht;

	SAVE_OPLINE();
	op1 = get_zval_ptr(opline->op1_type, opline->op1, BP_VAR_R);
	result_ht = C_ARRVAL_P(EX_VAR(opline->result.var));

add_unpack_again:
	if (EXPECTED(C_TYPE_P(op1) == IS_ARRAY)) {
		HashTable *ht = C_ARRVAL_P(op1);
		zval *val;

		if (HT_IS_PACKED(ht) && (crex_hash_num_elements(result_ht) == 0 || HT_IS_PACKED(result_ht))) {
			crex_hash_extend(result_ht, result_ht->nNumUsed + crex_hash_num_elements(ht), 1);
			CREX_HASH_FILL_PACKED(result_ht) {
				CREX_HASH_PACKED_FOREACH_VAL(ht, val) {
					if (UNEXPECTED(C_ISREF_P(val)) &&
						UNEXPECTED(C_REFCOUNT_P(val) == 1)) {
						val = C_REFVAL_P(val);
					}
					C_TRY_ADDREF_P(val);
					CREX_HASH_FILL_ADD(val);
				} CREX_HASH_FOREACH_END();
			} CREX_HASH_FILL_END();
		} else {
			crex_string *key;

			CREX_HASH_FOREACH_STR_KEY_VAL(ht, key, val) {
				if (UNEXPECTED(C_ISREF_P(val)) &&
					UNEXPECTED(C_REFCOUNT_P(val) == 1)) {
					val = C_REFVAL_P(val);
				}
				C_TRY_ADDREF_P(val);
				if (key) {
					crex_hash_update(result_ht, key, val);
				} else {
					if (!crex_hash_next_index_insert(result_ht, val)) {
						crex_cannot_add_element();
						zval_ptr_dtor_nogc(val);
						break;
					}
				}
			} CREX_HASH_FOREACH_END();
		}
	} else if (EXPECTED(C_TYPE_P(op1) == IS_OBJECT)) {
		crex_class_entry *ce = C_OBJCE_P(op1);
		crex_object_iterator *iter;

		if (!ce || !ce->get_iterator) {
			crex_type_error("Only arrays and Traversables can be unpacked");
		} else {
			iter = ce->get_iterator(ce, op1, 0);
			if (UNEXPECTED(!iter)) {
				FREE_OP(opline->op1_type, opline->op1.var);
				if (!EG(exception)) {
					crex_throw_exception_ex(
						NULL, 0, "Object of type %s did not create an Iterator", ZSTR_VAL(ce->name)
					);
				}
				HANDLE_EXCEPTION();
			}

			const crex_object_iterator_funcs *funcs = iter->funcs;
			if (funcs->rewind) {
				funcs->rewind(iter);
			}

			for (; funcs->valid(iter) == SUCCESS; ) {
				zval *val;

				if (UNEXPECTED(EG(exception) != NULL)) {
					break;
				}

				val = funcs->get_current_data(iter);
				if (UNEXPECTED(EG(exception) != NULL)) {
					break;
				}

				zval key;
				if (funcs->get_current_key) {
					funcs->get_current_key(iter, &key);
					if (UNEXPECTED(EG(exception) != NULL)) {
						break;
					}

					if (UNEXPECTED(C_TYPE(key) != IS_LONG && C_TYPE(key) != IS_STRING)) {
						crex_throw_error(NULL,
							"Keys must be of type int|string during array unpacking");
						zval_ptr_dtor(&key);
						break;
					}
				} else {
					ZVAL_UNDEF(&key);
				}

				ZVAL_DEREF(val);
				C_TRY_ADDREF_P(val);

				crex_ulong num_key;
				if (C_TYPE(key) == IS_STRING && !CREX_HANDLE_NUMERIC(C_STR(key), num_key)) {
					crex_hash_update(result_ht, C_STR(key), val);
					zval_ptr_dtor_str(&key);
				} else {
					zval_ptr_dtor(&key);
					if (!crex_hash_next_index_insert(result_ht, val)) {
						crex_cannot_add_element();
						zval_ptr_dtor_nogc(val);
						break;
					}
				}

				funcs->move_forward(iter);
				if (UNEXPECTED(EG(exception))) {
					break;
				}
			}

			crex_iterator_dtor(iter);
		}
	} else if (EXPECTED(C_ISREF_P(op1))) {
		op1 = C_REFVAL_P(op1);
		goto add_unpack_again;
	} else {
		crex_throw_error(NULL, "Only arrays and Traversables can be unpacked");
	}

	FREE_OP(opline->op1_type, opline->op1.var);
	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_VM_COLD CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_UNSET_STATIC_PROP_SPEC_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *varname;
	crex_string *name, *tmp_name = NULL;
	crex_class_entry *ce;

	SAVE_OPLINE();

	if (opline->op2_type == IS_CONST) {
		ce = CACHED_PTR(opline->extended_value);
		if (UNEXPECTED(ce == NULL)) {
			ce = crex_fetch_class_by_name(C_STR_P(RT_CONSTANT(opline, opline->op2)), C_STR_P(RT_CONSTANT(opline, opline->op2) + 1), CREX_FETCH_CLASS_DEFAULT | CREX_FETCH_CLASS_EXCEPTION);
			if (UNEXPECTED(ce == NULL)) {
				FREE_OP(opline->op1_type, opline->op1.var);
				HANDLE_EXCEPTION();
			}
			/*CACHE_PTR(opline->extended_value, ce);*/
		}
	} else if (opline->op2_type == IS_UNUSED) {
		ce = crex_fetch_class(NULL, opline->op2.num);
		if (UNEXPECTED(ce == NULL)) {
			FREE_OP(opline->op1_type, opline->op1.var);
			HANDLE_EXCEPTION();
		}
	} else {
		ce = C_CE_P(EX_VAR(opline->op2.var));
	}

	varname = get_zval_ptr_undef(opline->op1_type, opline->op1, BP_VAR_R);
	if (opline->op1_type == IS_CONST) {
		name = C_STR_P(varname);
	} else if (EXPECTED(C_TYPE_P(varname) == IS_STRING)) {
		name = C_STR_P(varname);
	} else {
		if (opline->op1_type == IS_CV && UNEXPECTED(C_TYPE_P(varname) == IS_UNDEF)) {
			varname = ZVAL_UNDEFINED_OP1();
		}
		name = zval_try_get_tmp_string(varname, &tmp_name);
		if (UNEXPECTED(!name)) {
			FREE_OP(opline->op1_type, opline->op1.var);
			HANDLE_EXCEPTION();
		}
	}

	crex_std_unset_static_property(ce, name);

	crex_tmp_string_release(tmp_name);
	FREE_OP(opline->op1_type, opline->op1.var);
	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static crex_never_inline CREX_OPCODE_HANDLER_RET CREX_FASTCALL crex_fe_fetch_object_helper_SPEC(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *array;
	zval *value;
	uint32_t value_type;
	HashTable *fe_ht;
	HashPosition pos;
	Bucket *p;
	crex_object_iterator *iter;

	array = EX_VAR(opline->op1.var);
	SAVE_OPLINE();

	CREX_ASSERT(C_TYPE_P(array) == IS_OBJECT);
	if ((iter = crex_iterator_unwrap(array)) == NULL) {
		/* plain object */

		fe_ht = C_OBJPROP_P(array);
		pos = crex_hash_iterator_pos(C_FE_ITER_P(array), fe_ht);
		p = fe_ht->arData + pos;
		while (1) {
			if (UNEXPECTED(pos >= fe_ht->nNumUsed)) {
				/* reached end of iteration */
				goto fe_fetch_r_exit;
			}
			pos++;
			value = &p->val;
			value_type = C_TYPE_INFO_P(value);
			if (EXPECTED(value_type != IS_UNDEF)) {
				if (UNEXPECTED(value_type == IS_INDIRECT)) {
					value = C_INDIRECT_P(value);
					value_type = C_TYPE_INFO_P(value);
					if (EXPECTED(value_type != IS_UNDEF)
					 && EXPECTED(crex_check_property_access(C_OBJ_P(array), p->key, 0) == SUCCESS)) {
						break;
					}
				} else if (EXPECTED(C_OBJCE_P(array)->default_properties_count == 0)
						|| !p->key
						|| crex_check_property_access(C_OBJ_P(array), p->key, 1) == SUCCESS) {
					break;
				}
			}
			p++;
		}
		EG(ht_iterators)[C_FE_ITER_P(array)].pos = pos;
		if (RETURN_VALUE_USED(opline)) {
			if (UNEXPECTED(!p->key)) {
				ZVAL_LONG(EX_VAR(opline->result.var), p->h);
			} else if (ZSTR_VAL(p->key)[0]) {
				ZVAL_STR_COPY(EX_VAR(opline->result.var), p->key);
			} else {
				const char *class_name, *prop_name;
				size_t prop_name_len;
				crex_unmangle_property_name_ex(
					p->key, &class_name, &prop_name, &prop_name_len);
				ZVAL_STRINGL(EX_VAR(opline->result.var), prop_name, prop_name_len);
			}
		}
	} else {
		const crex_object_iterator_funcs *funcs = iter->funcs;
		if (EXPECTED(++iter->index > 0)) {
			/* This could cause an endless loop if index becomes zero again.
			 * In case that ever happens we need an additional flag. */
			funcs->move_forward(iter);
			if (UNEXPECTED(EG(exception) != NULL)) {
				UNDEF_RESULT();
				HANDLE_EXCEPTION();
			}
			if (UNEXPECTED(funcs->valid(iter) == FAILURE)) {
				/* reached end of iteration */
				if (UNEXPECTED(EG(exception) != NULL)) {
					UNDEF_RESULT();
					HANDLE_EXCEPTION();
				}
fe_fetch_r_exit:
				CREX_VM_SET_RELATIVE_OPCODE(opline, opline->extended_value);
				CREX_VM_CONTINUE();
			}
		}
		value = funcs->get_current_data(iter);
		if (UNEXPECTED(EG(exception) != NULL)) {
			UNDEF_RESULT();
			HANDLE_EXCEPTION();
		}
		if (!value) {
			/* failure in get_current_data */
			goto fe_fetch_r_exit;
		}
		if (RETURN_VALUE_USED(opline)) {
			if (funcs->get_current_key) {
				funcs->get_current_key(iter, EX_VAR(opline->result.var));
				if (UNEXPECTED(EG(exception) != NULL)) {
					UNDEF_RESULT();
					HANDLE_EXCEPTION();
				}
			} else {
				ZVAL_LONG(EX_VAR(opline->result.var), iter->index);
			}
		}
		value_type = C_TYPE_INFO_P(value);
	}

	if (EXPECTED(opline->op2_type == IS_CV)) {
		zval *variable_ptr = EX_VAR(opline->op2.var);
		crex_assign_to_variable(variable_ptr, value, IS_CV, EX_USES_STRICT_TYPES());
	} else {
		zval *res = EX_VAR(opline->op2.var);
		crex_refcounted *gc = C_COUNTED_P(value);

		ZVAL_COPY_VALUE_EX(res, value, gc, value_type);
		if (C_TYPE_INFO_REFCOUNTED(value_type)) {
			GC_ADDREF(gc);
		}
	}
	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ISSET_ISEMPTY_STATIC_PROP_SPEC_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *value;
	crex_result fetch_result;
	bool result;

	SAVE_OPLINE();

	fetch_result = crex_fetch_static_property_address(&value, NULL, opline->extended_value & ~CREX_ISEMPTY, BP_VAR_IS, 0 OPLINE_CC EXECUTE_DATA_CC);

	if (!(opline->extended_value & CREX_ISEMPTY)) {
		result = fetch_result == SUCCESS && C_TYPE_P(value) > IS_NULL &&
		    (!C_ISREF_P(value) || C_TYPE_P(C_REFVAL_P(value)) != IS_NULL);
	} else {
		result = fetch_result != SUCCESS || !i_crex_is_true(value);
	}

	CREX_VM_SMART_BRANCH(result, 1);
}

static CREX_VM_COLD CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_EXIT_SPEC_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	SAVE_OPLINE();
	if (opline->op1_type != IS_UNUSED) {
		zval *ptr = get_zval_ptr(opline->op1_type, opline->op1, BP_VAR_R);

		do {
			if (C_TYPE_P(ptr) == IS_LONG) {
				EG(exit_status) = C_LVAL_P(ptr);
			} else {
				if ((opline->op1_type & (IS_VAR|IS_CV)) && C_ISREF_P(ptr)) {
					ptr = C_REFVAL_P(ptr);
					if (C_TYPE_P(ptr) == IS_LONG) {
						EG(exit_status) = C_LVAL_P(ptr);
						break;
					}
				}
				crex_print_zval(ptr, 0);
			}
		} while (0);
		FREE_OP(opline->op1_type, opline->op1.var);
	}

	if (!EG(exception)) {
		crex_throw_unwind_exit();
	}
	HANDLE_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_BEGIN_SILENCE_SPEC_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	ZVAL_LONG(EX_VAR(opline->result.var), EG(error_reporting));

	if (!E_HAS_ONLY_FATAL_ERRORS(EG(error_reporting))) {
		do {
			/* Do not silence fatal errors */
			EG(error_reporting) &= E_FATAL_ERRORS;
			if (!EG(error_reporting_ini_entry)) {
				zval *zv = crex_hash_find_known_hash(EG(ini_directives), ZSTR_KNOWN(CREX_STR_ERROR_REPORTING));
				if (zv) {
					EG(error_reporting_ini_entry) = (crex_ini_entry *)C_PTR_P(zv);
				} else {
					break;
				}
			}
			if (!EG(error_reporting_ini_entry)->modified) {
				if (!EG(modified_ini_directives)) {
					ALLOC_HASHTABLE(EG(modified_ini_directives));
					crex_hash_init(EG(modified_ini_directives), 8, NULL, NULL, 0);
				}
				if (EXPECTED(crex_hash_add_ptr(EG(modified_ini_directives), ZSTR_KNOWN(CREX_STR_ERROR_REPORTING), EG(error_reporting_ini_entry)) != NULL)) {
					EG(error_reporting_ini_entry)->orig_value = EG(error_reporting_ini_entry)->value;
					EG(error_reporting_ini_entry)->orig_modifiable = EG(error_reporting_ini_entry)->modifiable;
					EG(error_reporting_ini_entry)->modified = 1;
				}
			}
		} while (0);
	}
	CREX_VM_NEXT_OPCODE();
}

static CREX_VM_COLD CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_EXT_STMT_SPEC_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (!EG(no_extensions)) {
		SAVE_OPLINE();
		crex_llist_apply_with_argument(&crex_extensions, (llist_apply_with_arg_func_t) crex_extension_statement_handler, execute_data);
		CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
	}
	CREX_VM_NEXT_OPCODE();
}

static CREX_VM_COLD CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_EXT_FCALL_BEGIN_SPEC_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (!EG(no_extensions)) {
		SAVE_OPLINE();
		crex_llist_apply_with_argument(&crex_extensions, (llist_apply_with_arg_func_t) crex_extension_fcall_begin_handler, execute_data);
		CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
	}
	CREX_VM_NEXT_OPCODE();
}

static CREX_VM_COLD CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_EXT_FCALL_END_SPEC_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (!EG(no_extensions)) {
		SAVE_OPLINE();
		crex_llist_apply_with_argument(&crex_extensions, (llist_apply_with_arg_func_t) crex_extension_fcall_end_handler, execute_data);
		CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
	}
	CREX_VM_NEXT_OPCODE();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_DECLARE_ANON_CLASS_SPEC_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	zval *zv;
	crex_class_entry *ce;
	USE_OPLINE

	ce = CACHED_PTR(opline->extended_value);
	if (UNEXPECTED(ce == NULL)) {
		crex_string *rtd_key = C_STR_P(RT_CONSTANT(opline, opline->op1));
		zv = crex_hash_find_known_hash(EG(class_table), rtd_key);
		CREX_ASSERT(zv != NULL);
		ce = C_CE_P(zv);
		if (!(ce->ce_flags & CREX_ACC_LINKED)) {
			SAVE_OPLINE();
			ce = crex_do_link_class(ce, (opline->op2_type == IS_CONST) ? C_STR_P(RT_CONSTANT(opline, opline->op2)) : NULL, rtd_key);
			if (!ce) {
				HANDLE_EXCEPTION();
			}
		}
		CACHE_PTR(opline->extended_value, ce);
	}
	C_CE_P(EX_VAR(opline->result.var)) = ce;
	CREX_VM_NEXT_OPCODE();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_DECLARE_FUNCTION_SPEC_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	crex_function *func;
	USE_OPLINE

	SAVE_OPLINE();
	func = (crex_function *) EX(func)->op_array.dynamic_func_defs[opline->op2.num];
	do_bind_function(func, RT_CONSTANT(opline, opline->op1));
	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_TICKS_SPEC_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if ((uint32_t)++EG(ticks_count) >= opline->extended_value) {
		EG(ticks_count) = 0;
		if (crex_ticks_function) {
			SAVE_OPLINE();
			crex_fiber_switch_block();
			crex_ticks_function(opline->extended_value);
			crex_fiber_switch_unblock();
			CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
		}
	}
	CREX_VM_NEXT_OPCODE();
}

static CREX_VM_HOT CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_EXT_NOP_SPEC_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	CREX_VM_NEXT_OPCODE();
}

static CREX_VM_HOT CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_NOP_SPEC_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	CREX_VM_NEXT_OPCODE();
}

static crex_never_inline CREX_OPCODE_HANDLER_RET CREX_FASTCALL crex_dispatch_try_catch_finally_helper_SPEC(uint32_t try_catch_offset, uint32_t op_num CREX_OPCODE_HANDLER_ARGS_DC)
{
	/* May be NULL during generator closing (only finally blocks are executed) */
	crex_object *ex = EG(exception);

	/* Walk try/catch/finally structures upwards, performing the necessary actions */
	for (; try_catch_offset != (uint32_t) -1; try_catch_offset--) {
		crex_try_catch_element *try_catch =
			&EX(func)->op_array.try_catch_array[try_catch_offset];

		if (op_num < try_catch->catch_op && ex) {
			/* Go to catch block */
			cleanup_live_vars(execute_data, op_num, try_catch->catch_op);
			CREX_VM_JMP_EX(&EX(func)->op_array.opcodes[try_catch->catch_op], 0);

		} else if (op_num < try_catch->finally_op) {
			if (ex && crex_is_unwind_exit(ex)) {
				/* Don't execute finally blocks on exit (for now) */
				continue;
			}

			/* Go to finally block */
			zval *fast_call = EX_VAR(EX(func)->op_array.opcodes[try_catch->finally_end].op1.var);
			cleanup_live_vars(execute_data, op_num, try_catch->finally_op);
			C_OBJ_P(fast_call) = EG(exception);
			EG(exception) = NULL;
			C_OPLINE_NUM_P(fast_call) = (uint32_t)-1;
			CREX_VM_JMP_EX(&EX(func)->op_array.opcodes[try_catch->finally_op], 0);

		} else if (op_num < try_catch->finally_end) {
			zval *fast_call = EX_VAR(EX(func)->op_array.opcodes[try_catch->finally_end].op1.var);

			/* cleanup incomplete RETURN statement */
			if (C_OPLINE_NUM_P(fast_call) != (uint32_t)-1
			 && (EX(func)->op_array.opcodes[C_OPLINE_NUM_P(fast_call)].op2_type & (IS_TMP_VAR | IS_VAR))) {
				zval *return_value = EX_VAR(EX(func)->op_array.opcodes[C_OPLINE_NUM_P(fast_call)].op2.var);

				zval_ptr_dtor(return_value);
			}

			/* Chain potential exception from wrapping finally block */
			if (C_OBJ_P(fast_call)) {
				if (ex) {
					if (crex_is_unwind_exit(ex) || crex_is_graceful_exit(ex)) {
						/* discard the previously thrown exception */
						OBJ_RELEASE(C_OBJ_P(fast_call));
					} else {
						crex_exception_set_previous(ex, C_OBJ_P(fast_call));
					}
				} else {
					ex = EG(exception) = C_OBJ_P(fast_call);
				}
			}
		}
	}

	/* Uncaught exception */
	if (crex_observer_fcall_op_array_extension != -1) {
		crex_observer_fcall_end(execute_data, NULL);
	}
	cleanup_live_vars(execute_data, op_num, 0);
	if (UNEXPECTED((EX_CALL_INFO() & CREX_CALL_GENERATOR) != 0)) {
		crex_generator *generator = crex_get_running_generator(EXECUTE_DATA_C);
		EG(current_execute_data) = EX(prev_execute_data);
		crex_generator_close(generator, 1);
		CREX_VM_RETURN();
	} else {
		/* We didn't execute RETURN, and have to initialize return_value */
		if (EX(return_value)) {
			ZVAL_UNDEF(EX(return_value));
		}
		CREX_VM_TAIL_CALL(crex_leave_helper_SPEC(CREX_OPCODE_HANDLER_ARGS_PASSTHRU));
	}
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_HANDLE_EXCEPTION_SPEC_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	const crex_op *throw_op = EG(opline_before_exception);

	/* Exception was thrown before executing any op */
	if (UNEXPECTED(!throw_op)) {
		CREX_VM_TAIL_CALL(crex_dispatch_try_catch_finally_helper_SPEC(-1, 0 CREX_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
	}

	uint32_t throw_op_num = throw_op - EX(func)->op_array.opcodes;
	int i, current_try_catch_offset = -1;

	if ((throw_op->opcode == CREX_FREE || throw_op->opcode == CREX_FE_FREE)
		&& throw_op->extended_value & CREX_FREE_ON_RETURN) {
		/* exceptions thrown because of loop var destruction on return/break/...
		 * are logically thrown at the end of the foreach loop, so adjust the
		 * throw_op_num.
		 */
		const crex_live_range *range = find_live_range(
			&EX(func)->op_array, throw_op_num, throw_op->op1.var);
		/* free op1 of the corresponding RETURN */
		for (i = throw_op_num; i < range->end; i++) {
			if (EX(func)->op_array.opcodes[i].opcode == CREX_FREE
			 || EX(func)->op_array.opcodes[i].opcode == CREX_FE_FREE) {
				/* pass */
			} else {
				if (EX(func)->op_array.opcodes[i].opcode == CREX_RETURN
				 && (EX(func)->op_array.opcodes[i].op1_type & (IS_VAR|IS_TMP_VAR))) {
					zval_ptr_dtor(EX_VAR(EX(func)->op_array.opcodes[i].op1.var));
				}
				break;
			}
		}
		throw_op_num = range->end;
	}

	/* Find the innermost try/catch/finally the exception was thrown in */
	for (i = 0; i < EX(func)->op_array.last_try_catch; i++) {
		crex_try_catch_element *try_catch = &EX(func)->op_array.try_catch_array[i];
		if (try_catch->try_op > throw_op_num) {
			/* further blocks will not be relevant... */
			break;
		}
		if (throw_op_num < try_catch->catch_op || throw_op_num < try_catch->finally_end) {
			current_try_catch_offset = i;
		}
	}

	cleanup_unfinished_calls(execute_data, throw_op_num);

	if (throw_op->result_type & (IS_VAR | IS_TMP_VAR)) {
		switch (throw_op->opcode) {
			case CREX_ADD_ARRAY_ELEMENT:
			case CREX_ADD_ARRAY_UNPACK:
			case CREX_ROPE_INIT:
			case CREX_ROPE_ADD:
				break; /* exception while building structures, live range handling will free those */

			case CREX_FETCH_CLASS:
			case CREX_DECLARE_ANON_CLASS:
				break; /* return value is crex_class_entry pointer */

			default:
				/* smart branch opcodes may not initialize result */
				if (!crex_is_smart_branch(throw_op)) {
					zval_ptr_dtor_nogc(EX_VAR(throw_op->result.var));
				}
		}
	}

	CREX_VM_TAIL_CALL(crex_dispatch_try_catch_finally_helper_SPEC(current_try_catch_offset, throw_op_num CREX_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_USER_OPCODE_SPEC_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	int ret;

	SAVE_OPLINE();
	ret = crex_user_opcode_handlers[opline->opcode](execute_data);
	opline = EX(opline);

	switch (ret) {
		case CREX_USER_OPCODE_CONTINUE:
			CREX_VM_CONTINUE();
		case CREX_USER_OPCODE_RETURN:
			if (UNEXPECTED((EX_CALL_INFO() & CREX_CALL_GENERATOR) != 0)) {
				crex_generator *generator = crex_get_running_generator(EXECUTE_DATA_C);
				EG(current_execute_data) = EX(prev_execute_data);
				crex_generator_close(generator, 1);
				CREX_VM_RETURN();
			} else {
				CREX_VM_TAIL_CALL(crex_leave_helper_SPEC(CREX_OPCODE_HANDLER_ARGS_PASSTHRU));
			}
		case CREX_USER_OPCODE_ENTER:
			CREX_VM_ENTER();
		case CREX_USER_OPCODE_LEAVE:
			CREX_VM_LEAVE();
		case CREX_USER_OPCODE_DISPATCH:
			CREX_VM_DISPATCH(opline->opcode, opline);
		default:
			CREX_VM_DISPATCH((uint8_t)(ret & 0xff), opline);
	}
}

static crex_never_inline CREX_COLD CREX_OPCODE_HANDLER_RET CREX_FASTCALL crex_yield_in_closed_generator_helper_SPEC(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	SAVE_OPLINE();
	crex_throw_error(NULL, "Cannot yield from finally in a force-closed generator");
	FREE_OP(opline->op2_type, opline->op2.var);
	FREE_OP(opline->op1_type, opline->op1.var);
	UNDEF_RESULT();
	HANDLE_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_DISCARD_EXCEPTION_SPEC_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *fast_call = EX_VAR(opline->op1.var);
	SAVE_OPLINE();

	/* cleanup incomplete RETURN statement */
	if (C_OPLINE_NUM_P(fast_call) != (uint32_t)-1
	 && (EX(func)->op_array.opcodes[C_OPLINE_NUM_P(fast_call)].op2_type & (IS_TMP_VAR | IS_VAR))) {
		zval *return_value = EX_VAR(EX(func)->op_array.opcodes[C_OPLINE_NUM_P(fast_call)].op2.var);

		zval_ptr_dtor(return_value);
	}

	/* cleanup delayed exception */
	if (C_OBJ_P(fast_call) != NULL) {
		/* discard the previously thrown exception */
		OBJ_RELEASE(C_OBJ_P(fast_call));
		C_OBJ_P(fast_call) = NULL;
	}

	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FAST_CALL_SPEC_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *fast_call = EX_VAR(opline->result.var);

	C_OBJ_P(fast_call) = NULL;
	/* set return address */
	C_OPLINE_NUM_P(fast_call) = opline - EX(func)->op_array.opcodes;
	CREX_VM_JMP_EX(OP_JMP_ADDR(opline, opline->op1), 0);
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FAST_RET_SPEC_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *fast_call = EX_VAR(opline->op1.var);
	uint32_t current_try_catch_offset, current_op_num;

	if (C_OPLINE_NUM_P(fast_call) != (uint32_t)-1) {
		const crex_op *fast_ret = EX(func)->op_array.opcodes + C_OPLINE_NUM_P(fast_call);

		CREX_VM_JMP_EX(fast_ret + 1, 0);
	}

	/* special case for unhandled exceptions */
	EG(exception) = C_OBJ_P(fast_call);
	C_OBJ_P(fast_call) = NULL;
	current_try_catch_offset = opline->op2.num;
	current_op_num = opline - EX(func)->op_array.opcodes;
	CREX_VM_TAIL_CALL(crex_dispatch_try_catch_finally_helper_SPEC(current_try_catch_offset, current_op_num CREX_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ASSERT_CHECK_SPEC_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (EG(assertions) <= 0) {
		crex_op *target = OP_JMP_ADDR(opline, opline->op2);
		if (RETURN_VALUE_USED(opline)) {
			ZVAL_TRUE(EX_VAR(opline->result.var));
		}
		CREX_VM_JMP_EX(target, 0);
	} else {
		CREX_VM_NEXT_OPCODE();
	}
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_CALL_TRAMPOLINE_SPEC_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	crex_array *args = NULL;
	crex_function *fbc = EX(func);
	zval *ret = EX(return_value);
	uint32_t call_info = EX_CALL_INFO() & (CREX_CALL_NESTED | CREX_CALL_TOP | CREX_CALL_RELEASE_THIS | CREX_CALL_HAS_EXTRA_NAMED_PARAMS);
	uint32_t num_args = EX_NUM_ARGS();
	crex_execute_data *call;

	SAVE_OPLINE();

	if (num_args) {
		zval *p = CREX_CALL_ARG(execute_data, 1);
		zval *end = p + num_args;

		args = crex_new_array(num_args);
		crex_hash_real_init_packed(args);
		CREX_HASH_FILL_PACKED(args) {
			do {
				CREX_HASH_FILL_ADD(p);
				p++;
			} while (p != end);
		} CREX_HASH_FILL_END();
	}

	call = execute_data;
	execute_data = EG(current_execute_data) = EX(prev_execute_data);

	call->func = (fbc->op_array.fn_flags & CREX_ACC_STATIC) ? fbc->op_array.scope->__callstatic : fbc->op_array.scope->__call;
	CREX_ASSERT(crex_vm_calc_used_stack(2, call->func) <= (size_t)(((char*)EG(vm_stack_end)) - (char*)call));
	CREX_CALL_NUM_ARGS(call) = 2;

	ZVAL_STR(CREX_CALL_ARG(call, 1), fbc->common.function_name);

	zval *call_args = CREX_CALL_ARG(call, 2);
	if (args) {
		ZVAL_ARR(call_args, args);
	} else {
		ZVAL_EMPTY_ARRAY(call_args);
	}
	if (UNEXPECTED(call_info & CREX_CALL_HAS_EXTRA_NAMED_PARAMS)) {
		if (crex_hash_num_elements(C_ARRVAL_P(call_args)) == 0) {
			GC_ADDREF(call->extra_named_params);
			ZVAL_ARR(call_args, call->extra_named_params);
		} else {
			SEPARATE_ARRAY(call_args);
			crex_hash_copy(C_ARRVAL_P(call_args), call->extra_named_params, zval_add_ref);
		}
	}
	crex_free_trampoline(fbc);
	fbc = call->func;

	if (EXPECTED(fbc->type == CREX_USER_FUNCTION)) {
		if (UNEXPECTED(!RUN_TIME_CACHE(&fbc->op_array))) {
			init_func_run_time_cache(&fbc->op_array);
		}
		execute_data = call;
		i_init_func_execute_data(&fbc->op_array, ret, 0 EXECUTE_DATA_CC);
		if (EXPECTED(crex_execute_ex == execute_ex)) {
			LOAD_OPLINE_EX();


			CREX_VM_ENTER_EX();
		} else {
			SAVE_OPLINE_EX();

			execute_data = EX(prev_execute_data);
			if (execute_data) {
				LOAD_OPLINE();
			}
			CREX_ADD_CALL_FLAG(call, CREX_CALL_TOP);
			crex_execute_ex(call);
		}
	} else {
		zval retval;

		CREX_ASSERT(fbc->type == CREX_INTERNAL_FUNCTION);

		EG(current_execute_data) = call;

#if CREX_DEBUG
		bool should_throw = crex_internal_call_should_throw(fbc, call);
#endif

		if (ret == NULL) {
			ret = &retval;
		}

		ZVAL_NULL(ret);

		if (!crex_execute_internal) {
			/* saves one function call if crex_execute_internal is not used */
			fbc->internal_function.handler(call, ret);
		} else {
			crex_execute_internal(call, ret);
		}

#if CREX_DEBUG
		if (!EG(exception) && call->func) {
			if (should_throw) {
				crex_internal_call_arginfo_violation(call->func);
			}
			CREX_ASSERT(!(call->func->common.fn_flags & CREX_ACC_HAS_RETURN_TYPE) ||
				crex_verify_internal_return_type(call->func, ret));
			CREX_ASSERT((call->func->common.fn_flags & CREX_ACC_RETURN_REFERENCE)
				? C_ISREF_P(ret) : !C_ISREF_P(ret));
			crex_verify_internal_func_info(call->func, ret);
		}
#endif

		EG(current_execute_data) = call->prev_execute_data;

		crex_vm_stack_free_args(call);
		if (ret == &retval) {
			zval_ptr_dtor(ret);
		}
	}

	execute_data = EG(current_execute_data);

	if (!execute_data || !EX(func) || !CREX_USER_CODE(EX(func)->type) || (call_info & CREX_CALL_TOP)) {
		CREX_VM_RETURN();
	}

	if (UNEXPECTED(call_info & CREX_CALL_RELEASE_THIS)) {
		crex_object *object = C_OBJ(call->This);
		OBJ_RELEASE(object);
	}
	crex_vm_stack_free_call_frame(call);

	if (UNEXPECTED(EG(exception) != NULL)) {
		crex_rethrow_exception(execute_data);
		HANDLE_EXCEPTION_LEAVE();
	}

	LOAD_OPLINE();
	CREX_VM_INC_OPCODE();
	CREX_VM_LEAVE();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_CALL_TRAMPOLINE_SPEC_OBSERVER_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	crex_array *args = NULL;
	crex_function *fbc = EX(func);
	zval *ret = EX(return_value);
	uint32_t call_info = EX_CALL_INFO() & (CREX_CALL_NESTED | CREX_CALL_TOP | CREX_CALL_RELEASE_THIS | CREX_CALL_HAS_EXTRA_NAMED_PARAMS);
	uint32_t num_args = EX_NUM_ARGS();
	crex_execute_data *call;

	SAVE_OPLINE();

	if (num_args) {
		zval *p = CREX_CALL_ARG(execute_data, 1);
		zval *end = p + num_args;

		args = crex_new_array(num_args);
		crex_hash_real_init_packed(args);
		CREX_HASH_FILL_PACKED(args) {
			do {
				CREX_HASH_FILL_ADD(p);
				p++;
			} while (p != end);
		} CREX_HASH_FILL_END();
	}

	call = execute_data;
	execute_data = EG(current_execute_data) = EX(prev_execute_data);

	call->func = (fbc->op_array.fn_flags & CREX_ACC_STATIC) ? fbc->op_array.scope->__callstatic : fbc->op_array.scope->__call;
	CREX_ASSERT(crex_vm_calc_used_stack(2, call->func) <= (size_t)(((char*)EG(vm_stack_end)) - (char*)call));
	CREX_CALL_NUM_ARGS(call) = 2;

	ZVAL_STR(CREX_CALL_ARG(call, 1), fbc->common.function_name);

	zval *call_args = CREX_CALL_ARG(call, 2);
	if (args) {
		ZVAL_ARR(call_args, args);
	} else {
		ZVAL_EMPTY_ARRAY(call_args);
	}
	if (UNEXPECTED(call_info & CREX_CALL_HAS_EXTRA_NAMED_PARAMS)) {
		if (crex_hash_num_elements(C_ARRVAL_P(call_args)) == 0) {
			GC_ADDREF(call->extra_named_params);
			ZVAL_ARR(call_args, call->extra_named_params);
		} else {
			SEPARATE_ARRAY(call_args);
			crex_hash_copy(C_ARRVAL_P(call_args), call->extra_named_params, zval_add_ref);
		}
	}
	crex_free_trampoline(fbc);
	fbc = call->func;

	if (EXPECTED(fbc->type == CREX_USER_FUNCTION)) {
		if (UNEXPECTED(!RUN_TIME_CACHE(&fbc->op_array))) {
			init_func_run_time_cache(&fbc->op_array);
		}
		execute_data = call;
		i_init_func_execute_data(&fbc->op_array, ret, 0 EXECUTE_DATA_CC);
		if (EXPECTED(crex_execute_ex == execute_ex)) {
			LOAD_OPLINE_EX();
			SAVE_OPLINE();
			crex_observer_fcall_begin(execute_data);
			CREX_VM_ENTER_EX();
		} else {
			SAVE_OPLINE_EX();
			crex_observer_fcall_begin(execute_data);
			execute_data = EX(prev_execute_data);
			if (execute_data) {
				LOAD_OPLINE();
			}
			CREX_ADD_CALL_FLAG(call, CREX_CALL_TOP);
			crex_execute_ex(call);
		}
	} else {
		zval retval;

		CREX_ASSERT(fbc->type == CREX_INTERNAL_FUNCTION);

		EG(current_execute_data) = call;

#if CREX_DEBUG
		bool should_throw = crex_internal_call_should_throw(fbc, call);
#endif

		if (ret == NULL) {
			ret = &retval;
		}

		ZVAL_NULL(ret);
		crex_observer_fcall_begin(call);
		if (!crex_execute_internal) {
			/* saves one function call if crex_execute_internal is not used */
			fbc->internal_function.handler(call, ret);
		} else {
			crex_execute_internal(call, ret);
		}

#if CREX_DEBUG
		if (!EG(exception) && call->func) {
			if (should_throw) {
				crex_internal_call_arginfo_violation(call->func);
			}
			CREX_ASSERT(!(call->func->common.fn_flags & CREX_ACC_HAS_RETURN_TYPE) ||
				crex_verify_internal_return_type(call->func, ret));
			CREX_ASSERT((call->func->common.fn_flags & CREX_ACC_RETURN_REFERENCE)
				? C_ISREF_P(ret) : !C_ISREF_P(ret));
			crex_verify_internal_func_info(call->func, ret);
		}
#endif
		crex_observer_fcall_end(call, EG(exception) ? NULL : ret);

		EG(current_execute_data) = call->prev_execute_data;

		crex_vm_stack_free_args(call);
		if (ret == &retval) {
			zval_ptr_dtor(ret);
		}
	}

	execute_data = EG(current_execute_data);

	if (!execute_data || !EX(func) || !CREX_USER_CODE(EX(func)->type) || (call_info & CREX_CALL_TOP)) {
		CREX_VM_RETURN();
	}

	if (UNEXPECTED(call_info & CREX_CALL_RELEASE_THIS)) {
		crex_object *object = C_OBJ(call->This);
		OBJ_RELEASE(object);
	}
	crex_vm_stack_free_call_frame(call);

	if (UNEXPECTED(EG(exception) != NULL)) {
		crex_rethrow_exception(execute_data);
		HANDLE_EXCEPTION_LEAVE();
	}

	LOAD_OPLINE();
	CREX_VM_INC_OPCODE();
	CREX_VM_LEAVE();
}

static CREX_VM_HOT CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_JMP_FORWARD_SPEC_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	OPLINE = OP_JMP_ADDR(opline, opline->op1);
	CREX_VM_CONTINUE();
}

static crex_never_inline CREX_OPCODE_HANDLER_RET CREX_FASTCALL crex_interrupt_helper_SPEC(CREX_OPCODE_HANDLER_ARGS)
{
	crex_atomic_bool_store_ex(&EG(vm_interrupt), false);
	SAVE_OPLINE();
	if (crex_atomic_bool_load_ex(&EG(timed_out))) {
		crex_timeout();
	} else if (crex_interrupt_function) {
		crex_interrupt_function(execute_data);
		if (EG(exception)) {
			/* We have to UNDEF result, because CREX_HANDLE_EXCEPTION is going to free it */
			const crex_op *throw_op = EG(opline_before_exception);

			if (throw_op
			 && throw_op->result_type & (IS_TMP_VAR|IS_VAR)
			 && throw_op->opcode != CREX_ADD_ARRAY_ELEMENT
			 && throw_op->opcode != CREX_ADD_ARRAY_UNPACK
			 && throw_op->opcode != CREX_ROPE_INIT
			 && throw_op->opcode != CREX_ROPE_ADD) {
				ZVAL_UNDEF(CREX_CALL_VAR(EG(current_execute_data), throw_op->result.var));

			}
		}
		CREX_VM_ENTER();
	}
	CREX_VM_CONTINUE();
}
static CREX_VM_HOT CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_INIT_FCALL_BY_NAME_SPEC_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	crex_function *fbc;
	zval *function_name, *func;
	crex_execute_data *call;

	fbc = CACHED_PTR(opline->result.num);
	if (UNEXPECTED(fbc == NULL)) {
		function_name = (zval*)RT_CONSTANT(opline, opline->op2);
		func = crex_hash_find_known_hash(EG(function_table), C_STR_P(function_name+1));
		if (UNEXPECTED(func == NULL)) {
			CREX_VM_TAIL_CALL(crex_undefined_function_helper_SPEC(CREX_OPCODE_HANDLER_ARGS_PASSTHRU));
		}
		fbc = C_FUNC_P(func);
		if (EXPECTED(fbc->type == CREX_USER_FUNCTION) && UNEXPECTED(!RUN_TIME_CACHE(&fbc->op_array))) {
			init_func_run_time_cache(&fbc->op_array);
		}
		CACHE_PTR(opline->result.num, fbc);
	}
	call = _crex_vm_stack_push_call_frame(CREX_CALL_NESTED_FUNCTION,
		fbc, opline->extended_value, NULL);
	call->prev_execute_data = EX(call);
	EX(call) = call;

	CREX_VM_NEXT_OPCODE();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_INIT_DYNAMIC_CALL_SPEC_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *function_name;
	crex_execute_data *call;

	SAVE_OPLINE();
	function_name = RT_CONSTANT(opline, opline->op2);

try_function_name:
	if (IS_CONST != IS_CONST && EXPECTED(C_TYPE_P(function_name) == IS_STRING)) {
		call = crex_init_dynamic_call_string(C_STR_P(function_name), opline->extended_value);
	} else if (IS_CONST != IS_CONST && EXPECTED(C_TYPE_P(function_name) == IS_OBJECT)) {
		call = crex_init_dynamic_call_object(C_OBJ_P(function_name), opline->extended_value);
	} else if (EXPECTED(C_TYPE_P(function_name) == IS_ARRAY)) {
		call = crex_init_dynamic_call_array(C_ARRVAL_P(function_name), opline->extended_value);
	} else if ((IS_CONST & (IS_VAR|IS_CV)) && EXPECTED(C_TYPE_P(function_name) == IS_REFERENCE)) {
		function_name = C_REFVAL_P(function_name);
		goto try_function_name;
	} else {
		if (IS_CONST == IS_CV && UNEXPECTED(C_TYPE_P(function_name) == IS_UNDEF)) {
			function_name = ZVAL_UNDEFINED_OP2();
			if (UNEXPECTED(EG(exception) != NULL)) {
				HANDLE_EXCEPTION();
			}
		}
		crex_throw_error(NULL, "Value of type %s is not callable",
			crex_zval_type_name(function_name));
		call = NULL;
	}

	if (IS_CONST & (IS_VAR|IS_TMP_VAR)) {

		if (UNEXPECTED(EG(exception))) {
			if (call) {
				 if (call->func->common.fn_flags & CREX_ACC_CALL_VIA_TRAMPOLINE) {
					crex_string_release_ex(call->func->common.function_name, 0);
					crex_free_trampoline(call->func);
				}
				crex_vm_stack_free_call_frame(call);
			}
			HANDLE_EXCEPTION();
		}
	} else if (!call) {
		HANDLE_EXCEPTION();
	}

	call->prev_execute_data = EX(call);
	EX(call) = call;

	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_VM_HOT CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_INIT_NS_FCALL_BY_NAME_SPEC_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *func_name;
	zval *func;
	crex_function *fbc;
	crex_execute_data *call;

	fbc = CACHED_PTR(opline->result.num);
	if (UNEXPECTED(fbc == NULL)) {
		func_name = (zval *)RT_CONSTANT(opline, opline->op2);
		func = crex_hash_find_known_hash(EG(function_table), C_STR_P(func_name + 1));
		if (func == NULL) {
			func = crex_hash_find_known_hash(EG(function_table), C_STR_P(func_name + 2));
			if (UNEXPECTED(func == NULL)) {
				CREX_VM_TAIL_CALL(crex_undefined_function_helper_SPEC(CREX_OPCODE_HANDLER_ARGS_PASSTHRU));
			}
		}
		fbc = C_FUNC_P(func);
		if (EXPECTED(fbc->type == CREX_USER_FUNCTION) && UNEXPECTED(!RUN_TIME_CACHE(&fbc->op_array))) {
			init_func_run_time_cache(&fbc->op_array);
		}
		CACHE_PTR(opline->result.num, fbc);
	}

	call = _crex_vm_stack_push_call_frame(CREX_CALL_NESTED_FUNCTION,
		fbc, opline->extended_value, NULL);
	call->prev_execute_data = EX(call);
	EX(call) = call;

	CREX_VM_NEXT_OPCODE();
}

static CREX_VM_HOT CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_INIT_FCALL_SPEC_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *fname;
	zval *func;
	crex_function *fbc;
	crex_execute_data *call;

	fbc = CACHED_PTR(opline->result.num);
	if (UNEXPECTED(fbc == NULL)) {
		fname = (zval*)RT_CONSTANT(opline, opline->op2);
		func = crex_hash_find_known_hash(EG(function_table), C_STR_P(fname));
		CREX_ASSERT(func != NULL && "Function existence must be checked at compile time");
		fbc = C_FUNC_P(func);
		if (EXPECTED(fbc->type == CREX_USER_FUNCTION) && UNEXPECTED(!RUN_TIME_CACHE(&fbc->op_array))) {
			init_func_run_time_cache(&fbc->op_array);
		}
		CACHE_PTR(opline->result.num, fbc);
	}

	call = _crex_vm_stack_push_call_frame_ex(
		opline->op1.num, CREX_CALL_NESTED_FUNCTION,
		fbc, opline->extended_value, NULL);
	call->prev_execute_data = EX(call);
	EX(call) = call;

	CREX_VM_NEXT_OPCODE();
}

static CREX_VM_HOT CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_RECV_INIT_SPEC_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	uint32_t arg_num;
	zval *param;

	CREX_VM_REPEATABLE_OPCODE

	arg_num = opline->op1.num;
	param = EX_VAR(opline->result.var);
	if (arg_num > EX_NUM_ARGS()) {
		zval *default_value = RT_CONSTANT(opline, opline->op2);

		if (C_OPT_TYPE_P(default_value) == IS_CONSTANT_AST) {
			zval *cache_val = (zval*)CACHE_ADDR(C_CACHE_SLOT_P(default_value));

			/* we keep in cache only not refcounted values */
			if (C_TYPE_P(cache_val) != IS_UNDEF) {
				ZVAL_COPY_VALUE(param, cache_val);
			} else {
				SAVE_OPLINE();
				ZVAL_COPY(param, default_value);
				crex_ast_evaluate_ctx ctx = {0};
				if (UNEXPECTED(zval_update_constant_with_ctx(param, EX(func)->op_array.scope, &ctx) != SUCCESS)) {
					zval_ptr_dtor_nogc(param);
					ZVAL_UNDEF(param);
					HANDLE_EXCEPTION();
				}
				if (!C_REFCOUNTED_P(param) && !ctx.had_side_effects) {
					ZVAL_COPY_VALUE(cache_val, param);
				}
			}
			goto recv_init_check_type;
		} else {
			ZVAL_COPY(param, default_value);
		}
	} else {
recv_init_check_type:
		if (UNEXPECTED((EX(func)->op_array.fn_flags & CREX_ACC_HAS_TYPE_HINTS) != 0)) {
			SAVE_OPLINE();
			if (UNEXPECTED(!crex_verify_recv_arg_type(EX(func), arg_num, param, CACHE_ADDR(opline->extended_value)))) {
				HANDLE_EXCEPTION();
			}
		}
	}

	CREX_VM_REPEAT_OPCODE(CREX_RECV_INIT);
	CREX_VM_NEXT_OPCODE();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_INIT_DYNAMIC_CALL_SPEC_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *function_name;
	crex_execute_data *call;

	SAVE_OPLINE();
	function_name = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);

try_function_name:
	if ((IS_TMP_VAR|IS_VAR) != IS_CONST && EXPECTED(C_TYPE_P(function_name) == IS_STRING)) {
		call = crex_init_dynamic_call_string(C_STR_P(function_name), opline->extended_value);
	} else if ((IS_TMP_VAR|IS_VAR) != IS_CONST && EXPECTED(C_TYPE_P(function_name) == IS_OBJECT)) {
		call = crex_init_dynamic_call_object(C_OBJ_P(function_name), opline->extended_value);
	} else if (EXPECTED(C_TYPE_P(function_name) == IS_ARRAY)) {
		call = crex_init_dynamic_call_array(C_ARRVAL_P(function_name), opline->extended_value);
	} else if (((IS_TMP_VAR|IS_VAR) & (IS_VAR|IS_CV)) && EXPECTED(C_TYPE_P(function_name) == IS_REFERENCE)) {
		function_name = C_REFVAL_P(function_name);
		goto try_function_name;
	} else {
		if ((IS_TMP_VAR|IS_VAR) == IS_CV && UNEXPECTED(C_TYPE_P(function_name) == IS_UNDEF)) {
			function_name = ZVAL_UNDEFINED_OP2();
			if (UNEXPECTED(EG(exception) != NULL)) {
				HANDLE_EXCEPTION();
			}
		}
		crex_throw_error(NULL, "Value of type %s is not callable",
			crex_zval_type_name(function_name));
		call = NULL;
	}

	if ((IS_TMP_VAR|IS_VAR) & (IS_VAR|IS_TMP_VAR)) {
		zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
		if (UNEXPECTED(EG(exception))) {
			if (call) {
				 if (call->func->common.fn_flags & CREX_ACC_CALL_VIA_TRAMPOLINE) {
					crex_string_release_ex(call->func->common.function_name, 0);
					crex_free_trampoline(call->func);
				}
				crex_vm_stack_free_call_frame(call);
			}
			HANDLE_EXCEPTION();
		}
	} else if (!call) {
		HANDLE_EXCEPTION();
	}

	call->prev_execute_data = EX(call);
	EX(call) = call;

	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_VM_HOT CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_RECV_SPEC_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	uint32_t arg_num = opline->op1.num;
	zval *param;

	if (UNEXPECTED(arg_num > EX_NUM_ARGS())) {
		CREX_VM_TAIL_CALL(crex_missing_arg_helper_SPEC(CREX_OPCODE_HANDLER_ARGS_PASSTHRU));
	}

	param = EX_VAR(opline->result.var);

	if (UNEXPECTED(!(opline->op2.num & (1u << C_TYPE_P(param))))) {
		CREX_VM_TAIL_CALL(crex_verify_recv_arg_type_helper_SPEC(param CREX_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
	}

	CREX_VM_NEXT_OPCODE();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_RECV_VARIADIC_SPEC_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	uint32_t arg_num = opline->op1.num;
	uint32_t arg_count = EX_NUM_ARGS();
	zval *params;

	SAVE_OPLINE();

	params = EX_VAR(opline->result.var);

	if (arg_num <= arg_count) {
		CREX_ASSERT(EX(func)->common.fn_flags & CREX_ACC_VARIADIC);
		CREX_ASSERT(EX(func)->common.num_args == arg_num - 1);
		crex_arg_info *arg_info = &EX(func)->common.arg_info[arg_num - 1];

		array_init_size(params, arg_count - arg_num + 1);
		crex_hash_real_init_packed(C_ARRVAL_P(params));
		CREX_HASH_FILL_PACKED(C_ARRVAL_P(params)) {
			zval *param = EX_VAR_NUM(EX(func)->op_array.last_var + EX(func)->op_array.T);
			if (UNEXPECTED(CREX_TYPE_IS_SET(arg_info->type))) {
				CREX_ADD_CALL_FLAG(execute_data, CREX_CALL_FREE_EXTRA_ARGS);
				do {
					if (UNEXPECTED(!crex_verify_variadic_arg_type(EX(func), arg_info, arg_num, param, CACHE_ADDR(opline->extended_value)))) {
						CREX_HASH_FILL_FINISH();
						HANDLE_EXCEPTION();
					}

					if (C_OPT_REFCOUNTED_P(param)) C_ADDREF_P(param);
					CREX_HASH_FILL_ADD(param);
					param++;
				} while (++arg_num <= arg_count);
			} else {
				do {
					if (C_OPT_REFCOUNTED_P(param)) C_ADDREF_P(param);
					CREX_HASH_FILL_ADD(param);
					param++;
				} while (++arg_num <= arg_count);
			}
		} CREX_HASH_FILL_END();
	} else {
		ZVAL_EMPTY_ARRAY(params);
	}

	if (EX_CALL_INFO() & CREX_CALL_HAS_EXTRA_NAMED_PARAMS) {
		crex_string *name;
		zval *param;
		crex_arg_info *arg_info = &EX(func)->common.arg_info[EX(func)->common.num_args];
		if (CREX_TYPE_IS_SET(arg_info->type)) {
			SEPARATE_ARRAY(params);
			CREX_HASH_MAP_FOREACH_STR_KEY_VAL(EX(extra_named_params), name, param) {
				if (UNEXPECTED(!crex_verify_variadic_arg_type(EX(func), arg_info, arg_num, param, CACHE_ADDR(opline->extended_value)))) {
					HANDLE_EXCEPTION();
				}
				C_TRY_ADDREF_P(param);
				crex_hash_add_new(C_ARRVAL_P(params), name, param);
			} CREX_HASH_FOREACH_END();
		} else if (crex_hash_num_elements(C_ARRVAL_P(params)) == 0) {
			GC_ADDREF(EX(extra_named_params));
			ZVAL_ARR(params, EX(extra_named_params));
		} else {
			SEPARATE_ARRAY(params);
			CREX_HASH_MAP_FOREACH_STR_KEY_VAL(EX(extra_named_params), name, param) {
				C_TRY_ADDREF_P(param);
				crex_hash_add_new(C_ARRVAL_P(params), name, param);
			} CREX_HASH_FOREACH_END();
		}
	}

	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_INIT_DYNAMIC_CALL_SPEC_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *function_name;
	crex_execute_data *call;

	SAVE_OPLINE();
	function_name = EX_VAR(opline->op2.var);

try_function_name:
	if (IS_CV != IS_CONST && EXPECTED(C_TYPE_P(function_name) == IS_STRING)) {
		call = crex_init_dynamic_call_string(C_STR_P(function_name), opline->extended_value);
	} else if (IS_CV != IS_CONST && EXPECTED(C_TYPE_P(function_name) == IS_OBJECT)) {
		call = crex_init_dynamic_call_object(C_OBJ_P(function_name), opline->extended_value);
	} else if (EXPECTED(C_TYPE_P(function_name) == IS_ARRAY)) {
		call = crex_init_dynamic_call_array(C_ARRVAL_P(function_name), opline->extended_value);
	} else if ((IS_CV & (IS_VAR|IS_CV)) && EXPECTED(C_TYPE_P(function_name) == IS_REFERENCE)) {
		function_name = C_REFVAL_P(function_name);
		goto try_function_name;
	} else {
		if (IS_CV == IS_CV && UNEXPECTED(C_TYPE_P(function_name) == IS_UNDEF)) {
			function_name = ZVAL_UNDEFINED_OP2();
			if (UNEXPECTED(EG(exception) != NULL)) {
				HANDLE_EXCEPTION();
			}
		}
		crex_throw_error(NULL, "Value of type %s is not callable",
			crex_zval_type_name(function_name));
		call = NULL;
	}

	if (IS_CV & (IS_VAR|IS_TMP_VAR)) {

		if (UNEXPECTED(EG(exception))) {
			if (call) {
				 if (call->func->common.fn_flags & CREX_ACC_CALL_VIA_TRAMPOLINE) {
					crex_string_release_ex(call->func->common.function_name, 0);
					crex_free_trampoline(call->func);
				}
				crex_vm_stack_free_call_frame(call);
			}
			HANDLE_EXCEPTION();
		}
	} else if (!call) {
		HANDLE_EXCEPTION();
	}

	call->prev_execute_data = EX(call);
	EX(call) = call;

	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_VM_COLD CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_BW_NOT_SPEC_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1;

	op1 = RT_CONSTANT(opline, opline->op1);
	if (EXPECTED(C_TYPE_INFO_P(op1) == IS_LONG)) {
		ZVAL_LONG(EX_VAR(opline->result.var), ~C_LVAL_P(op1));
		CREX_VM_NEXT_OPCODE();
	}

	CREX_VM_TAIL_CALL(crex_bw_not_helper_SPEC(op1 CREX_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static CREX_VM_COLD CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_BOOL_NOT_SPEC_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *val;

	val = RT_CONSTANT(opline, opline->op1);
	if (C_TYPE_INFO_P(val) == IS_TRUE) {
		ZVAL_FALSE(EX_VAR(opline->result.var));
	} else if (EXPECTED(C_TYPE_INFO_P(val) <= IS_TRUE)) {
		/* The result and op1 can be the same cv zval */
		const uint32_t orig_val_type = C_TYPE_INFO_P(val);
		ZVAL_TRUE(EX_VAR(opline->result.var));
		if (IS_CONST == IS_CV && UNEXPECTED(orig_val_type == IS_UNDEF)) {
			SAVE_OPLINE();
			ZVAL_UNDEFINED_OP1();
			CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
		}
	} else {
		SAVE_OPLINE();
		ZVAL_BOOL(EX_VAR(opline->result.var), !i_crex_is_true(val));

		CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
	}
	CREX_VM_NEXT_OPCODE();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ECHO_SPEC_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *z;

	SAVE_OPLINE();
	z = RT_CONSTANT(opline, opline->op1);

	if (C_TYPE_P(z) == IS_STRING) {
		crex_string *str = C_STR_P(z);

		if (ZSTR_LEN(str) != 0) {
			crex_write(ZSTR_VAL(str), ZSTR_LEN(str));
		}
	} else {
		crex_string *str = zval_get_string_func(z);

		if (ZSTR_LEN(str) != 0) {
			crex_write(ZSTR_VAL(str), ZSTR_LEN(str));
		} else if (IS_CONST == IS_CV && UNEXPECTED(C_TYPE_P(z) == IS_UNDEF)) {
			ZVAL_UNDEFINED_OP1();
		}
		crex_string_release_ex(str, 0);
	}

	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_VM_COLD CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_JMPC_SPEC_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *val;
	uint8_t op1_type;

	val = RT_CONSTANT(opline, opline->op1);

	if (C_TYPE_INFO_P(val) == IS_TRUE) {
		CREX_VM_NEXT_OPCODE();
	} else if (EXPECTED(C_TYPE_INFO_P(val) <= IS_TRUE)) {
		if (IS_CONST == IS_CV && UNEXPECTED(C_TYPE_INFO_P(val) == IS_UNDEF)) {
			SAVE_OPLINE();
			ZVAL_UNDEFINED_OP1();
			if (UNEXPECTED(EG(exception))) {
				HANDLE_EXCEPTION();
			}
		}
		CREX_VM_JMP_EX(OP_JMP_ADDR(opline, opline->op2), 0);
	}

	SAVE_OPLINE();
	op1_type = IS_CONST;
	if (i_crex_is_true(val)) {
		opline++;
	} else {
		opline = OP_JMP_ADDR(opline, opline->op2);
	}
	if (op1_type & (IS_TMP_VAR|IS_VAR)) {
		zval_ptr_dtor_nogc(val);
	}
	CREX_VM_JMP(opline);
}

static CREX_VM_COLD CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_JMPNC_SPEC_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *val;
	uint8_t op1_type;

	val = RT_CONSTANT(opline, opline->op1);

	if (C_TYPE_INFO_P(val) == IS_TRUE) {
		CREX_VM_JMP_EX(OP_JMP_ADDR(opline, opline->op2), 0);
	} else if (EXPECTED(C_TYPE_INFO_P(val) <= IS_TRUE)) {
		if (IS_CONST == IS_CV && UNEXPECTED(C_TYPE_INFO_P(val) == IS_UNDEF)) {
			SAVE_OPLINE();
			ZVAL_UNDEFINED_OP1();
			if (UNEXPECTED(EG(exception))) {
				HANDLE_EXCEPTION();
			}
		}
		CREX_VM_NEXT_OPCODE();
	}

	SAVE_OPLINE();
	op1_type = IS_CONST;
	if (i_crex_is_true(val)) {
		opline = OP_JMP_ADDR(opline, opline->op2);
	} else {
		opline++;
	}
	if (op1_type & (IS_TMP_VAR|IS_VAR)) {
		zval_ptr_dtor_nogc(val);
	}
	CREX_VM_JMP(opline);
}

static CREX_VM_COLD CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_JMPC_EX_SPEC_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *val;
	bool ret;

	val = RT_CONSTANT(opline, opline->op1);

	if (C_TYPE_INFO_P(val) == IS_TRUE) {
		ZVAL_TRUE(EX_VAR(opline->result.var));
		CREX_VM_NEXT_OPCODE();
	} else if (EXPECTED(C_TYPE_INFO_P(val) <= IS_TRUE)) {
		ZVAL_FALSE(EX_VAR(opline->result.var));
		if (IS_CONST == IS_CV && UNEXPECTED(C_TYPE_INFO_P(val) == IS_UNDEF)) {
			SAVE_OPLINE();
			ZVAL_UNDEFINED_OP1();
			if (UNEXPECTED(EG(exception))) {
				HANDLE_EXCEPTION();
			}
		}
		CREX_VM_JMP_EX(OP_JMP_ADDR(opline, opline->op2), 0);
	}

	SAVE_OPLINE();
	ret = i_crex_is_true(val);

	if (ret) {
		ZVAL_TRUE(EX_VAR(opline->result.var));
		opline++;
	} else {
		ZVAL_FALSE(EX_VAR(opline->result.var));
		opline = OP_JMP_ADDR(opline, opline->op2);
	}
	CREX_VM_JMP(opline);
}

static CREX_VM_COLD CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_JMPNC_EX_SPEC_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *val;
	bool ret;

	val = RT_CONSTANT(opline, opline->op1);

	if (C_TYPE_INFO_P(val) == IS_TRUE) {
		ZVAL_TRUE(EX_VAR(opline->result.var));
		CREX_VM_JMP_EX(OP_JMP_ADDR(opline, opline->op2), 0);
	} else if (EXPECTED(C_TYPE_INFO_P(val) <= IS_TRUE)) {
		ZVAL_FALSE(EX_VAR(opline->result.var));
		if (IS_CONST == IS_CV && UNEXPECTED(C_TYPE_INFO_P(val) == IS_UNDEF)) {
			SAVE_OPLINE();
			ZVAL_UNDEFINED_OP1();
			CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
		} else {
			CREX_VM_NEXT_OPCODE();
		}
	}

	SAVE_OPLINE();
	ret = i_crex_is_true(val);

	if (ret) {
		ZVAL_TRUE(EX_VAR(opline->result.var));
		opline = OP_JMP_ADDR(opline, opline->op2);
	} else {
		ZVAL_FALSE(EX_VAR(opline->result.var));
		opline++;
	}
	CREX_VM_JMP(opline);
}

static CREX_VM_HOT CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_RETURN_SPEC_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *retval_ptr;
	zval *return_value;

	retval_ptr = RT_CONSTANT(opline, opline->op1);
	return_value = EX(return_value);

	if (IS_CONST == IS_CV && UNEXPECTED(C_TYPE_INFO_P(retval_ptr) == IS_UNDEF)) {
		SAVE_OPLINE();
		retval_ptr = ZVAL_UNDEFINED_OP1();
		if (return_value) {
			ZVAL_NULL(return_value);
		}
	} else if (!return_value) {
		if (IS_CONST & (IS_VAR|IS_TMP_VAR)) {
			if (C_REFCOUNTED_P(retval_ptr) && !C_DELREF_P(retval_ptr)) {
				SAVE_OPLINE();
				rc_dtor_func(C_COUNTED_P(retval_ptr));
			}
		}
	} else {
		if ((IS_CONST & (IS_CONST|IS_TMP_VAR))) {
			ZVAL_COPY_VALUE(return_value, retval_ptr);
			if (IS_CONST == IS_CONST) {
				if (UNEXPECTED(C_OPT_REFCOUNTED_P(return_value))) {
					C_ADDREF_P(return_value);
				}
			}
		} else if (IS_CONST == IS_CV) {
			do {
				if (C_OPT_REFCOUNTED_P(retval_ptr)) {
					if (EXPECTED(!C_OPT_ISREF_P(retval_ptr))) {
						if (EXPECTED(!(EX_CALL_INFO() & (CREX_CALL_CODE|CREX_CALL_OBSERVED)))) {
							crex_refcounted *ref = C_COUNTED_P(retval_ptr);
							ZVAL_COPY_VALUE(return_value, retval_ptr);
							if (GC_MAY_LEAK(ref)) {
								SAVE_OPLINE();
								gc_possible_root(ref);
							}
							ZVAL_NULL(retval_ptr);
							break;
						} else {
							C_ADDREF_P(retval_ptr);
						}
					} else {
						retval_ptr = C_REFVAL_P(retval_ptr);
						if (C_OPT_REFCOUNTED_P(retval_ptr)) {
							C_ADDREF_P(retval_ptr);
						}
					}
				}
				ZVAL_COPY_VALUE(return_value, retval_ptr);
			} while (0);
		} else /* if (IS_CONST == IS_VAR) */ {
			if (UNEXPECTED(C_ISREF_P(retval_ptr))) {
				crex_refcounted *ref = C_COUNTED_P(retval_ptr);

				retval_ptr = C_REFVAL_P(retval_ptr);
				ZVAL_COPY_VALUE(return_value, retval_ptr);
				if (UNEXPECTED(GC_DELREF(ref) == 0)) {
					efree_size(ref, sizeof(crex_reference));
				} else if (C_OPT_REFCOUNTED_P(retval_ptr)) {
					C_ADDREF_P(retval_ptr);
				}
			} else {
				ZVAL_COPY_VALUE(return_value, retval_ptr);
			}
		}
	}



	CREX_VM_TAIL_CALL(crex_leave_helper_SPEC(CREX_OPCODE_HANDLER_ARGS_PASSTHRU));
}

static CREX_VM_COLD CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_RETURN_SPEC_OBSERVER_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *retval_ptr;
	zval *return_value;
	zval observer_retval;

	retval_ptr = get_zval_ptr_undef(opline->op1_type, opline->op1, BP_VAR_R);
	return_value = EX(return_value);
	if (!return_value) { return_value = &observer_retval; };
	if (opline->op1_type == IS_CV && UNEXPECTED(C_TYPE_INFO_P(retval_ptr) == IS_UNDEF)) {
		SAVE_OPLINE();
		retval_ptr = ZVAL_UNDEFINED_OP1();
		if (return_value) {
			ZVAL_NULL(return_value);
		}
	} else if (!return_value) {
		if (opline->op1_type & (IS_VAR|IS_TMP_VAR)) {
			if (C_REFCOUNTED_P(retval_ptr) && !C_DELREF_P(retval_ptr)) {
				SAVE_OPLINE();
				rc_dtor_func(C_COUNTED_P(retval_ptr));
			}
		}
	} else {
		if ((opline->op1_type & (IS_CONST|IS_TMP_VAR))) {
			ZVAL_COPY_VALUE(return_value, retval_ptr);
			if (opline->op1_type == IS_CONST) {
				if (UNEXPECTED(C_OPT_REFCOUNTED_P(return_value))) {
					C_ADDREF_P(return_value);
				}
			}
		} else if (opline->op1_type == IS_CV) {
			do {
				if (C_OPT_REFCOUNTED_P(retval_ptr)) {
					if (EXPECTED(!C_OPT_ISREF_P(retval_ptr))) {
						if (EXPECTED(!(EX_CALL_INFO() & (CREX_CALL_CODE|CREX_CALL_OBSERVED)))) {
							crex_refcounted *ref = C_COUNTED_P(retval_ptr);
							ZVAL_COPY_VALUE(return_value, retval_ptr);
							if (GC_MAY_LEAK(ref)) {
								SAVE_OPLINE();
								gc_possible_root(ref);
							}
							ZVAL_NULL(retval_ptr);
							break;
						} else {
							C_ADDREF_P(retval_ptr);
						}
					} else {
						retval_ptr = C_REFVAL_P(retval_ptr);
						if (C_OPT_REFCOUNTED_P(retval_ptr)) {
							C_ADDREF_P(retval_ptr);
						}
					}
				}
				ZVAL_COPY_VALUE(return_value, retval_ptr);
			} while (0);
		} else /* if (opline->op1_type == IS_VAR) */ {
			if (UNEXPECTED(C_ISREF_P(retval_ptr))) {
				crex_refcounted *ref = C_COUNTED_P(retval_ptr);

				retval_ptr = C_REFVAL_P(retval_ptr);
				ZVAL_COPY_VALUE(return_value, retval_ptr);
				if (UNEXPECTED(GC_DELREF(ref) == 0)) {
					efree_size(ref, sizeof(crex_reference));
				} else if (C_OPT_REFCOUNTED_P(retval_ptr)) {
					C_ADDREF_P(retval_ptr);
				}
			} else {
				ZVAL_COPY_VALUE(return_value, retval_ptr);
			}
		}
	}
	SAVE_OPLINE();
	crex_observer_fcall_end(execute_data, return_value);
	if (return_value == &observer_retval) { zval_ptr_dtor_nogc(&observer_retval); };
	CREX_VM_TAIL_CALL(crex_leave_helper_SPEC(CREX_OPCODE_HANDLER_ARGS_PASSTHRU));
}

static CREX_VM_COLD CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_RETURN_BY_REF_SPEC_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *retval_ptr;
	zval *return_value;

	SAVE_OPLINE();

	return_value = EX(return_value);

	do {
		if ((IS_CONST & (IS_CONST|IS_TMP_VAR)) ||
		    (IS_CONST == IS_VAR && opline->extended_value == CREX_RETURNS_VALUE)) {
			/* Not supposed to happen, but we'll allow it */
			crex_error(E_NOTICE, "Only variable references should be returned by reference");

			retval_ptr = RT_CONSTANT(opline, opline->op1);
			if (!return_value) {

			} else {
				if (IS_CONST == IS_VAR && UNEXPECTED(C_ISREF_P(retval_ptr))) {
					ZVAL_COPY_VALUE(return_value, retval_ptr);
					break;
				}

				ZVAL_NEW_REF(return_value, retval_ptr);
				if (IS_CONST == IS_CONST) {
					C_TRY_ADDREF_P(retval_ptr);
				}
			}
			break;
		}

		retval_ptr = crex_get_bad_ptr();

		if (IS_CONST == IS_VAR) {
			CREX_ASSERT(retval_ptr != &EG(uninitialized_zval));
			if (opline->extended_value == CREX_RETURNS_FUNCTION && !C_ISREF_P(retval_ptr)) {
				crex_error(E_NOTICE, "Only variable references should be returned by reference");
				if (return_value) {
					ZVAL_NEW_REF(return_value, retval_ptr);
				} else {

				}
				break;
			}
		}

		if (return_value) {
			if (C_ISREF_P(retval_ptr)) {
				C_ADDREF_P(retval_ptr);
			} else {
				ZVAL_MAKE_REF_EX(retval_ptr, 2);
			}
			ZVAL_REF(return_value, C_REF_P(retval_ptr));
		}

	} while (0);


	CREX_VM_TAIL_CALL(crex_leave_helper_SPEC(CREX_OPCODE_HANDLER_ARGS_PASSTHRU));
}

static CREX_VM_COLD CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_RETURN_BY_REF_SPEC_OBSERVER_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *retval_ptr;
	zval *return_value;
	zval observer_retval;

	SAVE_OPLINE();

	return_value = EX(return_value);
	if (!return_value) { return_value = &observer_retval; };
	do {
		if ((opline->op1_type & (IS_CONST|IS_TMP_VAR)) ||
		    (opline->op1_type == IS_VAR && opline->extended_value == CREX_RETURNS_VALUE)) {
			/* Not supposed to happen, but we'll allow it */
			crex_error(E_NOTICE, "Only variable references should be returned by reference");

			retval_ptr = get_zval_ptr(opline->op1_type, opline->op1, BP_VAR_R);
			if (!return_value) {
				FREE_OP(opline->op1_type, opline->op1.var);
			} else {
				if (opline->op1_type == IS_VAR && UNEXPECTED(C_ISREF_P(retval_ptr))) {
					ZVAL_COPY_VALUE(return_value, retval_ptr);
					break;
				}

				ZVAL_NEW_REF(return_value, retval_ptr);
				if (opline->op1_type == IS_CONST) {
					C_TRY_ADDREF_P(retval_ptr);
				}
			}
			break;
		}

		retval_ptr = get_zval_ptr_ptr(opline->op1_type, opline->op1, BP_VAR_W);

		if (opline->op1_type == IS_VAR) {
			CREX_ASSERT(retval_ptr != &EG(uninitialized_zval));
			if (opline->extended_value == CREX_RETURNS_FUNCTION && !C_ISREF_P(retval_ptr)) {
				crex_error(E_NOTICE, "Only variable references should be returned by reference");
				if (return_value) {
					ZVAL_NEW_REF(return_value, retval_ptr);
				} else {
					FREE_OP(opline->op1_type, opline->op1.var);
				}
				break;
			}
		}

		if (return_value) {
			if (C_ISREF_P(retval_ptr)) {
				C_ADDREF_P(retval_ptr);
			} else {
				ZVAL_MAKE_REF_EX(retval_ptr, 2);
			}
			ZVAL_REF(return_value, C_REF_P(retval_ptr));
		}

		FREE_OP(opline->op1_type, opline->op1.var);
	} while (0);

	crex_observer_fcall_end(execute_data, return_value);
	if (return_value == &observer_retval) { zval_ptr_dtor_nogc(&observer_retval); };
	CREX_VM_TAIL_CALL(crex_leave_helper_SPEC(CREX_OPCODE_HANDLER_ARGS_PASSTHRU));
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_GENERATOR_RETURN_SPEC_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *retval;

	crex_generator *generator = crex_get_running_generator(EXECUTE_DATA_C);

	SAVE_OPLINE();
	retval = RT_CONSTANT(opline, opline->op1);

	/* Copy return value into generator->retval */
	if ((IS_CONST & (IS_CONST|IS_TMP_VAR))) {
		ZVAL_COPY_VALUE(&generator->retval, retval);
		if (IS_CONST == IS_CONST) {
			if (UNEXPECTED(C_OPT_REFCOUNTED(generator->retval))) {
				C_ADDREF(generator->retval);
			}
		}
	} else if (IS_CONST == IS_CV) {
		ZVAL_COPY_DEREF(&generator->retval, retval);
	} else /* if (IS_CONST == IS_VAR) */ {
		if (UNEXPECTED(C_ISREF_P(retval))) {
			crex_refcounted *ref = C_COUNTED_P(retval);

			retval = C_REFVAL_P(retval);
			ZVAL_COPY_VALUE(&generator->retval, retval);
			if (UNEXPECTED(GC_DELREF(ref) == 0)) {
				efree_size(ref, sizeof(crex_reference));
			} else if (C_OPT_REFCOUNTED_P(retval)) {
				C_ADDREF_P(retval);
			}
		} else {
			ZVAL_COPY_VALUE(&generator->retval, retval);
		}
	}

	EG(current_execute_data) = EX(prev_execute_data);

	/* Close the generator to free up resources */
	crex_generator_close(generator, 1);

	/* Pass execution back to handling code */
	CREX_VM_RETURN();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_GENERATOR_RETURN_SPEC_OBSERVER_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *retval;

	crex_generator *generator = crex_get_running_generator(EXECUTE_DATA_C);

	SAVE_OPLINE();
	retval = get_zval_ptr(opline->op1_type, opline->op1, BP_VAR_R);

	/* Copy return value into generator->retval */
	if ((opline->op1_type & (IS_CONST|IS_TMP_VAR))) {
		ZVAL_COPY_VALUE(&generator->retval, retval);
		if (opline->op1_type == IS_CONST) {
			if (UNEXPECTED(C_OPT_REFCOUNTED(generator->retval))) {
				C_ADDREF(generator->retval);
			}
		}
	} else if (opline->op1_type == IS_CV) {
		ZVAL_COPY_DEREF(&generator->retval, retval);
	} else /* if (opline->op1_type == IS_VAR) */ {
		if (UNEXPECTED(C_ISREF_P(retval))) {
			crex_refcounted *ref = C_COUNTED_P(retval);

			retval = C_REFVAL_P(retval);
			ZVAL_COPY_VALUE(&generator->retval, retval);
			if (UNEXPECTED(GC_DELREF(ref) == 0)) {
				efree_size(ref, sizeof(crex_reference));
			} else if (C_OPT_REFCOUNTED_P(retval)) {
				C_ADDREF_P(retval);
			}
		} else {
			ZVAL_COPY_VALUE(&generator->retval, retval);
		}
	}

	crex_observer_fcall_end(generator->execute_data, &generator->retval);

	EG(current_execute_data) = EX(prev_execute_data);

	/* Close the generator to free up resources */
	crex_generator_close(generator, 1);

	/* Pass execution back to handling code */
	CREX_VM_RETURN();
}

static CREX_VM_COLD CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_THROW_SPEC_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *value;

	SAVE_OPLINE();
	value = RT_CONSTANT(opline, opline->op1);

	do {
		if (IS_CONST == IS_CONST || UNEXPECTED(C_TYPE_P(value) != IS_OBJECT)) {
			if ((IS_CONST & (IS_VAR|IS_CV)) && C_ISREF_P(value)) {
				value = C_REFVAL_P(value);
				if (EXPECTED(C_TYPE_P(value) == IS_OBJECT)) {
					break;
				}
			}
			if (IS_CONST == IS_CV && UNEXPECTED(C_TYPE_P(value) == IS_UNDEF)) {
				ZVAL_UNDEFINED_OP1();
				if (UNEXPECTED(EG(exception) != NULL)) {
					HANDLE_EXCEPTION();
				}
			}
			crex_throw_error(NULL, "Can only throw objects");

			HANDLE_EXCEPTION();
		}
	} while (0);

	crex_exception_save();
	C_TRY_ADDREF_P(value);
	crex_throw_exception_object(value);
	crex_exception_restore();

	HANDLE_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_CATCH_SPEC_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	crex_class_entry *ce, *catch_ce;
	crex_object *exception;

	SAVE_OPLINE();
	/* Check whether an exception has been thrown, if not, jump over code */
	crex_exception_restore();
	if (EG(exception) == NULL) {
		CREX_VM_JMP_EX(OP_JMP_ADDR(opline, opline->op2), 0);
	}
	catch_ce = CACHED_PTR(opline->extended_value & ~CREX_LAST_CATCH);
	if (UNEXPECTED(catch_ce == NULL)) {
		catch_ce = crex_fetch_class_by_name(C_STR_P(RT_CONSTANT(opline, opline->op1)), C_STR_P(RT_CONSTANT(opline, opline->op1) + 1), CREX_FETCH_CLASS_NO_AUTOLOAD | CREX_FETCH_CLASS_SILENT);

		CACHE_PTR(opline->extended_value & ~CREX_LAST_CATCH, catch_ce);
	}
	ce = EG(exception)->ce;

#ifdef HAVE_DTRACE
	if (DTRACE_EXCEPTION_CAUGHT_ENABLED()) {
		DTRACE_EXCEPTION_CAUGHT((char *)ce->name);
	}
#endif /* HAVE_DTRACE */

	if (ce != catch_ce) {
		if (!catch_ce || !instanceof_function(ce, catch_ce)) {
			if (opline->extended_value & CREX_LAST_CATCH) {
				crex_rethrow_exception(execute_data);
				HANDLE_EXCEPTION();
			}
			CREX_VM_JMP_EX(OP_JMP_ADDR(opline, opline->op2), 0);
		}
	}

	exception = EG(exception);
	EG(exception) = NULL;
	if (RETURN_VALUE_USED(opline)) {
		/* Always perform a strict assignment. There is a reasonable expectation that if you
		 * write "catch (Exception $e)" then $e will actually be instanceof Exception. As such,
		 * we should not permit coercion to string here. */
		zval tmp;
		ZVAL_OBJ(&tmp, exception);
		crex_assign_to_variable(EX_VAR(opline->result.var), &tmp, IS_TMP_VAR, /* strict */ 1);
	} else {
		OBJ_RELEASE(exception);
	}
	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_SEND_USER_SPEC_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *arg, *param;

	SAVE_OPLINE();

	arg = RT_CONSTANT(opline, opline->op1);
	param = CREX_CALL_VAR(EX(call), opline->result.var);
	if (UNEXPECTED(ARG_MUST_BE_SENT_BY_REF(EX(call)->func, opline->op2.num))) {
		crex_param_must_be_ref(EX(call)->func, opline->op2.num);
		C_TRY_ADDREF_P(arg);
		ZVAL_NEW_REF(param, arg);
	} else {
		ZVAL_COPY(param, arg);
	}

	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_VM_COLD CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_BOOL_SPEC_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *val;

	val = RT_CONSTANT(opline, opline->op1);
	if (C_TYPE_INFO_P(val) == IS_TRUE) {
		ZVAL_TRUE(EX_VAR(opline->result.var));
	} else if (EXPECTED(C_TYPE_INFO_P(val) <= IS_TRUE)) {
		/* The result and op1 can be the same cv zval */
		const uint32_t orig_val_type = C_TYPE_INFO_P(val);
		ZVAL_FALSE(EX_VAR(opline->result.var));
		if (IS_CONST == IS_CV && UNEXPECTED(orig_val_type == IS_UNDEF)) {
			SAVE_OPLINE();
			ZVAL_UNDEFINED_OP1();
			CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
		}
	} else {
		SAVE_OPLINE();
		ZVAL_BOOL(EX_VAR(opline->result.var), i_crex_is_true(val));

		CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
	}
	CREX_VM_NEXT_OPCODE();
}

static CREX_VM_COLD CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_CLONE_SPEC_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *obj;
	crex_object *zobj;
	crex_class_entry *ce, *scope;
	crex_function *clone;
	crex_object_clone_obj_t clone_call;

	SAVE_OPLINE();
	obj = RT_CONSTANT(opline, opline->op1);

	do {
		if (IS_CONST == IS_CONST ||
		    (IS_CONST != IS_UNUSED && UNEXPECTED(C_TYPE_P(obj) != IS_OBJECT))) {
			if ((IS_CONST & (IS_VAR|IS_CV)) && C_ISREF_P(obj)) {
				obj = C_REFVAL_P(obj);
				if (EXPECTED(C_TYPE_P(obj) == IS_OBJECT)) {
					break;
				}
			}
			ZVAL_UNDEF(EX_VAR(opline->result.var));
			if (IS_CONST == IS_CV && UNEXPECTED(C_TYPE_P(obj) == IS_UNDEF)) {
				ZVAL_UNDEFINED_OP1();
				if (UNEXPECTED(EG(exception) != NULL)) {
					HANDLE_EXCEPTION();
				}
			}
			crex_throw_error(NULL, "__clone method called on non-object");

			HANDLE_EXCEPTION();
		}
	} while (0);

	zobj = C_OBJ_P(obj);
	ce = zobj->ce;
	clone = ce->clone;
	clone_call = zobj->handlers->clone_obj;
	if (UNEXPECTED(clone_call == NULL)) {
		crex_throw_error(NULL, "Trying to clone an uncloneable object of class %s", ZSTR_VAL(ce->name));

		ZVAL_UNDEF(EX_VAR(opline->result.var));
		HANDLE_EXCEPTION();
	}

	if (clone && !(clone->common.fn_flags & CREX_ACC_PUBLIC)) {
		scope = EX(func)->op_array.scope;
		if (clone->common.scope != scope) {
			if (UNEXPECTED(clone->common.fn_flags & CREX_ACC_PRIVATE)
			 || UNEXPECTED(!crex_check_protected(crex_get_function_root_class(clone), scope))) {
				crex_wrong_clone_call(clone, scope);

				ZVAL_UNDEF(EX_VAR(opline->result.var));
				HANDLE_EXCEPTION();
			}
		}
	}

	ZVAL_OBJ(EX_VAR(opline->result.var), clone_call(zobj));

	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_VM_COLD CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_CAST_SPEC_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *expr;
	zval *result = EX_VAR(opline->result.var);
	HashTable *ht;

	SAVE_OPLINE();
	expr = RT_CONSTANT(opline, opline->op1);

	switch (opline->extended_value) {
		case IS_LONG:
			ZVAL_LONG(result, zval_get_long(expr));
			break;
		case IS_DOUBLE:
			ZVAL_DOUBLE(result, zval_get_double(expr));
			break;
		case IS_STRING:
			ZVAL_STR(result, zval_get_string(expr));
			break;
		default:
			CREX_ASSERT(opline->extended_value != _IS_BOOL && "Must use CREX_BOOL instead");
			if (IS_CONST & (IS_VAR|IS_CV)) {
				ZVAL_DEREF(expr);
			}
			/* If value is already of correct type, return it directly */
			if (C_TYPE_P(expr) == opline->extended_value) {
				ZVAL_COPY_VALUE(result, expr);
				if (IS_CONST == IS_CONST) {
					if (UNEXPECTED(C_OPT_REFCOUNTED_P(result))) C_ADDREF_P(result);
				} else if (IS_CONST != IS_TMP_VAR) {
					if (C_OPT_REFCOUNTED_P(result)) C_ADDREF_P(result);
				}

				CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
			}

			if (opline->extended_value == IS_ARRAY) {
				if (IS_CONST == IS_CONST || C_TYPE_P(expr) != IS_OBJECT || C_OBJCE_P(expr) == crex_ce_closure) {
					if (C_TYPE_P(expr) != IS_NULL) {
						ZVAL_ARR(result, crex_new_array(1));
						expr = crex_hash_index_add_new(C_ARRVAL_P(result), 0, expr);
						if (IS_CONST == IS_CONST) {
							if (UNEXPECTED(C_OPT_REFCOUNTED_P(expr))) C_ADDREF_P(expr);
						} else {
							if (C_OPT_REFCOUNTED_P(expr)) C_ADDREF_P(expr);
						}
					} else {
						ZVAL_EMPTY_ARRAY(result);
					}
				} else if (C_OBJ_P(expr)->properties == NULL
				 && C_OBJ_HT_P(expr)->get_properties_for == NULL
				 && C_OBJ_HT_P(expr)->get_properties == crex_std_get_properties) {
					/* Optimized version without rebuilding properties HashTable */
					ZVAL_ARR(result, crex_std_build_object_properties_array(C_OBJ_P(expr)));
				} else {
					HashTable *obj_ht = crex_get_properties_for(expr, CREX_PROP_PURPOSE_ARRAY_CAST);
					if (obj_ht) {
						/* fast copy */
						ZVAL_ARR(result, crex_proptable_to_symtable(obj_ht,
							(C_OBJCE_P(expr)->default_properties_count ||
							 C_OBJ_P(expr)->handlers != &std_object_handlers ||
							 GC_IS_RECURSIVE(obj_ht))));
						crex_release_properties(obj_ht);
					} else {
						ZVAL_EMPTY_ARRAY(result);
					}
				}
			} else {
				CREX_ASSERT(opline->extended_value == IS_OBJECT);
				ZVAL_OBJ(result, crex_objects_new(crex_standard_class_def));
				if (C_TYPE_P(expr) == IS_ARRAY) {
					ht = crex_symtable_to_proptable(C_ARR_P(expr));
					if (GC_FLAGS(ht) & IS_ARRAY_IMMUTABLE) {
						/* TODO: try not to duplicate immutable arrays as well ??? */
						ht = crex_array_dup(ht);
					}
					C_OBJ_P(result)->properties = ht;
				} else if (C_TYPE_P(expr) != IS_NULL) {
					C_OBJ_P(result)->properties = ht = crex_new_array(1);
					expr = crex_hash_add_new(ht, ZSTR_KNOWN(CREX_STR_SCALAR), expr);
					if (IS_CONST == IS_CONST) {
						if (UNEXPECTED(C_OPT_REFCOUNTED_P(expr))) C_ADDREF_P(expr);
					} else {
						if (C_OPT_REFCOUNTED_P(expr)) C_ADDREF_P(expr);
					}
				}
			}
	}

	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_INCLUDE_OR_EVAL_SPEC_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	crex_op_array *new_op_array;
	zval *inc_filename;

	SAVE_OPLINE();
	inc_filename = RT_CONSTANT(opline, opline->op1);
	new_op_array = crex_include_or_eval(inc_filename, opline->extended_value);
	if (UNEXPECTED(EG(exception) != NULL)) {

		if (new_op_array != CREX_FAKE_OP_ARRAY && new_op_array != NULL) {
			destroy_op_array(new_op_array);
			efree_size(new_op_array, sizeof(crex_op_array));
		}
		UNDEF_RESULT();
		HANDLE_EXCEPTION();
	} else if (new_op_array == CREX_FAKE_OP_ARRAY) {
		if (RETURN_VALUE_USED(opline)) {
			ZVAL_TRUE(EX_VAR(opline->result.var));
		}
	} else if (UNEXPECTED(new_op_array == NULL)) {
		if (RETURN_VALUE_USED(opline)) {
			ZVAL_FALSE(EX_VAR(opline->result.var));
		}
	} else if (new_op_array->last == 1
			&& new_op_array->opcodes[0].opcode == CREX_RETURN
			&& new_op_array->opcodes[0].op1_type == IS_CONST
			&& EXPECTED(crex_execute_ex == execute_ex)) {
		if (RETURN_VALUE_USED(opline)) {
			const crex_op *op = new_op_array->opcodes;

			ZVAL_COPY(EX_VAR(opline->result.var), RT_CONSTANT(op, op->op1));
		}
		crex_destroy_static_vars(new_op_array);
		destroy_op_array(new_op_array);
		efree_size(new_op_array, sizeof(crex_op_array));
	} else {
		zval *return_value = NULL;
		crex_execute_data *call;
		if (RETURN_VALUE_USED(opline)) {
			return_value = EX_VAR(opline->result.var);
		}

		new_op_array->scope = EX(func)->op_array.scope;

		call = crex_vm_stack_push_call_frame(
			(C_TYPE_INFO(EX(This)) & CREX_CALL_HAS_THIS) | CREX_CALL_NESTED_CODE | CREX_CALL_HAS_SYMBOL_TABLE,
			(crex_function*)new_op_array, 0,
			C_PTR(EX(This)));

		if (EX_CALL_INFO() & CREX_CALL_HAS_SYMBOL_TABLE) {
			call->symbol_table = EX(symbol_table);
		} else {
			call->symbol_table = crex_rebuild_symbol_table();
		}

		call->prev_execute_data = execute_data;
		i_init_code_execute_data(call, new_op_array, return_value);

		if (EXPECTED(crex_execute_ex == execute_ex)) {

			CREX_VM_ENTER();
		} else {
			CREX_ADD_CALL_FLAG(call, CREX_CALL_TOP);
			crex_execute_ex(call);
			crex_vm_stack_free_call_frame(call);
		}

		crex_destroy_static_vars(new_op_array);
		destroy_op_array(new_op_array);
		efree_size(new_op_array, sizeof(crex_op_array));
		if (UNEXPECTED(EG(exception) != NULL)) {
			crex_rethrow_exception(execute_data);

			UNDEF_RESULT();
			HANDLE_EXCEPTION();
		}
	}

	CREX_VM_NEXT_OPCODE();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_INCLUDE_OR_EVAL_SPEC_OBSERVER_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	crex_op_array *new_op_array;
	zval *inc_filename;

	SAVE_OPLINE();
	inc_filename = get_zval_ptr(opline->op1_type, opline->op1, BP_VAR_R);
	new_op_array = crex_include_or_eval(inc_filename, opline->extended_value);
	if (UNEXPECTED(EG(exception) != NULL)) {
		FREE_OP(opline->op1_type, opline->op1.var);
		if (new_op_array != CREX_FAKE_OP_ARRAY && new_op_array != NULL) {
			destroy_op_array(new_op_array);
			efree_size(new_op_array, sizeof(crex_op_array));
		}
		UNDEF_RESULT();
		HANDLE_EXCEPTION();
	} else if (new_op_array == CREX_FAKE_OP_ARRAY) {
		if (RETURN_VALUE_USED(opline)) {
			ZVAL_TRUE(EX_VAR(opline->result.var));
		}
	} else if (UNEXPECTED(new_op_array == NULL)) {
		if (RETURN_VALUE_USED(opline)) {
			ZVAL_FALSE(EX_VAR(opline->result.var));
		}
	} else if (new_op_array->last == 1
			&& new_op_array->opcodes[0].opcode == CREX_RETURN
			&& new_op_array->opcodes[0].op1_type == IS_CONST
			&& EXPECTED(crex_execute_ex == execute_ex)) {
		if (RETURN_VALUE_USED(opline)) {
			const crex_op *op = new_op_array->opcodes;

			ZVAL_COPY(EX_VAR(opline->result.var), RT_CONSTANT(op, op->op1));
		}
		crex_destroy_static_vars(new_op_array);
		destroy_op_array(new_op_array);
		efree_size(new_op_array, sizeof(crex_op_array));
	} else {
		zval *return_value = NULL;
		crex_execute_data *call;
		if (RETURN_VALUE_USED(opline)) {
			return_value = EX_VAR(opline->result.var);
		}

		new_op_array->scope = EX(func)->op_array.scope;

		call = crex_vm_stack_push_call_frame(
			(C_TYPE_INFO(EX(This)) & CREX_CALL_HAS_THIS) | CREX_CALL_NESTED_CODE | CREX_CALL_HAS_SYMBOL_TABLE,
			(crex_function*)new_op_array, 0,
			C_PTR(EX(This)));

		if (EX_CALL_INFO() & CREX_CALL_HAS_SYMBOL_TABLE) {
			call->symbol_table = EX(symbol_table);
		} else {
			call->symbol_table = crex_rebuild_symbol_table();
		}

		call->prev_execute_data = execute_data;
		i_init_code_execute_data(call, new_op_array, return_value);
		crex_observer_fcall_begin(call);
		if (EXPECTED(crex_execute_ex == execute_ex)) {
			FREE_OP(opline->op1_type, opline->op1.var);
			CREX_VM_ENTER();
		} else {
			CREX_ADD_CALL_FLAG(call, CREX_CALL_TOP);
			crex_execute_ex(call);
			crex_vm_stack_free_call_frame(call);
		}

		crex_destroy_static_vars(new_op_array);
		destroy_op_array(new_op_array);
		efree_size(new_op_array, sizeof(crex_op_array));
		if (UNEXPECTED(EG(exception) != NULL)) {
			crex_rethrow_exception(execute_data);
			FREE_OP(opline->op1_type, opline->op1.var);
			UNDEF_RESULT();
			HANDLE_EXCEPTION();
		}
	}
	FREE_OP(opline->op1_type, opline->op1.var);
	CREX_VM_NEXT_OPCODE();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FE_RESET_R_SPEC_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *array_ptr, *result;

	SAVE_OPLINE();

	array_ptr = RT_CONSTANT(opline, opline->op1);
	if (EXPECTED(C_TYPE_P(array_ptr) == IS_ARRAY)) {
		result = EX_VAR(opline->result.var);
		ZVAL_COPY_VALUE(result, array_ptr);
		if (IS_CONST != IS_TMP_VAR && C_OPT_REFCOUNTED_P(result)) {
			C_ADDREF_P(array_ptr);
		}
		C_FE_POS_P(result) = 0;

		CREX_VM_NEXT_OPCODE();
	} else if (IS_CONST != IS_CONST && EXPECTED(C_TYPE_P(array_ptr) == IS_OBJECT)) {
		crex_object *zobj = C_OBJ_P(array_ptr);
		if (!zobj->ce->get_iterator) {
			HashTable *properties = zobj->properties;
			if (properties) {
				if (UNEXPECTED(GC_REFCOUNT(properties) > 1)) {
					if (EXPECTED(!(GC_FLAGS(properties) & IS_ARRAY_IMMUTABLE))) {
						GC_DELREF(properties);
					}
					properties = zobj->properties = crex_array_dup(properties);
				}
			} else {
				properties = zobj->handlers->get_properties(zobj);
			}

			result = EX_VAR(opline->result.var);
			ZVAL_COPY_VALUE(result, array_ptr);
			if (IS_CONST != IS_TMP_VAR) {
				C_ADDREF_P(array_ptr);
			}

			if (crex_hash_num_elements(properties) == 0) {
				C_FE_ITER_P(result) = (uint32_t) -1;

				CREX_VM_JMP(OP_JMP_ADDR(opline, opline->op2));
			}

			C_FE_ITER_P(result) = crex_hash_iterator_add(properties, 0);

			CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
		} else {
			bool is_empty = crex_fe_reset_iterator(array_ptr, 0 OPLINE_CC EXECUTE_DATA_CC);

			if (UNEXPECTED(EG(exception))) {
				HANDLE_EXCEPTION();
			} else if (is_empty) {
				CREX_VM_JMP_EX(OP_JMP_ADDR(opline, opline->op2), 0);
			} else {
				CREX_VM_NEXT_OPCODE();
			}
		}
	} else {
		crex_error(E_WARNING, "foreach() argument must be of type array|object, %s given", crex_zval_value_name(array_ptr));
		ZVAL_UNDEF(EX_VAR(opline->result.var));
		C_FE_ITER_P(EX_VAR(opline->result.var)) = (uint32_t)-1;

		CREX_VM_JMP(OP_JMP_ADDR(opline, opline->op2));
	}
}

static CREX_VM_COLD CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FE_RESET_RW_SPEC_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *array_ptr, *array_ref;

	SAVE_OPLINE();

	if (IS_CONST == IS_VAR || IS_CONST == IS_CV) {
		array_ref = array_ptr = crex_get_bad_ptr();
		if (C_ISREF_P(array_ref)) {
			array_ptr = C_REFVAL_P(array_ref);
		}
	} else {
		array_ref = array_ptr = RT_CONSTANT(opline, opline->op1);
	}

	if (EXPECTED(C_TYPE_P(array_ptr) == IS_ARRAY)) {
		if (IS_CONST == IS_VAR || IS_CONST == IS_CV) {
			if (array_ptr == array_ref) {
				ZVAL_NEW_REF(array_ref, array_ref);
				array_ptr = C_REFVAL_P(array_ref);
			}
			C_ADDREF_P(array_ref);
			ZVAL_COPY_VALUE(EX_VAR(opline->result.var), array_ref);
		} else {
			array_ref = EX_VAR(opline->result.var);
			ZVAL_NEW_REF(array_ref, array_ptr);
			array_ptr = C_REFVAL_P(array_ref);
		}
		if (IS_CONST == IS_CONST) {
			ZVAL_ARR(array_ptr, crex_array_dup(C_ARRVAL_P(array_ptr)));
		} else {
			SEPARATE_ARRAY(array_ptr);
		}
		C_FE_ITER_P(EX_VAR(opline->result.var)) = crex_hash_iterator_add(C_ARRVAL_P(array_ptr), 0);

		CREX_VM_NEXT_OPCODE();
	} else if (IS_CONST != IS_CONST && EXPECTED(C_TYPE_P(array_ptr) == IS_OBJECT)) {
		if (!C_OBJCE_P(array_ptr)->get_iterator) {
			HashTable *properties;
			if (IS_CONST == IS_VAR || IS_CONST == IS_CV) {
				if (array_ptr == array_ref) {
					ZVAL_NEW_REF(array_ref, array_ref);
					array_ptr = C_REFVAL_P(array_ref);
				}
				C_ADDREF_P(array_ref);
				ZVAL_COPY_VALUE(EX_VAR(opline->result.var), array_ref);
			} else {
				array_ptr = EX_VAR(opline->result.var);
				ZVAL_COPY_VALUE(array_ptr, array_ref);
			}
			if (C_OBJ_P(array_ptr)->properties
			 && UNEXPECTED(GC_REFCOUNT(C_OBJ_P(array_ptr)->properties) > 1)) {
				if (EXPECTED(!(GC_FLAGS(C_OBJ_P(array_ptr)->properties) & IS_ARRAY_IMMUTABLE))) {
					GC_DELREF(C_OBJ_P(array_ptr)->properties);
				}
				C_OBJ_P(array_ptr)->properties = crex_array_dup(C_OBJ_P(array_ptr)->properties);
			}

			properties = C_OBJPROP_P(array_ptr);
			if (crex_hash_num_elements(properties) == 0) {
				C_FE_ITER_P(EX_VAR(opline->result.var)) = (uint32_t) -1;

				CREX_VM_JMP(OP_JMP_ADDR(opline, opline->op2));
			}

			C_FE_ITER_P(EX_VAR(opline->result.var)) = crex_hash_iterator_add(properties, 0);

			CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
		} else {
			bool is_empty = crex_fe_reset_iterator(array_ptr, 1 OPLINE_CC EXECUTE_DATA_CC);

			if (UNEXPECTED(EG(exception))) {
				HANDLE_EXCEPTION();
			} else if (is_empty) {
				CREX_VM_JMP_EX(OP_JMP_ADDR(opline, opline->op2), 0);
			} else {
				CREX_VM_NEXT_OPCODE();
			}
		}
	} else {
		crex_error(E_WARNING, "foreach() argument must be of type array|object, %s given", crex_zval_value_name(array_ptr));
		ZVAL_UNDEF(EX_VAR(opline->result.var));
		C_FE_ITER_P(EX_VAR(opline->result.var)) = (uint32_t)-1;

		CREX_VM_JMP(OP_JMP_ADDR(opline, opline->op2));
	}
}

static CREX_VM_COLD CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_JMP_SET_SPEC_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *value;
	crex_reference *ref = NULL;
	bool ret;

	SAVE_OPLINE();
	value = RT_CONSTANT(opline, opline->op1);

	if ((IS_CONST == IS_VAR || IS_CONST == IS_CV) && C_ISREF_P(value)) {
		if (IS_CONST == IS_VAR) {
			ref = C_REF_P(value);
		}
		value = C_REFVAL_P(value);
	}

	ret = i_crex_is_true(value);

	if (UNEXPECTED(EG(exception))) {

		ZVAL_UNDEF(EX_VAR(opline->result.var));
		HANDLE_EXCEPTION();
	}

	if (ret) {
		zval *result = EX_VAR(opline->result.var);

		ZVAL_COPY_VALUE(result, value);
		if (IS_CONST == IS_CONST) {
			if (UNEXPECTED(C_OPT_REFCOUNTED_P(result))) C_ADDREF_P(result);
		} else if (IS_CONST == IS_CV) {
			if (C_OPT_REFCOUNTED_P(result)) C_ADDREF_P(result);
		} else if (IS_CONST == IS_VAR && ref) {
			if (UNEXPECTED(GC_DELREF(ref) == 0)) {
				efree_size(ref, sizeof(crex_reference));
			} else if (C_OPT_REFCOUNTED_P(result)) {
				C_ADDREF_P(result);
			}
		}
		CREX_VM_JMP_EX(OP_JMP_ADDR(opline, opline->op2), 0);
	}

	CREX_VM_NEXT_OPCODE();
}

static CREX_VM_COLD CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_COALESCE_SPEC_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *value;
	crex_reference *ref = NULL;

	SAVE_OPLINE();
	value = RT_CONSTANT(opline, opline->op1);

	if ((IS_CONST & (IS_VAR|IS_CV)) && C_ISREF_P(value)) {
		if (IS_CONST & IS_VAR) {
			ref = C_REF_P(value);
		}
		value = C_REFVAL_P(value);
	}

	if (C_TYPE_P(value) > IS_NULL) {
		zval *result = EX_VAR(opline->result.var);
		ZVAL_COPY_VALUE(result, value);
		if (IS_CONST == IS_CONST) {
			if (UNEXPECTED(C_OPT_REFCOUNTED_P(result))) C_ADDREF_P(result);
		} else if (IS_CONST == IS_CV) {
			if (C_OPT_REFCOUNTED_P(result)) C_ADDREF_P(result);
		} else if ((IS_CONST & IS_VAR) && ref) {
			if (UNEXPECTED(GC_DELREF(ref) == 0)) {
				efree_size(ref, sizeof(crex_reference));
			} else if (C_OPT_REFCOUNTED_P(result)) {
				C_ADDREF_P(result);
			}
		}
		CREX_VM_JMP_EX(OP_JMP_ADDR(opline, opline->op2), 0);
	}

	if ((IS_CONST & IS_VAR) && ref) {
		if (UNEXPECTED(GC_DELREF(ref) == 0)) {
			efree_size(ref, sizeof(crex_reference));
		}
	}
	CREX_VM_NEXT_OPCODE();
}

static CREX_VM_COLD CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_JMP_NULL_SPEC_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *val, *result;

	val = RT_CONSTANT(opline, opline->op1);

	if (C_TYPE_P(val) > IS_NULL) {
		do {
			if ((IS_CONST == IS_CV || IS_CONST == IS_VAR) && C_TYPE_P(val) == IS_REFERENCE) {
				val = C_REFVAL_P(val);
				if (C_TYPE_P(val) <= IS_NULL) {

					break;
				}
			}
			CREX_VM_NEXT_OPCODE();
		} while (0);
	}

	result = EX_VAR(opline->result.var);
	uint32_t short_circuiting_type = opline->extended_value & CREX_SHORT_CIRCUITING_CHAIN_MASK;
	if (EXPECTED(short_circuiting_type == CREX_SHORT_CIRCUITING_CHAIN_EXPR)) {
		ZVAL_NULL(result);
		if (IS_CONST == IS_CV
			&& UNEXPECTED(C_TYPE_P(val) == IS_UNDEF)
			&& (opline->extended_value & CREX_JMP_NULL_BP_VAR_IS) == 0
		) {
			SAVE_OPLINE();
			ZVAL_UNDEFINED_OP1();
			if (UNEXPECTED(EG(exception) != NULL)) {
				HANDLE_EXCEPTION();
			}
		}
	} else if (short_circuiting_type == CREX_SHORT_CIRCUITING_CHAIN_ISSET) {
		ZVAL_FALSE(result);
	} else {
		CREX_ASSERT(short_circuiting_type == CREX_SHORT_CIRCUITING_CHAIN_EMPTY);
		ZVAL_TRUE(result);
	}

	CREX_VM_JMP_EX(OP_JMP_ADDR(opline, opline->op2), 0);
}

static CREX_VM_HOT CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_QM_ASSIGN_SPEC_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *value;
	zval *result = EX_VAR(opline->result.var);

	value = RT_CONSTANT(opline, opline->op1);
	if (IS_CONST == IS_CV && UNEXPECTED(C_TYPE_P(value) == IS_UNDEF)) {
		SAVE_OPLINE();
		ZVAL_UNDEFINED_OP1();
		ZVAL_NULL(result);
		CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
	}

	if (IS_CONST == IS_CV) {
		ZVAL_COPY_DEREF(result, value);
	} else if (IS_CONST == IS_VAR) {
		if (UNEXPECTED(C_ISREF_P(value))) {
			ZVAL_COPY_VALUE(result, C_REFVAL_P(value));
			if (UNEXPECTED(C_DELREF_P(value) == 0)) {
				efree_size(C_REF_P(value), sizeof(crex_reference));
			} else if (C_OPT_REFCOUNTED_P(result)) {
				C_ADDREF_P(result);
			}
		} else {
			ZVAL_COPY_VALUE(result, value);
		}
	} else {
		ZVAL_COPY_VALUE(result, value);
		if (IS_CONST == IS_CONST) {
			if (UNEXPECTED(C_OPT_REFCOUNTED_P(result))) {
				C_ADDREF_P(result);
			}
		}
	}
	CREX_VM_NEXT_OPCODE();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_DECLARE_CLASS_SPEC_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	SAVE_OPLINE();
	do_bind_class(RT_CONSTANT(opline, opline->op1), (opline->op2_type == IS_CONST) ? C_STR_P(RT_CONSTANT(opline, opline->op2)) : NULL);
	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_DECLARE_LAMBDA_FUNCTION_SPEC_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	crex_function *func;
	zval *object;
	crex_class_entry *called_scope;

	func = (crex_function *) EX(func)->op_array.dynamic_func_defs[opline->op2.num];
	if (C_TYPE(EX(This)) == IS_OBJECT) {
		called_scope = C_OBJCE(EX(This));
		if (UNEXPECTED((func->common.fn_flags & CREX_ACC_STATIC) ||
				(EX(func)->common.fn_flags & CREX_ACC_STATIC))) {
			object = NULL;
		} else {
			object = &EX(This);
		}
	} else {
		called_scope = C_CE(EX(This));
		object = NULL;
	}
	SAVE_OPLINE();
	crex_create_closure(EX_VAR(opline->result.var), func,
		EX(func)->op_array.scope, called_scope, object);

	CREX_VM_NEXT_OPCODE();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_YIELD_FROM_SPEC_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	crex_generator *generator = crex_get_running_generator(EXECUTE_DATA_C);
	zval *val;

	SAVE_OPLINE();
	val = RT_CONSTANT(opline, opline->op1);

	if (UNEXPECTED(generator->flags & CREX_GENERATOR_FORCED_CLOSE)) {
		crex_throw_error(NULL, "Cannot use \"yield from\" in a force-closed generator");

		UNDEF_RESULT();
		HANDLE_EXCEPTION();
	}

yield_from_try_again:
	if (C_TYPE_P(val) == IS_ARRAY) {
		ZVAL_COPY_VALUE(&generator->values, val);
		if (C_OPT_REFCOUNTED_P(val)) {
			C_ADDREF_P(val);
		}
		C_FE_POS(generator->values) = 0;

	} else if (IS_CONST != IS_CONST && C_TYPE_P(val) == IS_OBJECT && C_OBJCE_P(val)->get_iterator) {
		crex_class_entry *ce = C_OBJCE_P(val);
		if (ce == crex_ce_generator) {
			crex_generator *new_gen = (crex_generator *) C_OBJ_P(val);

			C_ADDREF_P(val);

			if (UNEXPECTED(new_gen->execute_data == NULL)) {
				crex_throw_error(NULL, "Generator passed to yield from was aborted without proper return and is unable to continue");
				zval_ptr_dtor(val);
				UNDEF_RESULT();
				HANDLE_EXCEPTION();
			} else if (C_ISUNDEF(new_gen->retval)) {
				if (UNEXPECTED(crex_generator_get_current(new_gen) == generator)) {
					crex_throw_error(NULL, "Impossible to yield from the Generator being currently run");
					zval_ptr_dtor(val);
					UNDEF_RESULT();
					HANDLE_EXCEPTION();
				} else {
					crex_generator_yield_from(generator, new_gen);
				}
			} else {
				if (RETURN_VALUE_USED(opline)) {
					ZVAL_COPY(EX_VAR(opline->result.var), &new_gen->retval);
				}
				CREX_VM_NEXT_OPCODE();
			}
		} else {
			crex_object_iterator *iter = ce->get_iterator(ce, val, 0);

			if (UNEXPECTED(!iter) || UNEXPECTED(EG(exception))) {
				if (!EG(exception)) {
					crex_throw_error(NULL, "Object of type %s did not create an Iterator", ZSTR_VAL(ce->name));
				}
				UNDEF_RESULT();
				HANDLE_EXCEPTION();
			}

			iter->index = 0;
			if (iter->funcs->rewind) {
				iter->funcs->rewind(iter);
				if (UNEXPECTED(EG(exception) != NULL)) {
					OBJ_RELEASE(&iter->std);
					UNDEF_RESULT();
					HANDLE_EXCEPTION();
				}
			}

			ZVAL_OBJ(&generator->values, &iter->std);
		}
	} else if ((IS_CONST & (IS_VAR|IS_CV)) && C_TYPE_P(val) == IS_REFERENCE) {
		val = C_REFVAL_P(val);
		goto yield_from_try_again;
	} else {
		crex_throw_error(NULL, "Can use \"yield from\" only with arrays and Traversables");

		UNDEF_RESULT();
		HANDLE_EXCEPTION();
	}

	/* This is the default return value
	 * when the expression is a Generator, it will be overwritten in crex_generator_resume() */
	if (RETURN_VALUE_USED(opline)) {
		ZVAL_NULL(EX_VAR(opline->result.var));
	}

	/* This generator has no send target (though the generator we delegate to might have one) */
	generator->send_target = NULL;

	/* We increment to the next op, so we are at the correct position when the
	 * generator is resumed. */
	CREX_VM_INC_OPCODE();

	/* The GOTO VM uses a local opline variable. We need to set the opline
	 * variable in execute_data so we don't resume at an old position. */
	SAVE_OPLINE();

	CREX_VM_RETURN();
}

static CREX_VM_COLD CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_STRLEN_SPEC_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *value;

	value = RT_CONSTANT(opline, opline->op1);
	if (EXPECTED(C_TYPE_P(value) == IS_STRING)) {
		ZVAL_LONG(EX_VAR(opline->result.var), C_STRLEN_P(value));
		if (IS_CONST & (IS_TMP_VAR|IS_VAR)) {
			zval_ptr_dtor_str(value);
		}
		CREX_VM_NEXT_OPCODE();
	} else {
		bool strict;

		if ((IS_CONST & (IS_VAR|IS_CV)) && C_TYPE_P(value) == IS_REFERENCE) {
			value = C_REFVAL_P(value);
			if (EXPECTED(C_TYPE_P(value) == IS_STRING)) {
				ZVAL_LONG(EX_VAR(opline->result.var), C_STRLEN_P(value));

				CREX_VM_NEXT_OPCODE();
			}
		}

		SAVE_OPLINE();
		if (IS_CONST == IS_CV && UNEXPECTED(C_TYPE_P(value) == IS_UNDEF)) {
			value = ZVAL_UNDEFINED_OP1();
		}
		strict = EX_USES_STRICT_TYPES();
		do {
			if (EXPECTED(!strict)) {
				crex_string *str;
				zval tmp;

				if (UNEXPECTED(C_TYPE_P(value) == IS_NULL)) {
					crex_error(E_DEPRECATED,
						"strlen(): Passing null to parameter #1 ($string) of type string is deprecated");
					ZVAL_LONG(EX_VAR(opline->result.var), 0);
					if (UNEXPECTED(EG(exception))) {
						HANDLE_EXCEPTION();
					}
					break;
				}

				ZVAL_COPY(&tmp, value);
				if (crex_parse_arg_str_weak(&tmp, &str, 1)) {
					ZVAL_LONG(EX_VAR(opline->result.var), ZSTR_LEN(str));
					zval_ptr_dtor(&tmp);
					break;
				}
				zval_ptr_dtor(&tmp);
			}
			if (!EG(exception)) {
				crex_type_error("strlen(): Argument #1 ($string) must be of type string, %s given", crex_zval_value_name(value));
			}
			ZVAL_UNDEF(EX_VAR(opline->result.var));
		} while (0);
	}

	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_VM_COLD CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_TYPE_CHECK_SPEC_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *value;
	int result = 0;

	value = RT_CONSTANT(opline, opline->op1);
	if ((opline->extended_value >> (uint32_t)C_TYPE_P(value)) & 1) {
type_check_resource:
		if (opline->extended_value != MAY_BE_RESOURCE
		 || EXPECTED(NULL != crex_rsrc_list_get_rsrc_type(C_RES_P(value)))) {
			result = 1;
		}
	} else if ((IS_CONST & (IS_CV|IS_VAR)) && C_ISREF_P(value)) {
		value = C_REFVAL_P(value);
		if ((opline->extended_value >> (uint32_t)C_TYPE_P(value)) & 1) {
			goto type_check_resource;
		}
	} else if (IS_CONST == IS_CV && UNEXPECTED(C_TYPE_P(value) == IS_UNDEF)) {
		result = ((1 << IS_NULL) & opline->extended_value) != 0;
		SAVE_OPLINE();
		ZVAL_UNDEFINED_OP1();
		if (UNEXPECTED(EG(exception))) {
			ZVAL_UNDEF(EX_VAR(opline->result.var));
			HANDLE_EXCEPTION();
		}
	}
	if (IS_CONST & (IS_TMP_VAR|IS_VAR)) {
		SAVE_OPLINE();

		CREX_VM_SMART_BRANCH(result, 1);
	} else {
		CREX_VM_SMART_BRANCH(result, 0);
	}
}

static CREX_VM_HOT CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_DEFINED_SPEC_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	crex_constant *c;

	c = CACHED_PTR(opline->extended_value);
	if (EXPECTED(c != NULL)) {
		if (!IS_SPECIAL_CACHE_VAL(c)) {
defined_true:
			CREX_VM_SMART_BRANCH_TRUE();
		} else if (EXPECTED(crex_hash_num_elements(EG(crex_constants)) == DECODE_SPECIAL_CACHE_NUM(c))) {
defined_false:
			CREX_VM_SMART_BRANCH_FALSE();
		}
	}
	if (crex_quick_check_constant(RT_CONSTANT(opline, opline->op1) OPLINE_CC EXECUTE_DATA_CC) != SUCCESS) {
		CACHE_PTR(opline->extended_value, ENCODE_SPECIAL_CACHE_NUM(crex_hash_num_elements(EG(crex_constants))));
		goto defined_false;
	} else {
		goto defined_true;
	}
}

static CREX_VM_HOT CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_QM_ASSIGN_LONG_SPEC_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *value;

	value = RT_CONSTANT(opline, opline->op1);
	ZVAL_LONG(EX_VAR(opline->result.var), C_LVAL_P(value));
	CREX_VM_NEXT_OPCODE();
}

static CREX_VM_HOT CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_QM_ASSIGN_DOUBLE_SPEC_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *value;

	value = RT_CONSTANT(opline, opline->op1);
	ZVAL_DOUBLE(EX_VAR(opline->result.var), C_DVAL_P(value));
	CREX_VM_NEXT_OPCODE();
}

static CREX_VM_HOT CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_QM_ASSIGN_NOREF_SPEC_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *value;

	value = RT_CONSTANT(opline, opline->op1);
	ZVAL_COPY_VALUE(EX_VAR(opline->result.var), value);
	CREX_VM_NEXT_OPCODE();
}

static CREX_VM_HOT CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_SEND_VAL_SIMPLE_SPEC_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *value, *arg;

	value = RT_CONSTANT(opline, opline->op1);
	arg = CREX_CALL_VAR(EX(call), opline->result.var);
	ZVAL_COPY_VALUE(arg, value);
	CREX_VM_NEXT_OPCODE();
}

static CREX_VM_HOT CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_SEND_VAL_EX_SIMPLE_SPEC_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *value, *arg;
	uint32_t arg_num = opline->op2.num;

	arg = CREX_CALL_VAR(EX(call), opline->result.var);
	if (QUICK_ARG_MUST_BE_SENT_BY_REF(EX(call)->func, arg_num)) {
		CREX_VM_TAIL_CALL(crex_cannot_pass_by_ref_helper_SPEC(arg_num, arg CREX_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
	}
	value = RT_CONSTANT(opline, opline->op1);
	ZVAL_COPY_VALUE(arg, value);
	CREX_VM_NEXT_OPCODE();
}

static CREX_VM_COLD CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ADD_SPEC_CONST_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2, *result;
	double d1, d2;

	op1 = RT_CONSTANT(opline, opline->op1);
	op2 = RT_CONSTANT(opline, opline->op2);
	if (1 && IS_CONST == IS_CONST && IS_CONST == IS_CONST) {
		/* pass */
	} else if (EXPECTED(C_TYPE_INFO_P(op1) == IS_LONG)) {
		if (EXPECTED(C_TYPE_INFO_P(op2) == IS_LONG)) {
			result = EX_VAR(opline->result.var);
			fast_long_add_function(result, op1, op2);
			CREX_VM_NEXT_OPCODE();
		} else if (EXPECTED(C_TYPE_INFO_P(op2) == IS_DOUBLE)) {
			d1 = (double)C_LVAL_P(op1);
			d2 = C_DVAL_P(op2);
			goto add_double;
		}
	} else if (EXPECTED(C_TYPE_INFO_P(op1) == IS_DOUBLE)) {
		if (EXPECTED(C_TYPE_INFO_P(op2) == IS_DOUBLE)) {
			d1 = C_DVAL_P(op1);
			d2 = C_DVAL_P(op2);
add_double:
			result = EX_VAR(opline->result.var);
			ZVAL_DOUBLE(result, d1 + d2);
			CREX_VM_NEXT_OPCODE();
		} else if (EXPECTED(C_TYPE_INFO_P(op2) == IS_LONG)) {
			d1 = C_DVAL_P(op1);
			d2 = (double)C_LVAL_P(op2);
			goto add_double;
		}
	}

	CREX_VM_TAIL_CALL(crex_add_helper_SPEC(op1, op2 CREX_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static CREX_VM_COLD CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_SUB_SPEC_CONST_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2, *result;
	double d1, d2;

	op1 = RT_CONSTANT(opline, opline->op1);
	op2 = RT_CONSTANT(opline, opline->op2);
	if (1 && IS_CONST == IS_CONST && IS_CONST == IS_CONST) {
		/* pass */
	} else if (EXPECTED(C_TYPE_INFO_P(op1) == IS_LONG)) {
		if (EXPECTED(C_TYPE_INFO_P(op2) == IS_LONG)) {
			result = EX_VAR(opline->result.var);
			fast_long_sub_function(result, op1, op2);
			CREX_VM_NEXT_OPCODE();
		} else if (EXPECTED(C_TYPE_INFO_P(op2) == IS_DOUBLE)) {
			d1 = (double)C_LVAL_P(op1);
			d2 = C_DVAL_P(op2);
			goto sub_double;
		}
	} else if (EXPECTED(C_TYPE_INFO_P(op1) == IS_DOUBLE)) {
		if (EXPECTED(C_TYPE_INFO_P(op2) == IS_DOUBLE)) {
			d1 = C_DVAL_P(op1);
			d2 = C_DVAL_P(op2);
sub_double:
			result = EX_VAR(opline->result.var);
			ZVAL_DOUBLE(result, d1 - d2);
			CREX_VM_NEXT_OPCODE();
		} else if (EXPECTED(C_TYPE_INFO_P(op2) == IS_LONG)) {
			d1 = C_DVAL_P(op1);
			d2 = (double)C_LVAL_P(op2);
			goto sub_double;
		}
	}

	CREX_VM_TAIL_CALL(crex_sub_helper_SPEC(op1, op2 CREX_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static CREX_VM_COLD CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_MUL_SPEC_CONST_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2, *result;
	double d1, d2;

	op1 = RT_CONSTANT(opline, opline->op1);
	op2 = RT_CONSTANT(opline, opline->op2);
	if (1 && IS_CONST == IS_CONST && IS_CONST == IS_CONST) {
		/* pass */
	} else if (EXPECTED(C_TYPE_INFO_P(op1) == IS_LONG)) {
		if (EXPECTED(C_TYPE_INFO_P(op2) == IS_LONG)) {
			crex_long overflow;

			result = EX_VAR(opline->result.var);
			CREX_SIGNED_MULTIPLY_LONG(C_LVAL_P(op1), C_LVAL_P(op2), C_LVAL_P(result), C_DVAL_P(result), overflow);
			C_TYPE_INFO_P(result) = overflow ? IS_DOUBLE : IS_LONG;
			CREX_VM_NEXT_OPCODE();
		} else if (EXPECTED(C_TYPE_INFO_P(op2) == IS_DOUBLE)) {
			d1 = (double)C_LVAL_P(op1);
			d2 = C_DVAL_P(op2);
			goto mul_double;
		}
	} else if (EXPECTED(C_TYPE_INFO_P(op1) == IS_DOUBLE)) {
		if (EXPECTED(C_TYPE_INFO_P(op2) == IS_DOUBLE)) {
			d1 = C_DVAL_P(op1);
			d2 = C_DVAL_P(op2);
mul_double:
			result = EX_VAR(opline->result.var);
			ZVAL_DOUBLE(result, d1 * d2);
			CREX_VM_NEXT_OPCODE();
		} else if (EXPECTED(C_TYPE_INFO_P(op2) == IS_LONG)) {
			d1 = C_DVAL_P(op1);
			d2 = (double)C_LVAL_P(op2);
			goto mul_double;
		}
	}

	CREX_VM_TAIL_CALL(crex_mul_helper_SPEC(op1, op2 CREX_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static CREX_VM_COLD CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_DIV_SPEC_CONST_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;

	SAVE_OPLINE();
	op1 = RT_CONSTANT(opline, opline->op1);
	op2 = RT_CONSTANT(opline, opline->op2);
	div_function(EX_VAR(opline->result.var), op1, op2);


	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_VM_COLD CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_MOD_SPEC_CONST_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2, *result;

	op1 = RT_CONSTANT(opline, opline->op1);
	op2 = RT_CONSTANT(opline, opline->op2);
	if (1 && IS_CONST == IS_CONST && IS_CONST == IS_CONST) {
		/* pass */
	} else if (EXPECTED(C_TYPE_INFO_P(op1) == IS_LONG)) {
		if (EXPECTED(C_TYPE_INFO_P(op2) == IS_LONG)) {
			result = EX_VAR(opline->result.var);
			if (UNEXPECTED(C_LVAL_P(op2) == 0)) {
				CREX_VM_TAIL_CALL(crex_mod_by_zero_helper_SPEC(CREX_OPCODE_HANDLER_ARGS_PASSTHRU));
			} else if (UNEXPECTED(C_LVAL_P(op2) == -1)) {
				/* Prevent overflow error/crash if op1==CREX_LONG_MIN */
				ZVAL_LONG(result, 0);
			} else {
				ZVAL_LONG(result, C_LVAL_P(op1) % C_LVAL_P(op2));
			}
			CREX_VM_NEXT_OPCODE();
		}
	}

	CREX_VM_TAIL_CALL(crex_mod_helper_SPEC(op1, op2 CREX_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static CREX_VM_COLD CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_SL_SPEC_CONST_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;

	op1 = RT_CONSTANT(opline, opline->op1);
	op2 = RT_CONSTANT(opline, opline->op2);
	if (1 && IS_CONST == IS_CONST && IS_CONST == IS_CONST) {
		/* pass */
	} else if (EXPECTED(C_TYPE_INFO_P(op1) == IS_LONG)
			&& EXPECTED(C_TYPE_INFO_P(op2) == IS_LONG)
			&& EXPECTED((crex_ulong)C_LVAL_P(op2) < SIZEOF_CREX_LONG * 8)) {
		/* Perform shift on unsigned numbers to get well-defined wrap behavior. */
		ZVAL_LONG(EX_VAR(opline->result.var),
			(crex_long) ((crex_ulong) C_LVAL_P(op1) << C_LVAL_P(op2)));
		CREX_VM_NEXT_OPCODE();
	}

	CREX_VM_TAIL_CALL(crex_shift_left_helper_SPEC(op1, op2 CREX_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static CREX_VM_COLD CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_SR_SPEC_CONST_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;

	op1 = RT_CONSTANT(opline, opline->op1);
	op2 = RT_CONSTANT(opline, opline->op2);
	if (1 && IS_CONST == IS_CONST && IS_CONST == IS_CONST) {
		/* pass */
	} else if (EXPECTED(C_TYPE_INFO_P(op1) == IS_LONG)
			&& EXPECTED(C_TYPE_INFO_P(op2) == IS_LONG)
			&& EXPECTED((crex_ulong)C_LVAL_P(op2) < SIZEOF_CREX_LONG * 8)) {
		ZVAL_LONG(EX_VAR(opline->result.var), C_LVAL_P(op1) >> C_LVAL_P(op2));
		CREX_VM_NEXT_OPCODE();
	}

	CREX_VM_TAIL_CALL(crex_shift_right_helper_SPEC(op1, op2 CREX_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static CREX_VM_COLD CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_POW_SPEC_CONST_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;

	SAVE_OPLINE();
	op1 = RT_CONSTANT(opline, opline->op1);
	op2 = RT_CONSTANT(opline, opline->op2);
	pow_function(EX_VAR(opline->result.var), op1, op2);


	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_VM_COLD CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_IS_IDENTICAL_SPEC_CONST_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	bool result;

	SAVE_OPLINE();
	op1 = RT_CONSTANT(opline, opline->op1);
	op2 = RT_CONSTANT(opline, opline->op2);
	result = fast_is_identical_function(op1, op2);


	CREX_VM_SMART_BRANCH(result, 1);
}

static CREX_VM_COLD CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_IS_NOT_IDENTICAL_SPEC_CONST_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	bool result;

	SAVE_OPLINE();
	op1 = RT_CONSTANT(opline, opline->op1);
	op2 = RT_CONSTANT(opline, opline->op2);
	result = fast_is_not_identical_function(op1, op2);


	CREX_VM_SMART_BRANCH(result, 1);
}

static CREX_VM_COLD CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_IS_EQUAL_SPEC_CONST_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	double d1, d2;

	op1 = RT_CONSTANT(opline, opline->op1);
	op2 = RT_CONSTANT(opline, opline->op2);
	if (1 && IS_CONST == IS_CONST && IS_CONST == IS_CONST) {
		/* pass */
	} else if (EXPECTED(C_TYPE_P(op1) == IS_LONG)) {
		if (EXPECTED(C_TYPE_P(op2) == IS_LONG)) {
			if (EXPECTED(C_LVAL_P(op1) == C_LVAL_P(op2))) {
is_equal_true:
				CREX_VM_SMART_BRANCH_TRUE();
			} else {
is_equal_false:
				CREX_VM_SMART_BRANCH_FALSE();
			}
		} else if (EXPECTED(C_TYPE_P(op2) == IS_DOUBLE)) {
			d1 = (double)C_LVAL_P(op1);
			d2 = C_DVAL_P(op2);
			goto is_equal_double;
		}
	} else if (EXPECTED(C_TYPE_P(op1) == IS_DOUBLE)) {
		if (EXPECTED(C_TYPE_P(op2) == IS_DOUBLE)) {
			d1 = C_DVAL_P(op1);
			d2 = C_DVAL_P(op2);
is_equal_double:
			if (d1 == d2) {
				goto is_equal_true;
			} else {
				goto is_equal_false;
			}
		} else if (EXPECTED(C_TYPE_P(op2) == IS_LONG)) {
			d1 = C_DVAL_P(op1);
			d2 = (double)C_LVAL_P(op2);
			goto is_equal_double;
		}
	} else if (EXPECTED(C_TYPE_P(op1) == IS_STRING)) {
		if (EXPECTED(C_TYPE_P(op2) == IS_STRING)) {
			bool result = crex_fast_equal_strings(C_STR_P(op1), C_STR_P(op2));
			if (IS_CONST & (IS_TMP_VAR|IS_VAR)) {
				zval_ptr_dtor_str(op1);
			}
			if (IS_CONST & (IS_TMP_VAR|IS_VAR)) {
				zval_ptr_dtor_str(op2);
			}
			if (result) {
				goto is_equal_true;
			} else {
				goto is_equal_false;
			}
		}
	}
	CREX_VM_TAIL_CALL(crex_is_equal_helper_SPEC(op1, op2 CREX_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static CREX_VM_COLD CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_IS_NOT_EQUAL_SPEC_CONST_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	double d1, d2;

	op1 = RT_CONSTANT(opline, opline->op1);
	op2 = RT_CONSTANT(opline, opline->op2);
	if (1 && IS_CONST == IS_CONST && IS_CONST == IS_CONST) {
		/* pass */
	} else if (EXPECTED(C_TYPE_P(op1) == IS_LONG)) {
		if (EXPECTED(C_TYPE_P(op2) == IS_LONG)) {
			if (EXPECTED(C_LVAL_P(op1) != C_LVAL_P(op2))) {
is_not_equal_true:
				CREX_VM_SMART_BRANCH_TRUE();
			} else {
is_not_equal_false:
				CREX_VM_SMART_BRANCH_FALSE();
			}
		} else if (EXPECTED(C_TYPE_P(op2) == IS_DOUBLE)) {
			d1 = (double)C_LVAL_P(op1);
			d2 = C_DVAL_P(op2);
			goto is_not_equal_double;
		}
	} else if (EXPECTED(C_TYPE_P(op1) == IS_DOUBLE)) {
		if (EXPECTED(C_TYPE_P(op2) == IS_DOUBLE)) {
			d1 = C_DVAL_P(op1);
			d2 = C_DVAL_P(op2);
is_not_equal_double:
			if (d1 != d2) {
				goto is_not_equal_true;
			} else {
				goto is_not_equal_false;
			}
		} else if (EXPECTED(C_TYPE_P(op2) == IS_LONG)) {
			d1 = C_DVAL_P(op1);
			d2 = (double)C_LVAL_P(op2);
			goto is_not_equal_double;
		}
	} else if (EXPECTED(C_TYPE_P(op1) == IS_STRING)) {
		if (EXPECTED(C_TYPE_P(op2) == IS_STRING)) {
			bool result = crex_fast_equal_strings(C_STR_P(op1), C_STR_P(op2));
			if (IS_CONST & (IS_TMP_VAR|IS_VAR)) {
				zval_ptr_dtor_str(op1);
			}
			if (IS_CONST & (IS_TMP_VAR|IS_VAR)) {
				zval_ptr_dtor_str(op2);
			}
			if (!result) {
				goto is_not_equal_true;
			} else {
				goto is_not_equal_false;
			}
		}
	}
	CREX_VM_TAIL_CALL(crex_is_not_equal_helper_SPEC(op1, op2 CREX_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static CREX_VM_COLD CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_IS_SMALLER_SPEC_CONST_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	double d1, d2;

	op1 = RT_CONSTANT(opline, opline->op1);
	op2 = RT_CONSTANT(opline, opline->op2);
	if (1 && IS_CONST == IS_CONST && IS_CONST == IS_CONST) {
		/* pass */
	} else if (EXPECTED(C_TYPE_INFO_P(op1) == IS_LONG)) {
		if (EXPECTED(C_TYPE_INFO_P(op2) == IS_LONG)) {
			if (EXPECTED(C_LVAL_P(op1) < C_LVAL_P(op2))) {
is_smaller_true:
				CREX_VM_SMART_BRANCH_TRUE();
			} else {
is_smaller_false:
				CREX_VM_SMART_BRANCH_FALSE();
			}
		} else if (EXPECTED(C_TYPE_INFO_P(op2) == IS_DOUBLE)) {
			d1 = (double)C_LVAL_P(op1);
			d2 = C_DVAL_P(op2);
			goto is_smaller_double;
		}
	} else if (EXPECTED(C_TYPE_INFO_P(op1) == IS_DOUBLE)) {
		if (EXPECTED(C_TYPE_INFO_P(op2) == IS_DOUBLE)) {
			d1 = C_DVAL_P(op1);
			d2 = C_DVAL_P(op2);
is_smaller_double:
			if (d1 < d2) {
				goto is_smaller_true;
			} else {
				goto is_smaller_false;
			}
		} else if (EXPECTED(C_TYPE_INFO_P(op2) == IS_LONG)) {
			d1 = C_DVAL_P(op1);
			d2 = (double)C_LVAL_P(op2);
			goto is_smaller_double;
		}
	}
	CREX_VM_TAIL_CALL(crex_is_smaller_helper_SPEC(op1, op2 CREX_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static CREX_VM_COLD CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_IS_SMALLER_OR_EQUAL_SPEC_CONST_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	double d1, d2;

	op1 = RT_CONSTANT(opline, opline->op1);
	op2 = RT_CONSTANT(opline, opline->op2);
	if (1 && IS_CONST == IS_CONST && IS_CONST == IS_CONST) {
		/* pass */
	} else if (EXPECTED(C_TYPE_INFO_P(op1) == IS_LONG)) {
		if (EXPECTED(C_TYPE_INFO_P(op2) == IS_LONG)) {
			if (EXPECTED(C_LVAL_P(op1) <= C_LVAL_P(op2))) {
is_smaller_or_equal_true:
				CREX_VM_SMART_BRANCH_TRUE();
				ZVAL_TRUE(EX_VAR(opline->result.var));
				CREX_VM_NEXT_OPCODE();
			} else {
is_smaller_or_equal_false:
				CREX_VM_SMART_BRANCH_FALSE();
				ZVAL_FALSE(EX_VAR(opline->result.var));
				CREX_VM_NEXT_OPCODE();
			}
		} else if (EXPECTED(C_TYPE_INFO_P(op2) == IS_DOUBLE)) {
			d1 = (double)C_LVAL_P(op1);
			d2 = C_DVAL_P(op2);
			goto is_smaller_or_equal_double;
		}
	} else if (EXPECTED(C_TYPE_INFO_P(op1) == IS_DOUBLE)) {
		if (EXPECTED(C_TYPE_INFO_P(op2) == IS_DOUBLE)) {
			d1 = C_DVAL_P(op1);
			d2 = C_DVAL_P(op2);
is_smaller_or_equal_double:
			if (d1 <= d2) {
				goto is_smaller_or_equal_true;
			} else {
				goto is_smaller_or_equal_false;
			}
		} else if (EXPECTED(C_TYPE_INFO_P(op2) == IS_LONG)) {
			d1 = C_DVAL_P(op1);
			d2 = (double)C_LVAL_P(op2);
			goto is_smaller_or_equal_double;
		}
	}
	CREX_VM_TAIL_CALL(crex_is_smaller_or_equal_helper_SPEC(op1, op2 CREX_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static CREX_VM_COLD CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_SPACESHIP_SPEC_CONST_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;

	SAVE_OPLINE();
	op1 = RT_CONSTANT(opline, opline->op1);
	op2 = RT_CONSTANT(opline, opline->op2);
	compare_function(EX_VAR(opline->result.var), op1, op2);


	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_VM_COLD CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_BW_OR_SPEC_CONST_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;

	op1 = RT_CONSTANT(opline, opline->op1);
	op2 = RT_CONSTANT(opline, opline->op2);
	if (1 && IS_CONST == IS_CONST && IS_CONST == IS_CONST) {
		/* pass */
	} else if (EXPECTED(C_TYPE_INFO_P(op1) == IS_LONG)
			&& EXPECTED(C_TYPE_INFO_P(op2) == IS_LONG)) {
		ZVAL_LONG(EX_VAR(opline->result.var), C_LVAL_P(op1) | C_LVAL_P(op2));
		CREX_VM_NEXT_OPCODE();
	}

	CREX_VM_TAIL_CALL(crex_bw_or_helper_SPEC(op1, op2 CREX_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static CREX_VM_COLD CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_BW_AND_SPEC_CONST_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;

	op1 = RT_CONSTANT(opline, opline->op1);
	op2 = RT_CONSTANT(opline, opline->op2);
	if (1 && IS_CONST == IS_CONST && IS_CONST == IS_CONST) {
		/* pass */
	} else if (EXPECTED(C_TYPE_INFO_P(op1) == IS_LONG)
			&& EXPECTED(C_TYPE_INFO_P(op2) == IS_LONG)) {
		ZVAL_LONG(EX_VAR(opline->result.var), C_LVAL_P(op1) & C_LVAL_P(op2));
		CREX_VM_NEXT_OPCODE();
	}

	CREX_VM_TAIL_CALL(crex_bw_and_helper_SPEC(op1, op2 CREX_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static CREX_VM_COLD CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_BW_XOR_SPEC_CONST_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;

	op1 = RT_CONSTANT(opline, opline->op1);
	op2 = RT_CONSTANT(opline, opline->op2);
	if (1 && IS_CONST == IS_CONST && IS_CONST == IS_CONST) {
		/* pass */
	} else if (EXPECTED(C_TYPE_INFO_P(op1) == IS_LONG)
			&& EXPECTED(C_TYPE_INFO_P(op2) == IS_LONG)) {
		ZVAL_LONG(EX_VAR(opline->result.var), C_LVAL_P(op1) ^ C_LVAL_P(op2));
		CREX_VM_NEXT_OPCODE();
	}

	CREX_VM_TAIL_CALL(crex_bw_xor_helper_SPEC(op1, op2 CREX_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static CREX_VM_COLD CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_BOOL_XOR_SPEC_CONST_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;

	SAVE_OPLINE();
	op1 = RT_CONSTANT(opline, opline->op1);
	op2 = RT_CONSTANT(opline, opline->op2);
	boolean_xor_function(EX_VAR(opline->result.var), op1, op2);


	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_VM_COLD CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FETCH_DIM_R_SPEC_CONST_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container, *dim, *value;

	SAVE_OPLINE();
	container = RT_CONSTANT(opline, opline->op1);
	dim = RT_CONSTANT(opline, opline->op2);
	if (IS_CONST != IS_CONST) {
		if (EXPECTED(C_TYPE_P(container) == IS_ARRAY)) {
fetch_dim_r_array:
			value = crex_fetch_dimension_address_inner(C_ARRVAL_P(container), dim, IS_CONST, BP_VAR_R EXECUTE_DATA_CC);
			ZVAL_COPY_DEREF(EX_VAR(opline->result.var), value);
		} else if (EXPECTED(C_TYPE_P(container) == IS_REFERENCE)) {
			container = C_REFVAL_P(container);
			if (EXPECTED(C_TYPE_P(container) == IS_ARRAY)) {
				goto fetch_dim_r_array;
			} else {
				goto fetch_dim_r_slow;
			}
		} else {
fetch_dim_r_slow:
			if (IS_CONST == IS_CONST && C_EXTRA_P(dim) == CREX_EXTRA_VALUE) {
				dim++;
			}
			crex_fetch_dimension_address_read_R_slow(container, dim OPLINE_CC EXECUTE_DATA_CC);
		}
	} else {
		crex_fetch_dimension_address_read_R(container, dim, IS_CONST OPLINE_CC EXECUTE_DATA_CC);
	}


	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_VM_COLD CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FETCH_DIM_IS_SPEC_CONST_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;

	SAVE_OPLINE();
	container = RT_CONSTANT(opline, opline->op1);
	crex_fetch_dimension_address_read_IS(container, RT_CONSTANT(opline, opline->op2), IS_CONST OPLINE_CC EXECUTE_DATA_CC);


	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_VM_COLD CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FETCH_DIM_FUNC_ARG_SPEC_CONST_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
#if 0
	USE_OPLINE
#endif

	if (UNEXPECTED(CREX_CALL_INFO(EX(call)) & CREX_CALL_SEND_ARG_BY_REF)) {
		if ((IS_CONST & (IS_CONST|IS_TMP_VAR))) {
			CREX_VM_TAIL_CALL(crex_use_tmp_in_write_context_helper_SPEC(CREX_OPCODE_HANDLER_ARGS_PASSTHRU));
		}
		CREX_VM_TAIL_CALL(CREX_NULL_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU));
	} else {
		if (IS_CONST == IS_UNUSED) {
			CREX_VM_TAIL_CALL(crex_use_undef_in_read_context_helper_SPEC(CREX_OPCODE_HANDLER_ARGS_PASSTHRU));
		}
		CREX_VM_TAIL_CALL(CREX_FETCH_DIM_R_SPEC_CONST_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU));
	}
}

static CREX_VM_COLD CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FETCH_OBJ_R_SPEC_CONST_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;
	void **cache_slot = NULL;

	SAVE_OPLINE();
	container = RT_CONSTANT(opline, opline->op1);

	if (IS_CONST == IS_CONST ||
	    (IS_CONST != IS_UNUSED && UNEXPECTED(C_TYPE_P(container) != IS_OBJECT))) {
		do {
			if ((IS_CONST & (IS_VAR|IS_CV)) && C_ISREF_P(container)) {
				container = C_REFVAL_P(container);
				if (EXPECTED(C_TYPE_P(container) == IS_OBJECT)) {
					break;
				}
			}
			if (IS_CONST == IS_CV && UNEXPECTED(C_TYPE_P(container) == IS_UNDEF)) {
				ZVAL_UNDEFINED_OP1();
			}
			crex_wrong_property_read(container, RT_CONSTANT(opline, opline->op2));
			ZVAL_NULL(EX_VAR(opline->result.var));
			goto fetch_obj_r_finish;
		} while (0);
	}

	/* here we are sure we are dealing with an object */
	do {
		crex_object *zobj = C_OBJ_P(container);
		crex_string *name, *tmp_name;
		zval *retval;

		if (IS_CONST == IS_CONST) {
			cache_slot = CACHE_ADDR(opline->extended_value & ~CREX_FETCH_REF /* FUNC_ARG fetch may contain it */);

			if (EXPECTED(zobj->ce == CACHED_PTR_EX(cache_slot))) {
				uintptr_t prop_offset = (uintptr_t)CACHED_PTR_EX(cache_slot + 1);

				if (EXPECTED(IS_VALID_PROPERTY_OFFSET(prop_offset))) {
					retval = OBJ_PROP(zobj, prop_offset);
					if (EXPECTED(C_TYPE_INFO_P(retval) != IS_UNDEF)) {
						if (0 || (IS_CONST & (IS_TMP_VAR|IS_VAR)) != 0) {
							goto fetch_obj_r_copy;
						} else {
fetch_obj_r_fast_copy:
							ZVAL_COPY_DEREF(EX_VAR(opline->result.var), retval);
							CREX_VM_NEXT_OPCODE();
						}
					}
				} else if (EXPECTED(zobj->properties != NULL)) {
					name = C_STR_P(RT_CONSTANT(opline, opline->op2));
					if (!IS_UNKNOWN_DYNAMIC_PROPERTY_OFFSET(prop_offset)) {
						uintptr_t idx = CREX_DECODE_DYN_PROP_OFFSET(prop_offset);

						if (EXPECTED(idx < zobj->properties->nNumUsed * sizeof(Bucket))) {
							Bucket *p = (Bucket*)((char*)zobj->properties->arData + idx);

							if (EXPECTED(p->key == name) ||
							    (EXPECTED(p->h == ZSTR_H(name)) &&
							     EXPECTED(p->key != NULL) &&
							     EXPECTED(crex_string_equal_content(p->key, name)))) {
								retval = &p->val;
								if (0 || (IS_CONST & (IS_TMP_VAR|IS_VAR)) != 0) {
									goto fetch_obj_r_copy;
								} else {
									goto fetch_obj_r_fast_copy;
								}
							}
						}
						CACHE_PTR_EX(cache_slot + 1, (void*)CREX_DYNAMIC_PROPERTY_OFFSET);
					}
					retval = crex_hash_find_known_hash(zobj->properties, name);
					if (EXPECTED(retval)) {
						uintptr_t idx = (char*)retval - (char*)zobj->properties->arData;
						CACHE_PTR_EX(cache_slot + 1, (void*)CREX_ENCODE_DYN_PROP_OFFSET(idx));
						if (0 || (IS_CONST & (IS_TMP_VAR|IS_VAR)) != 0) {
							goto fetch_obj_r_copy;
						} else {
							goto fetch_obj_r_fast_copy;
						}
					}
				}
			}
			name = C_STR_P(RT_CONSTANT(opline, opline->op2));
		} else {
			name = zval_try_get_tmp_string(RT_CONSTANT(opline, opline->op2), &tmp_name);
			if (UNEXPECTED(!name)) {
				ZVAL_UNDEF(EX_VAR(opline->result.var));
				break;
			}
		}

#if CREX_DEBUG
		/* For non-standard object handlers, verify a declared property type in debug builds.
		 * Fetch prop_info before calling read_property(), as it may deallocate the object. */
		crex_property_info *prop_info = NULL;
		if (zobj->handlers->read_property != crex_std_read_property) {
			prop_info = crex_get_property_info(zobj->ce, name, /* silent */ true);
		}
#endif
		retval = zobj->handlers->read_property(zobj, name, BP_VAR_R, cache_slot, EX_VAR(opline->result.var));
#if CREX_DEBUG
		if (!EG(exception) && prop_info && prop_info != CREX_WRONG_PROPERTY_INFO
				&& CREX_TYPE_IS_SET(prop_info->type)) {
			ZVAL_OPT_DEREF(retval);
			crex_verify_property_type(prop_info, retval, /* strict */ true);
		}
#endif

		if (IS_CONST != IS_CONST) {
			crex_tmp_string_release(tmp_name);
		}

		if (retval != EX_VAR(opline->result.var)) {
fetch_obj_r_copy:
			ZVAL_COPY_DEREF(EX_VAR(opline->result.var), retval);
		} else if (UNEXPECTED(C_ISREF_P(retval))) {
			crex_unwrap_reference(retval);
		}
	} while (0);

fetch_obj_r_finish:


	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_VM_COLD CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FETCH_OBJ_IS_SPEC_CONST_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;
	void **cache_slot = NULL;

	SAVE_OPLINE();
	container = RT_CONSTANT(opline, opline->op1);

	if (IS_CONST == IS_CONST ||
	    (IS_CONST != IS_UNUSED && UNEXPECTED(C_TYPE_P(container) != IS_OBJECT))) {
		do {
			if ((IS_CONST & (IS_VAR|IS_CV)) && C_ISREF_P(container)) {
				container = C_REFVAL_P(container);
				if (EXPECTED(C_TYPE_P(container) == IS_OBJECT)) {
					break;
				}
			}
			if (IS_CONST == IS_CV && C_TYPE_P(EX_VAR(opline->op2.var)) == IS_UNDEF) {
				ZVAL_UNDEFINED_OP2();
			}
			ZVAL_NULL(EX_VAR(opline->result.var));
			goto fetch_obj_is_finish;
		} while (0);
	}

	/* here we are sure we are dealing with an object */
	do {
		crex_object *zobj = C_OBJ_P(container);
		crex_string *name, *tmp_name;
		zval *retval;

		if (IS_CONST == IS_CONST) {
			cache_slot = CACHE_ADDR(opline->extended_value);

			if (EXPECTED(zobj->ce == CACHED_PTR_EX(cache_slot))) {
				uintptr_t prop_offset = (uintptr_t)CACHED_PTR_EX(cache_slot + 1);

				if (EXPECTED(IS_VALID_PROPERTY_OFFSET(prop_offset))) {
					retval = OBJ_PROP(zobj, prop_offset);
					if (EXPECTED(C_TYPE_P(retval) != IS_UNDEF)) {
						if (0 || (IS_CONST & (IS_TMP_VAR|IS_VAR)) != 0) {
							goto fetch_obj_is_copy;
						} else {
fetch_obj_is_fast_copy:
							ZVAL_COPY_DEREF(EX_VAR(opline->result.var), retval);
							CREX_VM_NEXT_OPCODE();
						}
					}
				} else if (EXPECTED(zobj->properties != NULL)) {
					name = C_STR_P(RT_CONSTANT(opline, opline->op2));
					if (!IS_UNKNOWN_DYNAMIC_PROPERTY_OFFSET(prop_offset)) {
						uintptr_t idx = CREX_DECODE_DYN_PROP_OFFSET(prop_offset);

						if (EXPECTED(idx < zobj->properties->nNumUsed * sizeof(Bucket))) {
							Bucket *p = (Bucket*)((char*)zobj->properties->arData + idx);

							if (EXPECTED(p->key == name) ||
							    (EXPECTED(p->h == ZSTR_H(name)) &&
							     EXPECTED(p->key != NULL) &&
							     EXPECTED(crex_string_equal_content(p->key, name)))) {
								retval = &p->val;
								if (0 || (IS_CONST & (IS_TMP_VAR|IS_VAR)) != 0) {
									goto fetch_obj_is_copy;
								} else {
									goto fetch_obj_is_fast_copy;
								}
							}
						}
						CACHE_PTR_EX(cache_slot + 1, (void*)CREX_DYNAMIC_PROPERTY_OFFSET);
					}
					retval = crex_hash_find_known_hash(zobj->properties, name);
					if (EXPECTED(retval)) {
						uintptr_t idx = (char*)retval - (char*)zobj->properties->arData;
						CACHE_PTR_EX(cache_slot + 1, (void*)CREX_ENCODE_DYN_PROP_OFFSET(idx));
						if (0 || (IS_CONST & (IS_TMP_VAR|IS_VAR)) != 0) {
							goto fetch_obj_is_copy;
						} else {
							goto fetch_obj_is_fast_copy;
						}
					}
				}
			}
			name = C_STR_P(RT_CONSTANT(opline, opline->op2));
		} else {
			name = zval_try_get_tmp_string(RT_CONSTANT(opline, opline->op2), &tmp_name);
			if (UNEXPECTED(!name)) {
				ZVAL_UNDEF(EX_VAR(opline->result.var));
				break;
			}
		}

		retval = zobj->handlers->read_property(zobj, name, BP_VAR_IS, cache_slot, EX_VAR(opline->result.var));

		if (IS_CONST != IS_CONST) {
			crex_tmp_string_release(tmp_name);
		}

		if (retval != EX_VAR(opline->result.var)) {
fetch_obj_is_copy:
			ZVAL_COPY_DEREF(EX_VAR(opline->result.var), retval);
		} else if (UNEXPECTED(C_ISREF_P(retval))) {
			crex_unwrap_reference(retval);
		}
	} while (0);

fetch_obj_is_finish:


	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_VM_COLD CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FETCH_OBJ_FUNC_ARG_SPEC_CONST_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
#if 0
	USE_OPLINE
#endif

	if (UNEXPECTED(CREX_CALL_INFO(EX(call)) & CREX_CALL_SEND_ARG_BY_REF)) {
		/* Behave like FETCH_OBJ_W */
		if ((IS_CONST & (IS_CONST|IS_TMP_VAR))) {
			CREX_VM_TAIL_CALL(crex_use_tmp_in_write_context_helper_SPEC(CREX_OPCODE_HANDLER_ARGS_PASSTHRU));
		}
		CREX_VM_TAIL_CALL(CREX_NULL_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU));
	} else {
		CREX_VM_TAIL_CALL(CREX_FETCH_OBJ_R_SPEC_CONST_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU));
	}
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FETCH_LIST_R_SPEC_CONST_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;

	SAVE_OPLINE();
	container = RT_CONSTANT(opline, opline->op1);
	crex_fetch_dimension_address_LIST_r(container, RT_CONSTANT(opline, opline->op2), IS_CONST OPLINE_CC EXECUTE_DATA_CC);

	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_VM_COLD CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FAST_CONCAT_SPEC_CONST_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	crex_string *op1_str, *op2_str, *str;


	op1 = RT_CONSTANT(opline, opline->op1);
	op2 = RT_CONSTANT(opline, opline->op2);
	if ((IS_CONST == IS_CONST || EXPECTED(C_TYPE_P(op1) == IS_STRING)) &&
	    (IS_CONST == IS_CONST || EXPECTED(C_TYPE_P(op2) == IS_STRING))) {
		crex_string *op1_str = C_STR_P(op1);
		crex_string *op2_str = C_STR_P(op2);
		crex_string *str;
		uint32_t flags = ZSTR_GET_COPYABLE_CONCAT_PROPERTIES_BOTH(op1_str, op2_str);

		if (IS_CONST != IS_CONST && UNEXPECTED(ZSTR_LEN(op1_str) == 0)) {
			if (IS_CONST == IS_CONST || IS_CONST == IS_CV) {
				ZVAL_STR_COPY(EX_VAR(opline->result.var), op2_str);
			} else {
				ZVAL_STR(EX_VAR(opline->result.var), op2_str);
			}
			if (IS_CONST & (IS_TMP_VAR|IS_VAR)) {
				crex_string_release_ex(op1_str, 0);
			}
		} else if (IS_CONST != IS_CONST && UNEXPECTED(ZSTR_LEN(op2_str) == 0)) {
			if (IS_CONST == IS_CONST || IS_CONST == IS_CV) {
				ZVAL_STR_COPY(EX_VAR(opline->result.var), op1_str);
			} else {
				ZVAL_STR(EX_VAR(opline->result.var), op1_str);
			}
			if (IS_CONST & (IS_TMP_VAR|IS_VAR)) {
				crex_string_release_ex(op2_str, 0);
			}
		} else if (IS_CONST != IS_CONST && IS_CONST != IS_CV &&
		    !ZSTR_IS_INTERNED(op1_str) && GC_REFCOUNT(op1_str) == 1) {
			size_t len = ZSTR_LEN(op1_str);

			str = crex_string_extend(op1_str, len + ZSTR_LEN(op2_str), 0);
			memcpy(ZSTR_VAL(str) + len, ZSTR_VAL(op2_str), ZSTR_LEN(op2_str)+1);
			GC_ADD_FLAGS(str, flags);
			ZVAL_NEW_STR(EX_VAR(opline->result.var), str);
			if (IS_CONST & (IS_TMP_VAR|IS_VAR)) {
				crex_string_release_ex(op2_str, 0);
			}
		} else {
			str = crex_string_alloc(ZSTR_LEN(op1_str) + ZSTR_LEN(op2_str), 0);
			memcpy(ZSTR_VAL(str), ZSTR_VAL(op1_str), ZSTR_LEN(op1_str));
			memcpy(ZSTR_VAL(str) + ZSTR_LEN(op1_str), ZSTR_VAL(op2_str), ZSTR_LEN(op2_str)+1);
			GC_ADD_FLAGS(str, flags);
			ZVAL_NEW_STR(EX_VAR(opline->result.var), str);
			if (IS_CONST & (IS_TMP_VAR|IS_VAR)) {
				crex_string_release_ex(op1_str, 0);
			}
			if (IS_CONST & (IS_TMP_VAR|IS_VAR)) {
				crex_string_release_ex(op2_str, 0);
			}
		}
		CREX_VM_NEXT_OPCODE();
	}

	SAVE_OPLINE();
	if (IS_CONST == IS_CONST) {
		op1_str = C_STR_P(op1);
	} else if (EXPECTED(C_TYPE_P(op1) == IS_STRING)) {
		op1_str = crex_string_copy(C_STR_P(op1));
	} else {
		if (IS_CONST == IS_CV && UNEXPECTED(C_TYPE_P(op1) == IS_UNDEF)) {
			ZVAL_UNDEFINED_OP1();
		}
		op1_str = zval_get_string_func(op1);
	}
	if (IS_CONST == IS_CONST) {
		op2_str = C_STR_P(op2);
	} else if (EXPECTED(C_TYPE_P(op2) == IS_STRING)) {
		op2_str = crex_string_copy(C_STR_P(op2));
	} else {
		if (IS_CONST == IS_CV && UNEXPECTED(C_TYPE_P(op2) == IS_UNDEF)) {
			ZVAL_UNDEFINED_OP2();
		}
		op2_str = zval_get_string_func(op2);
	}
	do {
		if (IS_CONST != IS_CONST) {
			if (UNEXPECTED(ZSTR_LEN(op1_str) == 0)) {
				if (IS_CONST == IS_CONST) {
					if (UNEXPECTED(C_REFCOUNTED_P(op2))) {
						GC_ADDREF(op2_str);
					}
				}
				ZVAL_STR(EX_VAR(opline->result.var), op2_str);
				crex_string_release_ex(op1_str, 0);
				break;
			}
		}
		if (IS_CONST != IS_CONST) {
			if (UNEXPECTED(ZSTR_LEN(op2_str) == 0)) {
				if (IS_CONST == IS_CONST) {
					if (UNEXPECTED(C_REFCOUNTED_P(op1))) {
						GC_ADDREF(op1_str);
					}
				}
				ZVAL_STR(EX_VAR(opline->result.var), op1_str);
				crex_string_release_ex(op2_str, 0);
				break;
			}
		}
		str = crex_string_alloc(ZSTR_LEN(op1_str) + ZSTR_LEN(op2_str), 0);
		memcpy(ZSTR_VAL(str), ZSTR_VAL(op1_str), ZSTR_LEN(op1_str));
		memcpy(ZSTR_VAL(str) + ZSTR_LEN(op1_str), ZSTR_VAL(op2_str), ZSTR_LEN(op2_str)+1);

		ZSTR_COPY_CONCAT_PROPERTIES_BOTH(str, op1_str, op2_str);
		ZVAL_NEW_STR(EX_VAR(opline->result.var), str);
		if (IS_CONST != IS_CONST) {
			crex_string_release_ex(op1_str, 0);
		}
		if (IS_CONST != IS_CONST) {
			crex_string_release_ex(op2_str, 0);
		}
	} while (0);


	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_VM_COLD CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_INIT_METHOD_CALL_SPEC_CONST_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *function_name;
	zval *object;
	crex_function *fbc;
	crex_class_entry *called_scope;
	crex_object *obj;
	crex_execute_data *call;
	uint32_t call_info;

	SAVE_OPLINE();

	object = RT_CONSTANT(opline, opline->op1);

	if (IS_CONST != IS_CONST) {
		function_name = RT_CONSTANT(opline, opline->op2);
	}

	if (IS_CONST != IS_CONST &&
	    UNEXPECTED(C_TYPE_P(function_name) != IS_STRING)) {
		do {
			if ((IS_CONST & (IS_VAR|IS_CV)) && C_ISREF_P(function_name)) {
				function_name = C_REFVAL_P(function_name);
				if (EXPECTED(C_TYPE_P(function_name) == IS_STRING)) {
					break;
				}
			} else if (IS_CONST == IS_CV && UNEXPECTED(C_TYPE_P(function_name) == IS_UNDEF)) {
				ZVAL_UNDEFINED_OP2();
				if (UNEXPECTED(EG(exception) != NULL)) {

					HANDLE_EXCEPTION();
				}
			}
			crex_throw_error(NULL, "Method name must be a string");


			HANDLE_EXCEPTION();
		} while (0);
	}

	if (IS_CONST == IS_UNUSED) {
		obj = C_OBJ_P(object);
	} else {
		do {
			if (IS_CONST != IS_CONST && EXPECTED(C_TYPE_P(object) == IS_OBJECT)) {
				obj = C_OBJ_P(object);
			} else {
				if ((IS_CONST & (IS_VAR|IS_CV)) && EXPECTED(C_ISREF_P(object))) {
					crex_reference *ref = C_REF_P(object);

					object = &ref->val;
					if (EXPECTED(C_TYPE_P(object) == IS_OBJECT)) {
						obj = C_OBJ_P(object);
						if (IS_CONST & IS_VAR) {
							if (UNEXPECTED(GC_DELREF(ref) == 0)) {
								efree_size(ref, sizeof(crex_reference));
							} else {
								C_ADDREF_P(object);
							}
						}
						break;
					}
				}
				if (IS_CONST == IS_CV && UNEXPECTED(C_TYPE_P(object) == IS_UNDEF)) {
					object = ZVAL_UNDEFINED_OP1();
					if (UNEXPECTED(EG(exception) != NULL)) {
						if (IS_CONST != IS_CONST) {

						}
						HANDLE_EXCEPTION();
					}
				}
				if (IS_CONST == IS_CONST) {
					function_name = RT_CONSTANT(opline, opline->op2);
				}
				crex_invalid_method_call(object, function_name);


				HANDLE_EXCEPTION();
			}
		} while (0);
	}

	called_scope = obj->ce;

	if (IS_CONST == IS_CONST &&
	    EXPECTED(CACHED_PTR(opline->result.num) == called_scope)) {
		fbc = CACHED_PTR(opline->result.num + sizeof(void*));
	} else {
		crex_object *orig_obj = obj;

		if (IS_CONST == IS_CONST) {
			function_name = RT_CONSTANT(opline, opline->op2);
		}

		/* First, locate the function. */
		fbc = obj->handlers->get_method(&obj, C_STR_P(function_name), ((IS_CONST == IS_CONST) ? (RT_CONSTANT(opline, opline->op2) + 1) : NULL));
		if (UNEXPECTED(fbc == NULL)) {
			if (EXPECTED(!EG(exception))) {
				crex_undefined_method(obj->ce, C_STR_P(function_name));
			}

			if ((IS_CONST & (IS_VAR|IS_TMP_VAR)) && GC_DELREF(orig_obj) == 0) {
				crex_objects_store_del(orig_obj);
			}
			HANDLE_EXCEPTION();
		}
		if (IS_CONST == IS_CONST &&
		    EXPECTED(!(fbc->common.fn_flags & (CREX_ACC_CALL_VIA_TRAMPOLINE|CREX_ACC_NEVER_CACHE))) &&
		    EXPECTED(obj == orig_obj)) {
			CACHE_POLYMORPHIC_PTR(opline->result.num, called_scope, fbc);
		}
		if ((IS_CONST & (IS_VAR|IS_TMP_VAR)) && UNEXPECTED(obj != orig_obj)) {
			GC_ADDREF(obj); /* For $this pointer */
			if (GC_DELREF(orig_obj) == 0) {
				crex_objects_store_del(orig_obj);
			}
		}
		if (EXPECTED(fbc->type == CREX_USER_FUNCTION) && UNEXPECTED(!RUN_TIME_CACHE(&fbc->op_array))) {
			init_func_run_time_cache(&fbc->op_array);
		}
	}

	if (IS_CONST != IS_CONST) {

	}

	call_info = CREX_CALL_NESTED_FUNCTION | CREX_CALL_HAS_THIS;
	if (UNEXPECTED((fbc->common.fn_flags & CREX_ACC_STATIC) != 0)) {
		if ((IS_CONST & (IS_VAR|IS_TMP_VAR)) && GC_DELREF(obj) == 0) {
			crex_objects_store_del(obj);
			if (UNEXPECTED(EG(exception))) {
				HANDLE_EXCEPTION();
			}
		}
		/* call static method */
		obj = (crex_object*)called_scope;
		call_info = CREX_CALL_NESTED_FUNCTION;
	} else if (IS_CONST & (IS_VAR|IS_TMP_VAR|IS_CV)) {
		if (IS_CONST == IS_CV) {
			GC_ADDREF(obj); /* For $this pointer */
		}
		/* CV may be changed indirectly (e.g. when it's a reference) */
		call_info = CREX_CALL_NESTED_FUNCTION | CREX_CALL_HAS_THIS | CREX_CALL_RELEASE_THIS;
	}

	call = crex_vm_stack_push_call_frame(call_info,
		fbc, opline->extended_value, obj);
	call->prev_execute_data = EX(call);
	EX(call) = call;

	CREX_VM_NEXT_OPCODE();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_INIT_STATIC_METHOD_CALL_SPEC_CONST_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *function_name;
	crex_class_entry *ce;
	uint32_t call_info;
	crex_function *fbc;
	crex_execute_data *call;

	SAVE_OPLINE();

	if (IS_CONST == IS_CONST) {
		/* no function found. try a static method in class */
		ce = CACHED_PTR(opline->result.num);
		if (UNEXPECTED(ce == NULL)) {
			ce = crex_fetch_class_by_name(C_STR_P(RT_CONSTANT(opline, opline->op1)), C_STR_P(RT_CONSTANT(opline, opline->op1) + 1), CREX_FETCH_CLASS_DEFAULT | CREX_FETCH_CLASS_EXCEPTION);
			if (UNEXPECTED(ce == NULL)) {

				HANDLE_EXCEPTION();
			}
			if (IS_CONST != IS_CONST) {
				CACHE_PTR(opline->result.num, ce);
			}
		}
	} else if (IS_CONST == IS_UNUSED) {
		ce = crex_fetch_class(NULL, opline->op1.num);
		if (UNEXPECTED(ce == NULL)) {

			HANDLE_EXCEPTION();
		}
	} else {
		ce = C_CE_P(EX_VAR(opline->op1.var));
	}

	if (IS_CONST == IS_CONST &&
	    IS_CONST == IS_CONST &&
	    EXPECTED((fbc = CACHED_PTR(opline->result.num + sizeof(void*))) != NULL)) {
		/* nothing to do */
	} else if (IS_CONST != IS_CONST &&
	           IS_CONST == IS_CONST &&
	           EXPECTED(CACHED_PTR(opline->result.num) == ce)) {
		fbc = CACHED_PTR(opline->result.num + sizeof(void*));
	} else if (IS_CONST != IS_UNUSED) {
		function_name = RT_CONSTANT(opline, opline->op2);
		if (IS_CONST != IS_CONST) {
			if (UNEXPECTED(C_TYPE_P(function_name) != IS_STRING)) {
				do {
					if (IS_CONST & (IS_VAR|IS_CV) && C_ISREF_P(function_name)) {
						function_name = C_REFVAL_P(function_name);
						if (EXPECTED(C_TYPE_P(function_name) == IS_STRING)) {
							break;
						}
					} else if (IS_CONST == IS_CV && UNEXPECTED(C_TYPE_P(function_name) == IS_UNDEF)) {
						ZVAL_UNDEFINED_OP2();
						if (UNEXPECTED(EG(exception) != NULL)) {
							HANDLE_EXCEPTION();
						}
					}
					crex_throw_error(NULL, "Method name must be a string");

					HANDLE_EXCEPTION();
				} while (0);
			}
		}

		if (ce->get_static_method) {
			fbc = ce->get_static_method(ce, C_STR_P(function_name));
		} else {
			fbc = crex_std_get_static_method(ce, C_STR_P(function_name), ((IS_CONST == IS_CONST) ? (RT_CONSTANT(opline, opline->op2) + 1) : NULL));
		}
		if (UNEXPECTED(fbc == NULL)) {
			if (EXPECTED(!EG(exception))) {
				crex_undefined_method(ce, C_STR_P(function_name));
			}

			HANDLE_EXCEPTION();
		}
		if (IS_CONST == IS_CONST &&
		    EXPECTED(!(fbc->common.fn_flags & (CREX_ACC_CALL_VIA_TRAMPOLINE|CREX_ACC_NEVER_CACHE))) &&
			EXPECTED(!(fbc->common.scope->ce_flags & CREX_ACC_TRAIT))) {
			CACHE_POLYMORPHIC_PTR(opline->result.num, ce, fbc);
		}
		if (EXPECTED(fbc->type == CREX_USER_FUNCTION) && UNEXPECTED(!RUN_TIME_CACHE(&fbc->op_array))) {
			init_func_run_time_cache(&fbc->op_array);
		}
		if (IS_CONST != IS_CONST) {

		}
	} else {
		if (UNEXPECTED(ce->constructor == NULL)) {
			crex_throw_error(NULL, "Cannot call constructor");
			HANDLE_EXCEPTION();
		}
		if (C_TYPE(EX(This)) == IS_OBJECT && C_OBJ(EX(This))->ce != ce->constructor->common.scope && (ce->constructor->common.fn_flags & CREX_ACC_PRIVATE)) {
			crex_throw_error(NULL, "Cannot call private %s::__main()", ZSTR_VAL(ce->name));
			HANDLE_EXCEPTION();
		}
		fbc = ce->constructor;
		if (EXPECTED(fbc->type == CREX_USER_FUNCTION) && UNEXPECTED(!RUN_TIME_CACHE(&fbc->op_array))) {
			init_func_run_time_cache(&fbc->op_array);
		}
	}

	if (!(fbc->common.fn_flags & CREX_ACC_STATIC)) {
		if (C_TYPE(EX(This)) == IS_OBJECT && instanceof_function(C_OBJCE(EX(This)), ce)) {
			ce = (crex_class_entry*)C_OBJ(EX(This));
			call_info = CREX_CALL_NESTED_FUNCTION | CREX_CALL_HAS_THIS;
		} else {
			crex_non_static_method_call(fbc);
			HANDLE_EXCEPTION();
		}
	} else {
		/* previous opcode is CREX_FETCH_CLASS */
		if (IS_CONST == IS_UNUSED
		 && ((opline->op1.num & CREX_FETCH_CLASS_MASK) == CREX_FETCH_CLASS_PARENT ||
		     (opline->op1.num & CREX_FETCH_CLASS_MASK) == CREX_FETCH_CLASS_SELF)) {
			if (C_TYPE(EX(This)) == IS_OBJECT) {
				ce = C_OBJCE(EX(This));
			} else {
				ce = C_CE(EX(This));
			}
		}
		call_info = CREX_CALL_NESTED_FUNCTION;
	}

	call = crex_vm_stack_push_call_frame(call_info,
		fbc, opline->extended_value, ce);
	call->prev_execute_data = EX(call);
	EX(call) = call;

	CREX_VM_NEXT_OPCODE();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_INIT_USER_CALL_SPEC_CONST_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *function_name;
	crex_fcall_info_cache fcc;
	char *error = NULL;
	crex_function *func;
	void *object_or_called_scope;
	crex_execute_data *call;
	uint32_t call_info = CREX_CALL_NESTED_FUNCTION | CREX_CALL_DYNAMIC;

	SAVE_OPLINE();
	function_name = RT_CONSTANT(opline, opline->op2);
	if (crex_is_callable_ex(function_name, NULL, 0, NULL, &fcc, &error)) {
		CREX_ASSERT(!error);
		func = fcc.function_handler;
		object_or_called_scope = fcc.called_scope;
		if (func->common.fn_flags & CREX_ACC_CLOSURE) {
			/* Delay closure destruction until its invocation */
			GC_ADDREF(CREX_CLOSURE_OBJECT(func));
			call_info |= CREX_CALL_CLOSURE;
			if (func->common.fn_flags & CREX_ACC_FAKE_CLOSURE) {
				call_info |= CREX_CALL_FAKE_CLOSURE;
			}
			if (fcc.object) {
				object_or_called_scope = fcc.object;
				call_info |= CREX_CALL_HAS_THIS;
			}
		} else if (fcc.object) {
			GC_ADDREF(fcc.object); /* For $this pointer */
			object_or_called_scope = fcc.object;
			call_info |= CREX_CALL_RELEASE_THIS | CREX_CALL_HAS_THIS;
		}

		if ((IS_CONST & (IS_TMP_VAR|IS_VAR)) && UNEXPECTED(EG(exception))) {
			if (call_info & CREX_CALL_CLOSURE) {
				crex_object_release(CREX_CLOSURE_OBJECT(func));
			} else if (call_info & CREX_CALL_RELEASE_THIS) {
				crex_object_release(fcc.object);
			}
			HANDLE_EXCEPTION();
		}

		if (EXPECTED(func->type == CREX_USER_FUNCTION) && UNEXPECTED(!RUN_TIME_CACHE(&func->op_array))) {
			init_func_run_time_cache(&func->op_array);
		}
	} else {
		crex_type_error("%s(): Argument #1 ($callback) must be a valid callback, %s", C_STRVAL_P(RT_CONSTANT(opline, opline->op1)), error);
		efree(error);

		HANDLE_EXCEPTION();
	}

	call = crex_vm_stack_push_call_frame(call_info,
		func, opline->extended_value, object_or_called_scope);
	call->prev_execute_data = EX(call);
	EX(call) = call;

	CREX_VM_NEXT_OPCODE();
}

static CREX_VM_HOT CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_SEND_VAL_SPEC_CONST_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *value, *arg;

	if (IS_CONST == IS_CONST) {
		SAVE_OPLINE();
		crex_string *arg_name = C_STR_P(RT_CONSTANT(opline, opline->op2));
		uint32_t arg_num;
		arg = crex_handle_named_arg(&EX(call), arg_name, &arg_num, CACHE_ADDR(opline->result.num));
		if (UNEXPECTED(!arg)) {

			HANDLE_EXCEPTION();
		}
	} else {
		arg = CREX_CALL_VAR(EX(call), opline->result.var);
	}

	value = RT_CONSTANT(opline, opline->op1);
	ZVAL_COPY_VALUE(arg, value);
	if (IS_CONST == IS_CONST) {
		if (UNEXPECTED(C_OPT_REFCOUNTED_P(arg))) {
			C_ADDREF_P(arg);
		}
	}
	CREX_VM_NEXT_OPCODE();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_SEND_VAL_EX_SPEC_CONST_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *value, *arg;
	uint32_t arg_num;

	if (IS_CONST == IS_CONST) {
		SAVE_OPLINE();
		crex_string *arg_name = C_STR_P(RT_CONSTANT(opline, opline->op2));
		arg = crex_handle_named_arg(&EX(call), arg_name, &arg_num, CACHE_ADDR(opline->result.num));
		if (UNEXPECTED(!arg)) {

			HANDLE_EXCEPTION();
		}
	} else {
		arg = CREX_CALL_VAR(EX(call), opline->result.var);
		arg_num = opline->op2.num;
	}

	if (EXPECTED(arg_num <= MAX_ARG_FLAG_NUM)) {
		if (QUICK_ARG_MUST_BE_SENT_BY_REF(EX(call)->func, arg_num)) {
			goto send_val_by_ref;
		}
	} else if (ARG_MUST_BE_SENT_BY_REF(EX(call)->func, arg_num)) {
send_val_by_ref:
		CREX_VM_TAIL_CALL(crex_cannot_pass_by_ref_helper_SPEC(arg_num, arg CREX_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
	}
	value = RT_CONSTANT(opline, opline->op1);
	ZVAL_COPY_VALUE(arg, value);
	if (IS_CONST == IS_CONST) {
		if (UNEXPECTED(C_OPT_REFCOUNTED_P(arg))) {
			C_ADDREF_P(arg);
		}
	}
	CREX_VM_NEXT_OPCODE();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FETCH_CLASS_CONSTANT_SPEC_CONST_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	crex_class_entry *ce, *scope;
	crex_class_constant *c;
	zval *value, *zv, *constant_zv;
	crex_string *constant_name;
	USE_OPLINE

	SAVE_OPLINE();

	do {
		if (IS_CONST == IS_CONST && IS_CONST == IS_CONST) {
			if (EXPECTED(CACHED_PTR(opline->extended_value + sizeof(void*)))) {
				value = CACHED_PTR(opline->extended_value + sizeof(void*));
				break;
			}
		}
		if (IS_CONST == IS_CONST) {
			if (EXPECTED(CACHED_PTR(opline->extended_value))) {
				ce = CACHED_PTR(opline->extended_value);
			} else {
				ce = crex_fetch_class_by_name(C_STR_P(RT_CONSTANT(opline, opline->op1)), C_STR_P(RT_CONSTANT(opline, opline->op1) + 1), CREX_FETCH_CLASS_DEFAULT | CREX_FETCH_CLASS_EXCEPTION);
				if (UNEXPECTED(ce == NULL)) {
					ZVAL_UNDEF(EX_VAR(opline->result.var));

					HANDLE_EXCEPTION();
				}
				CACHE_PTR(opline->extended_value, ce);
			}
		} else if (IS_CONST == IS_UNUSED) {
			ce = crex_fetch_class(NULL, opline->op1.num);
			if (UNEXPECTED(ce == NULL)) {
				ZVAL_UNDEF(EX_VAR(opline->result.var));

				HANDLE_EXCEPTION();
			}
		} else {
			ce = C_CE_P(EX_VAR(opline->op1.var));
		}
		if (IS_CONST != IS_CONST
			&& IS_CONST == IS_CONST
			&& EXPECTED(CACHED_PTR(opline->extended_value) == ce)) {
			value = CACHED_PTR(opline->extended_value + sizeof(void*));
			break;
		}

		constant_zv = RT_CONSTANT(opline, opline->op2);
		if (UNEXPECTED(C_TYPE_P(constant_zv) != IS_STRING)) {
			crex_invalid_class_constant_type_error(C_TYPE_P(constant_zv));
			ZVAL_UNDEF(EX_VAR(opline->result.var));

			HANDLE_EXCEPTION();
		}
		constant_name = C_STR_P(constant_zv);
		/* Magic 'class' for constant OP2 is caught at compile-time */
		if (IS_CONST != IS_CONST && UNEXPECTED(crex_string_equals_literal_ci(constant_name, "class"))) {
			ZVAL_STR_COPY(EX_VAR(opline->result.var), ce->name);

			CREX_VM_NEXT_OPCODE();
		}
		zv = IS_CONST == IS_CONST
			? crex_hash_find_known_hash(CE_CONSTANTS_TABLE(ce), constant_name)
			: crex_hash_find(CE_CONSTANTS_TABLE(ce), constant_name);

		if (EXPECTED(zv != NULL)) {
			c = C_PTR_P(zv);
			scope = EX(func)->op_array.scope;
			if (!crex_verify_const_access(c, scope)) {
				crex_throw_error(NULL, "Cannot access %s constant %s::%s", crex_visibility_string(CREX_CLASS_CONST_FLAGS(c)), ZSTR_VAL(ce->name), ZSTR_VAL(constant_name));
				ZVAL_UNDEF(EX_VAR(opline->result.var));

				HANDLE_EXCEPTION();
			}

			if (ce->ce_flags & CREX_ACC_TRAIT) {
				crex_throw_error(NULL, "Cannot access trait constant %s::%s directly", ZSTR_VAL(ce->name), ZSTR_VAL(constant_name));
				ZVAL_UNDEF(EX_VAR(opline->result.var));

				HANDLE_EXCEPTION();
			}

			bool is_constant_deprecated = CREX_CLASS_CONST_FLAGS(c) & CREX_ACC_DEPRECATED;
			if (UNEXPECTED(is_constant_deprecated)) {
				crex_error(E_DEPRECATED, "Constant %s::%s is deprecated", ZSTR_VAL(ce->name), ZSTR_VAL(constant_name));

				if (EG(exception)) {
					ZVAL_UNDEF(EX_VAR(opline->result.var));

					HANDLE_EXCEPTION();
				}
			}

			value = &c->value;
			// Enums require loading of all class constants to build the backed enum table
			if (ce->ce_flags & CREX_ACC_ENUM && ce->enum_backing_type != IS_UNDEF && ce->type == CREX_USER_CLASS && !(ce->ce_flags & CREX_ACC_CONSTANTS_UPDATED)) {
				if (UNEXPECTED(crex_update_class_constants(ce) == FAILURE)) {
					ZVAL_UNDEF(EX_VAR(opline->result.var));

					HANDLE_EXCEPTION();
				}
			}
			if (C_TYPE_P(value) == IS_CONSTANT_AST) {
				if (UNEXPECTED(crex_update_class_constant(c, constant_name, c->ce) != SUCCESS)) {
					ZVAL_UNDEF(EX_VAR(opline->result.var));

					HANDLE_EXCEPTION();
				}
			}
			if (IS_CONST == IS_CONST && !is_constant_deprecated) {
				CACHE_POLYMORPHIC_PTR(opline->extended_value, ce, value);
			}
		} else {
			crex_throw_error(NULL, "Undefined constant %s::%s",
				ZSTR_VAL(ce->name), ZSTR_VAL(constant_name));
			ZVAL_UNDEF(EX_VAR(opline->result.var));

			HANDLE_EXCEPTION();
		}
	} while (0);

	ZVAL_COPY_OR_DUP(EX_VAR(opline->result.var), value);

	CREX_VM_NEXT_OPCODE();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ADD_ARRAY_ELEMENT_SPEC_CONST_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *expr_ptr, new_expr;

	SAVE_OPLINE();
	if ((IS_CONST == IS_VAR || IS_CONST == IS_CV) &&
	    UNEXPECTED(opline->extended_value & CREX_ARRAY_ELEMENT_REF)) {
		expr_ptr = crex_get_bad_ptr();
		if (C_ISREF_P(expr_ptr)) {
			C_ADDREF_P(expr_ptr);
		} else {
			ZVAL_MAKE_REF_EX(expr_ptr, 2);
		}

	} else {
		expr_ptr = RT_CONSTANT(opline, opline->op1);
		if (IS_CONST == IS_TMP_VAR) {
			/* pass */
		} else if (IS_CONST == IS_CONST) {
			C_TRY_ADDREF_P(expr_ptr);
		} else if (IS_CONST == IS_CV) {
			ZVAL_DEREF(expr_ptr);
			C_TRY_ADDREF_P(expr_ptr);
		} else /* if (IS_CONST == IS_VAR) */ {
			if (UNEXPECTED(C_ISREF_P(expr_ptr))) {
				crex_refcounted *ref = C_COUNTED_P(expr_ptr);

				expr_ptr = C_REFVAL_P(expr_ptr);
				if (UNEXPECTED(GC_DELREF(ref) == 0)) {
					ZVAL_COPY_VALUE(&new_expr, expr_ptr);
					expr_ptr = &new_expr;
					efree_size(ref, sizeof(crex_reference));
				} else if (C_OPT_REFCOUNTED_P(expr_ptr)) {
					C_ADDREF_P(expr_ptr);
				}
			}
		}
	}

	if (IS_CONST != IS_UNUSED) {
		zval *offset = RT_CONSTANT(opline, opline->op2);
		crex_string *str;
		crex_ulong hval;

add_again:
		if (EXPECTED(C_TYPE_P(offset) == IS_STRING)) {
			str = C_STR_P(offset);
			if (IS_CONST != IS_CONST) {
				if (CREX_HANDLE_NUMERIC(str, hval)) {
					goto num_index;
				}
			}
str_index:
			crex_hash_update(C_ARRVAL_P(EX_VAR(opline->result.var)), str, expr_ptr);
		} else if (EXPECTED(C_TYPE_P(offset) == IS_LONG)) {
			hval = C_LVAL_P(offset);
num_index:
			crex_hash_index_update(C_ARRVAL_P(EX_VAR(opline->result.var)), hval, expr_ptr);
		} else if ((IS_CONST & (IS_VAR|IS_CV)) && EXPECTED(C_TYPE_P(offset) == IS_REFERENCE)) {
			offset = C_REFVAL_P(offset);
			goto add_again;
		} else if (C_TYPE_P(offset) == IS_NULL) {
			str = ZSTR_EMPTY_ALLOC();
			goto str_index;
		} else if (C_TYPE_P(offset) == IS_DOUBLE) {
			hval = crex_dval_to_lval_safe(C_DVAL_P(offset));
			goto num_index;
		} else if (C_TYPE_P(offset) == IS_FALSE) {
			hval = 0;
			goto num_index;
		} else if (C_TYPE_P(offset) == IS_TRUE) {
			hval = 1;
			goto num_index;
		} else if (C_TYPE_P(offset) == IS_RESOURCE) {
			crex_use_resource_as_offset(offset);
			hval = C_RES_HANDLE_P(offset);
			goto num_index;
		} else if (IS_CONST == IS_CV && C_TYPE_P(offset) == IS_UNDEF) {
			ZVAL_UNDEFINED_OP2();
			str = ZSTR_EMPTY_ALLOC();
			goto str_index;
		} else {
			crex_illegal_array_offset_access(offset);
			zval_ptr_dtor_nogc(expr_ptr);
		}

	} else {
		if (!crex_hash_next_index_insert(C_ARRVAL_P(EX_VAR(opline->result.var)), expr_ptr)) {
			crex_cannot_add_element();
			zval_ptr_dtor_nogc(expr_ptr);
		}
	}
	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_INIT_ARRAY_SPEC_CONST_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	zval *array;
	uint32_t size;
	USE_OPLINE

	array = EX_VAR(opline->result.var);
	if (IS_CONST != IS_UNUSED) {
		size = opline->extended_value >> CREX_ARRAY_SIZE_SHIFT;
		ZVAL_ARR(array, crex_new_array(size));
		/* Explicitly initialize array as not-packed if flag is set */
		if (opline->extended_value & CREX_ARRAY_NOT_PACKED) {
			crex_hash_real_init_mixed(C_ARRVAL_P(array));
		}
		CREX_VM_TAIL_CALL(CREX_ADD_ARRAY_ELEMENT_SPEC_CONST_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU));
	} else {
		ZVAL_ARR(array, crex_new_array(0));
		CREX_VM_NEXT_OPCODE();
	}
}

static CREX_VM_COLD CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ISSET_ISEMPTY_DIM_OBJ_SPEC_CONST_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;
	bool result;
	crex_ulong hval;
	zval *offset;

	SAVE_OPLINE();
	container = RT_CONSTANT(opline, opline->op1);
	offset = RT_CONSTANT(opline, opline->op2);

	if (EXPECTED(C_TYPE_P(container) == IS_ARRAY)) {
		HashTable *ht;
		zval *value;
		crex_string *str;

isset_dim_obj_array:
		ht = C_ARRVAL_P(container);
isset_again:
		if (EXPECTED(C_TYPE_P(offset) == IS_STRING)) {
			str = C_STR_P(offset);
			if (IS_CONST != IS_CONST) {
				if (CREX_HANDLE_NUMERIC(str, hval)) {
					goto num_index_prop;
				}
			}
			value = crex_hash_find_ex(ht, str, IS_CONST == IS_CONST);
		} else if (EXPECTED(C_TYPE_P(offset) == IS_LONG)) {
			hval = C_LVAL_P(offset);
num_index_prop:
			value = crex_hash_index_find(ht, hval);
		} else if ((IS_CONST & (IS_VAR|IS_CV)) && EXPECTED(C_ISREF_P(offset))) {
			offset = C_REFVAL_P(offset);
			goto isset_again;
		} else {
			value = crex_find_array_dim_slow(ht, offset EXECUTE_DATA_CC);
			if (UNEXPECTED(EG(exception))) {
				result = 0;
				goto isset_dim_obj_exit;
			}
		}

		if (!(opline->extended_value & CREX_ISEMPTY)) {
			/* > IS_NULL means not IS_UNDEF and not IS_NULL */
			result = value != NULL && C_TYPE_P(value) > IS_NULL &&
			    (!C_ISREF_P(value) || C_TYPE_P(C_REFVAL_P(value)) != IS_NULL);

			if (IS_CONST & (IS_CONST|IS_CV)) {
				/* avoid exception check */

				CREX_VM_SMART_BRANCH(result, 0);
			}
		} else {
			result = (value == NULL || !i_crex_is_true(value));
		}
		goto isset_dim_obj_exit;
	} else if ((IS_CONST & (IS_VAR|IS_CV)) && EXPECTED(C_ISREF_P(container))) {
		container = C_REFVAL_P(container);
		if (EXPECTED(C_TYPE_P(container) == IS_ARRAY)) {
			goto isset_dim_obj_array;
		}
	}

	if (IS_CONST == IS_CONST && C_EXTRA_P(offset) == CREX_EXTRA_VALUE) {
		offset++;
	}
	if (!(opline->extended_value & CREX_ISEMPTY)) {
		result = crex_isset_dim_slow(container, offset EXECUTE_DATA_CC);
	} else {
		result = crex_isempty_dim_slow(container, offset EXECUTE_DATA_CC);
	}

isset_dim_obj_exit:


	CREX_VM_SMART_BRANCH(result, 1);
}

static CREX_VM_COLD CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ISSET_ISEMPTY_PROP_OBJ_SPEC_CONST_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;
	int result;
	zval *offset;
	crex_string *name, *tmp_name;

	SAVE_OPLINE();
	container = RT_CONSTANT(opline, opline->op1);
	offset = RT_CONSTANT(opline, opline->op2);

	if (IS_CONST == IS_CONST ||
	    (IS_CONST != IS_UNUSED && UNEXPECTED(C_TYPE_P(container) != IS_OBJECT))) {
		if ((IS_CONST & (IS_VAR|IS_CV)) && C_ISREF_P(container)) {
			container = C_REFVAL_P(container);
			if (UNEXPECTED(C_TYPE_P(container) != IS_OBJECT)) {
				result = (opline->extended_value & CREX_ISEMPTY);
				goto isset_object_finish;
			}
		} else {
			result = (opline->extended_value & CREX_ISEMPTY);
			goto isset_object_finish;
		}
	}

	if (IS_CONST == IS_CONST) {
		name = C_STR_P(offset);
	} else {
		name = zval_try_get_tmp_string(offset, &tmp_name);
		if (UNEXPECTED(!name)) {
			result = 0;
			goto isset_object_finish;
		}
	}

	result =
		(opline->extended_value & CREX_ISEMPTY) ^
		C_OBJ_HT_P(container)->has_property(C_OBJ_P(container), name, (opline->extended_value & CREX_ISEMPTY), ((IS_CONST == IS_CONST) ? CACHE_ADDR(opline->extended_value & ~CREX_ISEMPTY) : NULL));

	if (IS_CONST != IS_CONST) {
		crex_tmp_string_release(tmp_name);
	}

isset_object_finish:


	CREX_VM_SMART_BRANCH(result, 1);
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ARRAY_KEY_EXISTS_SPEC_CONST_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *key, *subject;
	HashTable *ht;
	bool result;

	SAVE_OPLINE();

	key = RT_CONSTANT(opline, opline->op1);
	subject = RT_CONSTANT(opline, opline->op2);

	if (EXPECTED(C_TYPE_P(subject) == IS_ARRAY)) {
array_key_exists_array:
		ht = C_ARRVAL_P(subject);
		result = crex_array_key_exists_fast(ht, key OPLINE_CC EXECUTE_DATA_CC);
	} else {
		if ((IS_CONST & (IS_VAR|IS_CV)) && EXPECTED(C_ISREF_P(subject))) {
			subject = C_REFVAL_P(subject);
			if (EXPECTED(C_TYPE_P(subject) == IS_ARRAY)) {
				goto array_key_exists_array;
			}
		}
		crex_array_key_exists_error(subject, key OPLINE_CC EXECUTE_DATA_CC);
		result = 0;
	}


	CREX_VM_SMART_BRANCH(result, 1);
}

/* No specialization for op_types (CONST|TMPVAR|UNUSED|CV, ANY) */
static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_DECLARE_CLASS_DELAYED_SPEC_CONST_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	crex_class_entry *ce = CACHED_PTR(opline->extended_value);
	if (ce == NULL) {
		zval *lcname = RT_CONSTANT(opline, opline->op1);
		zval *zv = crex_hash_find_known_hash(EG(class_table), C_STR_P(lcname + 1));
		if (zv) {
			SAVE_OPLINE();
			ce = crex_bind_class_in_slot(zv, lcname, C_STR_P(RT_CONSTANT(opline, opline->op2)));
			if (!ce) {
				HANDLE_EXCEPTION();
			}
		}
		CACHE_PTR(opline->extended_value, ce);
	}
	CREX_VM_NEXT_OPCODE();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_DECLARE_CONST_SPEC_CONST_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *name;
	zval *val;
	crex_constant c;

	SAVE_OPLINE();
	name  = RT_CONSTANT(opline, opline->op1);
	val   = RT_CONSTANT(opline, opline->op2);

	ZVAL_COPY(&c.value, val);
	if (C_OPT_CONSTANT(c.value)) {
		if (UNEXPECTED(zval_update_constant_ex(&c.value, EX(func)->op_array.scope) != SUCCESS)) {
			zval_ptr_dtor_nogc(&c.value);


			HANDLE_EXCEPTION();
		}
	}
	/* non persistent, case sensitive */
	CREX_CONSTANT_SET_FLAGS(&c, 0, CRX_USER_CONSTANT);
	c.name = crex_string_copy(C_STR_P(name));

	if (crex_register_constant(&c) == FAILURE) {
	}


	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_YIELD_SPEC_CONST_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	crex_generator *generator = crex_get_running_generator(EXECUTE_DATA_C);

	SAVE_OPLINE();
	if (UNEXPECTED(generator->flags & CREX_GENERATOR_FORCED_CLOSE)) {
		CREX_VM_TAIL_CALL(crex_yield_in_closed_generator_helper_SPEC(CREX_OPCODE_HANDLER_ARGS_PASSTHRU));
	}

	/* Destroy the previously yielded value */
	zval_ptr_dtor(&generator->value);

	/* Destroy the previously yielded key */
	zval_ptr_dtor(&generator->key);

	/* Set the new yielded value */
	if (IS_CONST != IS_UNUSED) {
		if (UNEXPECTED(EX(func)->op_array.fn_flags & CREX_ACC_RETURN_REFERENCE)) {
			/* Constants and temporary variables aren't yieldable by reference,
			 * but we still allow them with a notice. */
			if (IS_CONST & (IS_CONST|IS_TMP_VAR)) {
				zval *value;

				crex_error(E_NOTICE, "Only variable references should be yielded by reference");

				value = RT_CONSTANT(opline, opline->op1);
				ZVAL_COPY_VALUE(&generator->value, value);
				if (IS_CONST == IS_CONST) {
					if (UNEXPECTED(C_OPT_REFCOUNTED(generator->value))) {
						C_ADDREF(generator->value);
					}
				}
			} else {
				zval *value_ptr = crex_get_bad_ptr();

				/* If a function call result is yielded and the function did
				 * not return by reference we throw a notice. */
				do {
					if (IS_CONST == IS_VAR) {
						CREX_ASSERT(value_ptr != &EG(uninitialized_zval));
						if (opline->extended_value == CREX_RETURNS_FUNCTION
						 && !C_ISREF_P(value_ptr)) {
							crex_error(E_NOTICE, "Only variable references should be yielded by reference");
							ZVAL_COPY(&generator->value, value_ptr);
							break;
						}
					}
					if (C_ISREF_P(value_ptr)) {
						C_ADDREF_P(value_ptr);
					} else {
						ZVAL_MAKE_REF_EX(value_ptr, 2);
					}
					ZVAL_REF(&generator->value, C_REF_P(value_ptr));
				} while (0);

			}
		} else {
			zval *value = RT_CONSTANT(opline, opline->op1);

			/* Consts, temporary variables and references need copying */
			if (IS_CONST == IS_CONST) {
				ZVAL_COPY_VALUE(&generator->value, value);
				if (UNEXPECTED(C_OPT_REFCOUNTED(generator->value))) {
					C_ADDREF(generator->value);
				}
			} else if (IS_CONST == IS_TMP_VAR) {
				ZVAL_COPY_VALUE(&generator->value, value);
			} else if ((IS_CONST & (IS_VAR|IS_CV)) && C_ISREF_P(value)) {
				ZVAL_COPY(&generator->value, C_REFVAL_P(value));

			} else {
				ZVAL_COPY_VALUE(&generator->value, value);
				if (IS_CONST == IS_CV) {
					if (C_OPT_REFCOUNTED_P(value)) C_ADDREF_P(value);
				}
			}
		}
	} else {
		/* If no value was specified yield null */
		ZVAL_NULL(&generator->value);
	}

	/* Set the new yielded key */
	if (IS_CONST != IS_UNUSED) {
		zval *key = RT_CONSTANT(opline, opline->op2);
		if ((IS_CONST & (IS_CV|IS_VAR)) && UNEXPECTED(C_TYPE_P(key) == IS_REFERENCE)) {
			key = C_REFVAL_P(key);
		}
		ZVAL_COPY(&generator->key, key);

		if (C_TYPE(generator->key) == IS_LONG
		    && C_LVAL(generator->key) > generator->largest_used_integer_key
		) {
			generator->largest_used_integer_key = C_LVAL(generator->key);
		}
	} else {
		/* If no key was specified we use auto-increment keys */
		generator->largest_used_integer_key++;
		ZVAL_LONG(&generator->key, generator->largest_used_integer_key);
	}

	if (RETURN_VALUE_USED(opline)) {
		/* If the return value of yield is used set the send
		 * target and initialize it to NULL */
		generator->send_target = EX_VAR(opline->result.var);
		ZVAL_NULL(generator->send_target);
	} else {
		generator->send_target = NULL;
	}

	/* We increment to the next op, so we are at the correct position when the
	 * generator is resumed. */
	CREX_VM_INC_OPCODE();

	/* The GOTO VM uses a local opline variable. We need to set the opline
	 * variable in execute_data so we don't resume at an old position. */
	SAVE_OPLINE();

	CREX_VM_RETURN();
}

static CREX_VM_COLD CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_SWITCH_LONG_SPEC_CONST_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op, *jump_zv;
	HashTable *jumptable;

	op = RT_CONSTANT(opline, opline->op1);

	if (C_TYPE_P(op) != IS_LONG) {
		ZVAL_DEREF(op);
		if (C_TYPE_P(op) != IS_LONG) {
			/* Wrong type, fall back to CREX_CASE chain */
			CREX_VM_NEXT_OPCODE();
		}
	}

	jumptable = C_ARRVAL_P(RT_CONSTANT(opline, opline->op2));
	jump_zv = crex_hash_index_find(jumptable, C_LVAL_P(op));
	if (jump_zv != NULL) {
		CREX_VM_SET_RELATIVE_OPCODE(opline, C_LVAL_P(jump_zv));
		CREX_VM_CONTINUE();
	} else {
		/* default */
		CREX_VM_SET_RELATIVE_OPCODE(opline, opline->extended_value);
		CREX_VM_CONTINUE();
	}
}

static CREX_VM_COLD CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_SWITCH_STRING_SPEC_CONST_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op, *jump_zv;
	HashTable *jumptable;

	op = RT_CONSTANT(opline, opline->op1);

	if (C_TYPE_P(op) != IS_STRING) {
		if (IS_CONST == IS_CONST) {
			/* Wrong type, fall back to CREX_CASE chain */
			CREX_VM_NEXT_OPCODE();
		} else {
			ZVAL_DEREF(op);
			if (C_TYPE_P(op) != IS_STRING) {
				/* Wrong type, fall back to CREX_CASE chain */
				CREX_VM_NEXT_OPCODE();
			}
		}
	}

	jumptable = C_ARRVAL_P(RT_CONSTANT(opline, opline->op2));
	jump_zv = crex_hash_find_ex(jumptable, C_STR_P(op), IS_CONST == IS_CONST);
	if (jump_zv != NULL) {
		CREX_VM_SET_RELATIVE_OPCODE(opline, C_LVAL_P(jump_zv));
		CREX_VM_CONTINUE();
	} else {
		/* default */
		CREX_VM_SET_RELATIVE_OPCODE(opline, opline->extended_value);
		CREX_VM_CONTINUE();
	}
}

static CREX_VM_COLD CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_MATCH_SPEC_CONST_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op, *jump_zv;
	HashTable *jumptable;

	op = RT_CONSTANT(opline, opline->op1);
	jumptable = C_ARRVAL_P(RT_CONSTANT(opline, opline->op2));

match_try_again:
	if (C_TYPE_P(op) == IS_LONG) {
		jump_zv = crex_hash_index_find(jumptable, C_LVAL_P(op));
	} else if (C_TYPE_P(op) == IS_STRING) {
		jump_zv = crex_hash_find_ex(jumptable, C_STR_P(op), IS_CONST == IS_CONST);
	} else if (C_TYPE_P(op) == IS_REFERENCE) {
		op = C_REFVAL_P(op);
		goto match_try_again;
	} else {
		if (UNEXPECTED((IS_CONST & IS_CV) && C_TYPE_P(op) == IS_UNDEF)) {
			SAVE_OPLINE();
			op = ZVAL_UNDEFINED_OP1();
			if (UNEXPECTED(EG(exception))) {
				HANDLE_EXCEPTION();
			}
			goto match_try_again;
		}

		goto default_branch;
	}

	if (jump_zv != NULL) {
		CREX_VM_SET_RELATIVE_OPCODE(opline, C_LVAL_P(jump_zv));
		CREX_VM_CONTINUE();
	} else {
default_branch:
		/* default */
		CREX_VM_SET_RELATIVE_OPCODE(opline, opline->extended_value);
		CREX_VM_CONTINUE();
	}
}

static CREX_VM_COLD CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_IN_ARRAY_SPEC_CONST_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1;
	HashTable *ht = C_ARRVAL_P(RT_CONSTANT(opline, opline->op2));
	zval *result;

	op1 = RT_CONSTANT(opline, opline->op1);
	if (EXPECTED(C_TYPE_P(op1) == IS_STRING)) {
		result = crex_hash_find_ex(ht, C_STR_P(op1), IS_CONST == IS_CONST);
		if (IS_CONST & (IS_TMP_VAR|IS_VAR)) {
			zval_ptr_dtor_str(op1);
		}
		CREX_VM_SMART_BRANCH(result, 0);
	}

	if (opline->extended_value) {
		if (EXPECTED(C_TYPE_P(op1) == IS_LONG)) {
			result = crex_hash_index_find(ht, C_LVAL_P(op1));
			CREX_VM_SMART_BRANCH(result, 0);
		}
		SAVE_OPLINE();
		if ((IS_CONST & (IS_VAR|IS_CV)) && C_TYPE_P(op1) == IS_REFERENCE) {
			op1 = C_REFVAL_P(op1);
			if (EXPECTED(C_TYPE_P(op1) == IS_STRING)) {
				result = crex_hash_find(ht, C_STR_P(op1));

				CREX_VM_SMART_BRANCH(result, 0);
			} else if (EXPECTED(C_TYPE_P(op1) == IS_LONG)) {
				result = crex_hash_index_find(ht, C_LVAL_P(op1));

				CREX_VM_SMART_BRANCH(result, 0);
			}
		} else if (IS_CONST == IS_CV && UNEXPECTED(C_TYPE_P(op1) == IS_UNDEF)) {
			ZVAL_UNDEFINED_OP1();
		}
	} else if (C_TYPE_P(op1) <= IS_FALSE) {
		if (IS_CONST == IS_CV && UNEXPECTED(C_TYPE_P(op1) == IS_UNDEF)) {
			SAVE_OPLINE();
			ZVAL_UNDEFINED_OP1();
			if (UNEXPECTED(EG(exception) != NULL)) {
				HANDLE_EXCEPTION();
			}
		}
		result = crex_hash_find_known_hash(ht, ZSTR_EMPTY_ALLOC());
		CREX_VM_SMART_BRANCH(result, 0);
	} else {
		crex_string *key;
		zval key_tmp;

		if ((IS_CONST & (IS_VAR|IS_CV)) && C_TYPE_P(op1) == IS_REFERENCE) {
			op1 = C_REFVAL_P(op1);
			if (EXPECTED(C_TYPE_P(op1) == IS_STRING)) {
				result = crex_hash_find(ht, C_STR_P(op1));

				CREX_VM_SMART_BRANCH(result, 0);
			}
		}

		SAVE_OPLINE();
		CREX_HASH_MAP_FOREACH_STR_KEY(ht, key) {
			ZVAL_STR(&key_tmp, key);
			if (crex_compare(op1, &key_tmp) == 0) {

				CREX_VM_SMART_BRANCH(1, 1);
			}
		} CREX_HASH_FOREACH_END();
	}

	CREX_VM_SMART_BRANCH(0, 1);
}

static CREX_VM_HOT CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ADD_SPEC_CONST_TMPVARCV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2, *result;
	double d1, d2;

	op1 = RT_CONSTANT(opline, opline->op1);
	op2 = EX_VAR(opline->op2.var);
	if (1 && IS_CONST == IS_CONST && (IS_TMP_VAR|IS_VAR|IS_CV) == IS_CONST) {
		/* pass */
	} else if (EXPECTED(C_TYPE_INFO_P(op1) == IS_LONG)) {
		if (EXPECTED(C_TYPE_INFO_P(op2) == IS_LONG)) {
			result = EX_VAR(opline->result.var);
			fast_long_add_function(result, op1, op2);
			CREX_VM_NEXT_OPCODE();
		} else if (EXPECTED(C_TYPE_INFO_P(op2) == IS_DOUBLE)) {
			d1 = (double)C_LVAL_P(op1);
			d2 = C_DVAL_P(op2);
			goto add_double;
		}
	} else if (EXPECTED(C_TYPE_INFO_P(op1) == IS_DOUBLE)) {
		if (EXPECTED(C_TYPE_INFO_P(op2) == IS_DOUBLE)) {
			d1 = C_DVAL_P(op1);
			d2 = C_DVAL_P(op2);
add_double:
			result = EX_VAR(opline->result.var);
			ZVAL_DOUBLE(result, d1 + d2);
			CREX_VM_NEXT_OPCODE();
		} else if (EXPECTED(C_TYPE_INFO_P(op2) == IS_LONG)) {
			d1 = C_DVAL_P(op1);
			d2 = (double)C_LVAL_P(op2);
			goto add_double;
		}
	}

	CREX_VM_TAIL_CALL(crex_add_helper_SPEC(op1, op2 CREX_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static CREX_VM_HOT CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_SUB_SPEC_CONST_TMPVARCV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2, *result;
	double d1, d2;

	op1 = RT_CONSTANT(opline, opline->op1);
	op2 = EX_VAR(opline->op2.var);
	if (1 && IS_CONST == IS_CONST && (IS_TMP_VAR|IS_VAR|IS_CV) == IS_CONST) {
		/* pass */
	} else if (EXPECTED(C_TYPE_INFO_P(op1) == IS_LONG)) {
		if (EXPECTED(C_TYPE_INFO_P(op2) == IS_LONG)) {
			result = EX_VAR(opline->result.var);
			fast_long_sub_function(result, op1, op2);
			CREX_VM_NEXT_OPCODE();
		} else if (EXPECTED(C_TYPE_INFO_P(op2) == IS_DOUBLE)) {
			d1 = (double)C_LVAL_P(op1);
			d2 = C_DVAL_P(op2);
			goto sub_double;
		}
	} else if (EXPECTED(C_TYPE_INFO_P(op1) == IS_DOUBLE)) {
		if (EXPECTED(C_TYPE_INFO_P(op2) == IS_DOUBLE)) {
			d1 = C_DVAL_P(op1);
			d2 = C_DVAL_P(op2);
sub_double:
			result = EX_VAR(opline->result.var);
			ZVAL_DOUBLE(result, d1 - d2);
			CREX_VM_NEXT_OPCODE();
		} else if (EXPECTED(C_TYPE_INFO_P(op2) == IS_LONG)) {
			d1 = C_DVAL_P(op1);
			d2 = (double)C_LVAL_P(op2);
			goto sub_double;
		}
	}

	CREX_VM_TAIL_CALL(crex_sub_helper_SPEC(op1, op2 CREX_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_MOD_SPEC_CONST_TMPVARCV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2, *result;

	op1 = RT_CONSTANT(opline, opline->op1);
	op2 = EX_VAR(opline->op2.var);
	if (1 && IS_CONST == IS_CONST && (IS_TMP_VAR|IS_VAR|IS_CV) == IS_CONST) {
		/* pass */
	} else if (EXPECTED(C_TYPE_INFO_P(op1) == IS_LONG)) {
		if (EXPECTED(C_TYPE_INFO_P(op2) == IS_LONG)) {
			result = EX_VAR(opline->result.var);
			if (UNEXPECTED(C_LVAL_P(op2) == 0)) {
				CREX_VM_TAIL_CALL(crex_mod_by_zero_helper_SPEC(CREX_OPCODE_HANDLER_ARGS_PASSTHRU));
			} else if (UNEXPECTED(C_LVAL_P(op2) == -1)) {
				/* Prevent overflow error/crash if op1==CREX_LONG_MIN */
				ZVAL_LONG(result, 0);
			} else {
				ZVAL_LONG(result, C_LVAL_P(op1) % C_LVAL_P(op2));
			}
			CREX_VM_NEXT_OPCODE();
		}
	}

	CREX_VM_TAIL_CALL(crex_mod_helper_SPEC(op1, op2 CREX_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_SL_SPEC_CONST_TMPVARCV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;

	op1 = RT_CONSTANT(opline, opline->op1);
	op2 = EX_VAR(opline->op2.var);
	if (1 && IS_CONST == IS_CONST && (IS_TMP_VAR|IS_VAR|IS_CV) == IS_CONST) {
		/* pass */
	} else if (EXPECTED(C_TYPE_INFO_P(op1) == IS_LONG)
			&& EXPECTED(C_TYPE_INFO_P(op2) == IS_LONG)
			&& EXPECTED((crex_ulong)C_LVAL_P(op2) < SIZEOF_CREX_LONG * 8)) {
		/* Perform shift on unsigned numbers to get well-defined wrap behavior. */
		ZVAL_LONG(EX_VAR(opline->result.var),
			(crex_long) ((crex_ulong) C_LVAL_P(op1) << C_LVAL_P(op2)));
		CREX_VM_NEXT_OPCODE();
	}

	CREX_VM_TAIL_CALL(crex_shift_left_helper_SPEC(op1, op2 CREX_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_SR_SPEC_CONST_TMPVARCV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;

	op1 = RT_CONSTANT(opline, opline->op1);
	op2 = EX_VAR(opline->op2.var);
	if (1 && IS_CONST == IS_CONST && (IS_TMP_VAR|IS_VAR|IS_CV) == IS_CONST) {
		/* pass */
	} else if (EXPECTED(C_TYPE_INFO_P(op1) == IS_LONG)
			&& EXPECTED(C_TYPE_INFO_P(op2) == IS_LONG)
			&& EXPECTED((crex_ulong)C_LVAL_P(op2) < SIZEOF_CREX_LONG * 8)) {
		ZVAL_LONG(EX_VAR(opline->result.var), C_LVAL_P(op1) >> C_LVAL_P(op2));
		CREX_VM_NEXT_OPCODE();
	}

	CREX_VM_TAIL_CALL(crex_shift_right_helper_SPEC(op1, op2 CREX_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_IS_SMALLER_SPEC_CONST_TMPVARCV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	double d1, d2;

	op1 = RT_CONSTANT(opline, opline->op1);
	op2 = EX_VAR(opline->op2.var);
	if (1 && IS_CONST == IS_CONST && (IS_TMP_VAR|IS_VAR|IS_CV) == IS_CONST) {
		/* pass */
	} else if (EXPECTED(C_TYPE_INFO_P(op1) == IS_LONG)) {
		if (EXPECTED(C_TYPE_INFO_P(op2) == IS_LONG)) {
			if (EXPECTED(C_LVAL_P(op1) < C_LVAL_P(op2))) {
is_smaller_true:
				CREX_VM_SMART_BRANCH_TRUE_NONE();
			} else {
is_smaller_false:
				CREX_VM_SMART_BRANCH_FALSE_NONE();
			}
		} else if (EXPECTED(C_TYPE_INFO_P(op2) == IS_DOUBLE)) {
			d1 = (double)C_LVAL_P(op1);
			d2 = C_DVAL_P(op2);
			goto is_smaller_double;
		}
	} else if (EXPECTED(C_TYPE_INFO_P(op1) == IS_DOUBLE)) {
		if (EXPECTED(C_TYPE_INFO_P(op2) == IS_DOUBLE)) {
			d1 = C_DVAL_P(op1);
			d2 = C_DVAL_P(op2);
is_smaller_double:
			if (d1 < d2) {
				goto is_smaller_true;
			} else {
				goto is_smaller_false;
			}
		} else if (EXPECTED(C_TYPE_INFO_P(op2) == IS_LONG)) {
			d1 = C_DVAL_P(op1);
			d2 = (double)C_LVAL_P(op2);
			goto is_smaller_double;
		}
	}
	CREX_VM_TAIL_CALL(crex_is_smaller_helper_SPEC(op1, op2 CREX_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static CREX_VM_HOT CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_IS_SMALLER_SPEC_CONST_TMPVARCV_JMPC_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	double d1, d2;

	op1 = RT_CONSTANT(opline, opline->op1);
	op2 = EX_VAR(opline->op2.var);
	if (1 && IS_CONST == IS_CONST && (IS_TMP_VAR|IS_VAR|IS_CV) == IS_CONST) {
		/* pass */
	} else if (EXPECTED(C_TYPE_INFO_P(op1) == IS_LONG)) {
		if (EXPECTED(C_TYPE_INFO_P(op2) == IS_LONG)) {
			if (EXPECTED(C_LVAL_P(op1) < C_LVAL_P(op2))) {
is_smaller_true:
				CREX_VM_SMART_BRANCH_TRUE_JMPZ();
			} else {
is_smaller_false:
				CREX_VM_SMART_BRANCH_FALSE_JMPZ();
			}
		} else if (EXPECTED(C_TYPE_INFO_P(op2) == IS_DOUBLE)) {
			d1 = (double)C_LVAL_P(op1);
			d2 = C_DVAL_P(op2);
			goto is_smaller_double;
		}
	} else if (EXPECTED(C_TYPE_INFO_P(op1) == IS_DOUBLE)) {
		if (EXPECTED(C_TYPE_INFO_P(op2) == IS_DOUBLE)) {
			d1 = C_DVAL_P(op1);
			d2 = C_DVAL_P(op2);
is_smaller_double:
			if (d1 < d2) {
				goto is_smaller_true;
			} else {
				goto is_smaller_false;
			}
		} else if (EXPECTED(C_TYPE_INFO_P(op2) == IS_LONG)) {
			d1 = C_DVAL_P(op1);
			d2 = (double)C_LVAL_P(op2);
			goto is_smaller_double;
		}
	}
	CREX_VM_TAIL_CALL(crex_is_smaller_helper_SPEC(op1, op2 CREX_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static CREX_VM_HOT CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_IS_SMALLER_SPEC_CONST_TMPVARCV_JMPNC_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	double d1, d2;

	op1 = RT_CONSTANT(opline, opline->op1);
	op2 = EX_VAR(opline->op2.var);
	if (1 && IS_CONST == IS_CONST && (IS_TMP_VAR|IS_VAR|IS_CV) == IS_CONST) {
		/* pass */
	} else if (EXPECTED(C_TYPE_INFO_P(op1) == IS_LONG)) {
		if (EXPECTED(C_TYPE_INFO_P(op2) == IS_LONG)) {
			if (EXPECTED(C_LVAL_P(op1) < C_LVAL_P(op2))) {
is_smaller_true:
				CREX_VM_SMART_BRANCH_TRUE_JMPNZ();
			} else {
is_smaller_false:
				CREX_VM_SMART_BRANCH_FALSE_JMPNZ();
			}
		} else if (EXPECTED(C_TYPE_INFO_P(op2) == IS_DOUBLE)) {
			d1 = (double)C_LVAL_P(op1);
			d2 = C_DVAL_P(op2);
			goto is_smaller_double;
		}
	} else if (EXPECTED(C_TYPE_INFO_P(op1) == IS_DOUBLE)) {
		if (EXPECTED(C_TYPE_INFO_P(op2) == IS_DOUBLE)) {
			d1 = C_DVAL_P(op1);
			d2 = C_DVAL_P(op2);
is_smaller_double:
			if (d1 < d2) {
				goto is_smaller_true;
			} else {
				goto is_smaller_false;
			}
		} else if (EXPECTED(C_TYPE_INFO_P(op2) == IS_LONG)) {
			d1 = C_DVAL_P(op1);
			d2 = (double)C_LVAL_P(op2);
			goto is_smaller_double;
		}
	}
	CREX_VM_TAIL_CALL(crex_is_smaller_helper_SPEC(op1, op2 CREX_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_IS_SMALLER_OR_EQUAL_SPEC_CONST_TMPVARCV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	double d1, d2;

	op1 = RT_CONSTANT(opline, opline->op1);
	op2 = EX_VAR(opline->op2.var);
	if (1 && IS_CONST == IS_CONST && (IS_TMP_VAR|IS_VAR|IS_CV) == IS_CONST) {
		/* pass */
	} else if (EXPECTED(C_TYPE_INFO_P(op1) == IS_LONG)) {
		if (EXPECTED(C_TYPE_INFO_P(op2) == IS_LONG)) {
			if (EXPECTED(C_LVAL_P(op1) <= C_LVAL_P(op2))) {
is_smaller_or_equal_true:
				CREX_VM_SMART_BRANCH_TRUE_NONE();
				ZVAL_TRUE(EX_VAR(opline->result.var));
				CREX_VM_NEXT_OPCODE();
			} else {
is_smaller_or_equal_false:
				CREX_VM_SMART_BRANCH_FALSE_NONE();
				ZVAL_FALSE(EX_VAR(opline->result.var));
				CREX_VM_NEXT_OPCODE();
			}
		} else if (EXPECTED(C_TYPE_INFO_P(op2) == IS_DOUBLE)) {
			d1 = (double)C_LVAL_P(op1);
			d2 = C_DVAL_P(op2);
			goto is_smaller_or_equal_double;
		}
	} else if (EXPECTED(C_TYPE_INFO_P(op1) == IS_DOUBLE)) {
		if (EXPECTED(C_TYPE_INFO_P(op2) == IS_DOUBLE)) {
			d1 = C_DVAL_P(op1);
			d2 = C_DVAL_P(op2);
is_smaller_or_equal_double:
			if (d1 <= d2) {
				goto is_smaller_or_equal_true;
			} else {
				goto is_smaller_or_equal_false;
			}
		} else if (EXPECTED(C_TYPE_INFO_P(op2) == IS_LONG)) {
			d1 = C_DVAL_P(op1);
			d2 = (double)C_LVAL_P(op2);
			goto is_smaller_or_equal_double;
		}
	}
	CREX_VM_TAIL_CALL(crex_is_smaller_or_equal_helper_SPEC(op1, op2 CREX_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static CREX_VM_HOT CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_IS_SMALLER_OR_EQUAL_SPEC_CONST_TMPVARCV_JMPC_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	double d1, d2;

	op1 = RT_CONSTANT(opline, opline->op1);
	op2 = EX_VAR(opline->op2.var);
	if (1 && IS_CONST == IS_CONST && (IS_TMP_VAR|IS_VAR|IS_CV) == IS_CONST) {
		/* pass */
	} else if (EXPECTED(C_TYPE_INFO_P(op1) == IS_LONG)) {
		if (EXPECTED(C_TYPE_INFO_P(op2) == IS_LONG)) {
			if (EXPECTED(C_LVAL_P(op1) <= C_LVAL_P(op2))) {
is_smaller_or_equal_true:
				CREX_VM_SMART_BRANCH_TRUE_JMPZ();
				ZVAL_TRUE(EX_VAR(opline->result.var));
				CREX_VM_NEXT_OPCODE();
			} else {
is_smaller_or_equal_false:
				CREX_VM_SMART_BRANCH_FALSE_JMPZ();
				ZVAL_FALSE(EX_VAR(opline->result.var));
				CREX_VM_NEXT_OPCODE();
			}
		} else if (EXPECTED(C_TYPE_INFO_P(op2) == IS_DOUBLE)) {
			d1 = (double)C_LVAL_P(op1);
			d2 = C_DVAL_P(op2);
			goto is_smaller_or_equal_double;
		}
	} else if (EXPECTED(C_TYPE_INFO_P(op1) == IS_DOUBLE)) {
		if (EXPECTED(C_TYPE_INFO_P(op2) == IS_DOUBLE)) {
			d1 = C_DVAL_P(op1);
			d2 = C_DVAL_P(op2);
is_smaller_or_equal_double:
			if (d1 <= d2) {
				goto is_smaller_or_equal_true;
			} else {
				goto is_smaller_or_equal_false;
			}
		} else if (EXPECTED(C_TYPE_INFO_P(op2) == IS_LONG)) {
			d1 = C_DVAL_P(op1);
			d2 = (double)C_LVAL_P(op2);
			goto is_smaller_or_equal_double;
		}
	}
	CREX_VM_TAIL_CALL(crex_is_smaller_or_equal_helper_SPEC(op1, op2 CREX_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static CREX_VM_HOT CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_IS_SMALLER_OR_EQUAL_SPEC_CONST_TMPVARCV_JMPNC_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	double d1, d2;

	op1 = RT_CONSTANT(opline, opline->op1);
	op2 = EX_VAR(opline->op2.var);
	if (1 && IS_CONST == IS_CONST && (IS_TMP_VAR|IS_VAR|IS_CV) == IS_CONST) {
		/* pass */
	} else if (EXPECTED(C_TYPE_INFO_P(op1) == IS_LONG)) {
		if (EXPECTED(C_TYPE_INFO_P(op2) == IS_LONG)) {
			if (EXPECTED(C_LVAL_P(op1) <= C_LVAL_P(op2))) {
is_smaller_or_equal_true:
				CREX_VM_SMART_BRANCH_TRUE_JMPNZ();
				ZVAL_TRUE(EX_VAR(opline->result.var));
				CREX_VM_NEXT_OPCODE();
			} else {
is_smaller_or_equal_false:
				CREX_VM_SMART_BRANCH_FALSE_JMPNZ();
				ZVAL_FALSE(EX_VAR(opline->result.var));
				CREX_VM_NEXT_OPCODE();
			}
		} else if (EXPECTED(C_TYPE_INFO_P(op2) == IS_DOUBLE)) {
			d1 = (double)C_LVAL_P(op1);
			d2 = C_DVAL_P(op2);
			goto is_smaller_or_equal_double;
		}
	} else if (EXPECTED(C_TYPE_INFO_P(op1) == IS_DOUBLE)) {
		if (EXPECTED(C_TYPE_INFO_P(op2) == IS_DOUBLE)) {
			d1 = C_DVAL_P(op1);
			d2 = C_DVAL_P(op2);
is_smaller_or_equal_double:
			if (d1 <= d2) {
				goto is_smaller_or_equal_true;
			} else {
				goto is_smaller_or_equal_false;
			}
		} else if (EXPECTED(C_TYPE_INFO_P(op2) == IS_LONG)) {
			d1 = C_DVAL_P(op1);
			d2 = (double)C_LVAL_P(op2);
			goto is_smaller_or_equal_double;
		}
	}
	CREX_VM_TAIL_CALL(crex_is_smaller_or_equal_helper_SPEC(op1, op2 CREX_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FETCH_CLASS_CONSTANT_SPEC_CONST_TMPVARCV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	crex_class_entry *ce, *scope;
	crex_class_constant *c;
	zval *value, *zv, *constant_zv;
	crex_string *constant_name;
	USE_OPLINE

	SAVE_OPLINE();

	do {
		if (IS_CONST == IS_CONST && (IS_TMP_VAR|IS_VAR|IS_CV) == IS_CONST) {
			if (EXPECTED(CACHED_PTR(opline->extended_value + sizeof(void*)))) {
				value = CACHED_PTR(opline->extended_value + sizeof(void*));
				break;
			}
		}
		if (IS_CONST == IS_CONST) {
			if (EXPECTED(CACHED_PTR(opline->extended_value))) {
				ce = CACHED_PTR(opline->extended_value);
			} else {
				ce = crex_fetch_class_by_name(C_STR_P(RT_CONSTANT(opline, opline->op1)), C_STR_P(RT_CONSTANT(opline, opline->op1) + 1), CREX_FETCH_CLASS_DEFAULT | CREX_FETCH_CLASS_EXCEPTION);
				if (UNEXPECTED(ce == NULL)) {
					ZVAL_UNDEF(EX_VAR(opline->result.var));
					FREE_OP(opline->op2_type, opline->op2.var);
					HANDLE_EXCEPTION();
				}
				CACHE_PTR(opline->extended_value, ce);
			}
		} else if (IS_CONST == IS_UNUSED) {
			ce = crex_fetch_class(NULL, opline->op1.num);
			if (UNEXPECTED(ce == NULL)) {
				ZVAL_UNDEF(EX_VAR(opline->result.var));
				FREE_OP(opline->op2_type, opline->op2.var);
				HANDLE_EXCEPTION();
			}
		} else {
			ce = C_CE_P(EX_VAR(opline->op1.var));
		}
		if (IS_CONST != IS_CONST
			&& (IS_TMP_VAR|IS_VAR|IS_CV) == IS_CONST
			&& EXPECTED(CACHED_PTR(opline->extended_value) == ce)) {
			value = CACHED_PTR(opline->extended_value + sizeof(void*));
			break;
		}

		constant_zv = _get_zval_ptr_tmpvarcv(opline->op2_type, opline->op2, BP_VAR_R EXECUTE_DATA_CC);
		if (UNEXPECTED(C_TYPE_P(constant_zv) != IS_STRING)) {
			crex_invalid_class_constant_type_error(C_TYPE_P(constant_zv));
			ZVAL_UNDEF(EX_VAR(opline->result.var));
			FREE_OP(opline->op2_type, opline->op2.var);
			HANDLE_EXCEPTION();
		}
		constant_name = C_STR_P(constant_zv);
		/* Magic 'class' for constant OP2 is caught at compile-time */
		if ((IS_TMP_VAR|IS_VAR|IS_CV) != IS_CONST && UNEXPECTED(crex_string_equals_literal_ci(constant_name, "class"))) {
			ZVAL_STR_COPY(EX_VAR(opline->result.var), ce->name);
			FREE_OP(opline->op2_type, opline->op2.var);
			CREX_VM_NEXT_OPCODE();
		}
		zv = (IS_TMP_VAR|IS_VAR|IS_CV) == IS_CONST
			? crex_hash_find_known_hash(CE_CONSTANTS_TABLE(ce), constant_name)
			: crex_hash_find(CE_CONSTANTS_TABLE(ce), constant_name);

		if (EXPECTED(zv != NULL)) {
			c = C_PTR_P(zv);
			scope = EX(func)->op_array.scope;
			if (!crex_verify_const_access(c, scope)) {
				crex_throw_error(NULL, "Cannot access %s constant %s::%s", crex_visibility_string(CREX_CLASS_CONST_FLAGS(c)), ZSTR_VAL(ce->name), ZSTR_VAL(constant_name));
				ZVAL_UNDEF(EX_VAR(opline->result.var));
				FREE_OP(opline->op2_type, opline->op2.var);
				HANDLE_EXCEPTION();
			}

			if (ce->ce_flags & CREX_ACC_TRAIT) {
				crex_throw_error(NULL, "Cannot access trait constant %s::%s directly", ZSTR_VAL(ce->name), ZSTR_VAL(constant_name));
				ZVAL_UNDEF(EX_VAR(opline->result.var));
				FREE_OP(opline->op2_type, opline->op2.var);
				HANDLE_EXCEPTION();
			}

			bool is_constant_deprecated = CREX_CLASS_CONST_FLAGS(c) & CREX_ACC_DEPRECATED;
			if (UNEXPECTED(is_constant_deprecated)) {
				crex_error(E_DEPRECATED, "Constant %s::%s is deprecated", ZSTR_VAL(ce->name), ZSTR_VAL(constant_name));

				if (EG(exception)) {
					ZVAL_UNDEF(EX_VAR(opline->result.var));
					FREE_OP(opline->op2_type, opline->op2.var);
					HANDLE_EXCEPTION();
				}
			}

			value = &c->value;
			// Enums require loading of all class constants to build the backed enum table
			if (ce->ce_flags & CREX_ACC_ENUM && ce->enum_backing_type != IS_UNDEF && ce->type == CREX_USER_CLASS && !(ce->ce_flags & CREX_ACC_CONSTANTS_UPDATED)) {
				if (UNEXPECTED(crex_update_class_constants(ce) == FAILURE)) {
					ZVAL_UNDEF(EX_VAR(opline->result.var));
					FREE_OP(opline->op2_type, opline->op2.var);
					HANDLE_EXCEPTION();
				}
			}
			if (C_TYPE_P(value) == IS_CONSTANT_AST) {
				if (UNEXPECTED(crex_update_class_constant(c, constant_name, c->ce) != SUCCESS)) {
					ZVAL_UNDEF(EX_VAR(opline->result.var));
					FREE_OP(opline->op2_type, opline->op2.var);
					HANDLE_EXCEPTION();
				}
			}
			if ((IS_TMP_VAR|IS_VAR|IS_CV) == IS_CONST && !is_constant_deprecated) {
				CACHE_POLYMORPHIC_PTR(opline->extended_value, ce, value);
			}
		} else {
			crex_throw_error(NULL, "Undefined constant %s::%s",
				ZSTR_VAL(ce->name), ZSTR_VAL(constant_name));
			ZVAL_UNDEF(EX_VAR(opline->result.var));
			FREE_OP(opline->op2_type, opline->op2.var);
			HANDLE_EXCEPTION();
		}
	} while (0);

	ZVAL_COPY_OR_DUP(EX_VAR(opline->result.var), value);

	FREE_OP(opline->op2_type, opline->op2.var);
	CREX_VM_NEXT_OPCODE();
}

static CREX_VM_HOT CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_SUB_LONG_NO_OVERFLOW_SPEC_CONST_TMPVARCV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2, *result;

	op1 = RT_CONSTANT(opline, opline->op1);
	op2 = EX_VAR(opline->op2.var);
	result = EX_VAR(opline->result.var);
	ZVAL_LONG(result, C_LVAL_P(op1) - C_LVAL_P(op2));
	CREX_VM_NEXT_OPCODE();
}

static CREX_VM_HOT CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_SUB_LONG_SPEC_CONST_TMPVARCV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2, *result;

	op1 = RT_CONSTANT(opline, opline->op1);
	op2 = EX_VAR(opline->op2.var);
	result = EX_VAR(opline->result.var);
	fast_long_sub_function(result, op1, op2);
	CREX_VM_NEXT_OPCODE();
}

static CREX_VM_HOT CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_SUB_DOUBLE_SPEC_CONST_TMPVARCV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2, *result;

	op1 = RT_CONSTANT(opline, opline->op1);
	op2 = EX_VAR(opline->op2.var);
	result = EX_VAR(opline->result.var);
	ZVAL_DOUBLE(result, C_DVAL_P(op1) - C_DVAL_P(op2));
	CREX_VM_NEXT_OPCODE();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_IS_SMALLER_LONG_SPEC_CONST_TMPVARCV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	bool result;

	op1 = RT_CONSTANT(opline, opline->op1);
	op2 = EX_VAR(opline->op2.var);
	result = (C_LVAL_P(op1) < C_LVAL_P(op2));
	CREX_VM_SMART_BRANCH_NONE(result, 0);
}

static CREX_VM_HOT CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_IS_SMALLER_LONG_SPEC_CONST_TMPVARCV_JMPC_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	bool result;

	op1 = RT_CONSTANT(opline, opline->op1);
	op2 = EX_VAR(opline->op2.var);
	result = (C_LVAL_P(op1) < C_LVAL_P(op2));
	CREX_VM_SMART_BRANCH_JMPZ(result, 0);
}

static CREX_VM_HOT CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_IS_SMALLER_LONG_SPEC_CONST_TMPVARCV_JMPNC_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	bool result;

	op1 = RT_CONSTANT(opline, opline->op1);
	op2 = EX_VAR(opline->op2.var);
	result = (C_LVAL_P(op1) < C_LVAL_P(op2));
	CREX_VM_SMART_BRANCH_JMPNZ(result, 0);
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_IS_SMALLER_DOUBLE_SPEC_CONST_TMPVARCV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	bool result;

	op1 = RT_CONSTANT(opline, opline->op1);
	op2 = EX_VAR(opline->op2.var);
	result = (C_DVAL_P(op1) < C_DVAL_P(op2));
	CREX_VM_SMART_BRANCH_NONE(result, 0);
}

static CREX_VM_HOT CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_IS_SMALLER_DOUBLE_SPEC_CONST_TMPVARCV_JMPC_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	bool result;

	op1 = RT_CONSTANT(opline, opline->op1);
	op2 = EX_VAR(opline->op2.var);
	result = (C_DVAL_P(op1) < C_DVAL_P(op2));
	CREX_VM_SMART_BRANCH_JMPZ(result, 0);
}

static CREX_VM_HOT CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_IS_SMALLER_DOUBLE_SPEC_CONST_TMPVARCV_JMPNC_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	bool result;

	op1 = RT_CONSTANT(opline, opline->op1);
	op2 = EX_VAR(opline->op2.var);
	result = (C_DVAL_P(op1) < C_DVAL_P(op2));
	CREX_VM_SMART_BRANCH_JMPNZ(result, 0);
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_IS_SMALLER_OR_EQUAL_LONG_SPEC_CONST_TMPVARCV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	bool result;

	op1 = RT_CONSTANT(opline, opline->op1);
	op2 = EX_VAR(opline->op2.var);
	result = (C_LVAL_P(op1) <= C_LVAL_P(op2));
	CREX_VM_SMART_BRANCH_NONE(result, 0);
}

static CREX_VM_HOT CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_IS_SMALLER_OR_EQUAL_LONG_SPEC_CONST_TMPVARCV_JMPC_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	bool result;

	op1 = RT_CONSTANT(opline, opline->op1);
	op2 = EX_VAR(opline->op2.var);
	result = (C_LVAL_P(op1) <= C_LVAL_P(op2));
	CREX_VM_SMART_BRANCH_JMPZ(result, 0);
}

static CREX_VM_HOT CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_IS_SMALLER_OR_EQUAL_LONG_SPEC_CONST_TMPVARCV_JMPNC_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	bool result;

	op1 = RT_CONSTANT(opline, opline->op1);
	op2 = EX_VAR(opline->op2.var);
	result = (C_LVAL_P(op1) <= C_LVAL_P(op2));
	CREX_VM_SMART_BRANCH_JMPNZ(result, 0);
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_CONST_TMPVARCV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	bool result;

	op1 = RT_CONSTANT(opline, opline->op1);
	op2 = EX_VAR(opline->op2.var);
	result = (C_DVAL_P(op1) <= C_DVAL_P(op2));
	CREX_VM_SMART_BRANCH_NONE(result, 0);
}

static CREX_VM_HOT CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_CONST_TMPVARCV_JMPC_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	bool result;

	op1 = RT_CONSTANT(opline, opline->op1);
	op2 = EX_VAR(opline->op2.var);
	result = (C_DVAL_P(op1) <= C_DVAL_P(op2));
	CREX_VM_SMART_BRANCH_JMPZ(result, 0);
}

static CREX_VM_HOT CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_CONST_TMPVARCV_JMPNC_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	bool result;

	op1 = RT_CONSTANT(opline, opline->op1);
	op2 = EX_VAR(opline->op2.var);
	result = (C_DVAL_P(op1) <= C_DVAL_P(op2));
	CREX_VM_SMART_BRANCH_JMPNZ(result, 0);
}

static CREX_VM_HOT CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FETCH_DIM_R_INDEX_SPEC_CONST_TMPVARCV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container, *dim, *value;
	crex_long offset;
	HashTable *ht;

	container = RT_CONSTANT(opline, opline->op1);
	dim = EX_VAR(opline->op2.var);
	if (EXPECTED(C_TYPE_P(container) == IS_ARRAY)) {
fetch_dim_r_index_array:
		if (EXPECTED(C_TYPE_P(dim) == IS_LONG)) {
			offset = C_LVAL_P(dim);
		} else {
			SAVE_OPLINE();
			crex_fetch_dimension_address_read_R(container, dim, (IS_TMP_VAR|IS_VAR|IS_CV) OPLINE_CC EXECUTE_DATA_CC);

			CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
		}
		ht = C_ARRVAL_P(container);
		CREX_HASH_INDEX_FIND(ht, offset, value, fetch_dim_r_index_undef);
		ZVAL_COPY_DEREF(EX_VAR(opline->result.var), value);
		if (IS_CONST & (IS_TMP_VAR|IS_VAR)) {
			SAVE_OPLINE();

			CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
		} else {
			CREX_VM_NEXT_OPCODE();
		}
	} else if (IS_CONST != IS_CONST && EXPECTED(C_TYPE_P(container) == IS_REFERENCE)) {
		container = C_REFVAL_P(container);
		if (EXPECTED(C_TYPE_P(container) == IS_ARRAY)) {
			goto fetch_dim_r_index_array;
		} else {
			goto fetch_dim_r_index_slow;
		}
	} else {
fetch_dim_r_index_slow:
		SAVE_OPLINE();
		if ((IS_TMP_VAR|IS_VAR|IS_CV) == IS_CONST && C_EXTRA_P(dim) == CREX_EXTRA_VALUE) {
			dim++;
		}
		crex_fetch_dimension_address_read_R_slow(container, dim OPLINE_CC EXECUTE_DATA_CC);

		CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
	}

fetch_dim_r_index_undef:
	ZVAL_NULL(EX_VAR(opline->result.var));
	SAVE_OPLINE();
	crex_undefined_offset(offset);

	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_DIV_SPEC_CONST_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;

	SAVE_OPLINE();
	op1 = RT_CONSTANT(opline, opline->op1);
	op2 = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
	div_function(EX_VAR(opline->result.var), op1, op2);

	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_POW_SPEC_CONST_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;

	SAVE_OPLINE();
	op1 = RT_CONSTANT(opline, opline->op1);
	op2 = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
	pow_function(EX_VAR(opline->result.var), op1, op2);

	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_CONCAT_SPEC_CONST_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;

	op1 = RT_CONSTANT(opline, opline->op1);
	op2 = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);

	if ((IS_CONST == IS_CONST || EXPECTED(C_TYPE_P(op1) == IS_STRING)) &&
	    ((IS_TMP_VAR|IS_VAR) == IS_CONST || EXPECTED(C_TYPE_P(op2) == IS_STRING))) {
		crex_string *op1_str = C_STR_P(op1);
		crex_string *op2_str = C_STR_P(op2);
		crex_string *str;
		uint32_t flags = ZSTR_GET_COPYABLE_CONCAT_PROPERTIES_BOTH(op1_str, op2_str);

		if (IS_CONST != IS_CONST && UNEXPECTED(ZSTR_LEN(op1_str) == 0)) {
			if ((IS_TMP_VAR|IS_VAR) == IS_CONST || (IS_TMP_VAR|IS_VAR) == IS_CV) {
				ZVAL_STR_COPY(EX_VAR(opline->result.var), op2_str);
			} else {
				ZVAL_STR(EX_VAR(opline->result.var), op2_str);
			}
			if (IS_CONST & (IS_TMP_VAR|IS_VAR)) {
				crex_string_release_ex(op1_str, 0);
			}
		} else if ((IS_TMP_VAR|IS_VAR) != IS_CONST && UNEXPECTED(ZSTR_LEN(op2_str) == 0)) {
			if (IS_CONST == IS_CONST || IS_CONST == IS_CV) {
				ZVAL_STR_COPY(EX_VAR(opline->result.var), op1_str);
			} else {
				ZVAL_STR(EX_VAR(opline->result.var), op1_str);
			}
			if ((IS_TMP_VAR|IS_VAR) & (IS_TMP_VAR|IS_VAR)) {
				crex_string_release_ex(op2_str, 0);
			}
		} else if (IS_CONST != IS_CONST && IS_CONST != IS_CV &&
		    !ZSTR_IS_INTERNED(op1_str) && GC_REFCOUNT(op1_str) == 1) {
			size_t len = ZSTR_LEN(op1_str);

			if (UNEXPECTED(len > ZSTR_MAX_LEN - ZSTR_LEN(op2_str))) {
				crex_error_noreturn(E_ERROR, "Integer overflow in memory allocation");
			}
			str = crex_string_extend(op1_str, len + ZSTR_LEN(op2_str), 0);
			memcpy(ZSTR_VAL(str) + len, ZSTR_VAL(op2_str), ZSTR_LEN(op2_str)+1);
			GC_ADD_FLAGS(str, flags);
			ZVAL_NEW_STR(EX_VAR(opline->result.var), str);
			if ((IS_TMP_VAR|IS_VAR) & (IS_TMP_VAR|IS_VAR)) {
				crex_string_release_ex(op2_str, 0);
			}
		} else {
			str = crex_string_alloc(ZSTR_LEN(op1_str) + ZSTR_LEN(op2_str), 0);
			memcpy(ZSTR_VAL(str), ZSTR_VAL(op1_str), ZSTR_LEN(op1_str));
			memcpy(ZSTR_VAL(str) + ZSTR_LEN(op1_str), ZSTR_VAL(op2_str), ZSTR_LEN(op2_str)+1);
			GC_ADD_FLAGS(str, flags);
			ZVAL_NEW_STR(EX_VAR(opline->result.var), str);
			if (IS_CONST & (IS_TMP_VAR|IS_VAR)) {
				crex_string_release_ex(op1_str, 0);
			}
			if ((IS_TMP_VAR|IS_VAR) & (IS_TMP_VAR|IS_VAR)) {
				crex_string_release_ex(op2_str, 0);
			}
		}
		CREX_VM_NEXT_OPCODE();
	} else {
		SAVE_OPLINE();

		if (IS_CONST == IS_CV && UNEXPECTED(C_TYPE_P(op1) == IS_UNDEF)) {
			op1 = ZVAL_UNDEFINED_OP1();
		}
		if ((IS_TMP_VAR|IS_VAR) == IS_CV && UNEXPECTED(C_TYPE_P(op2) == IS_UNDEF)) {
			op2 = ZVAL_UNDEFINED_OP2();
		}
		concat_function(EX_VAR(opline->result.var), op1, op2);

		zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
		CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
	}
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_SPACESHIP_SPEC_CONST_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;

	SAVE_OPLINE();
	op1 = RT_CONSTANT(opline, opline->op1);
	op2 = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
	compare_function(EX_VAR(opline->result.var), op1, op2);

	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FETCH_DIM_R_SPEC_CONST_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container, *dim, *value;

	SAVE_OPLINE();
	container = RT_CONSTANT(opline, opline->op1);
	dim = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
	if (IS_CONST != IS_CONST) {
		if (EXPECTED(C_TYPE_P(container) == IS_ARRAY)) {
fetch_dim_r_array:
			value = crex_fetch_dimension_address_inner(C_ARRVAL_P(container), dim, (IS_TMP_VAR|IS_VAR), BP_VAR_R EXECUTE_DATA_CC);
			ZVAL_COPY_DEREF(EX_VAR(opline->result.var), value);
		} else if (EXPECTED(C_TYPE_P(container) == IS_REFERENCE)) {
			container = C_REFVAL_P(container);
			if (EXPECTED(C_TYPE_P(container) == IS_ARRAY)) {
				goto fetch_dim_r_array;
			} else {
				goto fetch_dim_r_slow;
			}
		} else {
fetch_dim_r_slow:
			if ((IS_TMP_VAR|IS_VAR) == IS_CONST && C_EXTRA_P(dim) == CREX_EXTRA_VALUE) {
				dim++;
			}
			crex_fetch_dimension_address_read_R_slow(container, dim OPLINE_CC EXECUTE_DATA_CC);
		}
	} else {
		crex_fetch_dimension_address_read_R(container, dim, (IS_TMP_VAR|IS_VAR) OPLINE_CC EXECUTE_DATA_CC);
	}
	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));

	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FETCH_DIM_IS_SPEC_CONST_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;

	SAVE_OPLINE();
	container = RT_CONSTANT(opline, opline->op1);
	crex_fetch_dimension_address_read_IS(container, _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC), (IS_TMP_VAR|IS_VAR) OPLINE_CC EXECUTE_DATA_CC);
	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));

	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FETCH_DIM_FUNC_ARG_SPEC_CONST_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
#if 0
	USE_OPLINE
#endif

	if (UNEXPECTED(CREX_CALL_INFO(EX(call)) & CREX_CALL_SEND_ARG_BY_REF)) {
		if ((IS_CONST & (IS_CONST|IS_TMP_VAR))) {
			CREX_VM_TAIL_CALL(crex_use_tmp_in_write_context_helper_SPEC(CREX_OPCODE_HANDLER_ARGS_PASSTHRU));
		}
		CREX_VM_TAIL_CALL(CREX_NULL_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU));
	} else {
		if ((IS_TMP_VAR|IS_VAR) == IS_UNUSED) {
			CREX_VM_TAIL_CALL(crex_use_undef_in_read_context_helper_SPEC(CREX_OPCODE_HANDLER_ARGS_PASSTHRU));
		}
		CREX_VM_TAIL_CALL(CREX_FETCH_DIM_R_SPEC_CONST_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU));
	}
}

static CREX_VM_COLD CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FETCH_OBJ_R_SPEC_CONST_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;
	void **cache_slot = NULL;

	SAVE_OPLINE();
	container = RT_CONSTANT(opline, opline->op1);

	if (IS_CONST == IS_CONST ||
	    (IS_CONST != IS_UNUSED && UNEXPECTED(C_TYPE_P(container) != IS_OBJECT))) {
		do {
			if ((IS_CONST & (IS_VAR|IS_CV)) && C_ISREF_P(container)) {
				container = C_REFVAL_P(container);
				if (EXPECTED(C_TYPE_P(container) == IS_OBJECT)) {
					break;
				}
			}
			if (IS_CONST == IS_CV && UNEXPECTED(C_TYPE_P(container) == IS_UNDEF)) {
				ZVAL_UNDEFINED_OP1();
			}
			crex_wrong_property_read(container, _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC));
			ZVAL_NULL(EX_VAR(opline->result.var));
			goto fetch_obj_r_finish;
		} while (0);
	}

	/* here we are sure we are dealing with an object */
	do {
		crex_object *zobj = C_OBJ_P(container);
		crex_string *name, *tmp_name;
		zval *retval;

		if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
			cache_slot = CACHE_ADDR(opline->extended_value & ~CREX_FETCH_REF /* FUNC_ARG fetch may contain it */);

			if (EXPECTED(zobj->ce == CACHED_PTR_EX(cache_slot))) {
				uintptr_t prop_offset = (uintptr_t)CACHED_PTR_EX(cache_slot + 1);

				if (EXPECTED(IS_VALID_PROPERTY_OFFSET(prop_offset))) {
					retval = OBJ_PROP(zobj, prop_offset);
					if (EXPECTED(C_TYPE_INFO_P(retval) != IS_UNDEF)) {
						if (0 || (IS_CONST & (IS_TMP_VAR|IS_VAR)) != 0) {
							goto fetch_obj_r_copy;
						} else {
fetch_obj_r_fast_copy:
							ZVAL_COPY_DEREF(EX_VAR(opline->result.var), retval);
							CREX_VM_NEXT_OPCODE();
						}
					}
				} else if (EXPECTED(zobj->properties != NULL)) {
					name = C_STR_P(_get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC));
					if (!IS_UNKNOWN_DYNAMIC_PROPERTY_OFFSET(prop_offset)) {
						uintptr_t idx = CREX_DECODE_DYN_PROP_OFFSET(prop_offset);

						if (EXPECTED(idx < zobj->properties->nNumUsed * sizeof(Bucket))) {
							Bucket *p = (Bucket*)((char*)zobj->properties->arData + idx);

							if (EXPECTED(p->key == name) ||
							    (EXPECTED(p->h == ZSTR_H(name)) &&
							     EXPECTED(p->key != NULL) &&
							     EXPECTED(crex_string_equal_content(p->key, name)))) {
								retval = &p->val;
								if (0 || (IS_CONST & (IS_TMP_VAR|IS_VAR)) != 0) {
									goto fetch_obj_r_copy;
								} else {
									goto fetch_obj_r_fast_copy;
								}
							}
						}
						CACHE_PTR_EX(cache_slot + 1, (void*)CREX_DYNAMIC_PROPERTY_OFFSET);
					}
					retval = crex_hash_find_known_hash(zobj->properties, name);
					if (EXPECTED(retval)) {
						uintptr_t idx = (char*)retval - (char*)zobj->properties->arData;
						CACHE_PTR_EX(cache_slot + 1, (void*)CREX_ENCODE_DYN_PROP_OFFSET(idx));
						if (0 || (IS_CONST & (IS_TMP_VAR|IS_VAR)) != 0) {
							goto fetch_obj_r_copy;
						} else {
							goto fetch_obj_r_fast_copy;
						}
					}
				}
			}
			name = C_STR_P(_get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC));
		} else {
			name = zval_try_get_tmp_string(_get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC), &tmp_name);
			if (UNEXPECTED(!name)) {
				ZVAL_UNDEF(EX_VAR(opline->result.var));
				break;
			}
		}

#if CREX_DEBUG
		/* For non-standard object handlers, verify a declared property type in debug builds.
		 * Fetch prop_info before calling read_property(), as it may deallocate the object. */
		crex_property_info *prop_info = NULL;
		if (zobj->handlers->read_property != crex_std_read_property) {
			prop_info = crex_get_property_info(zobj->ce, name, /* silent */ true);
		}
#endif
		retval = zobj->handlers->read_property(zobj, name, BP_VAR_R, cache_slot, EX_VAR(opline->result.var));
#if CREX_DEBUG
		if (!EG(exception) && prop_info && prop_info != CREX_WRONG_PROPERTY_INFO
				&& CREX_TYPE_IS_SET(prop_info->type)) {
			ZVAL_OPT_DEREF(retval);
			crex_verify_property_type(prop_info, retval, /* strict */ true);
		}
#endif

		if ((IS_TMP_VAR|IS_VAR) != IS_CONST) {
			crex_tmp_string_release(tmp_name);
		}

		if (retval != EX_VAR(opline->result.var)) {
fetch_obj_r_copy:
			ZVAL_COPY_DEREF(EX_VAR(opline->result.var), retval);
		} else if (UNEXPECTED(C_ISREF_P(retval))) {
			crex_unwrap_reference(retval);
		}
	} while (0);

fetch_obj_r_finish:
	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));

	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_VM_COLD CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FETCH_OBJ_IS_SPEC_CONST_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;
	void **cache_slot = NULL;

	SAVE_OPLINE();
	container = RT_CONSTANT(opline, opline->op1);

	if (IS_CONST == IS_CONST ||
	    (IS_CONST != IS_UNUSED && UNEXPECTED(C_TYPE_P(container) != IS_OBJECT))) {
		do {
			if ((IS_CONST & (IS_VAR|IS_CV)) && C_ISREF_P(container)) {
				container = C_REFVAL_P(container);
				if (EXPECTED(C_TYPE_P(container) == IS_OBJECT)) {
					break;
				}
			}
			if ((IS_TMP_VAR|IS_VAR) == IS_CV && C_TYPE_P(EX_VAR(opline->op2.var)) == IS_UNDEF) {
				ZVAL_UNDEFINED_OP2();
			}
			ZVAL_NULL(EX_VAR(opline->result.var));
			goto fetch_obj_is_finish;
		} while (0);
	}

	/* here we are sure we are dealing with an object */
	do {
		crex_object *zobj = C_OBJ_P(container);
		crex_string *name, *tmp_name;
		zval *retval;

		if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
			cache_slot = CACHE_ADDR(opline->extended_value);

			if (EXPECTED(zobj->ce == CACHED_PTR_EX(cache_slot))) {
				uintptr_t prop_offset = (uintptr_t)CACHED_PTR_EX(cache_slot + 1);

				if (EXPECTED(IS_VALID_PROPERTY_OFFSET(prop_offset))) {
					retval = OBJ_PROP(zobj, prop_offset);
					if (EXPECTED(C_TYPE_P(retval) != IS_UNDEF)) {
						if (0 || (IS_CONST & (IS_TMP_VAR|IS_VAR)) != 0) {
							goto fetch_obj_is_copy;
						} else {
fetch_obj_is_fast_copy:
							ZVAL_COPY_DEREF(EX_VAR(opline->result.var), retval);
							CREX_VM_NEXT_OPCODE();
						}
					}
				} else if (EXPECTED(zobj->properties != NULL)) {
					name = C_STR_P(_get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC));
					if (!IS_UNKNOWN_DYNAMIC_PROPERTY_OFFSET(prop_offset)) {
						uintptr_t idx = CREX_DECODE_DYN_PROP_OFFSET(prop_offset);

						if (EXPECTED(idx < zobj->properties->nNumUsed * sizeof(Bucket))) {
							Bucket *p = (Bucket*)((char*)zobj->properties->arData + idx);

							if (EXPECTED(p->key == name) ||
							    (EXPECTED(p->h == ZSTR_H(name)) &&
							     EXPECTED(p->key != NULL) &&
							     EXPECTED(crex_string_equal_content(p->key, name)))) {
								retval = &p->val;
								if (0 || (IS_CONST & (IS_TMP_VAR|IS_VAR)) != 0) {
									goto fetch_obj_is_copy;
								} else {
									goto fetch_obj_is_fast_copy;
								}
							}
						}
						CACHE_PTR_EX(cache_slot + 1, (void*)CREX_DYNAMIC_PROPERTY_OFFSET);
					}
					retval = crex_hash_find_known_hash(zobj->properties, name);
					if (EXPECTED(retval)) {
						uintptr_t idx = (char*)retval - (char*)zobj->properties->arData;
						CACHE_PTR_EX(cache_slot + 1, (void*)CREX_ENCODE_DYN_PROP_OFFSET(idx));
						if (0 || (IS_CONST & (IS_TMP_VAR|IS_VAR)) != 0) {
							goto fetch_obj_is_copy;
						} else {
							goto fetch_obj_is_fast_copy;
						}
					}
				}
			}
			name = C_STR_P(_get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC));
		} else {
			name = zval_try_get_tmp_string(_get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC), &tmp_name);
			if (UNEXPECTED(!name)) {
				ZVAL_UNDEF(EX_VAR(opline->result.var));
				break;
			}
		}

		retval = zobj->handlers->read_property(zobj, name, BP_VAR_IS, cache_slot, EX_VAR(opline->result.var));

		if ((IS_TMP_VAR|IS_VAR) != IS_CONST) {
			crex_tmp_string_release(tmp_name);
		}

		if (retval != EX_VAR(opline->result.var)) {
fetch_obj_is_copy:
			ZVAL_COPY_DEREF(EX_VAR(opline->result.var), retval);
		} else if (UNEXPECTED(C_ISREF_P(retval))) {
			crex_unwrap_reference(retval);
		}
	} while (0);

fetch_obj_is_finish:
	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));

	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_VM_COLD CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FETCH_OBJ_FUNC_ARG_SPEC_CONST_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
#if 0
	USE_OPLINE
#endif

	if (UNEXPECTED(CREX_CALL_INFO(EX(call)) & CREX_CALL_SEND_ARG_BY_REF)) {
		/* Behave like FETCH_OBJ_W */
		if ((IS_CONST & (IS_CONST|IS_TMP_VAR))) {
			CREX_VM_TAIL_CALL(crex_use_tmp_in_write_context_helper_SPEC(CREX_OPCODE_HANDLER_ARGS_PASSTHRU));
		}
		CREX_VM_TAIL_CALL(CREX_NULL_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU));
	} else {
		CREX_VM_TAIL_CALL(CREX_FETCH_OBJ_R_SPEC_CONST_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU));
	}
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FETCH_LIST_R_SPEC_CONST_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;

	SAVE_OPLINE();
	container = RT_CONSTANT(opline, opline->op1);
	crex_fetch_dimension_address_LIST_r(container, _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC), (IS_TMP_VAR|IS_VAR) OPLINE_CC EXECUTE_DATA_CC);
	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FAST_CONCAT_SPEC_CONST_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	crex_string *op1_str, *op2_str, *str;


	op1 = RT_CONSTANT(opline, opline->op1);
	op2 = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
	if ((IS_CONST == IS_CONST || EXPECTED(C_TYPE_P(op1) == IS_STRING)) &&
	    ((IS_TMP_VAR|IS_VAR) == IS_CONST || EXPECTED(C_TYPE_P(op2) == IS_STRING))) {
		crex_string *op1_str = C_STR_P(op1);
		crex_string *op2_str = C_STR_P(op2);
		crex_string *str;
		uint32_t flags = ZSTR_GET_COPYABLE_CONCAT_PROPERTIES_BOTH(op1_str, op2_str);

		if (IS_CONST != IS_CONST && UNEXPECTED(ZSTR_LEN(op1_str) == 0)) {
			if ((IS_TMP_VAR|IS_VAR) == IS_CONST || (IS_TMP_VAR|IS_VAR) == IS_CV) {
				ZVAL_STR_COPY(EX_VAR(opline->result.var), op2_str);
			} else {
				ZVAL_STR(EX_VAR(opline->result.var), op2_str);
			}
			if (IS_CONST & (IS_TMP_VAR|IS_VAR)) {
				crex_string_release_ex(op1_str, 0);
			}
		} else if ((IS_TMP_VAR|IS_VAR) != IS_CONST && UNEXPECTED(ZSTR_LEN(op2_str) == 0)) {
			if (IS_CONST == IS_CONST || IS_CONST == IS_CV) {
				ZVAL_STR_COPY(EX_VAR(opline->result.var), op1_str);
			} else {
				ZVAL_STR(EX_VAR(opline->result.var), op1_str);
			}
			if ((IS_TMP_VAR|IS_VAR) & (IS_TMP_VAR|IS_VAR)) {
				crex_string_release_ex(op2_str, 0);
			}
		} else if (IS_CONST != IS_CONST && IS_CONST != IS_CV &&
		    !ZSTR_IS_INTERNED(op1_str) && GC_REFCOUNT(op1_str) == 1) {
			size_t len = ZSTR_LEN(op1_str);

			str = crex_string_extend(op1_str, len + ZSTR_LEN(op2_str), 0);
			memcpy(ZSTR_VAL(str) + len, ZSTR_VAL(op2_str), ZSTR_LEN(op2_str)+1);
			GC_ADD_FLAGS(str, flags);
			ZVAL_NEW_STR(EX_VAR(opline->result.var), str);
			if ((IS_TMP_VAR|IS_VAR) & (IS_TMP_VAR|IS_VAR)) {
				crex_string_release_ex(op2_str, 0);
			}
		} else {
			str = crex_string_alloc(ZSTR_LEN(op1_str) + ZSTR_LEN(op2_str), 0);
			memcpy(ZSTR_VAL(str), ZSTR_VAL(op1_str), ZSTR_LEN(op1_str));
			memcpy(ZSTR_VAL(str) + ZSTR_LEN(op1_str), ZSTR_VAL(op2_str), ZSTR_LEN(op2_str)+1);
			GC_ADD_FLAGS(str, flags);
			ZVAL_NEW_STR(EX_VAR(opline->result.var), str);
			if (IS_CONST & (IS_TMP_VAR|IS_VAR)) {
				crex_string_release_ex(op1_str, 0);
			}
			if ((IS_TMP_VAR|IS_VAR) & (IS_TMP_VAR|IS_VAR)) {
				crex_string_release_ex(op2_str, 0);
			}
		}
		CREX_VM_NEXT_OPCODE();
	}

	SAVE_OPLINE();
	if (IS_CONST == IS_CONST) {
		op1_str = C_STR_P(op1);
	} else if (EXPECTED(C_TYPE_P(op1) == IS_STRING)) {
		op1_str = crex_string_copy(C_STR_P(op1));
	} else {
		if (IS_CONST == IS_CV && UNEXPECTED(C_TYPE_P(op1) == IS_UNDEF)) {
			ZVAL_UNDEFINED_OP1();
		}
		op1_str = zval_get_string_func(op1);
	}
	if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
		op2_str = C_STR_P(op2);
	} else if (EXPECTED(C_TYPE_P(op2) == IS_STRING)) {
		op2_str = crex_string_copy(C_STR_P(op2));
	} else {
		if ((IS_TMP_VAR|IS_VAR) == IS_CV && UNEXPECTED(C_TYPE_P(op2) == IS_UNDEF)) {
			ZVAL_UNDEFINED_OP2();
		}
		op2_str = zval_get_string_func(op2);
	}
	do {
		if (IS_CONST != IS_CONST) {
			if (UNEXPECTED(ZSTR_LEN(op1_str) == 0)) {
				if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
					if (UNEXPECTED(C_REFCOUNTED_P(op2))) {
						GC_ADDREF(op2_str);
					}
				}
				ZVAL_STR(EX_VAR(opline->result.var), op2_str);
				crex_string_release_ex(op1_str, 0);
				break;
			}
		}
		if ((IS_TMP_VAR|IS_VAR) != IS_CONST) {
			if (UNEXPECTED(ZSTR_LEN(op2_str) == 0)) {
				if (IS_CONST == IS_CONST) {
					if (UNEXPECTED(C_REFCOUNTED_P(op1))) {
						GC_ADDREF(op1_str);
					}
				}
				ZVAL_STR(EX_VAR(opline->result.var), op1_str);
				crex_string_release_ex(op2_str, 0);
				break;
			}
		}
		str = crex_string_alloc(ZSTR_LEN(op1_str) + ZSTR_LEN(op2_str), 0);
		memcpy(ZSTR_VAL(str), ZSTR_VAL(op1_str), ZSTR_LEN(op1_str));
		memcpy(ZSTR_VAL(str) + ZSTR_LEN(op1_str), ZSTR_VAL(op2_str), ZSTR_LEN(op2_str)+1);

		ZSTR_COPY_CONCAT_PROPERTIES_BOTH(str, op1_str, op2_str);
		ZVAL_NEW_STR(EX_VAR(opline->result.var), str);
		if (IS_CONST != IS_CONST) {
			crex_string_release_ex(op1_str, 0);
		}
		if ((IS_TMP_VAR|IS_VAR) != IS_CONST) {
			crex_string_release_ex(op2_str, 0);
		}
	} while (0);

	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_VM_COLD CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_INIT_METHOD_CALL_SPEC_CONST_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *function_name;
	zval *object;
	crex_function *fbc;
	crex_class_entry *called_scope;
	crex_object *obj;
	crex_execute_data *call;
	uint32_t call_info;

	SAVE_OPLINE();

	object = RT_CONSTANT(opline, opline->op1);

	if ((IS_TMP_VAR|IS_VAR) != IS_CONST) {
		function_name = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
	}

	if ((IS_TMP_VAR|IS_VAR) != IS_CONST &&
	    UNEXPECTED(C_TYPE_P(function_name) != IS_STRING)) {
		do {
			if (((IS_TMP_VAR|IS_VAR) & (IS_VAR|IS_CV)) && C_ISREF_P(function_name)) {
				function_name = C_REFVAL_P(function_name);
				if (EXPECTED(C_TYPE_P(function_name) == IS_STRING)) {
					break;
				}
			} else if ((IS_TMP_VAR|IS_VAR) == IS_CV && UNEXPECTED(C_TYPE_P(function_name) == IS_UNDEF)) {
				ZVAL_UNDEFINED_OP2();
				if (UNEXPECTED(EG(exception) != NULL)) {

					HANDLE_EXCEPTION();
				}
			}
			crex_throw_error(NULL, "Method name must be a string");
			zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));

			HANDLE_EXCEPTION();
		} while (0);
	}

	if (IS_CONST == IS_UNUSED) {
		obj = C_OBJ_P(object);
	} else {
		do {
			if (IS_CONST != IS_CONST && EXPECTED(C_TYPE_P(object) == IS_OBJECT)) {
				obj = C_OBJ_P(object);
			} else {
				if ((IS_CONST & (IS_VAR|IS_CV)) && EXPECTED(C_ISREF_P(object))) {
					crex_reference *ref = C_REF_P(object);

					object = &ref->val;
					if (EXPECTED(C_TYPE_P(object) == IS_OBJECT)) {
						obj = C_OBJ_P(object);
						if (IS_CONST & IS_VAR) {
							if (UNEXPECTED(GC_DELREF(ref) == 0)) {
								efree_size(ref, sizeof(crex_reference));
							} else {
								C_ADDREF_P(object);
							}
						}
						break;
					}
				}
				if (IS_CONST == IS_CV && UNEXPECTED(C_TYPE_P(object) == IS_UNDEF)) {
					object = ZVAL_UNDEFINED_OP1();
					if (UNEXPECTED(EG(exception) != NULL)) {
						if ((IS_TMP_VAR|IS_VAR) != IS_CONST) {
							zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
						}
						HANDLE_EXCEPTION();
					}
				}
				if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
					function_name = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
				}
				crex_invalid_method_call(object, function_name);
				zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));

				HANDLE_EXCEPTION();
			}
		} while (0);
	}

	called_scope = obj->ce;

	if ((IS_TMP_VAR|IS_VAR) == IS_CONST &&
	    EXPECTED(CACHED_PTR(opline->result.num) == called_scope)) {
		fbc = CACHED_PTR(opline->result.num + sizeof(void*));
	} else {
		crex_object *orig_obj = obj;

		if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
			function_name = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
		}

		/* First, locate the function. */
		fbc = obj->handlers->get_method(&obj, C_STR_P(function_name), (((IS_TMP_VAR|IS_VAR) == IS_CONST) ? (RT_CONSTANT(opline, opline->op2) + 1) : NULL));
		if (UNEXPECTED(fbc == NULL)) {
			if (EXPECTED(!EG(exception))) {
				crex_undefined_method(obj->ce, C_STR_P(function_name));
			}
			zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
			if ((IS_CONST & (IS_VAR|IS_TMP_VAR)) && GC_DELREF(orig_obj) == 0) {
				crex_objects_store_del(orig_obj);
			}
			HANDLE_EXCEPTION();
		}
		if ((IS_TMP_VAR|IS_VAR) == IS_CONST &&
		    EXPECTED(!(fbc->common.fn_flags & (CREX_ACC_CALL_VIA_TRAMPOLINE|CREX_ACC_NEVER_CACHE))) &&
		    EXPECTED(obj == orig_obj)) {
			CACHE_POLYMORPHIC_PTR(opline->result.num, called_scope, fbc);
		}
		if ((IS_CONST & (IS_VAR|IS_TMP_VAR)) && UNEXPECTED(obj != orig_obj)) {
			GC_ADDREF(obj); /* For $this pointer */
			if (GC_DELREF(orig_obj) == 0) {
				crex_objects_store_del(orig_obj);
			}
		}
		if (EXPECTED(fbc->type == CREX_USER_FUNCTION) && UNEXPECTED(!RUN_TIME_CACHE(&fbc->op_array))) {
			init_func_run_time_cache(&fbc->op_array);
		}
	}

	if ((IS_TMP_VAR|IS_VAR) != IS_CONST) {
		zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
	}

	call_info = CREX_CALL_NESTED_FUNCTION | CREX_CALL_HAS_THIS;
	if (UNEXPECTED((fbc->common.fn_flags & CREX_ACC_STATIC) != 0)) {
		if ((IS_CONST & (IS_VAR|IS_TMP_VAR)) && GC_DELREF(obj) == 0) {
			crex_objects_store_del(obj);
			if (UNEXPECTED(EG(exception))) {
				HANDLE_EXCEPTION();
			}
		}
		/* call static method */
		obj = (crex_object*)called_scope;
		call_info = CREX_CALL_NESTED_FUNCTION;
	} else if (IS_CONST & (IS_VAR|IS_TMP_VAR|IS_CV)) {
		if (IS_CONST == IS_CV) {
			GC_ADDREF(obj); /* For $this pointer */
		}
		/* CV may be changed indirectly (e.g. when it's a reference) */
		call_info = CREX_CALL_NESTED_FUNCTION | CREX_CALL_HAS_THIS | CREX_CALL_RELEASE_THIS;
	}

	call = crex_vm_stack_push_call_frame(call_info,
		fbc, opline->extended_value, obj);
	call->prev_execute_data = EX(call);
	EX(call) = call;

	CREX_VM_NEXT_OPCODE();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_INIT_STATIC_METHOD_CALL_SPEC_CONST_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *function_name;
	crex_class_entry *ce;
	uint32_t call_info;
	crex_function *fbc;
	crex_execute_data *call;

	SAVE_OPLINE();

	if (IS_CONST == IS_CONST) {
		/* no function found. try a static method in class */
		ce = CACHED_PTR(opline->result.num);
		if (UNEXPECTED(ce == NULL)) {
			ce = crex_fetch_class_by_name(C_STR_P(RT_CONSTANT(opline, opline->op1)), C_STR_P(RT_CONSTANT(opline, opline->op1) + 1), CREX_FETCH_CLASS_DEFAULT | CREX_FETCH_CLASS_EXCEPTION);
			if (UNEXPECTED(ce == NULL)) {
				zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
				HANDLE_EXCEPTION();
			}
			if ((IS_TMP_VAR|IS_VAR) != IS_CONST) {
				CACHE_PTR(opline->result.num, ce);
			}
		}
	} else if (IS_CONST == IS_UNUSED) {
		ce = crex_fetch_class(NULL, opline->op1.num);
		if (UNEXPECTED(ce == NULL)) {
			zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
			HANDLE_EXCEPTION();
		}
	} else {
		ce = C_CE_P(EX_VAR(opline->op1.var));
	}

	if (IS_CONST == IS_CONST &&
	    (IS_TMP_VAR|IS_VAR) == IS_CONST &&
	    EXPECTED((fbc = CACHED_PTR(opline->result.num + sizeof(void*))) != NULL)) {
		/* nothing to do */
	} else if (IS_CONST != IS_CONST &&
	           (IS_TMP_VAR|IS_VAR) == IS_CONST &&
	           EXPECTED(CACHED_PTR(opline->result.num) == ce)) {
		fbc = CACHED_PTR(opline->result.num + sizeof(void*));
	} else if ((IS_TMP_VAR|IS_VAR) != IS_UNUSED) {
		function_name = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
		if ((IS_TMP_VAR|IS_VAR) != IS_CONST) {
			if (UNEXPECTED(C_TYPE_P(function_name) != IS_STRING)) {
				do {
					if ((IS_TMP_VAR|IS_VAR) & (IS_VAR|IS_CV) && C_ISREF_P(function_name)) {
						function_name = C_REFVAL_P(function_name);
						if (EXPECTED(C_TYPE_P(function_name) == IS_STRING)) {
							break;
						}
					} else if ((IS_TMP_VAR|IS_VAR) == IS_CV && UNEXPECTED(C_TYPE_P(function_name) == IS_UNDEF)) {
						ZVAL_UNDEFINED_OP2();
						if (UNEXPECTED(EG(exception) != NULL)) {
							HANDLE_EXCEPTION();
						}
					}
					crex_throw_error(NULL, "Method name must be a string");
					zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
					HANDLE_EXCEPTION();
				} while (0);
			}
		}

		if (ce->get_static_method) {
			fbc = ce->get_static_method(ce, C_STR_P(function_name));
		} else {
			fbc = crex_std_get_static_method(ce, C_STR_P(function_name), (((IS_TMP_VAR|IS_VAR) == IS_CONST) ? (RT_CONSTANT(opline, opline->op2) + 1) : NULL));
		}
		if (UNEXPECTED(fbc == NULL)) {
			if (EXPECTED(!EG(exception))) {
				crex_undefined_method(ce, C_STR_P(function_name));
			}
			zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
			HANDLE_EXCEPTION();
		}
		if ((IS_TMP_VAR|IS_VAR) == IS_CONST &&
		    EXPECTED(!(fbc->common.fn_flags & (CREX_ACC_CALL_VIA_TRAMPOLINE|CREX_ACC_NEVER_CACHE))) &&
			EXPECTED(!(fbc->common.scope->ce_flags & CREX_ACC_TRAIT))) {
			CACHE_POLYMORPHIC_PTR(opline->result.num, ce, fbc);
		}
		if (EXPECTED(fbc->type == CREX_USER_FUNCTION) && UNEXPECTED(!RUN_TIME_CACHE(&fbc->op_array))) {
			init_func_run_time_cache(&fbc->op_array);
		}
		if ((IS_TMP_VAR|IS_VAR) != IS_CONST) {
			zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
		}
	} else {
		if (UNEXPECTED(ce->constructor == NULL)) {
			crex_throw_error(NULL, "Cannot call constructor");
			HANDLE_EXCEPTION();
		}
		if (C_TYPE(EX(This)) == IS_OBJECT && C_OBJ(EX(This))->ce != ce->constructor->common.scope && (ce->constructor->common.fn_flags & CREX_ACC_PRIVATE)) {
			crex_throw_error(NULL, "Cannot call private %s::__main()", ZSTR_VAL(ce->name));
			HANDLE_EXCEPTION();
		}
		fbc = ce->constructor;
		if (EXPECTED(fbc->type == CREX_USER_FUNCTION) && UNEXPECTED(!RUN_TIME_CACHE(&fbc->op_array))) {
			init_func_run_time_cache(&fbc->op_array);
		}
	}

	if (!(fbc->common.fn_flags & CREX_ACC_STATIC)) {
		if (C_TYPE(EX(This)) == IS_OBJECT && instanceof_function(C_OBJCE(EX(This)), ce)) {
			ce = (crex_class_entry*)C_OBJ(EX(This));
			call_info = CREX_CALL_NESTED_FUNCTION | CREX_CALL_HAS_THIS;
		} else {
			crex_non_static_method_call(fbc);
			HANDLE_EXCEPTION();
		}
	} else {
		/* previous opcode is CREX_FETCH_CLASS */
		if (IS_CONST == IS_UNUSED
		 && ((opline->op1.num & CREX_FETCH_CLASS_MASK) == CREX_FETCH_CLASS_PARENT ||
		     (opline->op1.num & CREX_FETCH_CLASS_MASK) == CREX_FETCH_CLASS_SELF)) {
			if (C_TYPE(EX(This)) == IS_OBJECT) {
				ce = C_OBJCE(EX(This));
			} else {
				ce = C_CE(EX(This));
			}
		}
		call_info = CREX_CALL_NESTED_FUNCTION;
	}

	call = crex_vm_stack_push_call_frame(call_info,
		fbc, opline->extended_value, ce);
	call->prev_execute_data = EX(call);
	EX(call) = call;

	CREX_VM_NEXT_OPCODE();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_INIT_USER_CALL_SPEC_CONST_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *function_name;
	crex_fcall_info_cache fcc;
	char *error = NULL;
	crex_function *func;
	void *object_or_called_scope;
	crex_execute_data *call;
	uint32_t call_info = CREX_CALL_NESTED_FUNCTION | CREX_CALL_DYNAMIC;

	SAVE_OPLINE();
	function_name = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
	if (crex_is_callable_ex(function_name, NULL, 0, NULL, &fcc, &error)) {
		CREX_ASSERT(!error);
		func = fcc.function_handler;
		object_or_called_scope = fcc.called_scope;
		if (func->common.fn_flags & CREX_ACC_CLOSURE) {
			/* Delay closure destruction until its invocation */
			GC_ADDREF(CREX_CLOSURE_OBJECT(func));
			call_info |= CREX_CALL_CLOSURE;
			if (func->common.fn_flags & CREX_ACC_FAKE_CLOSURE) {
				call_info |= CREX_CALL_FAKE_CLOSURE;
			}
			if (fcc.object) {
				object_or_called_scope = fcc.object;
				call_info |= CREX_CALL_HAS_THIS;
			}
		} else if (fcc.object) {
			GC_ADDREF(fcc.object); /* For $this pointer */
			object_or_called_scope = fcc.object;
			call_info |= CREX_CALL_RELEASE_THIS | CREX_CALL_HAS_THIS;
		}

		zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
		if (((IS_TMP_VAR|IS_VAR) & (IS_TMP_VAR|IS_VAR)) && UNEXPECTED(EG(exception))) {
			if (call_info & CREX_CALL_CLOSURE) {
				crex_object_release(CREX_CLOSURE_OBJECT(func));
			} else if (call_info & CREX_CALL_RELEASE_THIS) {
				crex_object_release(fcc.object);
			}
			HANDLE_EXCEPTION();
		}

		if (EXPECTED(func->type == CREX_USER_FUNCTION) && UNEXPECTED(!RUN_TIME_CACHE(&func->op_array))) {
			init_func_run_time_cache(&func->op_array);
		}
	} else {
		crex_type_error("%s(): Argument #1 ($callback) must be a valid callback, %s", C_STRVAL_P(RT_CONSTANT(opline, opline->op1)), error);
		efree(error);
		zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
		HANDLE_EXCEPTION();
	}

	call = crex_vm_stack_push_call_frame(call_info,
		func, opline->extended_value, object_or_called_scope);
	call->prev_execute_data = EX(call);
	EX(call) = call;

	CREX_VM_NEXT_OPCODE();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ADD_ARRAY_ELEMENT_SPEC_CONST_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *expr_ptr, new_expr;

	SAVE_OPLINE();
	if ((IS_CONST == IS_VAR || IS_CONST == IS_CV) &&
	    UNEXPECTED(opline->extended_value & CREX_ARRAY_ELEMENT_REF)) {
		expr_ptr = crex_get_bad_ptr();
		if (C_ISREF_P(expr_ptr)) {
			C_ADDREF_P(expr_ptr);
		} else {
			ZVAL_MAKE_REF_EX(expr_ptr, 2);
		}

	} else {
		expr_ptr = RT_CONSTANT(opline, opline->op1);
		if (IS_CONST == IS_TMP_VAR) {
			/* pass */
		} else if (IS_CONST == IS_CONST) {
			C_TRY_ADDREF_P(expr_ptr);
		} else if (IS_CONST == IS_CV) {
			ZVAL_DEREF(expr_ptr);
			C_TRY_ADDREF_P(expr_ptr);
		} else /* if (IS_CONST == IS_VAR) */ {
			if (UNEXPECTED(C_ISREF_P(expr_ptr))) {
				crex_refcounted *ref = C_COUNTED_P(expr_ptr);

				expr_ptr = C_REFVAL_P(expr_ptr);
				if (UNEXPECTED(GC_DELREF(ref) == 0)) {
					ZVAL_COPY_VALUE(&new_expr, expr_ptr);
					expr_ptr = &new_expr;
					efree_size(ref, sizeof(crex_reference));
				} else if (C_OPT_REFCOUNTED_P(expr_ptr)) {
					C_ADDREF_P(expr_ptr);
				}
			}
		}
	}

	if ((IS_TMP_VAR|IS_VAR) != IS_UNUSED) {
		zval *offset = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
		crex_string *str;
		crex_ulong hval;

add_again:
		if (EXPECTED(C_TYPE_P(offset) == IS_STRING)) {
			str = C_STR_P(offset);
			if ((IS_TMP_VAR|IS_VAR) != IS_CONST) {
				if (CREX_HANDLE_NUMERIC(str, hval)) {
					goto num_index;
				}
			}
str_index:
			crex_hash_update(C_ARRVAL_P(EX_VAR(opline->result.var)), str, expr_ptr);
		} else if (EXPECTED(C_TYPE_P(offset) == IS_LONG)) {
			hval = C_LVAL_P(offset);
num_index:
			crex_hash_index_update(C_ARRVAL_P(EX_VAR(opline->result.var)), hval, expr_ptr);
		} else if (((IS_TMP_VAR|IS_VAR) & (IS_VAR|IS_CV)) && EXPECTED(C_TYPE_P(offset) == IS_REFERENCE)) {
			offset = C_REFVAL_P(offset);
			goto add_again;
		} else if (C_TYPE_P(offset) == IS_NULL) {
			str = ZSTR_EMPTY_ALLOC();
			goto str_index;
		} else if (C_TYPE_P(offset) == IS_DOUBLE) {
			hval = crex_dval_to_lval_safe(C_DVAL_P(offset));
			goto num_index;
		} else if (C_TYPE_P(offset) == IS_FALSE) {
			hval = 0;
			goto num_index;
		} else if (C_TYPE_P(offset) == IS_TRUE) {
			hval = 1;
			goto num_index;
		} else if (C_TYPE_P(offset) == IS_RESOURCE) {
			crex_use_resource_as_offset(offset);
			hval = C_RES_HANDLE_P(offset);
			goto num_index;
		} else if ((IS_TMP_VAR|IS_VAR) == IS_CV && C_TYPE_P(offset) == IS_UNDEF) {
			ZVAL_UNDEFINED_OP2();
			str = ZSTR_EMPTY_ALLOC();
			goto str_index;
		} else {
			crex_illegal_array_offset_access(offset);
			zval_ptr_dtor_nogc(expr_ptr);
		}
		zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
	} else {
		if (!crex_hash_next_index_insert(C_ARRVAL_P(EX_VAR(opline->result.var)), expr_ptr)) {
			crex_cannot_add_element();
			zval_ptr_dtor_nogc(expr_ptr);
		}
	}
	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_INIT_ARRAY_SPEC_CONST_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	zval *array;
	uint32_t size;
	USE_OPLINE

	array = EX_VAR(opline->result.var);
	if (IS_CONST != IS_UNUSED) {
		size = opline->extended_value >> CREX_ARRAY_SIZE_SHIFT;
		ZVAL_ARR(array, crex_new_array(size));
		/* Explicitly initialize array as not-packed if flag is set */
		if (opline->extended_value & CREX_ARRAY_NOT_PACKED) {
			crex_hash_real_init_mixed(C_ARRVAL_P(array));
		}
		CREX_VM_TAIL_CALL(CREX_ADD_ARRAY_ELEMENT_SPEC_CONST_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU));
	} else {
		ZVAL_ARR(array, crex_new_array(0));
		CREX_VM_NEXT_OPCODE();
	}
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ISSET_ISEMPTY_DIM_OBJ_SPEC_CONST_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;
	bool result;
	crex_ulong hval;
	zval *offset;

	SAVE_OPLINE();
	container = RT_CONSTANT(opline, opline->op1);
	offset = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);

	if (EXPECTED(C_TYPE_P(container) == IS_ARRAY)) {
		HashTable *ht;
		zval *value;
		crex_string *str;

isset_dim_obj_array:
		ht = C_ARRVAL_P(container);
isset_again:
		if (EXPECTED(C_TYPE_P(offset) == IS_STRING)) {
			str = C_STR_P(offset);
			if ((IS_TMP_VAR|IS_VAR) != IS_CONST) {
				if (CREX_HANDLE_NUMERIC(str, hval)) {
					goto num_index_prop;
				}
			}
			value = crex_hash_find_ex(ht, str, (IS_TMP_VAR|IS_VAR) == IS_CONST);
		} else if (EXPECTED(C_TYPE_P(offset) == IS_LONG)) {
			hval = C_LVAL_P(offset);
num_index_prop:
			value = crex_hash_index_find(ht, hval);
		} else if (((IS_TMP_VAR|IS_VAR) & (IS_VAR|IS_CV)) && EXPECTED(C_ISREF_P(offset))) {
			offset = C_REFVAL_P(offset);
			goto isset_again;
		} else {
			value = crex_find_array_dim_slow(ht, offset EXECUTE_DATA_CC);
			if (UNEXPECTED(EG(exception))) {
				result = 0;
				goto isset_dim_obj_exit;
			}
		}

		if (!(opline->extended_value & CREX_ISEMPTY)) {
			/* > IS_NULL means not IS_UNDEF and not IS_NULL */
			result = value != NULL && C_TYPE_P(value) > IS_NULL &&
			    (!C_ISREF_P(value) || C_TYPE_P(C_REFVAL_P(value)) != IS_NULL);

			if (IS_CONST & (IS_CONST|IS_CV)) {
				/* avoid exception check */
				zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
				CREX_VM_SMART_BRANCH(result, 0);
			}
		} else {
			result = (value == NULL || !i_crex_is_true(value));
		}
		goto isset_dim_obj_exit;
	} else if ((IS_CONST & (IS_VAR|IS_CV)) && EXPECTED(C_ISREF_P(container))) {
		container = C_REFVAL_P(container);
		if (EXPECTED(C_TYPE_P(container) == IS_ARRAY)) {
			goto isset_dim_obj_array;
		}
	}

	if ((IS_TMP_VAR|IS_VAR) == IS_CONST && C_EXTRA_P(offset) == CREX_EXTRA_VALUE) {
		offset++;
	}
	if (!(opline->extended_value & CREX_ISEMPTY)) {
		result = crex_isset_dim_slow(container, offset EXECUTE_DATA_CC);
	} else {
		result = crex_isempty_dim_slow(container, offset EXECUTE_DATA_CC);
	}

isset_dim_obj_exit:
	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));

	CREX_VM_SMART_BRANCH(result, 1);
}

static CREX_VM_COLD CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ISSET_ISEMPTY_PROP_OBJ_SPEC_CONST_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;
	int result;
	zval *offset;
	crex_string *name, *tmp_name;

	SAVE_OPLINE();
	container = RT_CONSTANT(opline, opline->op1);
	offset = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);

	if (IS_CONST == IS_CONST ||
	    (IS_CONST != IS_UNUSED && UNEXPECTED(C_TYPE_P(container) != IS_OBJECT))) {
		if ((IS_CONST & (IS_VAR|IS_CV)) && C_ISREF_P(container)) {
			container = C_REFVAL_P(container);
			if (UNEXPECTED(C_TYPE_P(container) != IS_OBJECT)) {
				result = (opline->extended_value & CREX_ISEMPTY);
				goto isset_object_finish;
			}
		} else {
			result = (opline->extended_value & CREX_ISEMPTY);
			goto isset_object_finish;
		}
	}

	if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
		name = C_STR_P(offset);
	} else {
		name = zval_try_get_tmp_string(offset, &tmp_name);
		if (UNEXPECTED(!name)) {
			result = 0;
			goto isset_object_finish;
		}
	}

	result =
		(opline->extended_value & CREX_ISEMPTY) ^
		C_OBJ_HT_P(container)->has_property(C_OBJ_P(container), name, (opline->extended_value & CREX_ISEMPTY), (((IS_TMP_VAR|IS_VAR) == IS_CONST) ? CACHE_ADDR(opline->extended_value & ~CREX_ISEMPTY) : NULL));

	if ((IS_TMP_VAR|IS_VAR) != IS_CONST) {
		crex_tmp_string_release(tmp_name);
	}

isset_object_finish:
	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));

	CREX_VM_SMART_BRANCH(result, 1);
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ARRAY_KEY_EXISTS_SPEC_CONST_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *key, *subject;
	HashTable *ht;
	bool result;

	SAVE_OPLINE();

	key = RT_CONSTANT(opline, opline->op1);
	subject = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);

	if (EXPECTED(C_TYPE_P(subject) == IS_ARRAY)) {
array_key_exists_array:
		ht = C_ARRVAL_P(subject);
		result = crex_array_key_exists_fast(ht, key OPLINE_CC EXECUTE_DATA_CC);
	} else {
		if (((IS_TMP_VAR|IS_VAR) & (IS_VAR|IS_CV)) && EXPECTED(C_ISREF_P(subject))) {
			subject = C_REFVAL_P(subject);
			if (EXPECTED(C_TYPE_P(subject) == IS_ARRAY)) {
				goto array_key_exists_array;
			}
		}
		crex_array_key_exists_error(subject, key OPLINE_CC EXECUTE_DATA_CC);
		result = 0;
	}

	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));

	CREX_VM_SMART_BRANCH(result, 1);
}

/* No specialization for op_types (CONST|TMPVAR|UNUSED|CV, ANY) */
static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_YIELD_SPEC_CONST_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	crex_generator *generator = crex_get_running_generator(EXECUTE_DATA_C);

	SAVE_OPLINE();
	if (UNEXPECTED(generator->flags & CREX_GENERATOR_FORCED_CLOSE)) {
		CREX_VM_TAIL_CALL(crex_yield_in_closed_generator_helper_SPEC(CREX_OPCODE_HANDLER_ARGS_PASSTHRU));
	}

	/* Destroy the previously yielded value */
	zval_ptr_dtor(&generator->value);

	/* Destroy the previously yielded key */
	zval_ptr_dtor(&generator->key);

	/* Set the new yielded value */
	if (IS_CONST != IS_UNUSED) {
		if (UNEXPECTED(EX(func)->op_array.fn_flags & CREX_ACC_RETURN_REFERENCE)) {
			/* Constants and temporary variables aren't yieldable by reference,
			 * but we still allow them with a notice. */
			if (IS_CONST & (IS_CONST|IS_TMP_VAR)) {
				zval *value;

				crex_error(E_NOTICE, "Only variable references should be yielded by reference");

				value = RT_CONSTANT(opline, opline->op1);
				ZVAL_COPY_VALUE(&generator->value, value);
				if (IS_CONST == IS_CONST) {
					if (UNEXPECTED(C_OPT_REFCOUNTED(generator->value))) {
						C_ADDREF(generator->value);
					}
				}
			} else {
				zval *value_ptr = crex_get_bad_ptr();

				/* If a function call result is yielded and the function did
				 * not return by reference we throw a notice. */
				do {
					if (IS_CONST == IS_VAR) {
						CREX_ASSERT(value_ptr != &EG(uninitialized_zval));
						if (opline->extended_value == CREX_RETURNS_FUNCTION
						 && !C_ISREF_P(value_ptr)) {
							crex_error(E_NOTICE, "Only variable references should be yielded by reference");
							ZVAL_COPY(&generator->value, value_ptr);
							break;
						}
					}
					if (C_ISREF_P(value_ptr)) {
						C_ADDREF_P(value_ptr);
					} else {
						ZVAL_MAKE_REF_EX(value_ptr, 2);
					}
					ZVAL_REF(&generator->value, C_REF_P(value_ptr));
				} while (0);

			}
		} else {
			zval *value = RT_CONSTANT(opline, opline->op1);

			/* Consts, temporary variables and references need copying */
			if (IS_CONST == IS_CONST) {
				ZVAL_COPY_VALUE(&generator->value, value);
				if (UNEXPECTED(C_OPT_REFCOUNTED(generator->value))) {
					C_ADDREF(generator->value);
				}
			} else if (IS_CONST == IS_TMP_VAR) {
				ZVAL_COPY_VALUE(&generator->value, value);
			} else if ((IS_CONST & (IS_VAR|IS_CV)) && C_ISREF_P(value)) {
				ZVAL_COPY(&generator->value, C_REFVAL_P(value));

			} else {
				ZVAL_COPY_VALUE(&generator->value, value);
				if (IS_CONST == IS_CV) {
					if (C_OPT_REFCOUNTED_P(value)) C_ADDREF_P(value);
				}
			}
		}
	} else {
		/* If no value was specified yield null */
		ZVAL_NULL(&generator->value);
	}

	/* Set the new yielded key */
	if ((IS_TMP_VAR|IS_VAR) != IS_UNUSED) {
		zval *key = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
		if (((IS_TMP_VAR|IS_VAR) & (IS_CV|IS_VAR)) && UNEXPECTED(C_TYPE_P(key) == IS_REFERENCE)) {
			key = C_REFVAL_P(key);
		}
		ZVAL_COPY(&generator->key, key);
		zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));

		if (C_TYPE(generator->key) == IS_LONG
		    && C_LVAL(generator->key) > generator->largest_used_integer_key
		) {
			generator->largest_used_integer_key = C_LVAL(generator->key);
		}
	} else {
		/* If no key was specified we use auto-increment keys */
		generator->largest_used_integer_key++;
		ZVAL_LONG(&generator->key, generator->largest_used_integer_key);
	}

	if (RETURN_VALUE_USED(opline)) {
		/* If the return value of yield is used set the send
		 * target and initialize it to NULL */
		generator->send_target = EX_VAR(opline->result.var);
		ZVAL_NULL(generator->send_target);
	} else {
		generator->send_target = NULL;
	}

	/* We increment to the next op, so we are at the correct position when the
	 * generator is resumed. */
	CREX_VM_INC_OPCODE();

	/* The GOTO VM uses a local opline variable. We need to set the opline
	 * variable in execute_data so we don't resume at an old position. */
	SAVE_OPLINE();

	CREX_VM_RETURN();
}

static crex_never_inline CREX_OPCODE_HANDLER_RET CREX_FASTCALL crex_fetch_var_address_helper_SPEC_CONST_UNUSED(int type CREX_OPCODE_HANDLER_ARGS_DC)
{
	USE_OPLINE
	zval *varname;
	zval *retval;
	crex_string *name, *tmp_name;
	HashTable *target_symbol_table;

	SAVE_OPLINE();
	varname = RT_CONSTANT(opline, opline->op1);

	if (IS_CONST == IS_CONST) {
		name = C_STR_P(varname);
	} else if (EXPECTED(C_TYPE_P(varname) == IS_STRING)) {
		name = C_STR_P(varname);
		tmp_name = NULL;
	} else {
		if (IS_CONST == IS_CV && UNEXPECTED(C_TYPE_P(varname) == IS_UNDEF)) {
			ZVAL_UNDEFINED_OP1();
		}
		name = zval_try_get_tmp_string(varname, &tmp_name);
		if (UNEXPECTED(!name)) {
			if (!(opline->extended_value & CREX_FETCH_GLOBAL_LOCK)) {

			}
			ZVAL_UNDEF(EX_VAR(opline->result.var));
			HANDLE_EXCEPTION();
		}
	}

	target_symbol_table = crex_get_target_symbol_table(opline->extended_value EXECUTE_DATA_CC);
	retval = crex_hash_find_ex(target_symbol_table, name, IS_CONST == IS_CONST);
	if (retval == NULL) {
		if (UNEXPECTED(crex_string_equals(name, ZSTR_KNOWN(CREX_STR_THIS)))) {
fetch_this:
			crex_fetch_this_var(type OPLINE_CC EXECUTE_DATA_CC);
			if (IS_CONST != IS_CONST) {
				crex_tmp_string_release(tmp_name);
			}
			CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
		}
		if (type == BP_VAR_W) {
			retval = crex_hash_add_new(target_symbol_table, name, &EG(uninitialized_zval));
		} else if (type == BP_VAR_IS || type == BP_VAR_UNSET) {
			retval = &EG(uninitialized_zval);
		} else {
			if (IS_CONST == IS_CV) {
				/* Keep name alive in case an error handler tries to free it. */
				crex_string_addref(name);
			}
			crex_error(E_WARNING, "Undefined %svariable $%s",
				(opline->extended_value & CREX_FETCH_GLOBAL ? "global " : ""), ZSTR_VAL(name));
			if (type == BP_VAR_RW && !EG(exception)) {
				retval = crex_hash_update(target_symbol_table, name, &EG(uninitialized_zval));
			} else {
				retval = &EG(uninitialized_zval);
			}
			if (IS_CONST == IS_CV) {
				crex_string_release(name);
			}
		}
	/* GLOBAL or $$name variable may be an INDIRECT pointer to CV */
	} else if (C_TYPE_P(retval) == IS_INDIRECT) {
		retval = C_INDIRECT_P(retval);
		if (C_TYPE_P(retval) == IS_UNDEF) {
			if (UNEXPECTED(crex_string_equals(name, ZSTR_KNOWN(CREX_STR_THIS)))) {
				goto fetch_this;
			}
			if (type == BP_VAR_W) {
				ZVAL_NULL(retval);
			} else if (type == BP_VAR_IS || type == BP_VAR_UNSET) {
				retval = &EG(uninitialized_zval);
			} else {
				crex_error(E_WARNING, "Undefined %svariable $%s",
					(opline->extended_value & CREX_FETCH_GLOBAL ? "global " : ""), ZSTR_VAL(name));
				if (type == BP_VAR_RW && !EG(exception)) {
					ZVAL_NULL(retval);
				} else {
					retval = &EG(uninitialized_zval);
				}
			}
		}
	}

	if (!(opline->extended_value & CREX_FETCH_GLOBAL_LOCK)) {

	}

	if (IS_CONST != IS_CONST) {
		crex_tmp_string_release(tmp_name);
	}

	CREX_ASSERT(retval != NULL);
	if (type == BP_VAR_R || type == BP_VAR_IS) {
		ZVAL_COPY_DEREF(EX_VAR(opline->result.var), retval);
	} else {
		ZVAL_INDIRECT(EX_VAR(opline->result.var), retval);
	}
	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FETCH_R_SPEC_CONST_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	CREX_VM_TAIL_CALL(crex_fetch_var_address_helper_SPEC_CONST_UNUSED(BP_VAR_R CREX_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FETCH_W_SPEC_CONST_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	CREX_VM_TAIL_CALL(crex_fetch_var_address_helper_SPEC_CONST_UNUSED(BP_VAR_W CREX_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FETCH_RW_SPEC_CONST_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	CREX_VM_TAIL_CALL(crex_fetch_var_address_helper_SPEC_CONST_UNUSED(BP_VAR_RW CREX_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FETCH_FUNC_ARG_SPEC_CONST_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	int fetch_type =
		(UNEXPECTED(CREX_CALL_INFO(EX(call)) & CREX_CALL_SEND_ARG_BY_REF)) ?
			BP_VAR_W : BP_VAR_R;
	CREX_VM_TAIL_CALL(crex_fetch_var_address_helper_SPEC_CONST_UNUSED(fetch_type CREX_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FETCH_UNSET_SPEC_CONST_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	CREX_VM_TAIL_CALL(crex_fetch_var_address_helper_SPEC_CONST_UNUSED(BP_VAR_UNSET CREX_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FETCH_IS_SPEC_CONST_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	CREX_VM_TAIL_CALL(crex_fetch_var_address_helper_SPEC_CONST_UNUSED(BP_VAR_IS CREX_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

/* No specialization for op_types (CONST|TMPVAR|CV, UNUSED|CONST|VAR) */
static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FETCH_DIM_FUNC_ARG_SPEC_CONST_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
#if 0
	USE_OPLINE
#endif

	if (UNEXPECTED(CREX_CALL_INFO(EX(call)) & CREX_CALL_SEND_ARG_BY_REF)) {
		if ((IS_CONST & (IS_CONST|IS_TMP_VAR))) {
			CREX_VM_TAIL_CALL(crex_use_tmp_in_write_context_helper_SPEC(CREX_OPCODE_HANDLER_ARGS_PASSTHRU));
		}
		CREX_VM_TAIL_CALL(CREX_NULL_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU));
	} else {
		if (IS_UNUSED == IS_UNUSED) {
			CREX_VM_TAIL_CALL(crex_use_undef_in_read_context_helper_SPEC(CREX_OPCODE_HANDLER_ARGS_PASSTHRU));
		}
		CREX_VM_TAIL_CALL(CREX_NULL_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU));
	}
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_INIT_STATIC_METHOD_CALL_SPEC_CONST_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *function_name;
	crex_class_entry *ce;
	uint32_t call_info;
	crex_function *fbc;
	crex_execute_data *call;

	SAVE_OPLINE();

	if (IS_CONST == IS_CONST) {
		/* no function found. try a static method in class */
		ce = CACHED_PTR(opline->result.num);
		if (UNEXPECTED(ce == NULL)) {
			ce = crex_fetch_class_by_name(C_STR_P(RT_CONSTANT(opline, opline->op1)), C_STR_P(RT_CONSTANT(opline, opline->op1) + 1), CREX_FETCH_CLASS_DEFAULT | CREX_FETCH_CLASS_EXCEPTION);
			if (UNEXPECTED(ce == NULL)) {

				HANDLE_EXCEPTION();
			}
			if (IS_UNUSED != IS_CONST) {
				CACHE_PTR(opline->result.num, ce);
			}
		}
	} else if (IS_CONST == IS_UNUSED) {
		ce = crex_fetch_class(NULL, opline->op1.num);
		if (UNEXPECTED(ce == NULL)) {

			HANDLE_EXCEPTION();
		}
	} else {
		ce = C_CE_P(EX_VAR(opline->op1.var));
	}

	if (IS_CONST == IS_CONST &&
	    IS_UNUSED == IS_CONST &&
	    EXPECTED((fbc = CACHED_PTR(opline->result.num + sizeof(void*))) != NULL)) {
		/* nothing to do */
	} else if (IS_CONST != IS_CONST &&
	           IS_UNUSED == IS_CONST &&
	           EXPECTED(CACHED_PTR(opline->result.num) == ce)) {
		fbc = CACHED_PTR(opline->result.num + sizeof(void*));
	} else if (IS_UNUSED != IS_UNUSED) {
		function_name = NULL;
		if (IS_UNUSED != IS_CONST) {
			if (UNEXPECTED(C_TYPE_P(function_name) != IS_STRING)) {
				do {
					if (IS_UNUSED & (IS_VAR|IS_CV) && C_ISREF_P(function_name)) {
						function_name = C_REFVAL_P(function_name);
						if (EXPECTED(C_TYPE_P(function_name) == IS_STRING)) {
							break;
						}
					} else if (IS_UNUSED == IS_CV && UNEXPECTED(C_TYPE_P(function_name) == IS_UNDEF)) {
						ZVAL_UNDEFINED_OP2();
						if (UNEXPECTED(EG(exception) != NULL)) {
							HANDLE_EXCEPTION();
						}
					}
					crex_throw_error(NULL, "Method name must be a string");

					HANDLE_EXCEPTION();
				} while (0);
			}
		}

		if (ce->get_static_method) {
			fbc = ce->get_static_method(ce, C_STR_P(function_name));
		} else {
			fbc = crex_std_get_static_method(ce, C_STR_P(function_name), ((IS_UNUSED == IS_CONST) ? (RT_CONSTANT(opline, opline->op2) + 1) : NULL));
		}
		if (UNEXPECTED(fbc == NULL)) {
			if (EXPECTED(!EG(exception))) {
				crex_undefined_method(ce, C_STR_P(function_name));
			}

			HANDLE_EXCEPTION();
		}
		if (IS_UNUSED == IS_CONST &&
		    EXPECTED(!(fbc->common.fn_flags & (CREX_ACC_CALL_VIA_TRAMPOLINE|CREX_ACC_NEVER_CACHE))) &&
			EXPECTED(!(fbc->common.scope->ce_flags & CREX_ACC_TRAIT))) {
			CACHE_POLYMORPHIC_PTR(opline->result.num, ce, fbc);
		}
		if (EXPECTED(fbc->type == CREX_USER_FUNCTION) && UNEXPECTED(!RUN_TIME_CACHE(&fbc->op_array))) {
			init_func_run_time_cache(&fbc->op_array);
		}
		if (IS_UNUSED != IS_CONST) {

		}
	} else {
		if (UNEXPECTED(ce->constructor == NULL)) {
			crex_throw_error(NULL, "Cannot call constructor");
			HANDLE_EXCEPTION();
		}
		if (C_TYPE(EX(This)) == IS_OBJECT && C_OBJ(EX(This))->ce != ce->constructor->common.scope && (ce->constructor->common.fn_flags & CREX_ACC_PRIVATE)) {
			crex_throw_error(NULL, "Cannot call private %s::__main()", ZSTR_VAL(ce->name));
			HANDLE_EXCEPTION();
		}
		fbc = ce->constructor;
		if (EXPECTED(fbc->type == CREX_USER_FUNCTION) && UNEXPECTED(!RUN_TIME_CACHE(&fbc->op_array))) {
			init_func_run_time_cache(&fbc->op_array);
		}
	}

	if (!(fbc->common.fn_flags & CREX_ACC_STATIC)) {
		if (C_TYPE(EX(This)) == IS_OBJECT && instanceof_function(C_OBJCE(EX(This)), ce)) {
			ce = (crex_class_entry*)C_OBJ(EX(This));
			call_info = CREX_CALL_NESTED_FUNCTION | CREX_CALL_HAS_THIS;
		} else {
			crex_non_static_method_call(fbc);
			HANDLE_EXCEPTION();
		}
	} else {
		/* previous opcode is CREX_FETCH_CLASS */
		if (IS_CONST == IS_UNUSED
		 && ((opline->op1.num & CREX_FETCH_CLASS_MASK) == CREX_FETCH_CLASS_PARENT ||
		     (opline->op1.num & CREX_FETCH_CLASS_MASK) == CREX_FETCH_CLASS_SELF)) {
			if (C_TYPE(EX(This)) == IS_OBJECT) {
				ce = C_OBJCE(EX(This));
			} else {
				ce = C_CE(EX(This));
			}
		}
		call_info = CREX_CALL_NESTED_FUNCTION;
	}

	call = crex_vm_stack_push_call_frame(call_info,
		fbc, opline->extended_value, ce);
	call->prev_execute_data = EX(call);
	EX(call) = call;

	CREX_VM_NEXT_OPCODE();
}

static CREX_VM_COLD CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_VERIFY_RETURN_TYPE_SPEC_CONST_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	if (IS_CONST == IS_UNUSED) {
		SAVE_OPLINE();
		crex_verify_missing_return_type(EX(func));
		HANDLE_EXCEPTION();
	} else {
/* prevents "undefined variable opline" errors */
#if 0 || (IS_CONST != IS_UNUSED)
		USE_OPLINE
		zval *retval_ref, *retval_ptr;
		crex_arg_info *ret_info = EX(func)->common.arg_info - 1;
		retval_ref = retval_ptr = RT_CONSTANT(opline, opline->op1);

		if (IS_CONST == IS_CONST) {
			ZVAL_COPY(EX_VAR(opline->result.var), retval_ptr);
			retval_ref = retval_ptr = EX_VAR(opline->result.var);
		} else if (IS_CONST == IS_VAR) {
			if (UNEXPECTED(C_TYPE_P(retval_ptr) == IS_INDIRECT)) {
				retval_ref = retval_ptr = C_INDIRECT_P(retval_ptr);
			}
			ZVAL_DEREF(retval_ptr);
		} else if (IS_CONST == IS_CV) {
			ZVAL_DEREF(retval_ptr);
		}

		if (EXPECTED(CREX_TYPE_CONTAINS_CODE(ret_info->type, C_TYPE_P(retval_ptr)))) {
			CREX_VM_NEXT_OPCODE();
		}

		if (IS_CONST == IS_CV && UNEXPECTED(C_ISUNDEF_P(retval_ptr))) {
			SAVE_OPLINE();
			retval_ref = retval_ptr = ZVAL_UNDEFINED_OP1();
			if (UNEXPECTED(EG(exception))) {
				HANDLE_EXCEPTION();
			}
			if (CREX_TYPE_FULL_MASK(ret_info->type) & MAY_BE_NULL) {
				CREX_VM_NEXT_OPCODE();
			}
		}

		crex_reference *ref = NULL;
		void *cache_slot = CACHE_ADDR(opline->op2.num);
		if (UNEXPECTED(retval_ref != retval_ptr)) {
			if (UNEXPECTED(EX(func)->op_array.fn_flags & CREX_ACC_RETURN_REFERENCE)) {
				ref = C_REF_P(retval_ref);
			} else {
				/* A cast might happen - unwrap the reference if this is a by-value return */
				if (C_REFCOUNT_P(retval_ref) == 1) {
					ZVAL_UNREF(retval_ref);
				} else {
					C_DELREF_P(retval_ref);
					ZVAL_COPY(retval_ref, retval_ptr);
				}
				retval_ptr = retval_ref;
			}
		}

		SAVE_OPLINE();
		if (UNEXPECTED(!crex_check_type_slow(&ret_info->type, retval_ptr, ref, cache_slot, 1, 0))) {
			crex_verify_return_error(EX(func), retval_ptr);
			HANDLE_EXCEPTION();
		}
		CREX_VM_NEXT_OPCODE();
#endif
	}
}

static CREX_VM_HOT CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_SEND_VAL_SPEC_CONST_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *value, *arg;

	if (IS_UNUSED == IS_CONST) {
		SAVE_OPLINE();
		crex_string *arg_name = C_STR_P(RT_CONSTANT(opline, opline->op2));
		uint32_t arg_num;
		arg = crex_handle_named_arg(&EX(call), arg_name, &arg_num, CACHE_ADDR(opline->result.num));
		if (UNEXPECTED(!arg)) {

			HANDLE_EXCEPTION();
		}
	} else {
		arg = CREX_CALL_VAR(EX(call), opline->result.var);
	}

	value = RT_CONSTANT(opline, opline->op1);
	ZVAL_COPY_VALUE(arg, value);
	if (IS_CONST == IS_CONST) {
		if (UNEXPECTED(C_OPT_REFCOUNTED_P(arg))) {
			C_ADDREF_P(arg);
		}
	}
	CREX_VM_NEXT_OPCODE();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_SEND_VAL_EX_SPEC_CONST_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *value, *arg;
	uint32_t arg_num;

	if (IS_UNUSED == IS_CONST) {
		SAVE_OPLINE();
		crex_string *arg_name = C_STR_P(RT_CONSTANT(opline, opline->op2));
		arg = crex_handle_named_arg(&EX(call), arg_name, &arg_num, CACHE_ADDR(opline->result.num));
		if (UNEXPECTED(!arg)) {

			HANDLE_EXCEPTION();
		}
	} else {
		arg = CREX_CALL_VAR(EX(call), opline->result.var);
		arg_num = opline->op2.num;
	}

	if (EXPECTED(0)) {
		if (QUICK_ARG_MUST_BE_SENT_BY_REF(EX(call)->func, arg_num)) {
			goto send_val_by_ref;
		}
	} else if (ARG_MUST_BE_SENT_BY_REF(EX(call)->func, arg_num)) {
send_val_by_ref:
		CREX_VM_TAIL_CALL(crex_cannot_pass_by_ref_helper_SPEC(arg_num, arg CREX_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
	}
	value = RT_CONSTANT(opline, opline->op1);
	ZVAL_COPY_VALUE(arg, value);
	if (IS_CONST == IS_CONST) {
		if (UNEXPECTED(C_OPT_REFCOUNTED_P(arg))) {
			C_ADDREF_P(arg);
		}
	}
	CREX_VM_NEXT_OPCODE();
}

static CREX_VM_HOT CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_SEND_VAL_EX_SPEC_CONST_UNUSED_QUICK_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *value, *arg;
	uint32_t arg_num;

	if (IS_UNUSED == IS_CONST) {
		SAVE_OPLINE();
		crex_string *arg_name = C_STR_P(RT_CONSTANT(opline, opline->op2));
		arg = crex_handle_named_arg(&EX(call), arg_name, &arg_num, CACHE_ADDR(opline->result.num));
		if (UNEXPECTED(!arg)) {

			HANDLE_EXCEPTION();
		}
	} else {
		arg = CREX_CALL_VAR(EX(call), opline->result.var);
		arg_num = opline->op2.num;
	}

	if (EXPECTED(1)) {
		if (QUICK_ARG_MUST_BE_SENT_BY_REF(EX(call)->func, arg_num)) {
			goto send_val_by_ref;
		}
	} else if (ARG_MUST_BE_SENT_BY_REF(EX(call)->func, arg_num)) {
send_val_by_ref:
		CREX_VM_TAIL_CALL(crex_cannot_pass_by_ref_helper_SPEC(arg_num, arg CREX_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
	}
	value = RT_CONSTANT(opline, opline->op1);
	ZVAL_COPY_VALUE(arg, value);
	if (IS_CONST == IS_CONST) {
		if (UNEXPECTED(C_OPT_REFCOUNTED_P(arg))) {
			C_ADDREF_P(arg);
		}
	}
	CREX_VM_NEXT_OPCODE();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_NEW_SPEC_CONST_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *result;
	crex_function *constructor;
	crex_class_entry *ce;
	crex_execute_data *call;

	SAVE_OPLINE();
	if (IS_CONST == IS_CONST) {
		ce = CACHED_PTR(opline->op2.num);
		if (UNEXPECTED(ce == NULL)) {
			ce = crex_fetch_class_by_name(C_STR_P(RT_CONSTANT(opline, opline->op1)), C_STR_P(RT_CONSTANT(opline, opline->op1) + 1), CREX_FETCH_CLASS_DEFAULT | CREX_FETCH_CLASS_EXCEPTION);
			if (UNEXPECTED(ce == NULL)) {
				ZVAL_UNDEF(EX_VAR(opline->result.var));
				HANDLE_EXCEPTION();
			}
			CACHE_PTR(opline->op2.num, ce);
		}
	} else if (IS_CONST == IS_UNUSED) {
		ce = crex_fetch_class(NULL, opline->op1.num);
		if (UNEXPECTED(ce == NULL)) {
			ZVAL_UNDEF(EX_VAR(opline->result.var));
			HANDLE_EXCEPTION();
		}
	} else {
		ce = C_CE_P(EX_VAR(opline->op1.var));
	}

	result = EX_VAR(opline->result.var);
	if (UNEXPECTED(object_init_ex(result, ce) != SUCCESS)) {
		ZVAL_UNDEF(result);
		HANDLE_EXCEPTION();
	}

	constructor = C_OBJ_HT_P(result)->get_constructor(C_OBJ_P(result));
	if (constructor == NULL) {
		if (UNEXPECTED(EG(exception))) {
			HANDLE_EXCEPTION();
		}

		/* If there are no arguments, skip over the DO_FCALL opcode. We check if the next
		 * opcode is DO_FCALL in case EXT instructions are used. */
		if (EXPECTED(opline->extended_value == 0 && (opline+1)->opcode == CREX_DO_FCALL)) {
			CREX_VM_NEXT_OPCODE_EX(1, 2);
		}

		/* Perform a dummy function call */
		call = crex_vm_stack_push_call_frame(
			CREX_CALL_FUNCTION, (crex_function *) &crex_pass_function,
			opline->extended_value, NULL);
	} else {
		if (EXPECTED(constructor->type == CREX_USER_FUNCTION) && UNEXPECTED(!RUN_TIME_CACHE(&constructor->op_array))) {
			init_func_run_time_cache(&constructor->op_array);
		}
		/* We are not handling overloaded classes right now */
		call = crex_vm_stack_push_call_frame(
			CREX_CALL_FUNCTION | CREX_CALL_RELEASE_THIS | CREX_CALL_HAS_THIS,
			constructor,
			opline->extended_value,
			C_OBJ_P(result));
		C_ADDREF_P(result);
	}

	call->prev_execute_data = EX(call);
	EX(call) = call;
	CREX_VM_NEXT_OPCODE();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ADD_ARRAY_ELEMENT_SPEC_CONST_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *expr_ptr, new_expr;

	SAVE_OPLINE();
	if ((IS_CONST == IS_VAR || IS_CONST == IS_CV) &&
	    UNEXPECTED(opline->extended_value & CREX_ARRAY_ELEMENT_REF)) {
		expr_ptr = crex_get_bad_ptr();
		if (C_ISREF_P(expr_ptr)) {
			C_ADDREF_P(expr_ptr);
		} else {
			ZVAL_MAKE_REF_EX(expr_ptr, 2);
		}

	} else {
		expr_ptr = RT_CONSTANT(opline, opline->op1);
		if (IS_CONST == IS_TMP_VAR) {
			/* pass */
		} else if (IS_CONST == IS_CONST) {
			C_TRY_ADDREF_P(expr_ptr);
		} else if (IS_CONST == IS_CV) {
			ZVAL_DEREF(expr_ptr);
			C_TRY_ADDREF_P(expr_ptr);
		} else /* if (IS_CONST == IS_VAR) */ {
			if (UNEXPECTED(C_ISREF_P(expr_ptr))) {
				crex_refcounted *ref = C_COUNTED_P(expr_ptr);

				expr_ptr = C_REFVAL_P(expr_ptr);
				if (UNEXPECTED(GC_DELREF(ref) == 0)) {
					ZVAL_COPY_VALUE(&new_expr, expr_ptr);
					expr_ptr = &new_expr;
					efree_size(ref, sizeof(crex_reference));
				} else if (C_OPT_REFCOUNTED_P(expr_ptr)) {
					C_ADDREF_P(expr_ptr);
				}
			}
		}
	}

	if (IS_UNUSED != IS_UNUSED) {
		zval *offset = NULL;
		crex_string *str;
		crex_ulong hval;

add_again:
		if (EXPECTED(C_TYPE_P(offset) == IS_STRING)) {
			str = C_STR_P(offset);
			if (IS_UNUSED != IS_CONST) {
				if (CREX_HANDLE_NUMERIC(str, hval)) {
					goto num_index;
				}
			}
str_index:
			crex_hash_update(C_ARRVAL_P(EX_VAR(opline->result.var)), str, expr_ptr);
		} else if (EXPECTED(C_TYPE_P(offset) == IS_LONG)) {
			hval = C_LVAL_P(offset);
num_index:
			crex_hash_index_update(C_ARRVAL_P(EX_VAR(opline->result.var)), hval, expr_ptr);
		} else if ((IS_UNUSED & (IS_VAR|IS_CV)) && EXPECTED(C_TYPE_P(offset) == IS_REFERENCE)) {
			offset = C_REFVAL_P(offset);
			goto add_again;
		} else if (C_TYPE_P(offset) == IS_NULL) {
			str = ZSTR_EMPTY_ALLOC();
			goto str_index;
		} else if (C_TYPE_P(offset) == IS_DOUBLE) {
			hval = crex_dval_to_lval_safe(C_DVAL_P(offset));
			goto num_index;
		} else if (C_TYPE_P(offset) == IS_FALSE) {
			hval = 0;
			goto num_index;
		} else if (C_TYPE_P(offset) == IS_TRUE) {
			hval = 1;
			goto num_index;
		} else if (C_TYPE_P(offset) == IS_RESOURCE) {
			crex_use_resource_as_offset(offset);
			hval = C_RES_HANDLE_P(offset);
			goto num_index;
		} else if (IS_UNUSED == IS_CV && C_TYPE_P(offset) == IS_UNDEF) {
			ZVAL_UNDEFINED_OP2();
			str = ZSTR_EMPTY_ALLOC();
			goto str_index;
		} else {
			crex_illegal_array_offset_access(offset);
			zval_ptr_dtor_nogc(expr_ptr);
		}

	} else {
		if (!crex_hash_next_index_insert(C_ARRVAL_P(EX_VAR(opline->result.var)), expr_ptr)) {
			crex_cannot_add_element();
			zval_ptr_dtor_nogc(expr_ptr);
		}
	}
	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_INIT_ARRAY_SPEC_CONST_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	zval *array;
	uint32_t size;
	USE_OPLINE

	array = EX_VAR(opline->result.var);
	if (IS_CONST != IS_UNUSED) {
		size = opline->extended_value >> CREX_ARRAY_SIZE_SHIFT;
		ZVAL_ARR(array, crex_new_array(size));
		/* Explicitly initialize array as not-packed if flag is set */
		if (opline->extended_value & CREX_ARRAY_NOT_PACKED) {
			crex_hash_real_init_mixed(C_ARRVAL_P(array));
		}
		CREX_VM_TAIL_CALL(CREX_ADD_ARRAY_ELEMENT_SPEC_CONST_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU));
	} else {
		ZVAL_ARR(array, crex_new_array(0));
		CREX_VM_NEXT_OPCODE();
	}
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_UNSET_VAR_SPEC_CONST_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *varname;
	crex_string *name, *tmp_name;
	HashTable *target_symbol_table;

	SAVE_OPLINE();

	varname = RT_CONSTANT(opline, opline->op1);

	if (IS_CONST == IS_CONST) {
		name = C_STR_P(varname);
	} else if (EXPECTED(C_TYPE_P(varname) == IS_STRING)) {
		name = C_STR_P(varname);
		tmp_name = NULL;
	} else {
		if (IS_CONST == IS_CV && UNEXPECTED(C_TYPE_P(varname) == IS_UNDEF)) {
			varname = ZVAL_UNDEFINED_OP1();
		}
		name = zval_try_get_tmp_string(varname, &tmp_name);
		if (UNEXPECTED(!name)) {

			HANDLE_EXCEPTION();
		}
	}

	target_symbol_table = crex_get_target_symbol_table(opline->extended_value EXECUTE_DATA_CC);
	crex_hash_del_ind(target_symbol_table, name);

	if (IS_CONST != IS_CONST) {
		crex_tmp_string_release(tmp_name);
	}

	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

/* No specialization for op_types (CONST|TMPVAR|CV, UNUSED|CLASS_FETCH|CONST|VAR) */
static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ISSET_ISEMPTY_VAR_SPEC_CONST_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *value;
	/* Should be bool result? as below got: result = (opline->extended_value & CREX_ISEMPTY) */
	int result;
	zval *varname;
	crex_string *name, *tmp_name;
	HashTable *target_symbol_table;

	SAVE_OPLINE();
	varname = RT_CONSTANT(opline, opline->op1);
	if (IS_CONST == IS_CONST) {
		name = C_STR_P(varname);
	} else {
		name = zval_get_tmp_string(varname, &tmp_name);
	}

	target_symbol_table = crex_get_target_symbol_table(opline->extended_value EXECUTE_DATA_CC);
	value = crex_hash_find_ex(target_symbol_table, name, IS_CONST == IS_CONST);

	if (IS_CONST != IS_CONST) {
		crex_tmp_string_release(tmp_name);
	}

	if (!value) {
		result = (opline->extended_value & CREX_ISEMPTY);
	} else {
		if (C_TYPE_P(value) == IS_INDIRECT) {
			value = C_INDIRECT_P(value);
		}
		if (!(opline->extended_value & CREX_ISEMPTY)) {
			if (C_ISREF_P(value)) {
				value = C_REFVAL_P(value);
			}
			result = C_TYPE_P(value) > IS_NULL;
		} else {
			result = !i_crex_is_true(value);
		}
	}

	CREX_VM_SMART_BRANCH(result, 1);
}

/* No specialization for op_types (CONST|TMPVAR|CV, UNUSED|CLASS_FETCH|CONST|VAR) */
static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_YIELD_SPEC_CONST_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	crex_generator *generator = crex_get_running_generator(EXECUTE_DATA_C);

	SAVE_OPLINE();
	if (UNEXPECTED(generator->flags & CREX_GENERATOR_FORCED_CLOSE)) {
		CREX_VM_TAIL_CALL(crex_yield_in_closed_generator_helper_SPEC(CREX_OPCODE_HANDLER_ARGS_PASSTHRU));
	}

	/* Destroy the previously yielded value */
	zval_ptr_dtor(&generator->value);

	/* Destroy the previously yielded key */
	zval_ptr_dtor(&generator->key);

	/* Set the new yielded value */
	if (IS_CONST != IS_UNUSED) {
		if (UNEXPECTED(EX(func)->op_array.fn_flags & CREX_ACC_RETURN_REFERENCE)) {
			/* Constants and temporary variables aren't yieldable by reference,
			 * but we still allow them with a notice. */
			if (IS_CONST & (IS_CONST|IS_TMP_VAR)) {
				zval *value;

				crex_error(E_NOTICE, "Only variable references should be yielded by reference");

				value = RT_CONSTANT(opline, opline->op1);
				ZVAL_COPY_VALUE(&generator->value, value);
				if (IS_CONST == IS_CONST) {
					if (UNEXPECTED(C_OPT_REFCOUNTED(generator->value))) {
						C_ADDREF(generator->value);
					}
				}
			} else {
				zval *value_ptr = crex_get_bad_ptr();

				/* If a function call result is yielded and the function did
				 * not return by reference we throw a notice. */
				do {
					if (IS_CONST == IS_VAR) {
						CREX_ASSERT(value_ptr != &EG(uninitialized_zval));
						if (opline->extended_value == CREX_RETURNS_FUNCTION
						 && !C_ISREF_P(value_ptr)) {
							crex_error(E_NOTICE, "Only variable references should be yielded by reference");
							ZVAL_COPY(&generator->value, value_ptr);
							break;
						}
					}
					if (C_ISREF_P(value_ptr)) {
						C_ADDREF_P(value_ptr);
					} else {
						ZVAL_MAKE_REF_EX(value_ptr, 2);
					}
					ZVAL_REF(&generator->value, C_REF_P(value_ptr));
				} while (0);

			}
		} else {
			zval *value = RT_CONSTANT(opline, opline->op1);

			/* Consts, temporary variables and references need copying */
			if (IS_CONST == IS_CONST) {
				ZVAL_COPY_VALUE(&generator->value, value);
				if (UNEXPECTED(C_OPT_REFCOUNTED(generator->value))) {
					C_ADDREF(generator->value);
				}
			} else if (IS_CONST == IS_TMP_VAR) {
				ZVAL_COPY_VALUE(&generator->value, value);
			} else if ((IS_CONST & (IS_VAR|IS_CV)) && C_ISREF_P(value)) {
				ZVAL_COPY(&generator->value, C_REFVAL_P(value));

			} else {
				ZVAL_COPY_VALUE(&generator->value, value);
				if (IS_CONST == IS_CV) {
					if (C_OPT_REFCOUNTED_P(value)) C_ADDREF_P(value);
				}
			}
		}
	} else {
		/* If no value was specified yield null */
		ZVAL_NULL(&generator->value);
	}

	/* Set the new yielded key */
	if (IS_UNUSED != IS_UNUSED) {
		zval *key = NULL;
		if ((IS_UNUSED & (IS_CV|IS_VAR)) && UNEXPECTED(C_TYPE_P(key) == IS_REFERENCE)) {
			key = C_REFVAL_P(key);
		}
		ZVAL_COPY(&generator->key, key);

		if (C_TYPE(generator->key) == IS_LONG
		    && C_LVAL(generator->key) > generator->largest_used_integer_key
		) {
			generator->largest_used_integer_key = C_LVAL(generator->key);
		}
	} else {
		/* If no key was specified we use auto-increment keys */
		generator->largest_used_integer_key++;
		ZVAL_LONG(&generator->key, generator->largest_used_integer_key);
	}

	if (RETURN_VALUE_USED(opline)) {
		/* If the return value of yield is used set the send
		 * target and initialize it to NULL */
		generator->send_target = EX_VAR(opline->result.var);
		ZVAL_NULL(generator->send_target);
	} else {
		generator->send_target = NULL;
	}

	/* We increment to the next op, so we are at the correct position when the
	 * generator is resumed. */
	CREX_VM_INC_OPCODE();

	/* The GOTO VM uses a local opline variable. We need to set the opline
	 * variable in execute_data so we don't resume at an old position. */
	SAVE_OPLINE();

	CREX_VM_RETURN();
}

static CREX_VM_COLD CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_MATCH_ERROR_SPEC_CONST_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op;

	SAVE_OPLINE();
	op = RT_CONSTANT(opline, opline->op1);
	crex_match_unhandled_error(op);
	HANDLE_EXCEPTION();
}

static CREX_VM_COLD CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_COUNT_SPEC_CONST_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1;
	crex_long count;

	SAVE_OPLINE();
	op1 = RT_CONSTANT(opline, opline->op1);

	while (1) {
		if (C_TYPE_P(op1) == IS_ARRAY) {
			count = crex_hash_num_elements(C_ARRVAL_P(op1));
			break;
		} else if (C_TYPE_P(op1) == IS_OBJECT) {
			crex_object *zobj = C_OBJ_P(op1);

			/* first, we check if the handler is defined */
			if (zobj->handlers->count_elements) {
				if (SUCCESS == zobj->handlers->count_elements(zobj, &count)) {
					break;
				}
				if (UNEXPECTED(EG(exception))) {
					count = 0;
					break;
				}
			}

			/* if not and the object implements Countable we call its count() method */
			if (crex_class_implements_interface(zobj->ce, crex_ce_countable)) {
				zval retval;

				crex_function *count_fn = crex_hash_find_ptr(&zobj->ce->function_table, ZSTR_KNOWN(CREX_STR_COUNT));
				crex_call_known_instance_method_with_0_params(count_fn, zobj, &retval);
				count = zval_get_long(&retval);
				zval_ptr_dtor(&retval);
				break;
			}

			/* If There's no handler and it doesn't implement Countable then emit a TypeError */
		} else if ((IS_CONST & (IS_VAR|IS_CV)) != 0 && C_TYPE_P(op1) == IS_REFERENCE) {
			op1 = C_REFVAL_P(op1);
			continue;
		} else if (IS_CONST == IS_CV && UNEXPECTED(C_TYPE_P(op1) == IS_UNDEF)) {
			ZVAL_UNDEFINED_OP1();
		}
		count = 0;
		crex_type_error("%s(): Argument #1 ($value) must be of type Countable|array, %s given", opline->extended_value ? "sizeof" : "count", crex_zval_value_name(op1));
		break;
	}

	ZVAL_LONG(EX_VAR(opline->result.var), count);

	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_VM_COLD CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_GET_CLASS_SPEC_CONST_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (IS_CONST == IS_UNUSED) {
		SAVE_OPLINE();
		if (UNEXPECTED(!EX(func)->common.scope)) {
			crex_throw_error(NULL, "get_class() without arguments must be called from within a class");
			ZVAL_UNDEF(EX_VAR(opline->result.var));
			HANDLE_EXCEPTION();
		} else {
			crex_error(E_DEPRECATED, "Calling get_class() without arguments is deprecated");
			ZVAL_STR_COPY(EX_VAR(opline->result.var), EX(func)->common.scope->name);
			if (UNEXPECTED(EG(exception))) {
				HANDLE_EXCEPTION();
			}
			CREX_VM_NEXT_OPCODE();
		}
	} else {
		zval *op1;

		SAVE_OPLINE();
		op1 = RT_CONSTANT(opline, opline->op1);
		while (1) {
			if (C_TYPE_P(op1) == IS_OBJECT) {
				ZVAL_STR_COPY(EX_VAR(opline->result.var), C_OBJCE_P(op1)->name);
			} else if ((IS_CONST & (IS_VAR|IS_CV)) != 0 && C_TYPE_P(op1) == IS_REFERENCE) {
				op1 = C_REFVAL_P(op1);
				continue;
			} else {
				if (IS_CONST == IS_CV && UNEXPECTED(C_TYPE_P(op1) == IS_UNDEF)) {
					ZVAL_UNDEFINED_OP1();
				}
				crex_type_error("get_class(): Argument #1 ($object) must be of type object, %s given", crex_zval_value_name(op1));
				ZVAL_UNDEF(EX_VAR(opline->result.var));
			}
			break;
		}

		CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
	}
}

static CREX_VM_COLD CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_GET_TYPE_SPEC_CONST_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1;
	crex_string *type;

	SAVE_OPLINE();
	op1 = RT_CONSTANT(opline, opline->op1);
	type = crex_zval_get_legacy_type(op1);
	if (EXPECTED(type)) {
		ZVAL_INTERNED_STR(EX_VAR(opline->result.var), type);
	} else {
		ZVAL_STRING(EX_VAR(opline->result.var), "unknown type");
	}

	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FUNC_GET_ARGS_SPEC_CONST_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	crex_array *ht;
	uint32_t arg_count, result_size, skip;

	arg_count = EX_NUM_ARGS();
	if (IS_CONST == IS_CONST) {
		skip = C_LVAL_P(RT_CONSTANT(opline, opline->op1));
		if (arg_count < skip) {
			result_size = 0;
		} else {
			result_size = arg_count - skip;
		}
	} else {
		skip = 0;
		result_size = arg_count;
	}

	if (result_size) {
		uint32_t first_extra_arg = EX(func)->op_array.num_args;

		ht = crex_new_array(result_size);
		ZVAL_ARR(EX_VAR(opline->result.var), ht);
		crex_hash_real_init_packed(ht);
		CREX_HASH_FILL_PACKED(ht) {
			zval *p, *q;
			uint32_t i = skip;
			p = EX_VAR_NUM(i);
			if (arg_count > first_extra_arg) {
				while (i < first_extra_arg) {
					q = p;
					if (EXPECTED(C_TYPE_INFO_P(q) != IS_UNDEF)) {
						ZVAL_DEREF(q);
						if (C_OPT_REFCOUNTED_P(q)) {
							C_ADDREF_P(q);
						}
						CREX_HASH_FILL_SET(q);
					} else {
						CREX_HASH_FILL_SET_NULL();
					}
					CREX_HASH_FILL_NEXT();
					p++;
					i++;
				}
				if (skip < first_extra_arg) {
					skip = 0;
				} else {
					skip -= first_extra_arg;
				}
				p = EX_VAR_NUM(EX(func)->op_array.last_var + EX(func)->op_array.T + skip);
			}
			while (i < arg_count) {
				q = p;
				if (EXPECTED(C_TYPE_INFO_P(q) != IS_UNDEF)) {
					ZVAL_DEREF(q);
					if (C_OPT_REFCOUNTED_P(q)) {
						C_ADDREF_P(q);
					}
					CREX_HASH_FILL_SET(q);
				} else {
					CREX_HASH_FILL_SET_NULL();
				}
				CREX_HASH_FILL_NEXT();
				p++;
				i++;
			}
		} CREX_HASH_FILL_END();
		ht->nNumOfElements = result_size;
	} else {
		ZVAL_EMPTY_ARRAY(EX_VAR(opline->result.var));
	}
	CREX_VM_NEXT_OPCODE();
}

/* Contrary to what its name indicates, CREX_COPY_TMP may receive and define references. */
static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_DIV_SPEC_CONST_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;

	SAVE_OPLINE();
	op1 = RT_CONSTANT(opline, opline->op1);
	op2 = _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC);
	div_function(EX_VAR(opline->result.var), op1, op2);


	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_POW_SPEC_CONST_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;

	SAVE_OPLINE();
	op1 = RT_CONSTANT(opline, opline->op1);
	op2 = _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC);
	pow_function(EX_VAR(opline->result.var), op1, op2);


	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_CONCAT_SPEC_CONST_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;

	op1 = RT_CONSTANT(opline, opline->op1);
	op2 = EX_VAR(opline->op2.var);

	if ((IS_CONST == IS_CONST || EXPECTED(C_TYPE_P(op1) == IS_STRING)) &&
	    (IS_CV == IS_CONST || EXPECTED(C_TYPE_P(op2) == IS_STRING))) {
		crex_string *op1_str = C_STR_P(op1);
		crex_string *op2_str = C_STR_P(op2);
		crex_string *str;
		uint32_t flags = ZSTR_GET_COPYABLE_CONCAT_PROPERTIES_BOTH(op1_str, op2_str);

		if (IS_CONST != IS_CONST && UNEXPECTED(ZSTR_LEN(op1_str) == 0)) {
			if (IS_CV == IS_CONST || IS_CV == IS_CV) {
				ZVAL_STR_COPY(EX_VAR(opline->result.var), op2_str);
			} else {
				ZVAL_STR(EX_VAR(opline->result.var), op2_str);
			}
			if (IS_CONST & (IS_TMP_VAR|IS_VAR)) {
				crex_string_release_ex(op1_str, 0);
			}
		} else if (IS_CV != IS_CONST && UNEXPECTED(ZSTR_LEN(op2_str) == 0)) {
			if (IS_CONST == IS_CONST || IS_CONST == IS_CV) {
				ZVAL_STR_COPY(EX_VAR(opline->result.var), op1_str);
			} else {
				ZVAL_STR(EX_VAR(opline->result.var), op1_str);
			}
			if (IS_CV & (IS_TMP_VAR|IS_VAR)) {
				crex_string_release_ex(op2_str, 0);
			}
		} else if (IS_CONST != IS_CONST && IS_CONST != IS_CV &&
		    !ZSTR_IS_INTERNED(op1_str) && GC_REFCOUNT(op1_str) == 1) {
			size_t len = ZSTR_LEN(op1_str);

			if (UNEXPECTED(len > ZSTR_MAX_LEN - ZSTR_LEN(op2_str))) {
				crex_error_noreturn(E_ERROR, "Integer overflow in memory allocation");
			}
			str = crex_string_extend(op1_str, len + ZSTR_LEN(op2_str), 0);
			memcpy(ZSTR_VAL(str) + len, ZSTR_VAL(op2_str), ZSTR_LEN(op2_str)+1);
			GC_ADD_FLAGS(str, flags);
			ZVAL_NEW_STR(EX_VAR(opline->result.var), str);
			if (IS_CV & (IS_TMP_VAR|IS_VAR)) {
				crex_string_release_ex(op2_str, 0);
			}
		} else {
			str = crex_string_alloc(ZSTR_LEN(op1_str) + ZSTR_LEN(op2_str), 0);
			memcpy(ZSTR_VAL(str), ZSTR_VAL(op1_str), ZSTR_LEN(op1_str));
			memcpy(ZSTR_VAL(str) + ZSTR_LEN(op1_str), ZSTR_VAL(op2_str), ZSTR_LEN(op2_str)+1);
			GC_ADD_FLAGS(str, flags);
			ZVAL_NEW_STR(EX_VAR(opline->result.var), str);
			if (IS_CONST & (IS_TMP_VAR|IS_VAR)) {
				crex_string_release_ex(op1_str, 0);
			}
			if (IS_CV & (IS_TMP_VAR|IS_VAR)) {
				crex_string_release_ex(op2_str, 0);
			}
		}
		CREX_VM_NEXT_OPCODE();
	} else {
		SAVE_OPLINE();

		if (IS_CONST == IS_CV && UNEXPECTED(C_TYPE_P(op1) == IS_UNDEF)) {
			op1 = ZVAL_UNDEFINED_OP1();
		}
		if (IS_CV == IS_CV && UNEXPECTED(C_TYPE_P(op2) == IS_UNDEF)) {
			op2 = ZVAL_UNDEFINED_OP2();
		}
		concat_function(EX_VAR(opline->result.var), op1, op2);


		CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
	}
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_SPACESHIP_SPEC_CONST_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;

	SAVE_OPLINE();
	op1 = RT_CONSTANT(opline, opline->op1);
	op2 = _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC);
	compare_function(EX_VAR(opline->result.var), op1, op2);


	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FETCH_DIM_R_SPEC_CONST_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container, *dim, *value;

	SAVE_OPLINE();
	container = RT_CONSTANT(opline, opline->op1);
	dim = EX_VAR(opline->op2.var);
	if (IS_CONST != IS_CONST) {
		if (EXPECTED(C_TYPE_P(container) == IS_ARRAY)) {
fetch_dim_r_array:
			value = crex_fetch_dimension_address_inner(C_ARRVAL_P(container), dim, IS_CV, BP_VAR_R EXECUTE_DATA_CC);
			ZVAL_COPY_DEREF(EX_VAR(opline->result.var), value);
		} else if (EXPECTED(C_TYPE_P(container) == IS_REFERENCE)) {
			container = C_REFVAL_P(container);
			if (EXPECTED(C_TYPE_P(container) == IS_ARRAY)) {
				goto fetch_dim_r_array;
			} else {
				goto fetch_dim_r_slow;
			}
		} else {
fetch_dim_r_slow:
			if (IS_CV == IS_CONST && C_EXTRA_P(dim) == CREX_EXTRA_VALUE) {
				dim++;
			}
			crex_fetch_dimension_address_read_R_slow(container, dim OPLINE_CC EXECUTE_DATA_CC);
		}
	} else {
		crex_fetch_dimension_address_read_R(container, dim, IS_CV OPLINE_CC EXECUTE_DATA_CC);
	}


	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FETCH_DIM_IS_SPEC_CONST_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;

	SAVE_OPLINE();
	container = RT_CONSTANT(opline, opline->op1);
	crex_fetch_dimension_address_read_IS(container, EX_VAR(opline->op2.var), IS_CV OPLINE_CC EXECUTE_DATA_CC);


	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FETCH_DIM_FUNC_ARG_SPEC_CONST_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
#if 0
	USE_OPLINE
#endif

	if (UNEXPECTED(CREX_CALL_INFO(EX(call)) & CREX_CALL_SEND_ARG_BY_REF)) {
		if ((IS_CONST & (IS_CONST|IS_TMP_VAR))) {
			CREX_VM_TAIL_CALL(crex_use_tmp_in_write_context_helper_SPEC(CREX_OPCODE_HANDLER_ARGS_PASSTHRU));
		}
		CREX_VM_TAIL_CALL(CREX_NULL_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU));
	} else {
		if (IS_CV == IS_UNUSED) {
			CREX_VM_TAIL_CALL(crex_use_undef_in_read_context_helper_SPEC(CREX_OPCODE_HANDLER_ARGS_PASSTHRU));
		}
		CREX_VM_TAIL_CALL(CREX_FETCH_DIM_R_SPEC_CONST_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU));
	}
}

static CREX_VM_COLD CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FETCH_OBJ_R_SPEC_CONST_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;
	void **cache_slot = NULL;

	SAVE_OPLINE();
	container = RT_CONSTANT(opline, opline->op1);

	if (IS_CONST == IS_CONST ||
	    (IS_CONST != IS_UNUSED && UNEXPECTED(C_TYPE_P(container) != IS_OBJECT))) {
		do {
			if ((IS_CONST & (IS_VAR|IS_CV)) && C_ISREF_P(container)) {
				container = C_REFVAL_P(container);
				if (EXPECTED(C_TYPE_P(container) == IS_OBJECT)) {
					break;
				}
			}
			if (IS_CONST == IS_CV && UNEXPECTED(C_TYPE_P(container) == IS_UNDEF)) {
				ZVAL_UNDEFINED_OP1();
			}
			crex_wrong_property_read(container, _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC));
			ZVAL_NULL(EX_VAR(opline->result.var));
			goto fetch_obj_r_finish;
		} while (0);
	}

	/* here we are sure we are dealing with an object */
	do {
		crex_object *zobj = C_OBJ_P(container);
		crex_string *name, *tmp_name;
		zval *retval;

		if (IS_CV == IS_CONST) {
			cache_slot = CACHE_ADDR(opline->extended_value & ~CREX_FETCH_REF /* FUNC_ARG fetch may contain it */);

			if (EXPECTED(zobj->ce == CACHED_PTR_EX(cache_slot))) {
				uintptr_t prop_offset = (uintptr_t)CACHED_PTR_EX(cache_slot + 1);

				if (EXPECTED(IS_VALID_PROPERTY_OFFSET(prop_offset))) {
					retval = OBJ_PROP(zobj, prop_offset);
					if (EXPECTED(C_TYPE_INFO_P(retval) != IS_UNDEF)) {
						if (0 || (IS_CONST & (IS_TMP_VAR|IS_VAR)) != 0) {
							goto fetch_obj_r_copy;
						} else {
fetch_obj_r_fast_copy:
							ZVAL_COPY_DEREF(EX_VAR(opline->result.var), retval);
							CREX_VM_NEXT_OPCODE();
						}
					}
				} else if (EXPECTED(zobj->properties != NULL)) {
					name = C_STR_P(_get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC));
					if (!IS_UNKNOWN_DYNAMIC_PROPERTY_OFFSET(prop_offset)) {
						uintptr_t idx = CREX_DECODE_DYN_PROP_OFFSET(prop_offset);

						if (EXPECTED(idx < zobj->properties->nNumUsed * sizeof(Bucket))) {
							Bucket *p = (Bucket*)((char*)zobj->properties->arData + idx);

							if (EXPECTED(p->key == name) ||
							    (EXPECTED(p->h == ZSTR_H(name)) &&
							     EXPECTED(p->key != NULL) &&
							     EXPECTED(crex_string_equal_content(p->key, name)))) {
								retval = &p->val;
								if (0 || (IS_CONST & (IS_TMP_VAR|IS_VAR)) != 0) {
									goto fetch_obj_r_copy;
								} else {
									goto fetch_obj_r_fast_copy;
								}
							}
						}
						CACHE_PTR_EX(cache_slot + 1, (void*)CREX_DYNAMIC_PROPERTY_OFFSET);
					}
					retval = crex_hash_find_known_hash(zobj->properties, name);
					if (EXPECTED(retval)) {
						uintptr_t idx = (char*)retval - (char*)zobj->properties->arData;
						CACHE_PTR_EX(cache_slot + 1, (void*)CREX_ENCODE_DYN_PROP_OFFSET(idx));
						if (0 || (IS_CONST & (IS_TMP_VAR|IS_VAR)) != 0) {
							goto fetch_obj_r_copy;
						} else {
							goto fetch_obj_r_fast_copy;
						}
					}
				}
			}
			name = C_STR_P(_get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC));
		} else {
			name = zval_try_get_tmp_string(_get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC), &tmp_name);
			if (UNEXPECTED(!name)) {
				ZVAL_UNDEF(EX_VAR(opline->result.var));
				break;
			}
		}

#if CREX_DEBUG
		/* For non-standard object handlers, verify a declared property type in debug builds.
		 * Fetch prop_info before calling read_property(), as it may deallocate the object. */
		crex_property_info *prop_info = NULL;
		if (zobj->handlers->read_property != crex_std_read_property) {
			prop_info = crex_get_property_info(zobj->ce, name, /* silent */ true);
		}
#endif
		retval = zobj->handlers->read_property(zobj, name, BP_VAR_R, cache_slot, EX_VAR(opline->result.var));
#if CREX_DEBUG
		if (!EG(exception) && prop_info && prop_info != CREX_WRONG_PROPERTY_INFO
				&& CREX_TYPE_IS_SET(prop_info->type)) {
			ZVAL_OPT_DEREF(retval);
			crex_verify_property_type(prop_info, retval, /* strict */ true);
		}
#endif

		if (IS_CV != IS_CONST) {
			crex_tmp_string_release(tmp_name);
		}

		if (retval != EX_VAR(opline->result.var)) {
fetch_obj_r_copy:
			ZVAL_COPY_DEREF(EX_VAR(opline->result.var), retval);
		} else if (UNEXPECTED(C_ISREF_P(retval))) {
			crex_unwrap_reference(retval);
		}
	} while (0);

fetch_obj_r_finish:


	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_VM_COLD CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FETCH_OBJ_IS_SPEC_CONST_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;
	void **cache_slot = NULL;

	SAVE_OPLINE();
	container = RT_CONSTANT(opline, opline->op1);

	if (IS_CONST == IS_CONST ||
	    (IS_CONST != IS_UNUSED && UNEXPECTED(C_TYPE_P(container) != IS_OBJECT))) {
		do {
			if ((IS_CONST & (IS_VAR|IS_CV)) && C_ISREF_P(container)) {
				container = C_REFVAL_P(container);
				if (EXPECTED(C_TYPE_P(container) == IS_OBJECT)) {
					break;
				}
			}
			if (IS_CV == IS_CV && C_TYPE_P(EX_VAR(opline->op2.var)) == IS_UNDEF) {
				ZVAL_UNDEFINED_OP2();
			}
			ZVAL_NULL(EX_VAR(opline->result.var));
			goto fetch_obj_is_finish;
		} while (0);
	}

	/* here we are sure we are dealing with an object */
	do {
		crex_object *zobj = C_OBJ_P(container);
		crex_string *name, *tmp_name;
		zval *retval;

		if (IS_CV == IS_CONST) {
			cache_slot = CACHE_ADDR(opline->extended_value);

			if (EXPECTED(zobj->ce == CACHED_PTR_EX(cache_slot))) {
				uintptr_t prop_offset = (uintptr_t)CACHED_PTR_EX(cache_slot + 1);

				if (EXPECTED(IS_VALID_PROPERTY_OFFSET(prop_offset))) {
					retval = OBJ_PROP(zobj, prop_offset);
					if (EXPECTED(C_TYPE_P(retval) != IS_UNDEF)) {
						if (0 || (IS_CONST & (IS_TMP_VAR|IS_VAR)) != 0) {
							goto fetch_obj_is_copy;
						} else {
fetch_obj_is_fast_copy:
							ZVAL_COPY_DEREF(EX_VAR(opline->result.var), retval);
							CREX_VM_NEXT_OPCODE();
						}
					}
				} else if (EXPECTED(zobj->properties != NULL)) {
					name = C_STR_P(_get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC));
					if (!IS_UNKNOWN_DYNAMIC_PROPERTY_OFFSET(prop_offset)) {
						uintptr_t idx = CREX_DECODE_DYN_PROP_OFFSET(prop_offset);

						if (EXPECTED(idx < zobj->properties->nNumUsed * sizeof(Bucket))) {
							Bucket *p = (Bucket*)((char*)zobj->properties->arData + idx);

							if (EXPECTED(p->key == name) ||
							    (EXPECTED(p->h == ZSTR_H(name)) &&
							     EXPECTED(p->key != NULL) &&
							     EXPECTED(crex_string_equal_content(p->key, name)))) {
								retval = &p->val;
								if (0 || (IS_CONST & (IS_TMP_VAR|IS_VAR)) != 0) {
									goto fetch_obj_is_copy;
								} else {
									goto fetch_obj_is_fast_copy;
								}
							}
						}
						CACHE_PTR_EX(cache_slot + 1, (void*)CREX_DYNAMIC_PROPERTY_OFFSET);
					}
					retval = crex_hash_find_known_hash(zobj->properties, name);
					if (EXPECTED(retval)) {
						uintptr_t idx = (char*)retval - (char*)zobj->properties->arData;
						CACHE_PTR_EX(cache_slot + 1, (void*)CREX_ENCODE_DYN_PROP_OFFSET(idx));
						if (0 || (IS_CONST & (IS_TMP_VAR|IS_VAR)) != 0) {
							goto fetch_obj_is_copy;
						} else {
							goto fetch_obj_is_fast_copy;
						}
					}
				}
			}
			name = C_STR_P(_get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC));
		} else {
			name = zval_try_get_tmp_string(_get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC), &tmp_name);
			if (UNEXPECTED(!name)) {
				ZVAL_UNDEF(EX_VAR(opline->result.var));
				break;
			}
		}

		retval = zobj->handlers->read_property(zobj, name, BP_VAR_IS, cache_slot, EX_VAR(opline->result.var));

		if (IS_CV != IS_CONST) {
			crex_tmp_string_release(tmp_name);
		}

		if (retval != EX_VAR(opline->result.var)) {
fetch_obj_is_copy:
			ZVAL_COPY_DEREF(EX_VAR(opline->result.var), retval);
		} else if (UNEXPECTED(C_ISREF_P(retval))) {
			crex_unwrap_reference(retval);
		}
	} while (0);

fetch_obj_is_finish:


	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_VM_COLD CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FETCH_OBJ_FUNC_ARG_SPEC_CONST_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
#if 0
	USE_OPLINE
#endif

	if (UNEXPECTED(CREX_CALL_INFO(EX(call)) & CREX_CALL_SEND_ARG_BY_REF)) {
		/* Behave like FETCH_OBJ_W */
		if ((IS_CONST & (IS_CONST|IS_TMP_VAR))) {
			CREX_VM_TAIL_CALL(crex_use_tmp_in_write_context_helper_SPEC(CREX_OPCODE_HANDLER_ARGS_PASSTHRU));
		}
		CREX_VM_TAIL_CALL(CREX_NULL_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU));
	} else {
		CREX_VM_TAIL_CALL(CREX_FETCH_OBJ_R_SPEC_CONST_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU));
	}
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FETCH_LIST_R_SPEC_CONST_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;

	SAVE_OPLINE();
	container = RT_CONSTANT(opline, opline->op1);
	crex_fetch_dimension_address_LIST_r(container, EX_VAR(opline->op2.var), IS_CV OPLINE_CC EXECUTE_DATA_CC);

	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FAST_CONCAT_SPEC_CONST_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	crex_string *op1_str, *op2_str, *str;


	op1 = RT_CONSTANT(opline, opline->op1);
	op2 = EX_VAR(opline->op2.var);
	if ((IS_CONST == IS_CONST || EXPECTED(C_TYPE_P(op1) == IS_STRING)) &&
	    (IS_CV == IS_CONST || EXPECTED(C_TYPE_P(op2) == IS_STRING))) {
		crex_string *op1_str = C_STR_P(op1);
		crex_string *op2_str = C_STR_P(op2);
		crex_string *str;
		uint32_t flags = ZSTR_GET_COPYABLE_CONCAT_PROPERTIES_BOTH(op1_str, op2_str);

		if (IS_CONST != IS_CONST && UNEXPECTED(ZSTR_LEN(op1_str) == 0)) {
			if (IS_CV == IS_CONST || IS_CV == IS_CV) {
				ZVAL_STR_COPY(EX_VAR(opline->result.var), op2_str);
			} else {
				ZVAL_STR(EX_VAR(opline->result.var), op2_str);
			}
			if (IS_CONST & (IS_TMP_VAR|IS_VAR)) {
				crex_string_release_ex(op1_str, 0);
			}
		} else if (IS_CV != IS_CONST && UNEXPECTED(ZSTR_LEN(op2_str) == 0)) {
			if (IS_CONST == IS_CONST || IS_CONST == IS_CV) {
				ZVAL_STR_COPY(EX_VAR(opline->result.var), op1_str);
			} else {
				ZVAL_STR(EX_VAR(opline->result.var), op1_str);
			}
			if (IS_CV & (IS_TMP_VAR|IS_VAR)) {
				crex_string_release_ex(op2_str, 0);
			}
		} else if (IS_CONST != IS_CONST && IS_CONST != IS_CV &&
		    !ZSTR_IS_INTERNED(op1_str) && GC_REFCOUNT(op1_str) == 1) {
			size_t len = ZSTR_LEN(op1_str);

			str = crex_string_extend(op1_str, len + ZSTR_LEN(op2_str), 0);
			memcpy(ZSTR_VAL(str) + len, ZSTR_VAL(op2_str), ZSTR_LEN(op2_str)+1);
			GC_ADD_FLAGS(str, flags);
			ZVAL_NEW_STR(EX_VAR(opline->result.var), str);
			if (IS_CV & (IS_TMP_VAR|IS_VAR)) {
				crex_string_release_ex(op2_str, 0);
			}
		} else {
			str = crex_string_alloc(ZSTR_LEN(op1_str) + ZSTR_LEN(op2_str), 0);
			memcpy(ZSTR_VAL(str), ZSTR_VAL(op1_str), ZSTR_LEN(op1_str));
			memcpy(ZSTR_VAL(str) + ZSTR_LEN(op1_str), ZSTR_VAL(op2_str), ZSTR_LEN(op2_str)+1);
			GC_ADD_FLAGS(str, flags);
			ZVAL_NEW_STR(EX_VAR(opline->result.var), str);
			if (IS_CONST & (IS_TMP_VAR|IS_VAR)) {
				crex_string_release_ex(op1_str, 0);
			}
			if (IS_CV & (IS_TMP_VAR|IS_VAR)) {
				crex_string_release_ex(op2_str, 0);
			}
		}
		CREX_VM_NEXT_OPCODE();
	}

	SAVE_OPLINE();
	if (IS_CONST == IS_CONST) {
		op1_str = C_STR_P(op1);
	} else if (EXPECTED(C_TYPE_P(op1) == IS_STRING)) {
		op1_str = crex_string_copy(C_STR_P(op1));
	} else {
		if (IS_CONST == IS_CV && UNEXPECTED(C_TYPE_P(op1) == IS_UNDEF)) {
			ZVAL_UNDEFINED_OP1();
		}
		op1_str = zval_get_string_func(op1);
	}
	if (IS_CV == IS_CONST) {
		op2_str = C_STR_P(op2);
	} else if (EXPECTED(C_TYPE_P(op2) == IS_STRING)) {
		op2_str = crex_string_copy(C_STR_P(op2));
	} else {
		if (IS_CV == IS_CV && UNEXPECTED(C_TYPE_P(op2) == IS_UNDEF)) {
			ZVAL_UNDEFINED_OP2();
		}
		op2_str = zval_get_string_func(op2);
	}
	do {
		if (IS_CONST != IS_CONST) {
			if (UNEXPECTED(ZSTR_LEN(op1_str) == 0)) {
				if (IS_CV == IS_CONST) {
					if (UNEXPECTED(C_REFCOUNTED_P(op2))) {
						GC_ADDREF(op2_str);
					}
				}
				ZVAL_STR(EX_VAR(opline->result.var), op2_str);
				crex_string_release_ex(op1_str, 0);
				break;
			}
		}
		if (IS_CV != IS_CONST) {
			if (UNEXPECTED(ZSTR_LEN(op2_str) == 0)) {
				if (IS_CONST == IS_CONST) {
					if (UNEXPECTED(C_REFCOUNTED_P(op1))) {
						GC_ADDREF(op1_str);
					}
				}
				ZVAL_STR(EX_VAR(opline->result.var), op1_str);
				crex_string_release_ex(op2_str, 0);
				break;
			}
		}
		str = crex_string_alloc(ZSTR_LEN(op1_str) + ZSTR_LEN(op2_str), 0);
		memcpy(ZSTR_VAL(str), ZSTR_VAL(op1_str), ZSTR_LEN(op1_str));
		memcpy(ZSTR_VAL(str) + ZSTR_LEN(op1_str), ZSTR_VAL(op2_str), ZSTR_LEN(op2_str)+1);

		ZSTR_COPY_CONCAT_PROPERTIES_BOTH(str, op1_str, op2_str);
		ZVAL_NEW_STR(EX_VAR(opline->result.var), str);
		if (IS_CONST != IS_CONST) {
			crex_string_release_ex(op1_str, 0);
		}
		if (IS_CV != IS_CONST) {
			crex_string_release_ex(op2_str, 0);
		}
	} while (0);


	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_VM_COLD CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_INIT_METHOD_CALL_SPEC_CONST_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *function_name;
	zval *object;
	crex_function *fbc;
	crex_class_entry *called_scope;
	crex_object *obj;
	crex_execute_data *call;
	uint32_t call_info;

	SAVE_OPLINE();

	object = RT_CONSTANT(opline, opline->op1);

	if (IS_CV != IS_CONST) {
		function_name = EX_VAR(opline->op2.var);
	}

	if (IS_CV != IS_CONST &&
	    UNEXPECTED(C_TYPE_P(function_name) != IS_STRING)) {
		do {
			if ((IS_CV & (IS_VAR|IS_CV)) && C_ISREF_P(function_name)) {
				function_name = C_REFVAL_P(function_name);
				if (EXPECTED(C_TYPE_P(function_name) == IS_STRING)) {
					break;
				}
			} else if (IS_CV == IS_CV && UNEXPECTED(C_TYPE_P(function_name) == IS_UNDEF)) {
				ZVAL_UNDEFINED_OP2();
				if (UNEXPECTED(EG(exception) != NULL)) {

					HANDLE_EXCEPTION();
				}
			}
			crex_throw_error(NULL, "Method name must be a string");


			HANDLE_EXCEPTION();
		} while (0);
	}

	if (IS_CONST == IS_UNUSED) {
		obj = C_OBJ_P(object);
	} else {
		do {
			if (IS_CONST != IS_CONST && EXPECTED(C_TYPE_P(object) == IS_OBJECT)) {
				obj = C_OBJ_P(object);
			} else {
				if ((IS_CONST & (IS_VAR|IS_CV)) && EXPECTED(C_ISREF_P(object))) {
					crex_reference *ref = C_REF_P(object);

					object = &ref->val;
					if (EXPECTED(C_TYPE_P(object) == IS_OBJECT)) {
						obj = C_OBJ_P(object);
						if (IS_CONST & IS_VAR) {
							if (UNEXPECTED(GC_DELREF(ref) == 0)) {
								efree_size(ref, sizeof(crex_reference));
							} else {
								C_ADDREF_P(object);
							}
						}
						break;
					}
				}
				if (IS_CONST == IS_CV && UNEXPECTED(C_TYPE_P(object) == IS_UNDEF)) {
					object = ZVAL_UNDEFINED_OP1();
					if (UNEXPECTED(EG(exception) != NULL)) {
						if (IS_CV != IS_CONST) {

						}
						HANDLE_EXCEPTION();
					}
				}
				if (IS_CV == IS_CONST) {
					function_name = EX_VAR(opline->op2.var);
				}
				crex_invalid_method_call(object, function_name);


				HANDLE_EXCEPTION();
			}
		} while (0);
	}

	called_scope = obj->ce;

	if (IS_CV == IS_CONST &&
	    EXPECTED(CACHED_PTR(opline->result.num) == called_scope)) {
		fbc = CACHED_PTR(opline->result.num + sizeof(void*));
	} else {
		crex_object *orig_obj = obj;

		if (IS_CV == IS_CONST) {
			function_name = EX_VAR(opline->op2.var);
		}

		/* First, locate the function. */
		fbc = obj->handlers->get_method(&obj, C_STR_P(function_name), ((IS_CV == IS_CONST) ? (RT_CONSTANT(opline, opline->op2) + 1) : NULL));
		if (UNEXPECTED(fbc == NULL)) {
			if (EXPECTED(!EG(exception))) {
				crex_undefined_method(obj->ce, C_STR_P(function_name));
			}

			if ((IS_CONST & (IS_VAR|IS_TMP_VAR)) && GC_DELREF(orig_obj) == 0) {
				crex_objects_store_del(orig_obj);
			}
			HANDLE_EXCEPTION();
		}
		if (IS_CV == IS_CONST &&
		    EXPECTED(!(fbc->common.fn_flags & (CREX_ACC_CALL_VIA_TRAMPOLINE|CREX_ACC_NEVER_CACHE))) &&
		    EXPECTED(obj == orig_obj)) {
			CACHE_POLYMORPHIC_PTR(opline->result.num, called_scope, fbc);
		}
		if ((IS_CONST & (IS_VAR|IS_TMP_VAR)) && UNEXPECTED(obj != orig_obj)) {
			GC_ADDREF(obj); /* For $this pointer */
			if (GC_DELREF(orig_obj) == 0) {
				crex_objects_store_del(orig_obj);
			}
		}
		if (EXPECTED(fbc->type == CREX_USER_FUNCTION) && UNEXPECTED(!RUN_TIME_CACHE(&fbc->op_array))) {
			init_func_run_time_cache(&fbc->op_array);
		}
	}

	if (IS_CV != IS_CONST) {

	}

	call_info = CREX_CALL_NESTED_FUNCTION | CREX_CALL_HAS_THIS;
	if (UNEXPECTED((fbc->common.fn_flags & CREX_ACC_STATIC) != 0)) {
		if ((IS_CONST & (IS_VAR|IS_TMP_VAR)) && GC_DELREF(obj) == 0) {
			crex_objects_store_del(obj);
			if (UNEXPECTED(EG(exception))) {
				HANDLE_EXCEPTION();
			}
		}
		/* call static method */
		obj = (crex_object*)called_scope;
		call_info = CREX_CALL_NESTED_FUNCTION;
	} else if (IS_CONST & (IS_VAR|IS_TMP_VAR|IS_CV)) {
		if (IS_CONST == IS_CV) {
			GC_ADDREF(obj); /* For $this pointer */
		}
		/* CV may be changed indirectly (e.g. when it's a reference) */
		call_info = CREX_CALL_NESTED_FUNCTION | CREX_CALL_HAS_THIS | CREX_CALL_RELEASE_THIS;
	}

	call = crex_vm_stack_push_call_frame(call_info,
		fbc, opline->extended_value, obj);
	call->prev_execute_data = EX(call);
	EX(call) = call;

	CREX_VM_NEXT_OPCODE();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_INIT_STATIC_METHOD_CALL_SPEC_CONST_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *function_name;
	crex_class_entry *ce;
	uint32_t call_info;
	crex_function *fbc;
	crex_execute_data *call;

	SAVE_OPLINE();

	if (IS_CONST == IS_CONST) {
		/* no function found. try a static method in class */
		ce = CACHED_PTR(opline->result.num);
		if (UNEXPECTED(ce == NULL)) {
			ce = crex_fetch_class_by_name(C_STR_P(RT_CONSTANT(opline, opline->op1)), C_STR_P(RT_CONSTANT(opline, opline->op1) + 1), CREX_FETCH_CLASS_DEFAULT | CREX_FETCH_CLASS_EXCEPTION);
			if (UNEXPECTED(ce == NULL)) {

				HANDLE_EXCEPTION();
			}
			if (IS_CV != IS_CONST) {
				CACHE_PTR(opline->result.num, ce);
			}
		}
	} else if (IS_CONST == IS_UNUSED) {
		ce = crex_fetch_class(NULL, opline->op1.num);
		if (UNEXPECTED(ce == NULL)) {

			HANDLE_EXCEPTION();
		}
	} else {
		ce = C_CE_P(EX_VAR(opline->op1.var));
	}

	if (IS_CONST == IS_CONST &&
	    IS_CV == IS_CONST &&
	    EXPECTED((fbc = CACHED_PTR(opline->result.num + sizeof(void*))) != NULL)) {
		/* nothing to do */
	} else if (IS_CONST != IS_CONST &&
	           IS_CV == IS_CONST &&
	           EXPECTED(CACHED_PTR(opline->result.num) == ce)) {
		fbc = CACHED_PTR(opline->result.num + sizeof(void*));
	} else if (IS_CV != IS_UNUSED) {
		function_name = EX_VAR(opline->op2.var);
		if (IS_CV != IS_CONST) {
			if (UNEXPECTED(C_TYPE_P(function_name) != IS_STRING)) {
				do {
					if (IS_CV & (IS_VAR|IS_CV) && C_ISREF_P(function_name)) {
						function_name = C_REFVAL_P(function_name);
						if (EXPECTED(C_TYPE_P(function_name) == IS_STRING)) {
							break;
						}
					} else if (IS_CV == IS_CV && UNEXPECTED(C_TYPE_P(function_name) == IS_UNDEF)) {
						ZVAL_UNDEFINED_OP2();
						if (UNEXPECTED(EG(exception) != NULL)) {
							HANDLE_EXCEPTION();
						}
					}
					crex_throw_error(NULL, "Method name must be a string");

					HANDLE_EXCEPTION();
				} while (0);
			}
		}

		if (ce->get_static_method) {
			fbc = ce->get_static_method(ce, C_STR_P(function_name));
		} else {
			fbc = crex_std_get_static_method(ce, C_STR_P(function_name), ((IS_CV == IS_CONST) ? (RT_CONSTANT(opline, opline->op2) + 1) : NULL));
		}
		if (UNEXPECTED(fbc == NULL)) {
			if (EXPECTED(!EG(exception))) {
				crex_undefined_method(ce, C_STR_P(function_name));
			}

			HANDLE_EXCEPTION();
		}
		if (IS_CV == IS_CONST &&
		    EXPECTED(!(fbc->common.fn_flags & (CREX_ACC_CALL_VIA_TRAMPOLINE|CREX_ACC_NEVER_CACHE))) &&
			EXPECTED(!(fbc->common.scope->ce_flags & CREX_ACC_TRAIT))) {
			CACHE_POLYMORPHIC_PTR(opline->result.num, ce, fbc);
		}
		if (EXPECTED(fbc->type == CREX_USER_FUNCTION) && UNEXPECTED(!RUN_TIME_CACHE(&fbc->op_array))) {
			init_func_run_time_cache(&fbc->op_array);
		}
		if (IS_CV != IS_CONST) {

		}
	} else {
		if (UNEXPECTED(ce->constructor == NULL)) {
			crex_throw_error(NULL, "Cannot call constructor");
			HANDLE_EXCEPTION();
		}
		if (C_TYPE(EX(This)) == IS_OBJECT && C_OBJ(EX(This))->ce != ce->constructor->common.scope && (ce->constructor->common.fn_flags & CREX_ACC_PRIVATE)) {
			crex_throw_error(NULL, "Cannot call private %s::__main()", ZSTR_VAL(ce->name));
			HANDLE_EXCEPTION();
		}
		fbc = ce->constructor;
		if (EXPECTED(fbc->type == CREX_USER_FUNCTION) && UNEXPECTED(!RUN_TIME_CACHE(&fbc->op_array))) {
			init_func_run_time_cache(&fbc->op_array);
		}
	}

	if (!(fbc->common.fn_flags & CREX_ACC_STATIC)) {
		if (C_TYPE(EX(This)) == IS_OBJECT && instanceof_function(C_OBJCE(EX(This)), ce)) {
			ce = (crex_class_entry*)C_OBJ(EX(This));
			call_info = CREX_CALL_NESTED_FUNCTION | CREX_CALL_HAS_THIS;
		} else {
			crex_non_static_method_call(fbc);
			HANDLE_EXCEPTION();
		}
	} else {
		/* previous opcode is CREX_FETCH_CLASS */
		if (IS_CONST == IS_UNUSED
		 && ((opline->op1.num & CREX_FETCH_CLASS_MASK) == CREX_FETCH_CLASS_PARENT ||
		     (opline->op1.num & CREX_FETCH_CLASS_MASK) == CREX_FETCH_CLASS_SELF)) {
			if (C_TYPE(EX(This)) == IS_OBJECT) {
				ce = C_OBJCE(EX(This));
			} else {
				ce = C_CE(EX(This));
			}
		}
		call_info = CREX_CALL_NESTED_FUNCTION;
	}

	call = crex_vm_stack_push_call_frame(call_info,
		fbc, opline->extended_value, ce);
	call->prev_execute_data = EX(call);
	EX(call) = call;

	CREX_VM_NEXT_OPCODE();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_INIT_USER_CALL_SPEC_CONST_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *function_name;
	crex_fcall_info_cache fcc;
	char *error = NULL;
	crex_function *func;
	void *object_or_called_scope;
	crex_execute_data *call;
	uint32_t call_info = CREX_CALL_NESTED_FUNCTION | CREX_CALL_DYNAMIC;

	SAVE_OPLINE();
	function_name = _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC);
	if (crex_is_callable_ex(function_name, NULL, 0, NULL, &fcc, &error)) {
		CREX_ASSERT(!error);
		func = fcc.function_handler;
		object_or_called_scope = fcc.called_scope;
		if (func->common.fn_flags & CREX_ACC_CLOSURE) {
			/* Delay closure destruction until its invocation */
			GC_ADDREF(CREX_CLOSURE_OBJECT(func));
			call_info |= CREX_CALL_CLOSURE;
			if (func->common.fn_flags & CREX_ACC_FAKE_CLOSURE) {
				call_info |= CREX_CALL_FAKE_CLOSURE;
			}
			if (fcc.object) {
				object_or_called_scope = fcc.object;
				call_info |= CREX_CALL_HAS_THIS;
			}
		} else if (fcc.object) {
			GC_ADDREF(fcc.object); /* For $this pointer */
			object_or_called_scope = fcc.object;
			call_info |= CREX_CALL_RELEASE_THIS | CREX_CALL_HAS_THIS;
		}

		if ((IS_CV & (IS_TMP_VAR|IS_VAR)) && UNEXPECTED(EG(exception))) {
			if (call_info & CREX_CALL_CLOSURE) {
				crex_object_release(CREX_CLOSURE_OBJECT(func));
			} else if (call_info & CREX_CALL_RELEASE_THIS) {
				crex_object_release(fcc.object);
			}
			HANDLE_EXCEPTION();
		}

		if (EXPECTED(func->type == CREX_USER_FUNCTION) && UNEXPECTED(!RUN_TIME_CACHE(&func->op_array))) {
			init_func_run_time_cache(&func->op_array);
		}
	} else {
		crex_type_error("%s(): Argument #1 ($callback) must be a valid callback, %s", C_STRVAL_P(RT_CONSTANT(opline, opline->op1)), error);
		efree(error);

		HANDLE_EXCEPTION();
	}

	call = crex_vm_stack_push_call_frame(call_info,
		func, opline->extended_value, object_or_called_scope);
	call->prev_execute_data = EX(call);
	EX(call) = call;

	CREX_VM_NEXT_OPCODE();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ADD_ARRAY_ELEMENT_SPEC_CONST_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *expr_ptr, new_expr;

	SAVE_OPLINE();
	if ((IS_CONST == IS_VAR || IS_CONST == IS_CV) &&
	    UNEXPECTED(opline->extended_value & CREX_ARRAY_ELEMENT_REF)) {
		expr_ptr = crex_get_bad_ptr();
		if (C_ISREF_P(expr_ptr)) {
			C_ADDREF_P(expr_ptr);
		} else {
			ZVAL_MAKE_REF_EX(expr_ptr, 2);
		}

	} else {
		expr_ptr = RT_CONSTANT(opline, opline->op1);
		if (IS_CONST == IS_TMP_VAR) {
			/* pass */
		} else if (IS_CONST == IS_CONST) {
			C_TRY_ADDREF_P(expr_ptr);
		} else if (IS_CONST == IS_CV) {
			ZVAL_DEREF(expr_ptr);
			C_TRY_ADDREF_P(expr_ptr);
		} else /* if (IS_CONST == IS_VAR) */ {
			if (UNEXPECTED(C_ISREF_P(expr_ptr))) {
				crex_refcounted *ref = C_COUNTED_P(expr_ptr);

				expr_ptr = C_REFVAL_P(expr_ptr);
				if (UNEXPECTED(GC_DELREF(ref) == 0)) {
					ZVAL_COPY_VALUE(&new_expr, expr_ptr);
					expr_ptr = &new_expr;
					efree_size(ref, sizeof(crex_reference));
				} else if (C_OPT_REFCOUNTED_P(expr_ptr)) {
					C_ADDREF_P(expr_ptr);
				}
			}
		}
	}

	if (IS_CV != IS_UNUSED) {
		zval *offset = EX_VAR(opline->op2.var);
		crex_string *str;
		crex_ulong hval;

add_again:
		if (EXPECTED(C_TYPE_P(offset) == IS_STRING)) {
			str = C_STR_P(offset);
			if (IS_CV != IS_CONST) {
				if (CREX_HANDLE_NUMERIC(str, hval)) {
					goto num_index;
				}
			}
str_index:
			crex_hash_update(C_ARRVAL_P(EX_VAR(opline->result.var)), str, expr_ptr);
		} else if (EXPECTED(C_TYPE_P(offset) == IS_LONG)) {
			hval = C_LVAL_P(offset);
num_index:
			crex_hash_index_update(C_ARRVAL_P(EX_VAR(opline->result.var)), hval, expr_ptr);
		} else if ((IS_CV & (IS_VAR|IS_CV)) && EXPECTED(C_TYPE_P(offset) == IS_REFERENCE)) {
			offset = C_REFVAL_P(offset);
			goto add_again;
		} else if (C_TYPE_P(offset) == IS_NULL) {
			str = ZSTR_EMPTY_ALLOC();
			goto str_index;
		} else if (C_TYPE_P(offset) == IS_DOUBLE) {
			hval = crex_dval_to_lval_safe(C_DVAL_P(offset));
			goto num_index;
		} else if (C_TYPE_P(offset) == IS_FALSE) {
			hval = 0;
			goto num_index;
		} else if (C_TYPE_P(offset) == IS_TRUE) {
			hval = 1;
			goto num_index;
		} else if (C_TYPE_P(offset) == IS_RESOURCE) {
			crex_use_resource_as_offset(offset);
			hval = C_RES_HANDLE_P(offset);
			goto num_index;
		} else if (IS_CV == IS_CV && C_TYPE_P(offset) == IS_UNDEF) {
			ZVAL_UNDEFINED_OP2();
			str = ZSTR_EMPTY_ALLOC();
			goto str_index;
		} else {
			crex_illegal_array_offset_access(offset);
			zval_ptr_dtor_nogc(expr_ptr);
		}

	} else {
		if (!crex_hash_next_index_insert(C_ARRVAL_P(EX_VAR(opline->result.var)), expr_ptr)) {
			crex_cannot_add_element();
			zval_ptr_dtor_nogc(expr_ptr);
		}
	}
	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_INIT_ARRAY_SPEC_CONST_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	zval *array;
	uint32_t size;
	USE_OPLINE

	array = EX_VAR(opline->result.var);
	if (IS_CONST != IS_UNUSED) {
		size = opline->extended_value >> CREX_ARRAY_SIZE_SHIFT;
		ZVAL_ARR(array, crex_new_array(size));
		/* Explicitly initialize array as not-packed if flag is set */
		if (opline->extended_value & CREX_ARRAY_NOT_PACKED) {
			crex_hash_real_init_mixed(C_ARRVAL_P(array));
		}
		CREX_VM_TAIL_CALL(CREX_ADD_ARRAY_ELEMENT_SPEC_CONST_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU));
	} else {
		ZVAL_ARR(array, crex_new_array(0));
		CREX_VM_NEXT_OPCODE();
	}
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ISSET_ISEMPTY_DIM_OBJ_SPEC_CONST_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;
	bool result;
	crex_ulong hval;
	zval *offset;

	SAVE_OPLINE();
	container = RT_CONSTANT(opline, opline->op1);
	offset = EX_VAR(opline->op2.var);

	if (EXPECTED(C_TYPE_P(container) == IS_ARRAY)) {
		HashTable *ht;
		zval *value;
		crex_string *str;

isset_dim_obj_array:
		ht = C_ARRVAL_P(container);
isset_again:
		if (EXPECTED(C_TYPE_P(offset) == IS_STRING)) {
			str = C_STR_P(offset);
			if (IS_CV != IS_CONST) {
				if (CREX_HANDLE_NUMERIC(str, hval)) {
					goto num_index_prop;
				}
			}
			value = crex_hash_find_ex(ht, str, IS_CV == IS_CONST);
		} else if (EXPECTED(C_TYPE_P(offset) == IS_LONG)) {
			hval = C_LVAL_P(offset);
num_index_prop:
			value = crex_hash_index_find(ht, hval);
		} else if ((IS_CV & (IS_VAR|IS_CV)) && EXPECTED(C_ISREF_P(offset))) {
			offset = C_REFVAL_P(offset);
			goto isset_again;
		} else {
			value = crex_find_array_dim_slow(ht, offset EXECUTE_DATA_CC);
			if (UNEXPECTED(EG(exception))) {
				result = 0;
				goto isset_dim_obj_exit;
			}
		}

		if (!(opline->extended_value & CREX_ISEMPTY)) {
			/* > IS_NULL means not IS_UNDEF and not IS_NULL */
			result = value != NULL && C_TYPE_P(value) > IS_NULL &&
			    (!C_ISREF_P(value) || C_TYPE_P(C_REFVAL_P(value)) != IS_NULL);

			if (IS_CONST & (IS_CONST|IS_CV)) {
				/* avoid exception check */

				CREX_VM_SMART_BRANCH(result, 0);
			}
		} else {
			result = (value == NULL || !i_crex_is_true(value));
		}
		goto isset_dim_obj_exit;
	} else if ((IS_CONST & (IS_VAR|IS_CV)) && EXPECTED(C_ISREF_P(container))) {
		container = C_REFVAL_P(container);
		if (EXPECTED(C_TYPE_P(container) == IS_ARRAY)) {
			goto isset_dim_obj_array;
		}
	}

	if (IS_CV == IS_CONST && C_EXTRA_P(offset) == CREX_EXTRA_VALUE) {
		offset++;
	}
	if (!(opline->extended_value & CREX_ISEMPTY)) {
		result = crex_isset_dim_slow(container, offset EXECUTE_DATA_CC);
	} else {
		result = crex_isempty_dim_slow(container, offset EXECUTE_DATA_CC);
	}

isset_dim_obj_exit:


	CREX_VM_SMART_BRANCH(result, 1);
}

static CREX_VM_COLD CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ISSET_ISEMPTY_PROP_OBJ_SPEC_CONST_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;
	int result;
	zval *offset;
	crex_string *name, *tmp_name;

	SAVE_OPLINE();
	container = RT_CONSTANT(opline, opline->op1);
	offset = _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC);

	if (IS_CONST == IS_CONST ||
	    (IS_CONST != IS_UNUSED && UNEXPECTED(C_TYPE_P(container) != IS_OBJECT))) {
		if ((IS_CONST & (IS_VAR|IS_CV)) && C_ISREF_P(container)) {
			container = C_REFVAL_P(container);
			if (UNEXPECTED(C_TYPE_P(container) != IS_OBJECT)) {
				result = (opline->extended_value & CREX_ISEMPTY);
				goto isset_object_finish;
			}
		} else {
			result = (opline->extended_value & CREX_ISEMPTY);
			goto isset_object_finish;
		}
	}

	if (IS_CV == IS_CONST) {
		name = C_STR_P(offset);
	} else {
		name = zval_try_get_tmp_string(offset, &tmp_name);
		if (UNEXPECTED(!name)) {
			result = 0;
			goto isset_object_finish;
		}
	}

	result =
		(opline->extended_value & CREX_ISEMPTY) ^
		C_OBJ_HT_P(container)->has_property(C_OBJ_P(container), name, (opline->extended_value & CREX_ISEMPTY), ((IS_CV == IS_CONST) ? CACHE_ADDR(opline->extended_value & ~CREX_ISEMPTY) : NULL));

	if (IS_CV != IS_CONST) {
		crex_tmp_string_release(tmp_name);
	}

isset_object_finish:


	CREX_VM_SMART_BRANCH(result, 1);
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ARRAY_KEY_EXISTS_SPEC_CONST_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *key, *subject;
	HashTable *ht;
	bool result;

	SAVE_OPLINE();

	key = RT_CONSTANT(opline, opline->op1);
	subject = EX_VAR(opline->op2.var);

	if (EXPECTED(C_TYPE_P(subject) == IS_ARRAY)) {
array_key_exists_array:
		ht = C_ARRVAL_P(subject);
		result = crex_array_key_exists_fast(ht, key OPLINE_CC EXECUTE_DATA_CC);
	} else {
		if ((IS_CV & (IS_VAR|IS_CV)) && EXPECTED(C_ISREF_P(subject))) {
			subject = C_REFVAL_P(subject);
			if (EXPECTED(C_TYPE_P(subject) == IS_ARRAY)) {
				goto array_key_exists_array;
			}
		}
		crex_array_key_exists_error(subject, key OPLINE_CC EXECUTE_DATA_CC);
		result = 0;
	}


	CREX_VM_SMART_BRANCH(result, 1);
}

/* No specialization for op_types (CONST|TMPVAR|UNUSED|CV, ANY) */
static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_YIELD_SPEC_CONST_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	crex_generator *generator = crex_get_running_generator(EXECUTE_DATA_C);

	SAVE_OPLINE();
	if (UNEXPECTED(generator->flags & CREX_GENERATOR_FORCED_CLOSE)) {
		CREX_VM_TAIL_CALL(crex_yield_in_closed_generator_helper_SPEC(CREX_OPCODE_HANDLER_ARGS_PASSTHRU));
	}

	/* Destroy the previously yielded value */
	zval_ptr_dtor(&generator->value);

	/* Destroy the previously yielded key */
	zval_ptr_dtor(&generator->key);

	/* Set the new yielded value */
	if (IS_CONST != IS_UNUSED) {
		if (UNEXPECTED(EX(func)->op_array.fn_flags & CREX_ACC_RETURN_REFERENCE)) {
			/* Constants and temporary variables aren't yieldable by reference,
			 * but we still allow them with a notice. */
			if (IS_CONST & (IS_CONST|IS_TMP_VAR)) {
				zval *value;

				crex_error(E_NOTICE, "Only variable references should be yielded by reference");

				value = RT_CONSTANT(opline, opline->op1);
				ZVAL_COPY_VALUE(&generator->value, value);
				if (IS_CONST == IS_CONST) {
					if (UNEXPECTED(C_OPT_REFCOUNTED(generator->value))) {
						C_ADDREF(generator->value);
					}
				}
			} else {
				zval *value_ptr = crex_get_bad_ptr();

				/* If a function call result is yielded and the function did
				 * not return by reference we throw a notice. */
				do {
					if (IS_CONST == IS_VAR) {
						CREX_ASSERT(value_ptr != &EG(uninitialized_zval));
						if (opline->extended_value == CREX_RETURNS_FUNCTION
						 && !C_ISREF_P(value_ptr)) {
							crex_error(E_NOTICE, "Only variable references should be yielded by reference");
							ZVAL_COPY(&generator->value, value_ptr);
							break;
						}
					}
					if (C_ISREF_P(value_ptr)) {
						C_ADDREF_P(value_ptr);
					} else {
						ZVAL_MAKE_REF_EX(value_ptr, 2);
					}
					ZVAL_REF(&generator->value, C_REF_P(value_ptr));
				} while (0);

			}
		} else {
			zval *value = RT_CONSTANT(opline, opline->op1);

			/* Consts, temporary variables and references need copying */
			if (IS_CONST == IS_CONST) {
				ZVAL_COPY_VALUE(&generator->value, value);
				if (UNEXPECTED(C_OPT_REFCOUNTED(generator->value))) {
					C_ADDREF(generator->value);
				}
			} else if (IS_CONST == IS_TMP_VAR) {
				ZVAL_COPY_VALUE(&generator->value, value);
			} else if ((IS_CONST & (IS_VAR|IS_CV)) && C_ISREF_P(value)) {
				ZVAL_COPY(&generator->value, C_REFVAL_P(value));

			} else {
				ZVAL_COPY_VALUE(&generator->value, value);
				if (IS_CONST == IS_CV) {
					if (C_OPT_REFCOUNTED_P(value)) C_ADDREF_P(value);
				}
			}
		}
	} else {
		/* If no value was specified yield null */
		ZVAL_NULL(&generator->value);
	}

	/* Set the new yielded key */
	if (IS_CV != IS_UNUSED) {
		zval *key = _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC);
		if ((IS_CV & (IS_CV|IS_VAR)) && UNEXPECTED(C_TYPE_P(key) == IS_REFERENCE)) {
			key = C_REFVAL_P(key);
		}
		ZVAL_COPY(&generator->key, key);

		if (C_TYPE(generator->key) == IS_LONG
		    && C_LVAL(generator->key) > generator->largest_used_integer_key
		) {
			generator->largest_used_integer_key = C_LVAL(generator->key);
		}
	} else {
		/* If no key was specified we use auto-increment keys */
		generator->largest_used_integer_key++;
		ZVAL_LONG(&generator->key, generator->largest_used_integer_key);
	}

	if (RETURN_VALUE_USED(opline)) {
		/* If the return value of yield is used set the send
		 * target and initialize it to NULL */
		generator->send_target = EX_VAR(opline->result.var);
		ZVAL_NULL(generator->send_target);
	} else {
		generator->send_target = NULL;
	}

	/* We increment to the next op, so we are at the correct position when the
	 * generator is resumed. */
	CREX_VM_INC_OPCODE();

	/* The GOTO VM uses a local opline variable. We need to set the opline
	 * variable in execute_data so we don't resume at an old position. */
	SAVE_OPLINE();

	CREX_VM_RETURN();
}

static CREX_VM_HOT CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_BW_NOT_SPEC_TMPVARCV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1;

	op1 = EX_VAR(opline->op1.var);
	if (EXPECTED(C_TYPE_INFO_P(op1) == IS_LONG)) {
		ZVAL_LONG(EX_VAR(opline->result.var), ~C_LVAL_P(op1));
		CREX_VM_NEXT_OPCODE();
	}

	CREX_VM_TAIL_CALL(crex_bw_not_helper_SPEC(op1 CREX_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static CREX_VM_HOT CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_QM_ASSIGN_LONG_SPEC_TMPVARCV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *value;

	value = EX_VAR(opline->op1.var);
	ZVAL_LONG(EX_VAR(opline->result.var), C_LVAL_P(value));
	CREX_VM_NEXT_OPCODE();
}

static CREX_VM_HOT CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_QM_ASSIGN_DOUBLE_SPEC_TMPVARCV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *value;

	value = EX_VAR(opline->op1.var);
	ZVAL_DOUBLE(EX_VAR(opline->result.var), C_DVAL_P(value));
	CREX_VM_NEXT_OPCODE();
}

static CREX_VM_HOT CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_QM_ASSIGN_NOREF_SPEC_TMPVARCV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *value;

	value = EX_VAR(opline->op1.var);
	ZVAL_COPY_VALUE(EX_VAR(opline->result.var), value);
	CREX_VM_NEXT_OPCODE();
}

static CREX_VM_HOT CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ADD_SPEC_TMPVARCV_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2, *result;
	double d1, d2;

	op1 = EX_VAR(opline->op1.var);
	op2 = RT_CONSTANT(opline, opline->op2);
	if (1 && (IS_TMP_VAR|IS_VAR|IS_CV) == IS_CONST && IS_CONST == IS_CONST) {
		/* pass */
	} else if (EXPECTED(C_TYPE_INFO_P(op1) == IS_LONG)) {
		if (EXPECTED(C_TYPE_INFO_P(op2) == IS_LONG)) {
			result = EX_VAR(opline->result.var);
			fast_long_add_function(result, op1, op2);
			CREX_VM_NEXT_OPCODE();
		} else if (EXPECTED(C_TYPE_INFO_P(op2) == IS_DOUBLE)) {
			d1 = (double)C_LVAL_P(op1);
			d2 = C_DVAL_P(op2);
			goto add_double;
		}
	} else if (EXPECTED(C_TYPE_INFO_P(op1) == IS_DOUBLE)) {
		if (EXPECTED(C_TYPE_INFO_P(op2) == IS_DOUBLE)) {
			d1 = C_DVAL_P(op1);
			d2 = C_DVAL_P(op2);
add_double:
			result = EX_VAR(opline->result.var);
			ZVAL_DOUBLE(result, d1 + d2);
			CREX_VM_NEXT_OPCODE();
		} else if (EXPECTED(C_TYPE_INFO_P(op2) == IS_LONG)) {
			d1 = C_DVAL_P(op1);
			d2 = (double)C_LVAL_P(op2);
			goto add_double;
		}
	}

	CREX_VM_TAIL_CALL(crex_add_helper_SPEC(op1, op2 CREX_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static CREX_VM_HOT CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_SUB_SPEC_TMPVARCV_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2, *result;
	double d1, d2;

	op1 = EX_VAR(opline->op1.var);
	op2 = RT_CONSTANT(opline, opline->op2);
	if (1 && (IS_TMP_VAR|IS_VAR|IS_CV) == IS_CONST && IS_CONST == IS_CONST) {
		/* pass */
	} else if (EXPECTED(C_TYPE_INFO_P(op1) == IS_LONG)) {
		if (EXPECTED(C_TYPE_INFO_P(op2) == IS_LONG)) {
			result = EX_VAR(opline->result.var);
			fast_long_sub_function(result, op1, op2);
			CREX_VM_NEXT_OPCODE();
		} else if (EXPECTED(C_TYPE_INFO_P(op2) == IS_DOUBLE)) {
			d1 = (double)C_LVAL_P(op1);
			d2 = C_DVAL_P(op2);
			goto sub_double;
		}
	} else if (EXPECTED(C_TYPE_INFO_P(op1) == IS_DOUBLE)) {
		if (EXPECTED(C_TYPE_INFO_P(op2) == IS_DOUBLE)) {
			d1 = C_DVAL_P(op1);
			d2 = C_DVAL_P(op2);
sub_double:
			result = EX_VAR(opline->result.var);
			ZVAL_DOUBLE(result, d1 - d2);
			CREX_VM_NEXT_OPCODE();
		} else if (EXPECTED(C_TYPE_INFO_P(op2) == IS_LONG)) {
			d1 = C_DVAL_P(op1);
			d2 = (double)C_LVAL_P(op2);
			goto sub_double;
		}
	}

	CREX_VM_TAIL_CALL(crex_sub_helper_SPEC(op1, op2 CREX_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_MUL_SPEC_TMPVARCV_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2, *result;
	double d1, d2;

	op1 = EX_VAR(opline->op1.var);
	op2 = RT_CONSTANT(opline, opline->op2);
	if (1 && (IS_TMP_VAR|IS_VAR|IS_CV) == IS_CONST && IS_CONST == IS_CONST) {
		/* pass */
	} else if (EXPECTED(C_TYPE_INFO_P(op1) == IS_LONG)) {
		if (EXPECTED(C_TYPE_INFO_P(op2) == IS_LONG)) {
			crex_long overflow;

			result = EX_VAR(opline->result.var);
			CREX_SIGNED_MULTIPLY_LONG(C_LVAL_P(op1), C_LVAL_P(op2), C_LVAL_P(result), C_DVAL_P(result), overflow);
			C_TYPE_INFO_P(result) = overflow ? IS_DOUBLE : IS_LONG;
			CREX_VM_NEXT_OPCODE();
		} else if (EXPECTED(C_TYPE_INFO_P(op2) == IS_DOUBLE)) {
			d1 = (double)C_LVAL_P(op1);
			d2 = C_DVAL_P(op2);
			goto mul_double;
		}
	} else if (EXPECTED(C_TYPE_INFO_P(op1) == IS_DOUBLE)) {
		if (EXPECTED(C_TYPE_INFO_P(op2) == IS_DOUBLE)) {
			d1 = C_DVAL_P(op1);
			d2 = C_DVAL_P(op2);
mul_double:
			result = EX_VAR(opline->result.var);
			ZVAL_DOUBLE(result, d1 * d2);
			CREX_VM_NEXT_OPCODE();
		} else if (EXPECTED(C_TYPE_INFO_P(op2) == IS_LONG)) {
			d1 = C_DVAL_P(op1);
			d2 = (double)C_LVAL_P(op2);
			goto mul_double;
		}
	}

	CREX_VM_TAIL_CALL(crex_mul_helper_SPEC(op1, op2 CREX_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_MOD_SPEC_TMPVARCV_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2, *result;

	op1 = EX_VAR(opline->op1.var);
	op2 = RT_CONSTANT(opline, opline->op2);
	if (1 && (IS_TMP_VAR|IS_VAR|IS_CV) == IS_CONST && IS_CONST == IS_CONST) {
		/* pass */
	} else if (EXPECTED(C_TYPE_INFO_P(op1) == IS_LONG)) {
		if (EXPECTED(C_TYPE_INFO_P(op2) == IS_LONG)) {
			result = EX_VAR(opline->result.var);
			if (UNEXPECTED(C_LVAL_P(op2) == 0)) {
				CREX_VM_TAIL_CALL(crex_mod_by_zero_helper_SPEC(CREX_OPCODE_HANDLER_ARGS_PASSTHRU));
			} else if (UNEXPECTED(C_LVAL_P(op2) == -1)) {
				/* Prevent overflow error/crash if op1==CREX_LONG_MIN */
				ZVAL_LONG(result, 0);
			} else {
				ZVAL_LONG(result, C_LVAL_P(op1) % C_LVAL_P(op2));
			}
			CREX_VM_NEXT_OPCODE();
		}
	}

	CREX_VM_TAIL_CALL(crex_mod_helper_SPEC(op1, op2 CREX_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_SL_SPEC_TMPVARCV_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;

	op1 = EX_VAR(opline->op1.var);
	op2 = RT_CONSTANT(opline, opline->op2);
	if (1 && (IS_TMP_VAR|IS_VAR|IS_CV) == IS_CONST && IS_CONST == IS_CONST) {
		/* pass */
	} else if (EXPECTED(C_TYPE_INFO_P(op1) == IS_LONG)
			&& EXPECTED(C_TYPE_INFO_P(op2) == IS_LONG)
			&& EXPECTED((crex_ulong)C_LVAL_P(op2) < SIZEOF_CREX_LONG * 8)) {
		/* Perform shift on unsigned numbers to get well-defined wrap behavior. */
		ZVAL_LONG(EX_VAR(opline->result.var),
			(crex_long) ((crex_ulong) C_LVAL_P(op1) << C_LVAL_P(op2)));
		CREX_VM_NEXT_OPCODE();
	}

	CREX_VM_TAIL_CALL(crex_shift_left_helper_SPEC(op1, op2 CREX_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_SR_SPEC_TMPVARCV_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;

	op1 = EX_VAR(opline->op1.var);
	op2 = RT_CONSTANT(opline, opline->op2);
	if (1 && (IS_TMP_VAR|IS_VAR|IS_CV) == IS_CONST && IS_CONST == IS_CONST) {
		/* pass */
	} else if (EXPECTED(C_TYPE_INFO_P(op1) == IS_LONG)
			&& EXPECTED(C_TYPE_INFO_P(op2) == IS_LONG)
			&& EXPECTED((crex_ulong)C_LVAL_P(op2) < SIZEOF_CREX_LONG * 8)) {
		ZVAL_LONG(EX_VAR(opline->result.var), C_LVAL_P(op1) >> C_LVAL_P(op2));
		CREX_VM_NEXT_OPCODE();
	}

	CREX_VM_TAIL_CALL(crex_shift_right_helper_SPEC(op1, op2 CREX_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_IS_SMALLER_SPEC_TMPVARCV_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	double d1, d2;

	op1 = EX_VAR(opline->op1.var);
	op2 = RT_CONSTANT(opline, opline->op2);
	if (1 && (IS_TMP_VAR|IS_VAR|IS_CV) == IS_CONST && IS_CONST == IS_CONST) {
		/* pass */
	} else if (EXPECTED(C_TYPE_INFO_P(op1) == IS_LONG)) {
		if (EXPECTED(C_TYPE_INFO_P(op2) == IS_LONG)) {
			if (EXPECTED(C_LVAL_P(op1) < C_LVAL_P(op2))) {
is_smaller_true:
				CREX_VM_SMART_BRANCH_TRUE_NONE();
			} else {
is_smaller_false:
				CREX_VM_SMART_BRANCH_FALSE_NONE();
			}
		} else if (EXPECTED(C_TYPE_INFO_P(op2) == IS_DOUBLE)) {
			d1 = (double)C_LVAL_P(op1);
			d2 = C_DVAL_P(op2);
			goto is_smaller_double;
		}
	} else if (EXPECTED(C_TYPE_INFO_P(op1) == IS_DOUBLE)) {
		if (EXPECTED(C_TYPE_INFO_P(op2) == IS_DOUBLE)) {
			d1 = C_DVAL_P(op1);
			d2 = C_DVAL_P(op2);
is_smaller_double:
			if (d1 < d2) {
				goto is_smaller_true;
			} else {
				goto is_smaller_false;
			}
		} else if (EXPECTED(C_TYPE_INFO_P(op2) == IS_LONG)) {
			d1 = C_DVAL_P(op1);
			d2 = (double)C_LVAL_P(op2);
			goto is_smaller_double;
		}
	}
	CREX_VM_TAIL_CALL(crex_is_smaller_helper_SPEC(op1, op2 CREX_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static CREX_VM_HOT CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_IS_SMALLER_SPEC_TMPVARCV_CONST_JMPC_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	double d1, d2;

	op1 = EX_VAR(opline->op1.var);
	op2 = RT_CONSTANT(opline, opline->op2);
	if (1 && (IS_TMP_VAR|IS_VAR|IS_CV) == IS_CONST && IS_CONST == IS_CONST) {
		/* pass */
	} else if (EXPECTED(C_TYPE_INFO_P(op1) == IS_LONG)) {
		if (EXPECTED(C_TYPE_INFO_P(op2) == IS_LONG)) {
			if (EXPECTED(C_LVAL_P(op1) < C_LVAL_P(op2))) {
is_smaller_true:
				CREX_VM_SMART_BRANCH_TRUE_JMPZ();
			} else {
is_smaller_false:
				CREX_VM_SMART_BRANCH_FALSE_JMPZ();
			}
		} else if (EXPECTED(C_TYPE_INFO_P(op2) == IS_DOUBLE)) {
			d1 = (double)C_LVAL_P(op1);
			d2 = C_DVAL_P(op2);
			goto is_smaller_double;
		}
	} else if (EXPECTED(C_TYPE_INFO_P(op1) == IS_DOUBLE)) {
		if (EXPECTED(C_TYPE_INFO_P(op2) == IS_DOUBLE)) {
			d1 = C_DVAL_P(op1);
			d2 = C_DVAL_P(op2);
is_smaller_double:
			if (d1 < d2) {
				goto is_smaller_true;
			} else {
				goto is_smaller_false;
			}
		} else if (EXPECTED(C_TYPE_INFO_P(op2) == IS_LONG)) {
			d1 = C_DVAL_P(op1);
			d2 = (double)C_LVAL_P(op2);
			goto is_smaller_double;
		}
	}
	CREX_VM_TAIL_CALL(crex_is_smaller_helper_SPEC(op1, op2 CREX_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static CREX_VM_HOT CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_IS_SMALLER_SPEC_TMPVARCV_CONST_JMPNC_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	double d1, d2;

	op1 = EX_VAR(opline->op1.var);
	op2 = RT_CONSTANT(opline, opline->op2);
	if (1 && (IS_TMP_VAR|IS_VAR|IS_CV) == IS_CONST && IS_CONST == IS_CONST) {
		/* pass */
	} else if (EXPECTED(C_TYPE_INFO_P(op1) == IS_LONG)) {
		if (EXPECTED(C_TYPE_INFO_P(op2) == IS_LONG)) {
			if (EXPECTED(C_LVAL_P(op1) < C_LVAL_P(op2))) {
is_smaller_true:
				CREX_VM_SMART_BRANCH_TRUE_JMPNZ();
			} else {
is_smaller_false:
				CREX_VM_SMART_BRANCH_FALSE_JMPNZ();
			}
		} else if (EXPECTED(C_TYPE_INFO_P(op2) == IS_DOUBLE)) {
			d1 = (double)C_LVAL_P(op1);
			d2 = C_DVAL_P(op2);
			goto is_smaller_double;
		}
	} else if (EXPECTED(C_TYPE_INFO_P(op1) == IS_DOUBLE)) {
		if (EXPECTED(C_TYPE_INFO_P(op2) == IS_DOUBLE)) {
			d1 = C_DVAL_P(op1);
			d2 = C_DVAL_P(op2);
is_smaller_double:
			if (d1 < d2) {
				goto is_smaller_true;
			} else {
				goto is_smaller_false;
			}
		} else if (EXPECTED(C_TYPE_INFO_P(op2) == IS_LONG)) {
			d1 = C_DVAL_P(op1);
			d2 = (double)C_LVAL_P(op2);
			goto is_smaller_double;
		}
	}
	CREX_VM_TAIL_CALL(crex_is_smaller_helper_SPEC(op1, op2 CREX_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_IS_SMALLER_OR_EQUAL_SPEC_TMPVARCV_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	double d1, d2;

	op1 = EX_VAR(opline->op1.var);
	op2 = RT_CONSTANT(opline, opline->op2);
	if (1 && (IS_TMP_VAR|IS_VAR|IS_CV) == IS_CONST && IS_CONST == IS_CONST) {
		/* pass */
	} else if (EXPECTED(C_TYPE_INFO_P(op1) == IS_LONG)) {
		if (EXPECTED(C_TYPE_INFO_P(op2) == IS_LONG)) {
			if (EXPECTED(C_LVAL_P(op1) <= C_LVAL_P(op2))) {
is_smaller_or_equal_true:
				CREX_VM_SMART_BRANCH_TRUE_NONE();
				ZVAL_TRUE(EX_VAR(opline->result.var));
				CREX_VM_NEXT_OPCODE();
			} else {
is_smaller_or_equal_false:
				CREX_VM_SMART_BRANCH_FALSE_NONE();
				ZVAL_FALSE(EX_VAR(opline->result.var));
				CREX_VM_NEXT_OPCODE();
			}
		} else if (EXPECTED(C_TYPE_INFO_P(op2) == IS_DOUBLE)) {
			d1 = (double)C_LVAL_P(op1);
			d2 = C_DVAL_P(op2);
			goto is_smaller_or_equal_double;
		}
	} else if (EXPECTED(C_TYPE_INFO_P(op1) == IS_DOUBLE)) {
		if (EXPECTED(C_TYPE_INFO_P(op2) == IS_DOUBLE)) {
			d1 = C_DVAL_P(op1);
			d2 = C_DVAL_P(op2);
is_smaller_or_equal_double:
			if (d1 <= d2) {
				goto is_smaller_or_equal_true;
			} else {
				goto is_smaller_or_equal_false;
			}
		} else if (EXPECTED(C_TYPE_INFO_P(op2) == IS_LONG)) {
			d1 = C_DVAL_P(op1);
			d2 = (double)C_LVAL_P(op2);
			goto is_smaller_or_equal_double;
		}
	}
	CREX_VM_TAIL_CALL(crex_is_smaller_or_equal_helper_SPEC(op1, op2 CREX_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static CREX_VM_HOT CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_IS_SMALLER_OR_EQUAL_SPEC_TMPVARCV_CONST_JMPC_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	double d1, d2;

	op1 = EX_VAR(opline->op1.var);
	op2 = RT_CONSTANT(opline, opline->op2);
	if (1 && (IS_TMP_VAR|IS_VAR|IS_CV) == IS_CONST && IS_CONST == IS_CONST) {
		/* pass */
	} else if (EXPECTED(C_TYPE_INFO_P(op1) == IS_LONG)) {
		if (EXPECTED(C_TYPE_INFO_P(op2) == IS_LONG)) {
			if (EXPECTED(C_LVAL_P(op1) <= C_LVAL_P(op2))) {
is_smaller_or_equal_true:
				CREX_VM_SMART_BRANCH_TRUE_JMPZ();
				ZVAL_TRUE(EX_VAR(opline->result.var));
				CREX_VM_NEXT_OPCODE();
			} else {
is_smaller_or_equal_false:
				CREX_VM_SMART_BRANCH_FALSE_JMPZ();
				ZVAL_FALSE(EX_VAR(opline->result.var));
				CREX_VM_NEXT_OPCODE();
			}
		} else if (EXPECTED(C_TYPE_INFO_P(op2) == IS_DOUBLE)) {
			d1 = (double)C_LVAL_P(op1);
			d2 = C_DVAL_P(op2);
			goto is_smaller_or_equal_double;
		}
	} else if (EXPECTED(C_TYPE_INFO_P(op1) == IS_DOUBLE)) {
		if (EXPECTED(C_TYPE_INFO_P(op2) == IS_DOUBLE)) {
			d1 = C_DVAL_P(op1);
			d2 = C_DVAL_P(op2);
is_smaller_or_equal_double:
			if (d1 <= d2) {
				goto is_smaller_or_equal_true;
			} else {
				goto is_smaller_or_equal_false;
			}
		} else if (EXPECTED(C_TYPE_INFO_P(op2) == IS_LONG)) {
			d1 = C_DVAL_P(op1);
			d2 = (double)C_LVAL_P(op2);
			goto is_smaller_or_equal_double;
		}
	}
	CREX_VM_TAIL_CALL(crex_is_smaller_or_equal_helper_SPEC(op1, op2 CREX_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static CREX_VM_HOT CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_IS_SMALLER_OR_EQUAL_SPEC_TMPVARCV_CONST_JMPNC_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	double d1, d2;

	op1 = EX_VAR(opline->op1.var);
	op2 = RT_CONSTANT(opline, opline->op2);
	if (1 && (IS_TMP_VAR|IS_VAR|IS_CV) == IS_CONST && IS_CONST == IS_CONST) {
		/* pass */
	} else if (EXPECTED(C_TYPE_INFO_P(op1) == IS_LONG)) {
		if (EXPECTED(C_TYPE_INFO_P(op2) == IS_LONG)) {
			if (EXPECTED(C_LVAL_P(op1) <= C_LVAL_P(op2))) {
is_smaller_or_equal_true:
				CREX_VM_SMART_BRANCH_TRUE_JMPNZ();
				ZVAL_TRUE(EX_VAR(opline->result.var));
				CREX_VM_NEXT_OPCODE();
			} else {
is_smaller_or_equal_false:
				CREX_VM_SMART_BRANCH_FALSE_JMPNZ();
				ZVAL_FALSE(EX_VAR(opline->result.var));
				CREX_VM_NEXT_OPCODE();
			}
		} else if (EXPECTED(C_TYPE_INFO_P(op2) == IS_DOUBLE)) {
			d1 = (double)C_LVAL_P(op1);
			d2 = C_DVAL_P(op2);
			goto is_smaller_or_equal_double;
		}
	} else if (EXPECTED(C_TYPE_INFO_P(op1) == IS_DOUBLE)) {
		if (EXPECTED(C_TYPE_INFO_P(op2) == IS_DOUBLE)) {
			d1 = C_DVAL_P(op1);
			d2 = C_DVAL_P(op2);
is_smaller_or_equal_double:
			if (d1 <= d2) {
				goto is_smaller_or_equal_true;
			} else {
				goto is_smaller_or_equal_false;
			}
		} else if (EXPECTED(C_TYPE_INFO_P(op2) == IS_LONG)) {
			d1 = C_DVAL_P(op1);
			d2 = (double)C_LVAL_P(op2);
			goto is_smaller_or_equal_double;
		}
	}
	CREX_VM_TAIL_CALL(crex_is_smaller_or_equal_helper_SPEC(op1, op2 CREX_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static CREX_VM_HOT CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_BW_OR_SPEC_TMPVARCV_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;

	op1 = EX_VAR(opline->op1.var);
	op2 = RT_CONSTANT(opline, opline->op2);
	if (1 && (IS_TMP_VAR|IS_VAR|IS_CV) == IS_CONST && IS_CONST == IS_CONST) {
		/* pass */
	} else if (EXPECTED(C_TYPE_INFO_P(op1) == IS_LONG)
			&& EXPECTED(C_TYPE_INFO_P(op2) == IS_LONG)) {
		ZVAL_LONG(EX_VAR(opline->result.var), C_LVAL_P(op1) | C_LVAL_P(op2));
		CREX_VM_NEXT_OPCODE();
	}

	CREX_VM_TAIL_CALL(crex_bw_or_helper_SPEC(op1, op2 CREX_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static CREX_VM_HOT CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_BW_AND_SPEC_TMPVARCV_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;

	op1 = EX_VAR(opline->op1.var);
	op2 = RT_CONSTANT(opline, opline->op2);
	if (1 && (IS_TMP_VAR|IS_VAR|IS_CV) == IS_CONST && IS_CONST == IS_CONST) {
		/* pass */
	} else if (EXPECTED(C_TYPE_INFO_P(op1) == IS_LONG)
			&& EXPECTED(C_TYPE_INFO_P(op2) == IS_LONG)) {
		ZVAL_LONG(EX_VAR(opline->result.var), C_LVAL_P(op1) & C_LVAL_P(op2));
		CREX_VM_NEXT_OPCODE();
	}

	CREX_VM_TAIL_CALL(crex_bw_and_helper_SPEC(op1, op2 CREX_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static CREX_VM_HOT CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_BW_XOR_SPEC_TMPVARCV_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;

	op1 = EX_VAR(opline->op1.var);
	op2 = RT_CONSTANT(opline, opline->op2);
	if (1 && (IS_TMP_VAR|IS_VAR|IS_CV) == IS_CONST && IS_CONST == IS_CONST) {
		/* pass */
	} else if (EXPECTED(C_TYPE_INFO_P(op1) == IS_LONG)
			&& EXPECTED(C_TYPE_INFO_P(op2) == IS_LONG)) {
		ZVAL_LONG(EX_VAR(opline->result.var), C_LVAL_P(op1) ^ C_LVAL_P(op2));
		CREX_VM_NEXT_OPCODE();
	}

	CREX_VM_TAIL_CALL(crex_bw_xor_helper_SPEC(op1, op2 CREX_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FETCH_LIST_R_SPEC_TMPVARCV_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;

	SAVE_OPLINE();
	container = EX_VAR(opline->op1.var);
	crex_fetch_dimension_address_LIST_r(container, RT_CONSTANT(opline, opline->op2), IS_CONST OPLINE_CC EXECUTE_DATA_CC);

	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_SWITCH_LONG_SPEC_TMPVARCV_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op, *jump_zv;
	HashTable *jumptable;

	op = EX_VAR(opline->op1.var);

	if (C_TYPE_P(op) != IS_LONG) {
		ZVAL_DEREF(op);
		if (C_TYPE_P(op) != IS_LONG) {
			/* Wrong type, fall back to CREX_CASE chain */
			CREX_VM_NEXT_OPCODE();
		}
	}

	jumptable = C_ARRVAL_P(RT_CONSTANT(opline, opline->op2));
	jump_zv = crex_hash_index_find(jumptable, C_LVAL_P(op));
	if (jump_zv != NULL) {
		CREX_VM_SET_RELATIVE_OPCODE(opline, C_LVAL_P(jump_zv));
		CREX_VM_CONTINUE();
	} else {
		/* default */
		CREX_VM_SET_RELATIVE_OPCODE(opline, opline->extended_value);
		CREX_VM_CONTINUE();
	}
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_SWITCH_STRING_SPEC_TMPVARCV_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op, *jump_zv;
	HashTable *jumptable;

	op = EX_VAR(opline->op1.var);

	if (C_TYPE_P(op) != IS_STRING) {
		if ((IS_TMP_VAR|IS_VAR|IS_CV) == IS_CONST) {
			/* Wrong type, fall back to CREX_CASE chain */
			CREX_VM_NEXT_OPCODE();
		} else {
			ZVAL_DEREF(op);
			if (C_TYPE_P(op) != IS_STRING) {
				/* Wrong type, fall back to CREX_CASE chain */
				CREX_VM_NEXT_OPCODE();
			}
		}
	}

	jumptable = C_ARRVAL_P(RT_CONSTANT(opline, opline->op2));
	jump_zv = crex_hash_find_ex(jumptable, C_STR_P(op), (IS_TMP_VAR|IS_VAR|IS_CV) == IS_CONST);
	if (jump_zv != NULL) {
		CREX_VM_SET_RELATIVE_OPCODE(opline, C_LVAL_P(jump_zv));
		CREX_VM_CONTINUE();
	} else {
		/* default */
		CREX_VM_SET_RELATIVE_OPCODE(opline, opline->extended_value);
		CREX_VM_CONTINUE();
	}
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_MATCH_SPEC_TMPVARCV_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op, *jump_zv;
	HashTable *jumptable;

	op = EX_VAR(opline->op1.var);
	jumptable = C_ARRVAL_P(RT_CONSTANT(opline, opline->op2));

match_try_again:
	if (C_TYPE_P(op) == IS_LONG) {
		jump_zv = crex_hash_index_find(jumptable, C_LVAL_P(op));
	} else if (C_TYPE_P(op) == IS_STRING) {
		jump_zv = crex_hash_find_ex(jumptable, C_STR_P(op), (IS_TMP_VAR|IS_VAR|IS_CV) == IS_CONST);
	} else if (C_TYPE_P(op) == IS_REFERENCE) {
		op = C_REFVAL_P(op);
		goto match_try_again;
	} else {
		if (UNEXPECTED(((IS_TMP_VAR|IS_VAR|IS_CV) & IS_CV) && C_TYPE_P(op) == IS_UNDEF)) {
			SAVE_OPLINE();
			op = ZVAL_UNDEFINED_OP1();
			if (UNEXPECTED(EG(exception))) {
				HANDLE_EXCEPTION();
			}
			goto match_try_again;
		}

		goto default_branch;
	}

	if (jump_zv != NULL) {
		CREX_VM_SET_RELATIVE_OPCODE(opline, C_LVAL_P(jump_zv));
		CREX_VM_CONTINUE();
	} else {
default_branch:
		/* default */
		CREX_VM_SET_RELATIVE_OPCODE(opline, opline->extended_value);
		CREX_VM_CONTINUE();
	}
}

static CREX_VM_HOT CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ADD_LONG_NO_OVERFLOW_SPEC_TMPVARCV_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2, *result;

	op1 = EX_VAR(opline->op1.var);
	op2 = RT_CONSTANT(opline, opline->op2);
	result = EX_VAR(opline->result.var);
	ZVAL_LONG(result, C_LVAL_P(op1) + C_LVAL_P(op2));
	CREX_VM_NEXT_OPCODE();
}

static CREX_VM_HOT CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ADD_LONG_SPEC_TMPVARCV_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2, *result;

	op1 = EX_VAR(opline->op1.var);
	op2 = RT_CONSTANT(opline, opline->op2);
	result = EX_VAR(opline->result.var);
	fast_long_add_function(result, op1, op2);
	CREX_VM_NEXT_OPCODE();
}

static CREX_VM_HOT CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ADD_DOUBLE_SPEC_TMPVARCV_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2, *result;

	op1 = EX_VAR(opline->op1.var);
	op2 = RT_CONSTANT(opline, opline->op2);
	result = EX_VAR(opline->result.var);
	ZVAL_DOUBLE(result, C_DVAL_P(op1) + C_DVAL_P(op2));
	CREX_VM_NEXT_OPCODE();
}

static CREX_VM_HOT CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_SUB_LONG_NO_OVERFLOW_SPEC_TMPVARCV_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2, *result;

	op1 = EX_VAR(opline->op1.var);
	op2 = RT_CONSTANT(opline, opline->op2);
	result = EX_VAR(opline->result.var);
	ZVAL_LONG(result, C_LVAL_P(op1) - C_LVAL_P(op2));
	CREX_VM_NEXT_OPCODE();
}

static CREX_VM_HOT CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_SUB_LONG_SPEC_TMPVARCV_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2, *result;

	op1 = EX_VAR(opline->op1.var);
	op2 = RT_CONSTANT(opline, opline->op2);
	result = EX_VAR(opline->result.var);
	fast_long_sub_function(result, op1, op2);
	CREX_VM_NEXT_OPCODE();
}

static CREX_VM_HOT CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_SUB_DOUBLE_SPEC_TMPVARCV_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2, *result;

	op1 = EX_VAR(opline->op1.var);
	op2 = RT_CONSTANT(opline, opline->op2);
	result = EX_VAR(opline->result.var);
	ZVAL_DOUBLE(result, C_DVAL_P(op1) - C_DVAL_P(op2));
	CREX_VM_NEXT_OPCODE();
}

static CREX_VM_HOT CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_MUL_LONG_NO_OVERFLOW_SPEC_TMPVARCV_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2, *result;

	op1 = EX_VAR(opline->op1.var);
	op2 = RT_CONSTANT(opline, opline->op2);
	result = EX_VAR(opline->result.var);
	ZVAL_LONG(result, C_LVAL_P(op1) * C_LVAL_P(op2));
	CREX_VM_NEXT_OPCODE();
}

static CREX_VM_HOT CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_MUL_LONG_SPEC_TMPVARCV_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2, *result;
	crex_long overflow;

	op1 = EX_VAR(opline->op1.var);
	op2 = RT_CONSTANT(opline, opline->op2);
	result = EX_VAR(opline->result.var);
	CREX_SIGNED_MULTIPLY_LONG(C_LVAL_P(op1), C_LVAL_P(op2), C_LVAL_P(result), C_DVAL_P(result), overflow);
	C_TYPE_INFO_P(result) = overflow ? IS_DOUBLE : IS_LONG;
	CREX_VM_NEXT_OPCODE();
}

static CREX_VM_HOT CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_MUL_DOUBLE_SPEC_TMPVARCV_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2, *result;

	op1 = EX_VAR(opline->op1.var);
	op2 = RT_CONSTANT(opline, opline->op2);
	result = EX_VAR(opline->result.var);
	ZVAL_DOUBLE(result, C_DVAL_P(op1) * C_DVAL_P(op2));
	CREX_VM_NEXT_OPCODE();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_IS_EQUAL_LONG_SPEC_TMPVARCV_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	bool result;

	op1 = EX_VAR(opline->op1.var);
	op2 = RT_CONSTANT(opline, opline->op2);
	result = (C_LVAL_P(op1) == C_LVAL_P(op2));
	CREX_VM_SMART_BRANCH_NONE(result, 0);
}

static CREX_VM_HOT CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_IS_EQUAL_LONG_SPEC_TMPVARCV_CONST_JMPC_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	bool result;

	op1 = EX_VAR(opline->op1.var);
	op2 = RT_CONSTANT(opline, opline->op2);
	result = (C_LVAL_P(op1) == C_LVAL_P(op2));
	CREX_VM_SMART_BRANCH_JMPZ(result, 0);
}

static CREX_VM_HOT CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_IS_EQUAL_LONG_SPEC_TMPVARCV_CONST_JMPNC_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	bool result;

	op1 = EX_VAR(opline->op1.var);
	op2 = RT_CONSTANT(opline, opline->op2);
	result = (C_LVAL_P(op1) == C_LVAL_P(op2));
	CREX_VM_SMART_BRANCH_JMPNZ(result, 0);
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_IS_EQUAL_DOUBLE_SPEC_TMPVARCV_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	bool result;

	op1 = EX_VAR(opline->op1.var);
	op2 = RT_CONSTANT(opline, opline->op2);
	result = (C_DVAL_P(op1) == C_DVAL_P(op2));
	CREX_VM_SMART_BRANCH_NONE(result, 0);
}

static CREX_VM_HOT CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_IS_EQUAL_DOUBLE_SPEC_TMPVARCV_CONST_JMPC_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	bool result;

	op1 = EX_VAR(opline->op1.var);
	op2 = RT_CONSTANT(opline, opline->op2);
	result = (C_DVAL_P(op1) == C_DVAL_P(op2));
	CREX_VM_SMART_BRANCH_JMPZ(result, 0);
}

static CREX_VM_HOT CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_IS_EQUAL_DOUBLE_SPEC_TMPVARCV_CONST_JMPNC_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	bool result;

	op1 = EX_VAR(opline->op1.var);
	op2 = RT_CONSTANT(opline, opline->op2);
	result = (C_DVAL_P(op1) == C_DVAL_P(op2));
	CREX_VM_SMART_BRANCH_JMPNZ(result, 0);
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_IS_NOT_EQUAL_LONG_SPEC_TMPVARCV_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	bool result;

	op1 = EX_VAR(opline->op1.var);
	op2 = RT_CONSTANT(opline, opline->op2);
	result = (C_LVAL_P(op1) != C_LVAL_P(op2));
	CREX_VM_SMART_BRANCH_NONE(result, 0);
}

static CREX_VM_HOT CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_IS_NOT_EQUAL_LONG_SPEC_TMPVARCV_CONST_JMPC_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	bool result;

	op1 = EX_VAR(opline->op1.var);
	op2 = RT_CONSTANT(opline, opline->op2);
	result = (C_LVAL_P(op1) != C_LVAL_P(op2));
	CREX_VM_SMART_BRANCH_JMPZ(result, 0);
}

static CREX_VM_HOT CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_IS_NOT_EQUAL_LONG_SPEC_TMPVARCV_CONST_JMPNC_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	bool result;

	op1 = EX_VAR(opline->op1.var);
	op2 = RT_CONSTANT(opline, opline->op2);
	result = (C_LVAL_P(op1) != C_LVAL_P(op2));
	CREX_VM_SMART_BRANCH_JMPNZ(result, 0);
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_IS_NOT_EQUAL_DOUBLE_SPEC_TMPVARCV_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	bool result;

	op1 = EX_VAR(opline->op1.var);
	op2 = RT_CONSTANT(opline, opline->op2);
	result = (C_DVAL_P(op1) != C_DVAL_P(op2));
	CREX_VM_SMART_BRANCH_NONE(result, 0);
}

static CREX_VM_HOT CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_IS_NOT_EQUAL_DOUBLE_SPEC_TMPVARCV_CONST_JMPC_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	bool result;

	op1 = EX_VAR(opline->op1.var);
	op2 = RT_CONSTANT(opline, opline->op2);
	result = (C_DVAL_P(op1) != C_DVAL_P(op2));
	CREX_VM_SMART_BRANCH_JMPZ(result, 0);
}

static CREX_VM_HOT CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_IS_NOT_EQUAL_DOUBLE_SPEC_TMPVARCV_CONST_JMPNC_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	bool result;

	op1 = EX_VAR(opline->op1.var);
	op2 = RT_CONSTANT(opline, opline->op2);
	result = (C_DVAL_P(op1) != C_DVAL_P(op2));
	CREX_VM_SMART_BRANCH_JMPNZ(result, 0);
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_IS_SMALLER_LONG_SPEC_TMPVARCV_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	bool result;

	op1 = EX_VAR(opline->op1.var);
	op2 = RT_CONSTANT(opline, opline->op2);
	result = (C_LVAL_P(op1) < C_LVAL_P(op2));
	CREX_VM_SMART_BRANCH_NONE(result, 0);
}

static CREX_VM_HOT CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_IS_SMALLER_LONG_SPEC_TMPVARCV_CONST_JMPC_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	bool result;

	op1 = EX_VAR(opline->op1.var);
	op2 = RT_CONSTANT(opline, opline->op2);
	result = (C_LVAL_P(op1) < C_LVAL_P(op2));
	CREX_VM_SMART_BRANCH_JMPZ(result, 0);
}

static CREX_VM_HOT CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_IS_SMALLER_LONG_SPEC_TMPVARCV_CONST_JMPNC_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	bool result;

	op1 = EX_VAR(opline->op1.var);
	op2 = RT_CONSTANT(opline, opline->op2);
	result = (C_LVAL_P(op1) < C_LVAL_P(op2));
	CREX_VM_SMART_BRANCH_JMPNZ(result, 0);
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_IS_SMALLER_DOUBLE_SPEC_TMPVARCV_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	bool result;

	op1 = EX_VAR(opline->op1.var);
	op2 = RT_CONSTANT(opline, opline->op2);
	result = (C_DVAL_P(op1) < C_DVAL_P(op2));
	CREX_VM_SMART_BRANCH_NONE(result, 0);
}

static CREX_VM_HOT CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_IS_SMALLER_DOUBLE_SPEC_TMPVARCV_CONST_JMPC_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	bool result;

	op1 = EX_VAR(opline->op1.var);
	op2 = RT_CONSTANT(opline, opline->op2);
	result = (C_DVAL_P(op1) < C_DVAL_P(op2));
	CREX_VM_SMART_BRANCH_JMPZ(result, 0);
}

static CREX_VM_HOT CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_IS_SMALLER_DOUBLE_SPEC_TMPVARCV_CONST_JMPNC_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	bool result;

	op1 = EX_VAR(opline->op1.var);
	op2 = RT_CONSTANT(opline, opline->op2);
	result = (C_DVAL_P(op1) < C_DVAL_P(op2));
	CREX_VM_SMART_BRANCH_JMPNZ(result, 0);
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_IS_SMALLER_OR_EQUAL_LONG_SPEC_TMPVARCV_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	bool result;

	op1 = EX_VAR(opline->op1.var);
	op2 = RT_CONSTANT(opline, opline->op2);
	result = (C_LVAL_P(op1) <= C_LVAL_P(op2));
	CREX_VM_SMART_BRANCH_NONE(result, 0);
}

static CREX_VM_HOT CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_IS_SMALLER_OR_EQUAL_LONG_SPEC_TMPVARCV_CONST_JMPC_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	bool result;

	op1 = EX_VAR(opline->op1.var);
	op2 = RT_CONSTANT(opline, opline->op2);
	result = (C_LVAL_P(op1) <= C_LVAL_P(op2));
	CREX_VM_SMART_BRANCH_JMPZ(result, 0);
}

static CREX_VM_HOT CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_IS_SMALLER_OR_EQUAL_LONG_SPEC_TMPVARCV_CONST_JMPNC_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	bool result;

	op1 = EX_VAR(opline->op1.var);
	op2 = RT_CONSTANT(opline, opline->op2);
	result = (C_LVAL_P(op1) <= C_LVAL_P(op2));
	CREX_VM_SMART_BRANCH_JMPNZ(result, 0);
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_TMPVARCV_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	bool result;

	op1 = EX_VAR(opline->op1.var);
	op2 = RT_CONSTANT(opline, opline->op2);
	result = (C_DVAL_P(op1) <= C_DVAL_P(op2));
	CREX_VM_SMART_BRANCH_NONE(result, 0);
}

static CREX_VM_HOT CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_TMPVARCV_CONST_JMPC_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	bool result;

	op1 = EX_VAR(opline->op1.var);
	op2 = RT_CONSTANT(opline, opline->op2);
	result = (C_DVAL_P(op1) <= C_DVAL_P(op2));
	CREX_VM_SMART_BRANCH_JMPZ(result, 0);
}

static CREX_VM_HOT CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_TMPVARCV_CONST_JMPNC_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	bool result;

	op1 = EX_VAR(opline->op1.var);
	op2 = RT_CONSTANT(opline, opline->op2);
	result = (C_DVAL_P(op1) <= C_DVAL_P(op2));
	CREX_VM_SMART_BRANCH_JMPNZ(result, 0);
}

static CREX_VM_HOT CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ADD_SPEC_TMPVARCV_TMPVARCV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2, *result;
	double d1, d2;

	op1 = EX_VAR(opline->op1.var);
	op2 = EX_VAR(opline->op2.var);
	if (1 && (IS_TMP_VAR|IS_VAR|IS_CV) == IS_CONST && (IS_TMP_VAR|IS_VAR|IS_CV) == IS_CONST) {
		/* pass */
	} else if (EXPECTED(C_TYPE_INFO_P(op1) == IS_LONG)) {
		if (EXPECTED(C_TYPE_INFO_P(op2) == IS_LONG)) {
			result = EX_VAR(opline->result.var);
			fast_long_add_function(result, op1, op2);
			CREX_VM_NEXT_OPCODE();
		} else if (EXPECTED(C_TYPE_INFO_P(op2) == IS_DOUBLE)) {
			d1 = (double)C_LVAL_P(op1);
			d2 = C_DVAL_P(op2);
			goto add_double;
		}
	} else if (EXPECTED(C_TYPE_INFO_P(op1) == IS_DOUBLE)) {
		if (EXPECTED(C_TYPE_INFO_P(op2) == IS_DOUBLE)) {
			d1 = C_DVAL_P(op1);
			d2 = C_DVAL_P(op2);
add_double:
			result = EX_VAR(opline->result.var);
			ZVAL_DOUBLE(result, d1 + d2);
			CREX_VM_NEXT_OPCODE();
		} else if (EXPECTED(C_TYPE_INFO_P(op2) == IS_LONG)) {
			d1 = C_DVAL_P(op1);
			d2 = (double)C_LVAL_P(op2);
			goto add_double;
		}
	}

	CREX_VM_TAIL_CALL(crex_add_helper_SPEC(op1, op2 CREX_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static CREX_VM_HOT CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_SUB_SPEC_TMPVARCV_TMPVARCV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2, *result;
	double d1, d2;

	op1 = EX_VAR(opline->op1.var);
	op2 = EX_VAR(opline->op2.var);
	if (1 && (IS_TMP_VAR|IS_VAR|IS_CV) == IS_CONST && (IS_TMP_VAR|IS_VAR|IS_CV) == IS_CONST) {
		/* pass */
	} else if (EXPECTED(C_TYPE_INFO_P(op1) == IS_LONG)) {
		if (EXPECTED(C_TYPE_INFO_P(op2) == IS_LONG)) {
			result = EX_VAR(opline->result.var);
			fast_long_sub_function(result, op1, op2);
			CREX_VM_NEXT_OPCODE();
		} else if (EXPECTED(C_TYPE_INFO_P(op2) == IS_DOUBLE)) {
			d1 = (double)C_LVAL_P(op1);
			d2 = C_DVAL_P(op2);
			goto sub_double;
		}
	} else if (EXPECTED(C_TYPE_INFO_P(op1) == IS_DOUBLE)) {
		if (EXPECTED(C_TYPE_INFO_P(op2) == IS_DOUBLE)) {
			d1 = C_DVAL_P(op1);
			d2 = C_DVAL_P(op2);
sub_double:
			result = EX_VAR(opline->result.var);
			ZVAL_DOUBLE(result, d1 - d2);
			CREX_VM_NEXT_OPCODE();
		} else if (EXPECTED(C_TYPE_INFO_P(op2) == IS_LONG)) {
			d1 = C_DVAL_P(op1);
			d2 = (double)C_LVAL_P(op2);
			goto sub_double;
		}
	}

	CREX_VM_TAIL_CALL(crex_sub_helper_SPEC(op1, op2 CREX_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_MUL_SPEC_TMPVARCV_TMPVARCV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2, *result;
	double d1, d2;

	op1 = EX_VAR(opline->op1.var);
	op2 = EX_VAR(opline->op2.var);
	if (1 && (IS_TMP_VAR|IS_VAR|IS_CV) == IS_CONST && (IS_TMP_VAR|IS_VAR|IS_CV) == IS_CONST) {
		/* pass */
	} else if (EXPECTED(C_TYPE_INFO_P(op1) == IS_LONG)) {
		if (EXPECTED(C_TYPE_INFO_P(op2) == IS_LONG)) {
			crex_long overflow;

			result = EX_VAR(opline->result.var);
			CREX_SIGNED_MULTIPLY_LONG(C_LVAL_P(op1), C_LVAL_P(op2), C_LVAL_P(result), C_DVAL_P(result), overflow);
			C_TYPE_INFO_P(result) = overflow ? IS_DOUBLE : IS_LONG;
			CREX_VM_NEXT_OPCODE();
		} else if (EXPECTED(C_TYPE_INFO_P(op2) == IS_DOUBLE)) {
			d1 = (double)C_LVAL_P(op1);
			d2 = C_DVAL_P(op2);
			goto mul_double;
		}
	} else if (EXPECTED(C_TYPE_INFO_P(op1) == IS_DOUBLE)) {
		if (EXPECTED(C_TYPE_INFO_P(op2) == IS_DOUBLE)) {
			d1 = C_DVAL_P(op1);
			d2 = C_DVAL_P(op2);
mul_double:
			result = EX_VAR(opline->result.var);
			ZVAL_DOUBLE(result, d1 * d2);
			CREX_VM_NEXT_OPCODE();
		} else if (EXPECTED(C_TYPE_INFO_P(op2) == IS_LONG)) {
			d1 = C_DVAL_P(op1);
			d2 = (double)C_LVAL_P(op2);
			goto mul_double;
		}
	}

	CREX_VM_TAIL_CALL(crex_mul_helper_SPEC(op1, op2 CREX_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_MOD_SPEC_TMPVARCV_TMPVARCV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2, *result;

	op1 = EX_VAR(opline->op1.var);
	op2 = EX_VAR(opline->op2.var);
	if (1 && (IS_TMP_VAR|IS_VAR|IS_CV) == IS_CONST && (IS_TMP_VAR|IS_VAR|IS_CV) == IS_CONST) {
		/* pass */
	} else if (EXPECTED(C_TYPE_INFO_P(op1) == IS_LONG)) {
		if (EXPECTED(C_TYPE_INFO_P(op2) == IS_LONG)) {
			result = EX_VAR(opline->result.var);
			if (UNEXPECTED(C_LVAL_P(op2) == 0)) {
				CREX_VM_TAIL_CALL(crex_mod_by_zero_helper_SPEC(CREX_OPCODE_HANDLER_ARGS_PASSTHRU));
			} else if (UNEXPECTED(C_LVAL_P(op2) == -1)) {
				/* Prevent overflow error/crash if op1==CREX_LONG_MIN */
				ZVAL_LONG(result, 0);
			} else {
				ZVAL_LONG(result, C_LVAL_P(op1) % C_LVAL_P(op2));
			}
			CREX_VM_NEXT_OPCODE();
		}
	}

	CREX_VM_TAIL_CALL(crex_mod_helper_SPEC(op1, op2 CREX_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_SL_SPEC_TMPVARCV_TMPVARCV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;

	op1 = EX_VAR(opline->op1.var);
	op2 = EX_VAR(opline->op2.var);
	if (1 && (IS_TMP_VAR|IS_VAR|IS_CV) == IS_CONST && (IS_TMP_VAR|IS_VAR|IS_CV) == IS_CONST) {
		/* pass */
	} else if (EXPECTED(C_TYPE_INFO_P(op1) == IS_LONG)
			&& EXPECTED(C_TYPE_INFO_P(op2) == IS_LONG)
			&& EXPECTED((crex_ulong)C_LVAL_P(op2) < SIZEOF_CREX_LONG * 8)) {
		/* Perform shift on unsigned numbers to get well-defined wrap behavior. */
		ZVAL_LONG(EX_VAR(opline->result.var),
			(crex_long) ((crex_ulong) C_LVAL_P(op1) << C_LVAL_P(op2)));
		CREX_VM_NEXT_OPCODE();
	}

	CREX_VM_TAIL_CALL(crex_shift_left_helper_SPEC(op1, op2 CREX_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_SR_SPEC_TMPVARCV_TMPVARCV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;

	op1 = EX_VAR(opline->op1.var);
	op2 = EX_VAR(opline->op2.var);
	if (1 && (IS_TMP_VAR|IS_VAR|IS_CV) == IS_CONST && (IS_TMP_VAR|IS_VAR|IS_CV) == IS_CONST) {
		/* pass */
	} else if (EXPECTED(C_TYPE_INFO_P(op1) == IS_LONG)
			&& EXPECTED(C_TYPE_INFO_P(op2) == IS_LONG)
			&& EXPECTED((crex_ulong)C_LVAL_P(op2) < SIZEOF_CREX_LONG * 8)) {
		ZVAL_LONG(EX_VAR(opline->result.var), C_LVAL_P(op1) >> C_LVAL_P(op2));
		CREX_VM_NEXT_OPCODE();
	}

	CREX_VM_TAIL_CALL(crex_shift_right_helper_SPEC(op1, op2 CREX_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_IS_SMALLER_SPEC_TMPVARCV_TMPVARCV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	double d1, d2;

	op1 = EX_VAR(opline->op1.var);
	op2 = EX_VAR(opline->op2.var);
	if (1 && (IS_TMP_VAR|IS_VAR|IS_CV) == IS_CONST && (IS_TMP_VAR|IS_VAR|IS_CV) == IS_CONST) {
		/* pass */
	} else if (EXPECTED(C_TYPE_INFO_P(op1) == IS_LONG)) {
		if (EXPECTED(C_TYPE_INFO_P(op2) == IS_LONG)) {
			if (EXPECTED(C_LVAL_P(op1) < C_LVAL_P(op2))) {
is_smaller_true:
				CREX_VM_SMART_BRANCH_TRUE_NONE();
			} else {
is_smaller_false:
				CREX_VM_SMART_BRANCH_FALSE_NONE();
			}
		} else if (EXPECTED(C_TYPE_INFO_P(op2) == IS_DOUBLE)) {
			d1 = (double)C_LVAL_P(op1);
			d2 = C_DVAL_P(op2);
			goto is_smaller_double;
		}
	} else if (EXPECTED(C_TYPE_INFO_P(op1) == IS_DOUBLE)) {
		if (EXPECTED(C_TYPE_INFO_P(op2) == IS_DOUBLE)) {
			d1 = C_DVAL_P(op1);
			d2 = C_DVAL_P(op2);
is_smaller_double:
			if (d1 < d2) {
				goto is_smaller_true;
			} else {
				goto is_smaller_false;
			}
		} else if (EXPECTED(C_TYPE_INFO_P(op2) == IS_LONG)) {
			d1 = C_DVAL_P(op1);
			d2 = (double)C_LVAL_P(op2);
			goto is_smaller_double;
		}
	}
	CREX_VM_TAIL_CALL(crex_is_smaller_helper_SPEC(op1, op2 CREX_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static CREX_VM_HOT CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_IS_SMALLER_SPEC_TMPVARCV_TMPVARCV_JMPC_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	double d1, d2;

	op1 = EX_VAR(opline->op1.var);
	op2 = EX_VAR(opline->op2.var);
	if (1 && (IS_TMP_VAR|IS_VAR|IS_CV) == IS_CONST && (IS_TMP_VAR|IS_VAR|IS_CV) == IS_CONST) {
		/* pass */
	} else if (EXPECTED(C_TYPE_INFO_P(op1) == IS_LONG)) {
		if (EXPECTED(C_TYPE_INFO_P(op2) == IS_LONG)) {
			if (EXPECTED(C_LVAL_P(op1) < C_LVAL_P(op2))) {
is_smaller_true:
				CREX_VM_SMART_BRANCH_TRUE_JMPZ();
			} else {
is_smaller_false:
				CREX_VM_SMART_BRANCH_FALSE_JMPZ();
			}
		} else if (EXPECTED(C_TYPE_INFO_P(op2) == IS_DOUBLE)) {
			d1 = (double)C_LVAL_P(op1);
			d2 = C_DVAL_P(op2);
			goto is_smaller_double;
		}
	} else if (EXPECTED(C_TYPE_INFO_P(op1) == IS_DOUBLE)) {
		if (EXPECTED(C_TYPE_INFO_P(op2) == IS_DOUBLE)) {
			d1 = C_DVAL_P(op1);
			d2 = C_DVAL_P(op2);
is_smaller_double:
			if (d1 < d2) {
				goto is_smaller_true;
			} else {
				goto is_smaller_false;
			}
		} else if (EXPECTED(C_TYPE_INFO_P(op2) == IS_LONG)) {
			d1 = C_DVAL_P(op1);
			d2 = (double)C_LVAL_P(op2);
			goto is_smaller_double;
		}
	}
	CREX_VM_TAIL_CALL(crex_is_smaller_helper_SPEC(op1, op2 CREX_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static CREX_VM_HOT CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_IS_SMALLER_SPEC_TMPVARCV_TMPVARCV_JMPNC_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	double d1, d2;

	op1 = EX_VAR(opline->op1.var);
	op2 = EX_VAR(opline->op2.var);
	if (1 && (IS_TMP_VAR|IS_VAR|IS_CV) == IS_CONST && (IS_TMP_VAR|IS_VAR|IS_CV) == IS_CONST) {
		/* pass */
	} else if (EXPECTED(C_TYPE_INFO_P(op1) == IS_LONG)) {
		if (EXPECTED(C_TYPE_INFO_P(op2) == IS_LONG)) {
			if (EXPECTED(C_LVAL_P(op1) < C_LVAL_P(op2))) {
is_smaller_true:
				CREX_VM_SMART_BRANCH_TRUE_JMPNZ();
			} else {
is_smaller_false:
				CREX_VM_SMART_BRANCH_FALSE_JMPNZ();
			}
		} else if (EXPECTED(C_TYPE_INFO_P(op2) == IS_DOUBLE)) {
			d1 = (double)C_LVAL_P(op1);
			d2 = C_DVAL_P(op2);
			goto is_smaller_double;
		}
	} else if (EXPECTED(C_TYPE_INFO_P(op1) == IS_DOUBLE)) {
		if (EXPECTED(C_TYPE_INFO_P(op2) == IS_DOUBLE)) {
			d1 = C_DVAL_P(op1);
			d2 = C_DVAL_P(op2);
is_smaller_double:
			if (d1 < d2) {
				goto is_smaller_true;
			} else {
				goto is_smaller_false;
			}
		} else if (EXPECTED(C_TYPE_INFO_P(op2) == IS_LONG)) {
			d1 = C_DVAL_P(op1);
			d2 = (double)C_LVAL_P(op2);
			goto is_smaller_double;
		}
	}
	CREX_VM_TAIL_CALL(crex_is_smaller_helper_SPEC(op1, op2 CREX_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_IS_SMALLER_OR_EQUAL_SPEC_TMPVARCV_TMPVARCV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	double d1, d2;

	op1 = EX_VAR(opline->op1.var);
	op2 = EX_VAR(opline->op2.var);
	if (1 && (IS_TMP_VAR|IS_VAR|IS_CV) == IS_CONST && (IS_TMP_VAR|IS_VAR|IS_CV) == IS_CONST) {
		/* pass */
	} else if (EXPECTED(C_TYPE_INFO_P(op1) == IS_LONG)) {
		if (EXPECTED(C_TYPE_INFO_P(op2) == IS_LONG)) {
			if (EXPECTED(C_LVAL_P(op1) <= C_LVAL_P(op2))) {
is_smaller_or_equal_true:
				CREX_VM_SMART_BRANCH_TRUE_NONE();
				ZVAL_TRUE(EX_VAR(opline->result.var));
				CREX_VM_NEXT_OPCODE();
			} else {
is_smaller_or_equal_false:
				CREX_VM_SMART_BRANCH_FALSE_NONE();
				ZVAL_FALSE(EX_VAR(opline->result.var));
				CREX_VM_NEXT_OPCODE();
			}
		} else if (EXPECTED(C_TYPE_INFO_P(op2) == IS_DOUBLE)) {
			d1 = (double)C_LVAL_P(op1);
			d2 = C_DVAL_P(op2);
			goto is_smaller_or_equal_double;
		}
	} else if (EXPECTED(C_TYPE_INFO_P(op1) == IS_DOUBLE)) {
		if (EXPECTED(C_TYPE_INFO_P(op2) == IS_DOUBLE)) {
			d1 = C_DVAL_P(op1);
			d2 = C_DVAL_P(op2);
is_smaller_or_equal_double:
			if (d1 <= d2) {
				goto is_smaller_or_equal_true;
			} else {
				goto is_smaller_or_equal_false;
			}
		} else if (EXPECTED(C_TYPE_INFO_P(op2) == IS_LONG)) {
			d1 = C_DVAL_P(op1);
			d2 = (double)C_LVAL_P(op2);
			goto is_smaller_or_equal_double;
		}
	}
	CREX_VM_TAIL_CALL(crex_is_smaller_or_equal_helper_SPEC(op1, op2 CREX_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static CREX_VM_HOT CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_IS_SMALLER_OR_EQUAL_SPEC_TMPVARCV_TMPVARCV_JMPC_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	double d1, d2;

	op1 = EX_VAR(opline->op1.var);
	op2 = EX_VAR(opline->op2.var);
	if (1 && (IS_TMP_VAR|IS_VAR|IS_CV) == IS_CONST && (IS_TMP_VAR|IS_VAR|IS_CV) == IS_CONST) {
		/* pass */
	} else if (EXPECTED(C_TYPE_INFO_P(op1) == IS_LONG)) {
		if (EXPECTED(C_TYPE_INFO_P(op2) == IS_LONG)) {
			if (EXPECTED(C_LVAL_P(op1) <= C_LVAL_P(op2))) {
is_smaller_or_equal_true:
				CREX_VM_SMART_BRANCH_TRUE_JMPZ();
				ZVAL_TRUE(EX_VAR(opline->result.var));
				CREX_VM_NEXT_OPCODE();
			} else {
is_smaller_or_equal_false:
				CREX_VM_SMART_BRANCH_FALSE_JMPZ();
				ZVAL_FALSE(EX_VAR(opline->result.var));
				CREX_VM_NEXT_OPCODE();
			}
		} else if (EXPECTED(C_TYPE_INFO_P(op2) == IS_DOUBLE)) {
			d1 = (double)C_LVAL_P(op1);
			d2 = C_DVAL_P(op2);
			goto is_smaller_or_equal_double;
		}
	} else if (EXPECTED(C_TYPE_INFO_P(op1) == IS_DOUBLE)) {
		if (EXPECTED(C_TYPE_INFO_P(op2) == IS_DOUBLE)) {
			d1 = C_DVAL_P(op1);
			d2 = C_DVAL_P(op2);
is_smaller_or_equal_double:
			if (d1 <= d2) {
				goto is_smaller_or_equal_true;
			} else {
				goto is_smaller_or_equal_false;
			}
		} else if (EXPECTED(C_TYPE_INFO_P(op2) == IS_LONG)) {
			d1 = C_DVAL_P(op1);
			d2 = (double)C_LVAL_P(op2);
			goto is_smaller_or_equal_double;
		}
	}
	CREX_VM_TAIL_CALL(crex_is_smaller_or_equal_helper_SPEC(op1, op2 CREX_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static CREX_VM_HOT CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_IS_SMALLER_OR_EQUAL_SPEC_TMPVARCV_TMPVARCV_JMPNC_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	double d1, d2;

	op1 = EX_VAR(opline->op1.var);
	op2 = EX_VAR(opline->op2.var);
	if (1 && (IS_TMP_VAR|IS_VAR|IS_CV) == IS_CONST && (IS_TMP_VAR|IS_VAR|IS_CV) == IS_CONST) {
		/* pass */
	} else if (EXPECTED(C_TYPE_INFO_P(op1) == IS_LONG)) {
		if (EXPECTED(C_TYPE_INFO_P(op2) == IS_LONG)) {
			if (EXPECTED(C_LVAL_P(op1) <= C_LVAL_P(op2))) {
is_smaller_or_equal_true:
				CREX_VM_SMART_BRANCH_TRUE_JMPNZ();
				ZVAL_TRUE(EX_VAR(opline->result.var));
				CREX_VM_NEXT_OPCODE();
			} else {
is_smaller_or_equal_false:
				CREX_VM_SMART_BRANCH_FALSE_JMPNZ();
				ZVAL_FALSE(EX_VAR(opline->result.var));
				CREX_VM_NEXT_OPCODE();
			}
		} else if (EXPECTED(C_TYPE_INFO_P(op2) == IS_DOUBLE)) {
			d1 = (double)C_LVAL_P(op1);
			d2 = C_DVAL_P(op2);
			goto is_smaller_or_equal_double;
		}
	} else if (EXPECTED(C_TYPE_INFO_P(op1) == IS_DOUBLE)) {
		if (EXPECTED(C_TYPE_INFO_P(op2) == IS_DOUBLE)) {
			d1 = C_DVAL_P(op1);
			d2 = C_DVAL_P(op2);
is_smaller_or_equal_double:
			if (d1 <= d2) {
				goto is_smaller_or_equal_true;
			} else {
				goto is_smaller_or_equal_false;
			}
		} else if (EXPECTED(C_TYPE_INFO_P(op2) == IS_LONG)) {
			d1 = C_DVAL_P(op1);
			d2 = (double)C_LVAL_P(op2);
			goto is_smaller_or_equal_double;
		}
	}
	CREX_VM_TAIL_CALL(crex_is_smaller_or_equal_helper_SPEC(op1, op2 CREX_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static CREX_VM_HOT CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_BW_OR_SPEC_TMPVARCV_TMPVARCV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;

	op1 = EX_VAR(opline->op1.var);
	op2 = EX_VAR(opline->op2.var);
	if (1 && (IS_TMP_VAR|IS_VAR|IS_CV) == IS_CONST && (IS_TMP_VAR|IS_VAR|IS_CV) == IS_CONST) {
		/* pass */
	} else if (EXPECTED(C_TYPE_INFO_P(op1) == IS_LONG)
			&& EXPECTED(C_TYPE_INFO_P(op2) == IS_LONG)) {
		ZVAL_LONG(EX_VAR(opline->result.var), C_LVAL_P(op1) | C_LVAL_P(op2));
		CREX_VM_NEXT_OPCODE();
	}

	CREX_VM_TAIL_CALL(crex_bw_or_helper_SPEC(op1, op2 CREX_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static CREX_VM_HOT CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_BW_AND_SPEC_TMPVARCV_TMPVARCV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;

	op1 = EX_VAR(opline->op1.var);
	op2 = EX_VAR(opline->op2.var);
	if (1 && (IS_TMP_VAR|IS_VAR|IS_CV) == IS_CONST && (IS_TMP_VAR|IS_VAR|IS_CV) == IS_CONST) {
		/* pass */
	} else if (EXPECTED(C_TYPE_INFO_P(op1) == IS_LONG)
			&& EXPECTED(C_TYPE_INFO_P(op2) == IS_LONG)) {
		ZVAL_LONG(EX_VAR(opline->result.var), C_LVAL_P(op1) & C_LVAL_P(op2));
		CREX_VM_NEXT_OPCODE();
	}

	CREX_VM_TAIL_CALL(crex_bw_and_helper_SPEC(op1, op2 CREX_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static CREX_VM_HOT CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_BW_XOR_SPEC_TMPVARCV_TMPVARCV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;

	op1 = EX_VAR(opline->op1.var);
	op2 = EX_VAR(opline->op2.var);
	if (1 && (IS_TMP_VAR|IS_VAR|IS_CV) == IS_CONST && (IS_TMP_VAR|IS_VAR|IS_CV) == IS_CONST) {
		/* pass */
	} else if (EXPECTED(C_TYPE_INFO_P(op1) == IS_LONG)
			&& EXPECTED(C_TYPE_INFO_P(op2) == IS_LONG)) {
		ZVAL_LONG(EX_VAR(opline->result.var), C_LVAL_P(op1) ^ C_LVAL_P(op2));
		CREX_VM_NEXT_OPCODE();
	}

	CREX_VM_TAIL_CALL(crex_bw_xor_helper_SPEC(op1, op2 CREX_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static CREX_VM_HOT CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ADD_LONG_NO_OVERFLOW_SPEC_TMPVARCV_TMPVARCV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2, *result;

	op1 = EX_VAR(opline->op1.var);
	op2 = EX_VAR(opline->op2.var);
	result = EX_VAR(opline->result.var);
	ZVAL_LONG(result, C_LVAL_P(op1) + C_LVAL_P(op2));
	CREX_VM_NEXT_OPCODE();
}

static CREX_VM_HOT CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ADD_LONG_SPEC_TMPVARCV_TMPVARCV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2, *result;

	op1 = EX_VAR(opline->op1.var);
	op2 = EX_VAR(opline->op2.var);
	result = EX_VAR(opline->result.var);
	fast_long_add_function(result, op1, op2);
	CREX_VM_NEXT_OPCODE();
}

static CREX_VM_HOT CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ADD_DOUBLE_SPEC_TMPVARCV_TMPVARCV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2, *result;

	op1 = EX_VAR(opline->op1.var);
	op2 = EX_VAR(opline->op2.var);
	result = EX_VAR(opline->result.var);
	ZVAL_DOUBLE(result, C_DVAL_P(op1) + C_DVAL_P(op2));
	CREX_VM_NEXT_OPCODE();
}

static CREX_VM_HOT CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_SUB_LONG_NO_OVERFLOW_SPEC_TMPVARCV_TMPVARCV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2, *result;

	op1 = EX_VAR(opline->op1.var);
	op2 = EX_VAR(opline->op2.var);
	result = EX_VAR(opline->result.var);
	ZVAL_LONG(result, C_LVAL_P(op1) - C_LVAL_P(op2));
	CREX_VM_NEXT_OPCODE();
}

static CREX_VM_HOT CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_SUB_LONG_SPEC_TMPVARCV_TMPVARCV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2, *result;

	op1 = EX_VAR(opline->op1.var);
	op2 = EX_VAR(opline->op2.var);
	result = EX_VAR(opline->result.var);
	fast_long_sub_function(result, op1, op2);
	CREX_VM_NEXT_OPCODE();
}

static CREX_VM_HOT CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_SUB_DOUBLE_SPEC_TMPVARCV_TMPVARCV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2, *result;

	op1 = EX_VAR(opline->op1.var);
	op2 = EX_VAR(opline->op2.var);
	result = EX_VAR(opline->result.var);
	ZVAL_DOUBLE(result, C_DVAL_P(op1) - C_DVAL_P(op2));
	CREX_VM_NEXT_OPCODE();
}

static CREX_VM_HOT CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_MUL_LONG_NO_OVERFLOW_SPEC_TMPVARCV_TMPVARCV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2, *result;

	op1 = EX_VAR(opline->op1.var);
	op2 = EX_VAR(opline->op2.var);
	result = EX_VAR(opline->result.var);
	ZVAL_LONG(result, C_LVAL_P(op1) * C_LVAL_P(op2));
	CREX_VM_NEXT_OPCODE();
}

static CREX_VM_HOT CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_MUL_LONG_SPEC_TMPVARCV_TMPVARCV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2, *result;
	crex_long overflow;

	op1 = EX_VAR(opline->op1.var);
	op2 = EX_VAR(opline->op2.var);
	result = EX_VAR(opline->result.var);
	CREX_SIGNED_MULTIPLY_LONG(C_LVAL_P(op1), C_LVAL_P(op2), C_LVAL_P(result), C_DVAL_P(result), overflow);
	C_TYPE_INFO_P(result) = overflow ? IS_DOUBLE : IS_LONG;
	CREX_VM_NEXT_OPCODE();
}

static CREX_VM_HOT CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_MUL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2, *result;

	op1 = EX_VAR(opline->op1.var);
	op2 = EX_VAR(opline->op2.var);
	result = EX_VAR(opline->result.var);
	ZVAL_DOUBLE(result, C_DVAL_P(op1) * C_DVAL_P(op2));
	CREX_VM_NEXT_OPCODE();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_IS_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	bool result;

	op1 = EX_VAR(opline->op1.var);
	op2 = EX_VAR(opline->op2.var);
	result = (C_LVAL_P(op1) == C_LVAL_P(op2));
	CREX_VM_SMART_BRANCH_NONE(result, 0);
}

static CREX_VM_HOT CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_IS_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPC_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	bool result;

	op1 = EX_VAR(opline->op1.var);
	op2 = EX_VAR(opline->op2.var);
	result = (C_LVAL_P(op1) == C_LVAL_P(op2));
	CREX_VM_SMART_BRANCH_JMPZ(result, 0);
}

static CREX_VM_HOT CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_IS_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPNC_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	bool result;

	op1 = EX_VAR(opline->op1.var);
	op2 = EX_VAR(opline->op2.var);
	result = (C_LVAL_P(op1) == C_LVAL_P(op2));
	CREX_VM_SMART_BRANCH_JMPNZ(result, 0);
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_IS_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	bool result;

	op1 = EX_VAR(opline->op1.var);
	op2 = EX_VAR(opline->op2.var);
	result = (C_DVAL_P(op1) == C_DVAL_P(op2));
	CREX_VM_SMART_BRANCH_NONE(result, 0);
}

static CREX_VM_HOT CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_IS_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPC_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	bool result;

	op1 = EX_VAR(opline->op1.var);
	op2 = EX_VAR(opline->op2.var);
	result = (C_DVAL_P(op1) == C_DVAL_P(op2));
	CREX_VM_SMART_BRANCH_JMPZ(result, 0);
}

static CREX_VM_HOT CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_IS_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPNC_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	bool result;

	op1 = EX_VAR(opline->op1.var);
	op2 = EX_VAR(opline->op2.var);
	result = (C_DVAL_P(op1) == C_DVAL_P(op2));
	CREX_VM_SMART_BRANCH_JMPNZ(result, 0);
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_IS_NOT_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	bool result;

	op1 = EX_VAR(opline->op1.var);
	op2 = EX_VAR(opline->op2.var);
	result = (C_LVAL_P(op1) != C_LVAL_P(op2));
	CREX_VM_SMART_BRANCH_NONE(result, 0);
}

static CREX_VM_HOT CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_IS_NOT_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPC_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	bool result;

	op1 = EX_VAR(opline->op1.var);
	op2 = EX_VAR(opline->op2.var);
	result = (C_LVAL_P(op1) != C_LVAL_P(op2));
	CREX_VM_SMART_BRANCH_JMPZ(result, 0);
}

static CREX_VM_HOT CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_IS_NOT_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPNC_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	bool result;

	op1 = EX_VAR(opline->op1.var);
	op2 = EX_VAR(opline->op2.var);
	result = (C_LVAL_P(op1) != C_LVAL_P(op2));
	CREX_VM_SMART_BRANCH_JMPNZ(result, 0);
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_IS_NOT_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	bool result;

	op1 = EX_VAR(opline->op1.var);
	op2 = EX_VAR(opline->op2.var);
	result = (C_DVAL_P(op1) != C_DVAL_P(op2));
	CREX_VM_SMART_BRANCH_NONE(result, 0);
}

static CREX_VM_HOT CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_IS_NOT_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPC_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	bool result;

	op1 = EX_VAR(opline->op1.var);
	op2 = EX_VAR(opline->op2.var);
	result = (C_DVAL_P(op1) != C_DVAL_P(op2));
	CREX_VM_SMART_BRANCH_JMPZ(result, 0);
}

static CREX_VM_HOT CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_IS_NOT_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPNC_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	bool result;

	op1 = EX_VAR(opline->op1.var);
	op2 = EX_VAR(opline->op2.var);
	result = (C_DVAL_P(op1) != C_DVAL_P(op2));
	CREX_VM_SMART_BRANCH_JMPNZ(result, 0);
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_IS_SMALLER_LONG_SPEC_TMPVARCV_TMPVARCV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	bool result;

	op1 = EX_VAR(opline->op1.var);
	op2 = EX_VAR(opline->op2.var);
	result = (C_LVAL_P(op1) < C_LVAL_P(op2));
	CREX_VM_SMART_BRANCH_NONE(result, 0);
}

static CREX_VM_HOT CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_IS_SMALLER_LONG_SPEC_TMPVARCV_TMPVARCV_JMPC_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	bool result;

	op1 = EX_VAR(opline->op1.var);
	op2 = EX_VAR(opline->op2.var);
	result = (C_LVAL_P(op1) < C_LVAL_P(op2));
	CREX_VM_SMART_BRANCH_JMPZ(result, 0);
}

static CREX_VM_HOT CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_IS_SMALLER_LONG_SPEC_TMPVARCV_TMPVARCV_JMPNC_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	bool result;

	op1 = EX_VAR(opline->op1.var);
	op2 = EX_VAR(opline->op2.var);
	result = (C_LVAL_P(op1) < C_LVAL_P(op2));
	CREX_VM_SMART_BRANCH_JMPNZ(result, 0);
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_IS_SMALLER_DOUBLE_SPEC_TMPVARCV_TMPVARCV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	bool result;

	op1 = EX_VAR(opline->op1.var);
	op2 = EX_VAR(opline->op2.var);
	result = (C_DVAL_P(op1) < C_DVAL_P(op2));
	CREX_VM_SMART_BRANCH_NONE(result, 0);
}

static CREX_VM_HOT CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_IS_SMALLER_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPC_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	bool result;

	op1 = EX_VAR(opline->op1.var);
	op2 = EX_VAR(opline->op2.var);
	result = (C_DVAL_P(op1) < C_DVAL_P(op2));
	CREX_VM_SMART_BRANCH_JMPZ(result, 0);
}

static CREX_VM_HOT CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_IS_SMALLER_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPNC_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	bool result;

	op1 = EX_VAR(opline->op1.var);
	op2 = EX_VAR(opline->op2.var);
	result = (C_DVAL_P(op1) < C_DVAL_P(op2));
	CREX_VM_SMART_BRANCH_JMPNZ(result, 0);
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_IS_SMALLER_OR_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	bool result;

	op1 = EX_VAR(opline->op1.var);
	op2 = EX_VAR(opline->op2.var);
	result = (C_LVAL_P(op1) <= C_LVAL_P(op2));
	CREX_VM_SMART_BRANCH_NONE(result, 0);
}

static CREX_VM_HOT CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_IS_SMALLER_OR_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPC_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	bool result;

	op1 = EX_VAR(opline->op1.var);
	op2 = EX_VAR(opline->op2.var);
	result = (C_LVAL_P(op1) <= C_LVAL_P(op2));
	CREX_VM_SMART_BRANCH_JMPZ(result, 0);
}

static CREX_VM_HOT CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_IS_SMALLER_OR_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPNC_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	bool result;

	op1 = EX_VAR(opline->op1.var);
	op2 = EX_VAR(opline->op2.var);
	result = (C_LVAL_P(op1) <= C_LVAL_P(op2));
	CREX_VM_SMART_BRANCH_JMPNZ(result, 0);
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	bool result;

	op1 = EX_VAR(opline->op1.var);
	op2 = EX_VAR(opline->op2.var);
	result = (C_DVAL_P(op1) <= C_DVAL_P(op2));
	CREX_VM_SMART_BRANCH_NONE(result, 0);
}

static CREX_VM_HOT CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPC_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	bool result;

	op1 = EX_VAR(opline->op1.var);
	op2 = EX_VAR(opline->op2.var);
	result = (C_DVAL_P(op1) <= C_DVAL_P(op2));
	CREX_VM_SMART_BRANCH_JMPZ(result, 0);
}

static CREX_VM_HOT CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPNC_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	bool result;

	op1 = EX_VAR(opline->op1.var);
	op2 = EX_VAR(opline->op2.var);
	result = (C_DVAL_P(op1) <= C_DVAL_P(op2));
	CREX_VM_SMART_BRANCH_JMPNZ(result, 0);
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FETCH_LIST_R_SPEC_TMPVARCV_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;

	SAVE_OPLINE();
	container = EX_VAR(opline->op1.var);
	crex_fetch_dimension_address_LIST_r(container, _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC), (IS_TMP_VAR|IS_VAR) OPLINE_CC EXECUTE_DATA_CC);
	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_MATCH_ERROR_SPEC_TMPVARCV_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op;

	SAVE_OPLINE();
	op = EX_VAR(opline->op1.var);
	crex_match_unhandled_error(op);
	HANDLE_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FETCH_LIST_R_SPEC_TMPVARCV_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;

	SAVE_OPLINE();
	container = EX_VAR(opline->op1.var);
	crex_fetch_dimension_address_LIST_r(container, EX_VAR(opline->op2.var), IS_CV OPLINE_CC EXECUTE_DATA_CC);

	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_BOOL_NOT_SPEC_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *val;

	val = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	if (C_TYPE_INFO_P(val) == IS_TRUE) {
		ZVAL_FALSE(EX_VAR(opline->result.var));
	} else if (EXPECTED(C_TYPE_INFO_P(val) <= IS_TRUE)) {
		/* The result and op1 can be the same cv zval */
		const uint32_t orig_val_type = C_TYPE_INFO_P(val);
		ZVAL_TRUE(EX_VAR(opline->result.var));
		if ((IS_TMP_VAR|IS_VAR) == IS_CV && UNEXPECTED(orig_val_type == IS_UNDEF)) {
			SAVE_OPLINE();
			ZVAL_UNDEFINED_OP1();
			CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
		}
	} else {
		SAVE_OPLINE();
		ZVAL_BOOL(EX_VAR(opline->result.var), !i_crex_is_true(val));
		zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
		CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
	}
	CREX_VM_NEXT_OPCODE();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ECHO_SPEC_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *z;

	SAVE_OPLINE();
	z = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);

	if (C_TYPE_P(z) == IS_STRING) {
		crex_string *str = C_STR_P(z);

		if (ZSTR_LEN(str) != 0) {
			crex_write(ZSTR_VAL(str), ZSTR_LEN(str));
		}
	} else {
		crex_string *str = zval_get_string_func(z);

		if (ZSTR_LEN(str) != 0) {
			crex_write(ZSTR_VAL(str), ZSTR_LEN(str));
		} else if ((IS_TMP_VAR|IS_VAR) == IS_CV && UNEXPECTED(C_TYPE_P(z) == IS_UNDEF)) {
			ZVAL_UNDEFINED_OP1();
		}
		crex_string_release_ex(str, 0);
	}

	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_VM_HOT CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_JMPC_SPEC_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *val;
	uint8_t op1_type;

	val = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);

	if (C_TYPE_INFO_P(val) == IS_TRUE) {
		CREX_VM_NEXT_OPCODE();
	} else if (EXPECTED(C_TYPE_INFO_P(val) <= IS_TRUE)) {
		if ((IS_TMP_VAR|IS_VAR) == IS_CV && UNEXPECTED(C_TYPE_INFO_P(val) == IS_UNDEF)) {
			SAVE_OPLINE();
			ZVAL_UNDEFINED_OP1();
			if (UNEXPECTED(EG(exception))) {
				HANDLE_EXCEPTION();
			}
		}
		CREX_VM_JMP_EX(OP_JMP_ADDR(opline, opline->op2), 0);
	}

	SAVE_OPLINE();
	op1_type = (IS_TMP_VAR|IS_VAR);
	if (i_crex_is_true(val)) {
		opline++;
	} else {
		opline = OP_JMP_ADDR(opline, opline->op2);
	}
	if (op1_type & (IS_TMP_VAR|IS_VAR)) {
		zval_ptr_dtor_nogc(val);
	}
	CREX_VM_JMP(opline);
}

static CREX_VM_HOT CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_JMPNC_SPEC_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *val;
	uint8_t op1_type;

	val = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);

	if (C_TYPE_INFO_P(val) == IS_TRUE) {
		CREX_VM_JMP_EX(OP_JMP_ADDR(opline, opline->op2), 0);
	} else if (EXPECTED(C_TYPE_INFO_P(val) <= IS_TRUE)) {
		if ((IS_TMP_VAR|IS_VAR) == IS_CV && UNEXPECTED(C_TYPE_INFO_P(val) == IS_UNDEF)) {
			SAVE_OPLINE();
			ZVAL_UNDEFINED_OP1();
			if (UNEXPECTED(EG(exception))) {
				HANDLE_EXCEPTION();
			}
		}
		CREX_VM_NEXT_OPCODE();
	}

	SAVE_OPLINE();
	op1_type = (IS_TMP_VAR|IS_VAR);
	if (i_crex_is_true(val)) {
		opline = OP_JMP_ADDR(opline, opline->op2);
	} else {
		opline++;
	}
	if (op1_type & (IS_TMP_VAR|IS_VAR)) {
		zval_ptr_dtor_nogc(val);
	}
	CREX_VM_JMP(opline);
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_JMPC_EX_SPEC_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *val;
	bool ret;

	val = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);

	if (C_TYPE_INFO_P(val) == IS_TRUE) {
		ZVAL_TRUE(EX_VAR(opline->result.var));
		CREX_VM_NEXT_OPCODE();
	} else if (EXPECTED(C_TYPE_INFO_P(val) <= IS_TRUE)) {
		ZVAL_FALSE(EX_VAR(opline->result.var));
		if ((IS_TMP_VAR|IS_VAR) == IS_CV && UNEXPECTED(C_TYPE_INFO_P(val) == IS_UNDEF)) {
			SAVE_OPLINE();
			ZVAL_UNDEFINED_OP1();
			if (UNEXPECTED(EG(exception))) {
				HANDLE_EXCEPTION();
			}
		}
		CREX_VM_JMP_EX(OP_JMP_ADDR(opline, opline->op2), 0);
	}

	SAVE_OPLINE();
	ret = i_crex_is_true(val);
	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	if (ret) {
		ZVAL_TRUE(EX_VAR(opline->result.var));
		opline++;
	} else {
		ZVAL_FALSE(EX_VAR(opline->result.var));
		opline = OP_JMP_ADDR(opline, opline->op2);
	}
	CREX_VM_JMP(opline);
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_JMPNC_EX_SPEC_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *val;
	bool ret;

	val = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);

	if (C_TYPE_INFO_P(val) == IS_TRUE) {
		ZVAL_TRUE(EX_VAR(opline->result.var));
		CREX_VM_JMP_EX(OP_JMP_ADDR(opline, opline->op2), 0);
	} else if (EXPECTED(C_TYPE_INFO_P(val) <= IS_TRUE)) {
		ZVAL_FALSE(EX_VAR(opline->result.var));
		if ((IS_TMP_VAR|IS_VAR) == IS_CV && UNEXPECTED(C_TYPE_INFO_P(val) == IS_UNDEF)) {
			SAVE_OPLINE();
			ZVAL_UNDEFINED_OP1();
			CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
		} else {
			CREX_VM_NEXT_OPCODE();
		}
	}

	SAVE_OPLINE();
	ret = i_crex_is_true(val);
	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	if (ret) {
		ZVAL_TRUE(EX_VAR(opline->result.var));
		opline = OP_JMP_ADDR(opline, opline->op2);
	} else {
		ZVAL_FALSE(EX_VAR(opline->result.var));
		opline++;
	}
	CREX_VM_JMP(opline);
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FREE_SPEC_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	SAVE_OPLINE();
	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_VM_HOT CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FE_FREE_SPEC_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	zval *var;
	USE_OPLINE

	var = EX_VAR(opline->op1.var);
	if (C_TYPE_P(var) != IS_ARRAY) {
		SAVE_OPLINE();
		if (C_FE_ITER_P(var) != (uint32_t)-1) {
			crex_hash_iterator_del(C_FE_ITER_P(var));
		}
		zval_ptr_dtor_nogc(var);
		CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
	}

	/* This is freeing an array. Use an inlined version of zval_ptr_dtor_nogc. */
	/* CRX only needs to save the opline and check for an exception if the last reference to the array was garbage collected (destructors of elements in the array could throw an exception) */
	if (C_REFCOUNTED_P(var) && !C_DELREF_P(var)) {
		SAVE_OPLINE();
		rc_dtor_func(C_COUNTED_P(var));
		CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
	}
	CREX_VM_NEXT_OPCODE();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_THROW_SPEC_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *value;

	SAVE_OPLINE();
	value = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);

	do {
		if ((IS_TMP_VAR|IS_VAR) == IS_CONST || UNEXPECTED(C_TYPE_P(value) != IS_OBJECT)) {
			if (((IS_TMP_VAR|IS_VAR) & (IS_VAR|IS_CV)) && C_ISREF_P(value)) {
				value = C_REFVAL_P(value);
				if (EXPECTED(C_TYPE_P(value) == IS_OBJECT)) {
					break;
				}
			}
			if ((IS_TMP_VAR|IS_VAR) == IS_CV && UNEXPECTED(C_TYPE_P(value) == IS_UNDEF)) {
				ZVAL_UNDEFINED_OP1();
				if (UNEXPECTED(EG(exception) != NULL)) {
					HANDLE_EXCEPTION();
				}
			}
			crex_throw_error(NULL, "Can only throw objects");
			zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
			HANDLE_EXCEPTION();
		}
	} while (0);

	crex_exception_save();
	C_TRY_ADDREF_P(value);
	crex_throw_exception_object(value);
	crex_exception_restore();
	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	HANDLE_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_BOOL_SPEC_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *val;

	val = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	if (C_TYPE_INFO_P(val) == IS_TRUE) {
		ZVAL_TRUE(EX_VAR(opline->result.var));
	} else if (EXPECTED(C_TYPE_INFO_P(val) <= IS_TRUE)) {
		/* The result and op1 can be the same cv zval */
		const uint32_t orig_val_type = C_TYPE_INFO_P(val);
		ZVAL_FALSE(EX_VAR(opline->result.var));
		if ((IS_TMP_VAR|IS_VAR) == IS_CV && UNEXPECTED(orig_val_type == IS_UNDEF)) {
			SAVE_OPLINE();
			ZVAL_UNDEFINED_OP1();
			CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
		}
	} else {
		SAVE_OPLINE();
		ZVAL_BOOL(EX_VAR(opline->result.var), i_crex_is_true(val));
		zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
		CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
	}
	CREX_VM_NEXT_OPCODE();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_CLONE_SPEC_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *obj;
	crex_object *zobj;
	crex_class_entry *ce, *scope;
	crex_function *clone;
	crex_object_clone_obj_t clone_call;

	SAVE_OPLINE();
	obj = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);

	do {
		if ((IS_TMP_VAR|IS_VAR) == IS_CONST ||
		    ((IS_TMP_VAR|IS_VAR) != IS_UNUSED && UNEXPECTED(C_TYPE_P(obj) != IS_OBJECT))) {
			if (((IS_TMP_VAR|IS_VAR) & (IS_VAR|IS_CV)) && C_ISREF_P(obj)) {
				obj = C_REFVAL_P(obj);
				if (EXPECTED(C_TYPE_P(obj) == IS_OBJECT)) {
					break;
				}
			}
			ZVAL_UNDEF(EX_VAR(opline->result.var));
			if ((IS_TMP_VAR|IS_VAR) == IS_CV && UNEXPECTED(C_TYPE_P(obj) == IS_UNDEF)) {
				ZVAL_UNDEFINED_OP1();
				if (UNEXPECTED(EG(exception) != NULL)) {
					HANDLE_EXCEPTION();
				}
			}
			crex_throw_error(NULL, "__clone method called on non-object");
			zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
			HANDLE_EXCEPTION();
		}
	} while (0);

	zobj = C_OBJ_P(obj);
	ce = zobj->ce;
	clone = ce->clone;
	clone_call = zobj->handlers->clone_obj;
	if (UNEXPECTED(clone_call == NULL)) {
		crex_throw_error(NULL, "Trying to clone an uncloneable object of class %s", ZSTR_VAL(ce->name));
		zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
		ZVAL_UNDEF(EX_VAR(opline->result.var));
		HANDLE_EXCEPTION();
	}

	if (clone && !(clone->common.fn_flags & CREX_ACC_PUBLIC)) {
		scope = EX(func)->op_array.scope;
		if (clone->common.scope != scope) {
			if (UNEXPECTED(clone->common.fn_flags & CREX_ACC_PRIVATE)
			 || UNEXPECTED(!crex_check_protected(crex_get_function_root_class(clone), scope))) {
				crex_wrong_clone_call(clone, scope);
				zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
				ZVAL_UNDEF(EX_VAR(opline->result.var));
				HANDLE_EXCEPTION();
			}
		}
	}

	ZVAL_OBJ(EX_VAR(opline->result.var), clone_call(zobj));

	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_INCLUDE_OR_EVAL_SPEC_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	crex_op_array *new_op_array;
	zval *inc_filename;

	SAVE_OPLINE();
	inc_filename = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	new_op_array = crex_include_or_eval(inc_filename, opline->extended_value);
	if (UNEXPECTED(EG(exception) != NULL)) {
		zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
		if (new_op_array != CREX_FAKE_OP_ARRAY && new_op_array != NULL) {
			destroy_op_array(new_op_array);
			efree_size(new_op_array, sizeof(crex_op_array));
		}
		UNDEF_RESULT();
		HANDLE_EXCEPTION();
	} else if (new_op_array == CREX_FAKE_OP_ARRAY) {
		if (RETURN_VALUE_USED(opline)) {
			ZVAL_TRUE(EX_VAR(opline->result.var));
		}
	} else if (UNEXPECTED(new_op_array == NULL)) {
		if (RETURN_VALUE_USED(opline)) {
			ZVAL_FALSE(EX_VAR(opline->result.var));
		}
	} else if (new_op_array->last == 1
			&& new_op_array->opcodes[0].opcode == CREX_RETURN
			&& new_op_array->opcodes[0].op1_type == IS_CONST
			&& EXPECTED(crex_execute_ex == execute_ex)) {
		if (RETURN_VALUE_USED(opline)) {
			const crex_op *op = new_op_array->opcodes;

			ZVAL_COPY(EX_VAR(opline->result.var), RT_CONSTANT(op, op->op1));
		}
		crex_destroy_static_vars(new_op_array);
		destroy_op_array(new_op_array);
		efree_size(new_op_array, sizeof(crex_op_array));
	} else {
		zval *return_value = NULL;
		crex_execute_data *call;
		if (RETURN_VALUE_USED(opline)) {
			return_value = EX_VAR(opline->result.var);
		}

		new_op_array->scope = EX(func)->op_array.scope;

		call = crex_vm_stack_push_call_frame(
			(C_TYPE_INFO(EX(This)) & CREX_CALL_HAS_THIS) | CREX_CALL_NESTED_CODE | CREX_CALL_HAS_SYMBOL_TABLE,
			(crex_function*)new_op_array, 0,
			C_PTR(EX(This)));

		if (EX_CALL_INFO() & CREX_CALL_HAS_SYMBOL_TABLE) {
			call->symbol_table = EX(symbol_table);
		} else {
			call->symbol_table = crex_rebuild_symbol_table();
		}

		call->prev_execute_data = execute_data;
		i_init_code_execute_data(call, new_op_array, return_value);

		if (EXPECTED(crex_execute_ex == execute_ex)) {
			zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
			CREX_VM_ENTER();
		} else {
			CREX_ADD_CALL_FLAG(call, CREX_CALL_TOP);
			crex_execute_ex(call);
			crex_vm_stack_free_call_frame(call);
		}

		crex_destroy_static_vars(new_op_array);
		destroy_op_array(new_op_array);
		efree_size(new_op_array, sizeof(crex_op_array));
		if (UNEXPECTED(EG(exception) != NULL)) {
			crex_rethrow_exception(execute_data);
			zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
			UNDEF_RESULT();
			HANDLE_EXCEPTION();
		}
	}
	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	CREX_VM_NEXT_OPCODE();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_YIELD_FROM_SPEC_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	crex_generator *generator = crex_get_running_generator(EXECUTE_DATA_C);
	zval *val;

	SAVE_OPLINE();
	val = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);

	if (UNEXPECTED(generator->flags & CREX_GENERATOR_FORCED_CLOSE)) {
		crex_throw_error(NULL, "Cannot use \"yield from\" in a force-closed generator");
		zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
		UNDEF_RESULT();
		HANDLE_EXCEPTION();
	}

yield_from_try_again:
	if (C_TYPE_P(val) == IS_ARRAY) {
		ZVAL_COPY_VALUE(&generator->values, val);
		if (C_OPT_REFCOUNTED_P(val)) {
			C_ADDREF_P(val);
		}
		C_FE_POS(generator->values) = 0;
		zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	} else if ((IS_TMP_VAR|IS_VAR) != IS_CONST && C_TYPE_P(val) == IS_OBJECT && C_OBJCE_P(val)->get_iterator) {
		crex_class_entry *ce = C_OBJCE_P(val);
		if (ce == crex_ce_generator) {
			crex_generator *new_gen = (crex_generator *) C_OBJ_P(val);

			C_ADDREF_P(val);
			zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));

			if (UNEXPECTED(new_gen->execute_data == NULL)) {
				crex_throw_error(NULL, "Generator passed to yield from was aborted without proper return and is unable to continue");
				zval_ptr_dtor(val);
				UNDEF_RESULT();
				HANDLE_EXCEPTION();
			} else if (C_ISUNDEF(new_gen->retval)) {
				if (UNEXPECTED(crex_generator_get_current(new_gen) == generator)) {
					crex_throw_error(NULL, "Impossible to yield from the Generator being currently run");
					zval_ptr_dtor(val);
					UNDEF_RESULT();
					HANDLE_EXCEPTION();
				} else {
					crex_generator_yield_from(generator, new_gen);
				}
			} else {
				if (RETURN_VALUE_USED(opline)) {
					ZVAL_COPY(EX_VAR(opline->result.var), &new_gen->retval);
				}
				CREX_VM_NEXT_OPCODE();
			}
		} else {
			crex_object_iterator *iter = ce->get_iterator(ce, val, 0);
			zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));

			if (UNEXPECTED(!iter) || UNEXPECTED(EG(exception))) {
				if (!EG(exception)) {
					crex_throw_error(NULL, "Object of type %s did not create an Iterator", ZSTR_VAL(ce->name));
				}
				UNDEF_RESULT();
				HANDLE_EXCEPTION();
			}

			iter->index = 0;
			if (iter->funcs->rewind) {
				iter->funcs->rewind(iter);
				if (UNEXPECTED(EG(exception) != NULL)) {
					OBJ_RELEASE(&iter->std);
					UNDEF_RESULT();
					HANDLE_EXCEPTION();
				}
			}

			ZVAL_OBJ(&generator->values, &iter->std);
		}
	} else if (((IS_TMP_VAR|IS_VAR) & (IS_VAR|IS_CV)) && C_TYPE_P(val) == IS_REFERENCE) {
		val = C_REFVAL_P(val);
		goto yield_from_try_again;
	} else {
		crex_throw_error(NULL, "Can use \"yield from\" only with arrays and Traversables");
		zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
		UNDEF_RESULT();
		HANDLE_EXCEPTION();
	}

	/* This is the default return value
	 * when the expression is a Generator, it will be overwritten in crex_generator_resume() */
	if (RETURN_VALUE_USED(opline)) {
		ZVAL_NULL(EX_VAR(opline->result.var));
	}

	/* This generator has no send target (though the generator we delegate to might have one) */
	generator->send_target = NULL;

	/* We increment to the next op, so we are at the correct position when the
	 * generator is resumed. */
	CREX_VM_INC_OPCODE();

	/* The GOTO VM uses a local opline variable. We need to set the opline
	 * variable in execute_data so we don't resume at an old position. */
	SAVE_OPLINE();

	CREX_VM_RETURN();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_STRLEN_SPEC_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *value;

	value = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	if (EXPECTED(C_TYPE_P(value) == IS_STRING)) {
		ZVAL_LONG(EX_VAR(opline->result.var), C_STRLEN_P(value));
		if ((IS_TMP_VAR|IS_VAR) & (IS_TMP_VAR|IS_VAR)) {
			zval_ptr_dtor_str(value);
		}
		CREX_VM_NEXT_OPCODE();
	} else {
		bool strict;

		if (((IS_TMP_VAR|IS_VAR) & (IS_VAR|IS_CV)) && C_TYPE_P(value) == IS_REFERENCE) {
			value = C_REFVAL_P(value);
			if (EXPECTED(C_TYPE_P(value) == IS_STRING)) {
				ZVAL_LONG(EX_VAR(opline->result.var), C_STRLEN_P(value));
				zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
				CREX_VM_NEXT_OPCODE();
			}
		}

		SAVE_OPLINE();
		if ((IS_TMP_VAR|IS_VAR) == IS_CV && UNEXPECTED(C_TYPE_P(value) == IS_UNDEF)) {
			value = ZVAL_UNDEFINED_OP1();
		}
		strict = EX_USES_STRICT_TYPES();
		do {
			if (EXPECTED(!strict)) {
				crex_string *str;
				zval tmp;

				if (UNEXPECTED(C_TYPE_P(value) == IS_NULL)) {
					crex_error(E_DEPRECATED,
						"strlen(): Passing null to parameter #1 ($string) of type string is deprecated");
					ZVAL_LONG(EX_VAR(opline->result.var), 0);
					if (UNEXPECTED(EG(exception))) {
						HANDLE_EXCEPTION();
					}
					break;
				}

				ZVAL_COPY(&tmp, value);
				if (crex_parse_arg_str_weak(&tmp, &str, 1)) {
					ZVAL_LONG(EX_VAR(opline->result.var), ZSTR_LEN(str));
					zval_ptr_dtor(&tmp);
					break;
				}
				zval_ptr_dtor(&tmp);
			}
			if (!EG(exception)) {
				crex_type_error("strlen(): Argument #1 ($string) must be of type string, %s given", crex_zval_value_name(value));
			}
			ZVAL_UNDEF(EX_VAR(opline->result.var));
		} while (0);
	}
	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_VM_HOT CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_TYPE_CHECK_SPEC_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *value;
	int result = 0;

	value = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	if ((opline->extended_value >> (uint32_t)C_TYPE_P(value)) & 1) {
type_check_resource:
		if (opline->extended_value != MAY_BE_RESOURCE
		 || EXPECTED(NULL != crex_rsrc_list_get_rsrc_type(C_RES_P(value)))) {
			result = 1;
		}
	} else if (((IS_TMP_VAR|IS_VAR) & (IS_CV|IS_VAR)) && C_ISREF_P(value)) {
		value = C_REFVAL_P(value);
		if ((opline->extended_value >> (uint32_t)C_TYPE_P(value)) & 1) {
			goto type_check_resource;
		}
	} else if ((IS_TMP_VAR|IS_VAR) == IS_CV && UNEXPECTED(C_TYPE_P(value) == IS_UNDEF)) {
		result = ((1 << IS_NULL) & opline->extended_value) != 0;
		SAVE_OPLINE();
		ZVAL_UNDEFINED_OP1();
		if (UNEXPECTED(EG(exception))) {
			ZVAL_UNDEF(EX_VAR(opline->result.var));
			HANDLE_EXCEPTION();
		}
	}
	if ((IS_TMP_VAR|IS_VAR) & (IS_TMP_VAR|IS_VAR)) {
		SAVE_OPLINE();
		zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
		CREX_VM_SMART_BRANCH(result, 1);
	} else {
		CREX_VM_SMART_BRANCH(result, 0);
	}
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FETCH_CLASS_NAME_SPEC_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	uint32_t fetch_type;
	crex_class_entry *called_scope, *scope;
	USE_OPLINE

	if ((IS_TMP_VAR|IS_VAR) != IS_UNUSED) {
		SAVE_OPLINE();
		zval *op = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);
		if (UNEXPECTED(C_TYPE_P(op) != IS_OBJECT)) {
			ZVAL_DEREF(op);
			if (C_TYPE_P(op) != IS_OBJECT) {
				crex_type_error("Cannot use \"::class\" on %s", crex_zval_value_name(op));
				ZVAL_UNDEF(EX_VAR(opline->result.var));
				zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
				HANDLE_EXCEPTION();
			}
		}

		ZVAL_STR_COPY(EX_VAR(opline->result.var), C_OBJCE_P(op)->name);
		zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
		CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
	}

	fetch_type = opline->op1.num;
	scope = EX(func)->op_array.scope;
	if (UNEXPECTED(scope == NULL)) {
		SAVE_OPLINE();
		crex_throw_error(NULL, "Cannot use \"%s\" in the global scope",
			fetch_type == CREX_FETCH_CLASS_SELF ? "self" :
			fetch_type == CREX_FETCH_CLASS_PARENT ? "parent" : "static");
		ZVAL_UNDEF(EX_VAR(opline->result.var));
		HANDLE_EXCEPTION();
	}

	switch (fetch_type) {
		case CREX_FETCH_CLASS_SELF:
			ZVAL_STR_COPY(EX_VAR(opline->result.var), scope->name);
			break;
		case CREX_FETCH_CLASS_PARENT:
			if (UNEXPECTED(scope->parent == NULL)) {
				SAVE_OPLINE();
				crex_throw_error(NULL,
					"Cannot use \"parent\" when current class scope has no parent");
				ZVAL_UNDEF(EX_VAR(opline->result.var));
				HANDLE_EXCEPTION();
			}
			ZVAL_STR_COPY(EX_VAR(opline->result.var), scope->parent->name);
			break;
		case CREX_FETCH_CLASS_STATIC:
			if (C_TYPE(EX(This)) == IS_OBJECT) {
				called_scope = C_OBJCE(EX(This));
			} else {
				called_scope = C_CE(EX(This));
			}
			ZVAL_STR_COPY(EX_VAR(opline->result.var), called_scope->name);
			break;
		EMPTY_SWITCH_DEFAULT_CASE()
	}
	CREX_VM_NEXT_OPCODE();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_DIV_SPEC_TMPVAR_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;

	SAVE_OPLINE();
	op1 = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	op2 = RT_CONSTANT(opline, opline->op2);
	div_function(EX_VAR(opline->result.var), op1, op2);
	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));

	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_POW_SPEC_TMPVAR_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;

	SAVE_OPLINE();
	op1 = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	op2 = RT_CONSTANT(opline, opline->op2);
	pow_function(EX_VAR(opline->result.var), op1, op2);
	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));

	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_CONCAT_SPEC_TMPVAR_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;

	op1 = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	op2 = RT_CONSTANT(opline, opline->op2);

	if (((IS_TMP_VAR|IS_VAR) == IS_CONST || EXPECTED(C_TYPE_P(op1) == IS_STRING)) &&
	    (IS_CONST == IS_CONST || EXPECTED(C_TYPE_P(op2) == IS_STRING))) {
		crex_string *op1_str = C_STR_P(op1);
		crex_string *op2_str = C_STR_P(op2);
		crex_string *str;
		uint32_t flags = ZSTR_GET_COPYABLE_CONCAT_PROPERTIES_BOTH(op1_str, op2_str);

		if ((IS_TMP_VAR|IS_VAR) != IS_CONST && UNEXPECTED(ZSTR_LEN(op1_str) == 0)) {
			if (IS_CONST == IS_CONST || IS_CONST == IS_CV) {
				ZVAL_STR_COPY(EX_VAR(opline->result.var), op2_str);
			} else {
				ZVAL_STR(EX_VAR(opline->result.var), op2_str);
			}
			if ((IS_TMP_VAR|IS_VAR) & (IS_TMP_VAR|IS_VAR)) {
				crex_string_release_ex(op1_str, 0);
			}
		} else if (IS_CONST != IS_CONST && UNEXPECTED(ZSTR_LEN(op2_str) == 0)) {
			if ((IS_TMP_VAR|IS_VAR) == IS_CONST || (IS_TMP_VAR|IS_VAR) == IS_CV) {
				ZVAL_STR_COPY(EX_VAR(opline->result.var), op1_str);
			} else {
				ZVAL_STR(EX_VAR(opline->result.var), op1_str);
			}
			if (IS_CONST & (IS_TMP_VAR|IS_VAR)) {
				crex_string_release_ex(op2_str, 0);
			}
		} else if ((IS_TMP_VAR|IS_VAR) != IS_CONST && (IS_TMP_VAR|IS_VAR) != IS_CV &&
		    !ZSTR_IS_INTERNED(op1_str) && GC_REFCOUNT(op1_str) == 1) {
			size_t len = ZSTR_LEN(op1_str);

			if (UNEXPECTED(len > ZSTR_MAX_LEN - ZSTR_LEN(op2_str))) {
				crex_error_noreturn(E_ERROR, "Integer overflow in memory allocation");
			}
			str = crex_string_extend(op1_str, len + ZSTR_LEN(op2_str), 0);
			memcpy(ZSTR_VAL(str) + len, ZSTR_VAL(op2_str), ZSTR_LEN(op2_str)+1);
			GC_ADD_FLAGS(str, flags);
			ZVAL_NEW_STR(EX_VAR(opline->result.var), str);
			if (IS_CONST & (IS_TMP_VAR|IS_VAR)) {
				crex_string_release_ex(op2_str, 0);
			}
		} else {
			str = crex_string_alloc(ZSTR_LEN(op1_str) + ZSTR_LEN(op2_str), 0);
			memcpy(ZSTR_VAL(str), ZSTR_VAL(op1_str), ZSTR_LEN(op1_str));
			memcpy(ZSTR_VAL(str) + ZSTR_LEN(op1_str), ZSTR_VAL(op2_str), ZSTR_LEN(op2_str)+1);
			GC_ADD_FLAGS(str, flags);
			ZVAL_NEW_STR(EX_VAR(opline->result.var), str);
			if ((IS_TMP_VAR|IS_VAR) & (IS_TMP_VAR|IS_VAR)) {
				crex_string_release_ex(op1_str, 0);
			}
			if (IS_CONST & (IS_TMP_VAR|IS_VAR)) {
				crex_string_release_ex(op2_str, 0);
			}
		}
		CREX_VM_NEXT_OPCODE();
	} else {
		SAVE_OPLINE();

		if ((IS_TMP_VAR|IS_VAR) == IS_CV && UNEXPECTED(C_TYPE_P(op1) == IS_UNDEF)) {
			op1 = ZVAL_UNDEFINED_OP1();
		}
		if (IS_CONST == IS_CV && UNEXPECTED(C_TYPE_P(op2) == IS_UNDEF)) {
			op2 = ZVAL_UNDEFINED_OP2();
		}
		concat_function(EX_VAR(opline->result.var), op1, op2);
		zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));

		CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
	}
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_IS_EQUAL_SPEC_TMPVAR_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	double d1, d2;

	op1 = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	op2 = RT_CONSTANT(opline, opline->op2);
	if (1 && (IS_TMP_VAR|IS_VAR) == IS_CONST && IS_CONST == IS_CONST) {
		/* pass */
	} else if (EXPECTED(C_TYPE_P(op1) == IS_LONG)) {
		if (EXPECTED(C_TYPE_P(op2) == IS_LONG)) {
			if (EXPECTED(C_LVAL_P(op1) == C_LVAL_P(op2))) {
is_equal_true:
				CREX_VM_SMART_BRANCH_TRUE_NONE();
			} else {
is_equal_false:
				CREX_VM_SMART_BRANCH_FALSE_NONE();
			}
		} else if (EXPECTED(C_TYPE_P(op2) == IS_DOUBLE)) {
			d1 = (double)C_LVAL_P(op1);
			d2 = C_DVAL_P(op2);
			goto is_equal_double;
		}
	} else if (EXPECTED(C_TYPE_P(op1) == IS_DOUBLE)) {
		if (EXPECTED(C_TYPE_P(op2) == IS_DOUBLE)) {
			d1 = C_DVAL_P(op1);
			d2 = C_DVAL_P(op2);
is_equal_double:
			if (d1 == d2) {
				goto is_equal_true;
			} else {
				goto is_equal_false;
			}
		} else if (EXPECTED(C_TYPE_P(op2) == IS_LONG)) {
			d1 = C_DVAL_P(op1);
			d2 = (double)C_LVAL_P(op2);
			goto is_equal_double;
		}
	} else if (EXPECTED(C_TYPE_P(op1) == IS_STRING)) {
		if (EXPECTED(C_TYPE_P(op2) == IS_STRING)) {
			bool result = crex_fast_equal_strings(C_STR_P(op1), C_STR_P(op2));
			if ((IS_TMP_VAR|IS_VAR) & (IS_TMP_VAR|IS_VAR)) {
				zval_ptr_dtor_str(op1);
			}
			if (IS_CONST & (IS_TMP_VAR|IS_VAR)) {
				zval_ptr_dtor_str(op2);
			}
			if (result) {
				goto is_equal_true;
			} else {
				goto is_equal_false;
			}
		}
	}
	CREX_VM_TAIL_CALL(crex_is_equal_helper_SPEC(op1, op2 CREX_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_IS_EQUAL_SPEC_TMPVAR_CONST_JMPC_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	double d1, d2;

	op1 = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	op2 = RT_CONSTANT(opline, opline->op2);
	if (1 && (IS_TMP_VAR|IS_VAR) == IS_CONST && IS_CONST == IS_CONST) {
		/* pass */
	} else if (EXPECTED(C_TYPE_P(op1) == IS_LONG)) {
		if (EXPECTED(C_TYPE_P(op2) == IS_LONG)) {
			if (EXPECTED(C_LVAL_P(op1) == C_LVAL_P(op2))) {
is_equal_true:
				CREX_VM_SMART_BRANCH_TRUE_JMPZ();
			} else {
is_equal_false:
				CREX_VM_SMART_BRANCH_FALSE_JMPZ();
			}
		} else if (EXPECTED(C_TYPE_P(op2) == IS_DOUBLE)) {
			d1 = (double)C_LVAL_P(op1);
			d2 = C_DVAL_P(op2);
			goto is_equal_double;
		}
	} else if (EXPECTED(C_TYPE_P(op1) == IS_DOUBLE)) {
		if (EXPECTED(C_TYPE_P(op2) == IS_DOUBLE)) {
			d1 = C_DVAL_P(op1);
			d2 = C_DVAL_P(op2);
is_equal_double:
			if (d1 == d2) {
				goto is_equal_true;
			} else {
				goto is_equal_false;
			}
		} else if (EXPECTED(C_TYPE_P(op2) == IS_LONG)) {
			d1 = C_DVAL_P(op1);
			d2 = (double)C_LVAL_P(op2);
			goto is_equal_double;
		}
	} else if (EXPECTED(C_TYPE_P(op1) == IS_STRING)) {
		if (EXPECTED(C_TYPE_P(op2) == IS_STRING)) {
			bool result = crex_fast_equal_strings(C_STR_P(op1), C_STR_P(op2));
			if ((IS_TMP_VAR|IS_VAR) & (IS_TMP_VAR|IS_VAR)) {
				zval_ptr_dtor_str(op1);
			}
			if (IS_CONST & (IS_TMP_VAR|IS_VAR)) {
				zval_ptr_dtor_str(op2);
			}
			if (result) {
				goto is_equal_true;
			} else {
				goto is_equal_false;
			}
		}
	}
	CREX_VM_TAIL_CALL(crex_is_equal_helper_SPEC(op1, op2 CREX_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_IS_EQUAL_SPEC_TMPVAR_CONST_JMPNC_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	double d1, d2;

	op1 = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	op2 = RT_CONSTANT(opline, opline->op2);
	if (1 && (IS_TMP_VAR|IS_VAR) == IS_CONST && IS_CONST == IS_CONST) {
		/* pass */
	} else if (EXPECTED(C_TYPE_P(op1) == IS_LONG)) {
		if (EXPECTED(C_TYPE_P(op2) == IS_LONG)) {
			if (EXPECTED(C_LVAL_P(op1) == C_LVAL_P(op2))) {
is_equal_true:
				CREX_VM_SMART_BRANCH_TRUE_JMPNZ();
			} else {
is_equal_false:
				CREX_VM_SMART_BRANCH_FALSE_JMPNZ();
			}
		} else if (EXPECTED(C_TYPE_P(op2) == IS_DOUBLE)) {
			d1 = (double)C_LVAL_P(op1);
			d2 = C_DVAL_P(op2);
			goto is_equal_double;
		}
	} else if (EXPECTED(C_TYPE_P(op1) == IS_DOUBLE)) {
		if (EXPECTED(C_TYPE_P(op2) == IS_DOUBLE)) {
			d1 = C_DVAL_P(op1);
			d2 = C_DVAL_P(op2);
is_equal_double:
			if (d1 == d2) {
				goto is_equal_true;
			} else {
				goto is_equal_false;
			}
		} else if (EXPECTED(C_TYPE_P(op2) == IS_LONG)) {
			d1 = C_DVAL_P(op1);
			d2 = (double)C_LVAL_P(op2);
			goto is_equal_double;
		}
	} else if (EXPECTED(C_TYPE_P(op1) == IS_STRING)) {
		if (EXPECTED(C_TYPE_P(op2) == IS_STRING)) {
			bool result = crex_fast_equal_strings(C_STR_P(op1), C_STR_P(op2));
			if ((IS_TMP_VAR|IS_VAR) & (IS_TMP_VAR|IS_VAR)) {
				zval_ptr_dtor_str(op1);
			}
			if (IS_CONST & (IS_TMP_VAR|IS_VAR)) {
				zval_ptr_dtor_str(op2);
			}
			if (result) {
				goto is_equal_true;
			} else {
				goto is_equal_false;
			}
		}
	}
	CREX_VM_TAIL_CALL(crex_is_equal_helper_SPEC(op1, op2 CREX_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_IS_NOT_EQUAL_SPEC_TMPVAR_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	double d1, d2;

	op1 = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	op2 = RT_CONSTANT(opline, opline->op2);
	if (1 && (IS_TMP_VAR|IS_VAR) == IS_CONST && IS_CONST == IS_CONST) {
		/* pass */
	} else if (EXPECTED(C_TYPE_P(op1) == IS_LONG)) {
		if (EXPECTED(C_TYPE_P(op2) == IS_LONG)) {
			if (EXPECTED(C_LVAL_P(op1) != C_LVAL_P(op2))) {
is_not_equal_true:
				CREX_VM_SMART_BRANCH_TRUE_NONE();
			} else {
is_not_equal_false:
				CREX_VM_SMART_BRANCH_FALSE_NONE();
			}
		} else if (EXPECTED(C_TYPE_P(op2) == IS_DOUBLE)) {
			d1 = (double)C_LVAL_P(op1);
			d2 = C_DVAL_P(op2);
			goto is_not_equal_double;
		}
	} else if (EXPECTED(C_TYPE_P(op1) == IS_DOUBLE)) {
		if (EXPECTED(C_TYPE_P(op2) == IS_DOUBLE)) {
			d1 = C_DVAL_P(op1);
			d2 = C_DVAL_P(op2);
is_not_equal_double:
			if (d1 != d2) {
				goto is_not_equal_true;
			} else {
				goto is_not_equal_false;
			}
		} else if (EXPECTED(C_TYPE_P(op2) == IS_LONG)) {
			d1 = C_DVAL_P(op1);
			d2 = (double)C_LVAL_P(op2);
			goto is_not_equal_double;
		}
	} else if (EXPECTED(C_TYPE_P(op1) == IS_STRING)) {
		if (EXPECTED(C_TYPE_P(op2) == IS_STRING)) {
			bool result = crex_fast_equal_strings(C_STR_P(op1), C_STR_P(op2));
			if ((IS_TMP_VAR|IS_VAR) & (IS_TMP_VAR|IS_VAR)) {
				zval_ptr_dtor_str(op1);
			}
			if (IS_CONST & (IS_TMP_VAR|IS_VAR)) {
				zval_ptr_dtor_str(op2);
			}
			if (!result) {
				goto is_not_equal_true;
			} else {
				goto is_not_equal_false;
			}
		}
	}
	CREX_VM_TAIL_CALL(crex_is_not_equal_helper_SPEC(op1, op2 CREX_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_IS_NOT_EQUAL_SPEC_TMPVAR_CONST_JMPC_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	double d1, d2;

	op1 = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	op2 = RT_CONSTANT(opline, opline->op2);
	if (1 && (IS_TMP_VAR|IS_VAR) == IS_CONST && IS_CONST == IS_CONST) {
		/* pass */
	} else if (EXPECTED(C_TYPE_P(op1) == IS_LONG)) {
		if (EXPECTED(C_TYPE_P(op2) == IS_LONG)) {
			if (EXPECTED(C_LVAL_P(op1) != C_LVAL_P(op2))) {
is_not_equal_true:
				CREX_VM_SMART_BRANCH_TRUE_JMPZ();
			} else {
is_not_equal_false:
				CREX_VM_SMART_BRANCH_FALSE_JMPZ();
			}
		} else if (EXPECTED(C_TYPE_P(op2) == IS_DOUBLE)) {
			d1 = (double)C_LVAL_P(op1);
			d2 = C_DVAL_P(op2);
			goto is_not_equal_double;
		}
	} else if (EXPECTED(C_TYPE_P(op1) == IS_DOUBLE)) {
		if (EXPECTED(C_TYPE_P(op2) == IS_DOUBLE)) {
			d1 = C_DVAL_P(op1);
			d2 = C_DVAL_P(op2);
is_not_equal_double:
			if (d1 != d2) {
				goto is_not_equal_true;
			} else {
				goto is_not_equal_false;
			}
		} else if (EXPECTED(C_TYPE_P(op2) == IS_LONG)) {
			d1 = C_DVAL_P(op1);
			d2 = (double)C_LVAL_P(op2);
			goto is_not_equal_double;
		}
	} else if (EXPECTED(C_TYPE_P(op1) == IS_STRING)) {
		if (EXPECTED(C_TYPE_P(op2) == IS_STRING)) {
			bool result = crex_fast_equal_strings(C_STR_P(op1), C_STR_P(op2));
			if ((IS_TMP_VAR|IS_VAR) & (IS_TMP_VAR|IS_VAR)) {
				zval_ptr_dtor_str(op1);
			}
			if (IS_CONST & (IS_TMP_VAR|IS_VAR)) {
				zval_ptr_dtor_str(op2);
			}
			if (!result) {
				goto is_not_equal_true;
			} else {
				goto is_not_equal_false;
			}
		}
	}
	CREX_VM_TAIL_CALL(crex_is_not_equal_helper_SPEC(op1, op2 CREX_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_IS_NOT_EQUAL_SPEC_TMPVAR_CONST_JMPNC_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	double d1, d2;

	op1 = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	op2 = RT_CONSTANT(opline, opline->op2);
	if (1 && (IS_TMP_VAR|IS_VAR) == IS_CONST && IS_CONST == IS_CONST) {
		/* pass */
	} else if (EXPECTED(C_TYPE_P(op1) == IS_LONG)) {
		if (EXPECTED(C_TYPE_P(op2) == IS_LONG)) {
			if (EXPECTED(C_LVAL_P(op1) != C_LVAL_P(op2))) {
is_not_equal_true:
				CREX_VM_SMART_BRANCH_TRUE_JMPNZ();
			} else {
is_not_equal_false:
				CREX_VM_SMART_BRANCH_FALSE_JMPNZ();
			}
		} else if (EXPECTED(C_TYPE_P(op2) == IS_DOUBLE)) {
			d1 = (double)C_LVAL_P(op1);
			d2 = C_DVAL_P(op2);
			goto is_not_equal_double;
		}
	} else if (EXPECTED(C_TYPE_P(op1) == IS_DOUBLE)) {
		if (EXPECTED(C_TYPE_P(op2) == IS_DOUBLE)) {
			d1 = C_DVAL_P(op1);
			d2 = C_DVAL_P(op2);
is_not_equal_double:
			if (d1 != d2) {
				goto is_not_equal_true;
			} else {
				goto is_not_equal_false;
			}
		} else if (EXPECTED(C_TYPE_P(op2) == IS_LONG)) {
			d1 = C_DVAL_P(op1);
			d2 = (double)C_LVAL_P(op2);
			goto is_not_equal_double;
		}
	} else if (EXPECTED(C_TYPE_P(op1) == IS_STRING)) {
		if (EXPECTED(C_TYPE_P(op2) == IS_STRING)) {
			bool result = crex_fast_equal_strings(C_STR_P(op1), C_STR_P(op2));
			if ((IS_TMP_VAR|IS_VAR) & (IS_TMP_VAR|IS_VAR)) {
				zval_ptr_dtor_str(op1);
			}
			if (IS_CONST & (IS_TMP_VAR|IS_VAR)) {
				zval_ptr_dtor_str(op2);
			}
			if (!result) {
				goto is_not_equal_true;
			} else {
				goto is_not_equal_false;
			}
		}
	}
	CREX_VM_TAIL_CALL(crex_is_not_equal_helper_SPEC(op1, op2 CREX_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_SPACESHIP_SPEC_TMPVAR_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;

	SAVE_OPLINE();
	op1 = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	op2 = RT_CONSTANT(opline, opline->op2);
	compare_function(EX_VAR(opline->result.var), op1, op2);
	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));

	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_BOOL_XOR_SPEC_TMPVAR_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;

	SAVE_OPLINE();
	op1 = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	op2 = RT_CONSTANT(opline, opline->op2);
	boolean_xor_function(EX_VAR(opline->result.var), op1, op2);
	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));

	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FETCH_DIM_R_SPEC_TMPVAR_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container, *dim, *value;

	SAVE_OPLINE();
	container = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	dim = RT_CONSTANT(opline, opline->op2);
	if ((IS_TMP_VAR|IS_VAR) != IS_CONST) {
		if (EXPECTED(C_TYPE_P(container) == IS_ARRAY)) {
fetch_dim_r_array:
			value = crex_fetch_dimension_address_inner(C_ARRVAL_P(container), dim, IS_CONST, BP_VAR_R EXECUTE_DATA_CC);
			ZVAL_COPY_DEREF(EX_VAR(opline->result.var), value);
		} else if (EXPECTED(C_TYPE_P(container) == IS_REFERENCE)) {
			container = C_REFVAL_P(container);
			if (EXPECTED(C_TYPE_P(container) == IS_ARRAY)) {
				goto fetch_dim_r_array;
			} else {
				goto fetch_dim_r_slow;
			}
		} else {
fetch_dim_r_slow:
			if (IS_CONST == IS_CONST && C_EXTRA_P(dim) == CREX_EXTRA_VALUE) {
				dim++;
			}
			crex_fetch_dimension_address_read_R_slow(container, dim OPLINE_CC EXECUTE_DATA_CC);
		}
	} else {
		crex_fetch_dimension_address_read_R(container, dim, IS_CONST OPLINE_CC EXECUTE_DATA_CC);
	}

	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FETCH_DIM_IS_SPEC_TMPVAR_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;

	SAVE_OPLINE();
	container = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	crex_fetch_dimension_address_read_IS(container, RT_CONSTANT(opline, opline->op2), IS_CONST OPLINE_CC EXECUTE_DATA_CC);

	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FETCH_OBJ_R_SPEC_TMPVAR_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;
	void **cache_slot = NULL;

	SAVE_OPLINE();
	container = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);

	if ((IS_TMP_VAR|IS_VAR) == IS_CONST ||
	    ((IS_TMP_VAR|IS_VAR) != IS_UNUSED && UNEXPECTED(C_TYPE_P(container) != IS_OBJECT))) {
		do {
			if (((IS_TMP_VAR|IS_VAR) & (IS_VAR|IS_CV)) && C_ISREF_P(container)) {
				container = C_REFVAL_P(container);
				if (EXPECTED(C_TYPE_P(container) == IS_OBJECT)) {
					break;
				}
			}
			if ((IS_TMP_VAR|IS_VAR) == IS_CV && UNEXPECTED(C_TYPE_P(container) == IS_UNDEF)) {
				ZVAL_UNDEFINED_OP1();
			}
			crex_wrong_property_read(container, RT_CONSTANT(opline, opline->op2));
			ZVAL_NULL(EX_VAR(opline->result.var));
			goto fetch_obj_r_finish;
		} while (0);
	}

	/* here we are sure we are dealing with an object */
	do {
		crex_object *zobj = C_OBJ_P(container);
		crex_string *name, *tmp_name;
		zval *retval;

		if (IS_CONST == IS_CONST) {
			cache_slot = CACHE_ADDR(opline->extended_value & ~CREX_FETCH_REF /* FUNC_ARG fetch may contain it */);

			if (EXPECTED(zobj->ce == CACHED_PTR_EX(cache_slot))) {
				uintptr_t prop_offset = (uintptr_t)CACHED_PTR_EX(cache_slot + 1);

				if (EXPECTED(IS_VALID_PROPERTY_OFFSET(prop_offset))) {
					retval = OBJ_PROP(zobj, prop_offset);
					if (EXPECTED(C_TYPE_INFO_P(retval) != IS_UNDEF)) {
						if (0 || ((IS_TMP_VAR|IS_VAR) & (IS_TMP_VAR|IS_VAR)) != 0) {
							goto fetch_obj_r_copy;
						} else {
fetch_obj_r_fast_copy:
							ZVAL_COPY_DEREF(EX_VAR(opline->result.var), retval);
							CREX_VM_NEXT_OPCODE();
						}
					}
				} else if (EXPECTED(zobj->properties != NULL)) {
					name = C_STR_P(RT_CONSTANT(opline, opline->op2));
					if (!IS_UNKNOWN_DYNAMIC_PROPERTY_OFFSET(prop_offset)) {
						uintptr_t idx = CREX_DECODE_DYN_PROP_OFFSET(prop_offset);

						if (EXPECTED(idx < zobj->properties->nNumUsed * sizeof(Bucket))) {
							Bucket *p = (Bucket*)((char*)zobj->properties->arData + idx);

							if (EXPECTED(p->key == name) ||
							    (EXPECTED(p->h == ZSTR_H(name)) &&
							     EXPECTED(p->key != NULL) &&
							     EXPECTED(crex_string_equal_content(p->key, name)))) {
								retval = &p->val;
								if (0 || ((IS_TMP_VAR|IS_VAR) & (IS_TMP_VAR|IS_VAR)) != 0) {
									goto fetch_obj_r_copy;
								} else {
									goto fetch_obj_r_fast_copy;
								}
							}
						}
						CACHE_PTR_EX(cache_slot + 1, (void*)CREX_DYNAMIC_PROPERTY_OFFSET);
					}
					retval = crex_hash_find_known_hash(zobj->properties, name);
					if (EXPECTED(retval)) {
						uintptr_t idx = (char*)retval - (char*)zobj->properties->arData;
						CACHE_PTR_EX(cache_slot + 1, (void*)CREX_ENCODE_DYN_PROP_OFFSET(idx));
						if (0 || ((IS_TMP_VAR|IS_VAR) & (IS_TMP_VAR|IS_VAR)) != 0) {
							goto fetch_obj_r_copy;
						} else {
							goto fetch_obj_r_fast_copy;
						}
					}
				}
			}
			name = C_STR_P(RT_CONSTANT(opline, opline->op2));
		} else {
			name = zval_try_get_tmp_string(RT_CONSTANT(opline, opline->op2), &tmp_name);
			if (UNEXPECTED(!name)) {
				ZVAL_UNDEF(EX_VAR(opline->result.var));
				break;
			}
		}

#if CREX_DEBUG
		/* For non-standard object handlers, verify a declared property type in debug builds.
		 * Fetch prop_info before calling read_property(), as it may deallocate the object. */
		crex_property_info *prop_info = NULL;
		if (zobj->handlers->read_property != crex_std_read_property) {
			prop_info = crex_get_property_info(zobj->ce, name, /* silent */ true);
		}
#endif
		retval = zobj->handlers->read_property(zobj, name, BP_VAR_R, cache_slot, EX_VAR(opline->result.var));
#if CREX_DEBUG
		if (!EG(exception) && prop_info && prop_info != CREX_WRONG_PROPERTY_INFO
				&& CREX_TYPE_IS_SET(prop_info->type)) {
			ZVAL_OPT_DEREF(retval);
			crex_verify_property_type(prop_info, retval, /* strict */ true);
		}
#endif

		if (IS_CONST != IS_CONST) {
			crex_tmp_string_release(tmp_name);
		}

		if (retval != EX_VAR(opline->result.var)) {
fetch_obj_r_copy:
			ZVAL_COPY_DEREF(EX_VAR(opline->result.var), retval);
		} else if (UNEXPECTED(C_ISREF_P(retval))) {
			crex_unwrap_reference(retval);
		}
	} while (0);

fetch_obj_r_finish:

	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FETCH_OBJ_IS_SPEC_TMPVAR_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;
	void **cache_slot = NULL;

	SAVE_OPLINE();
	container = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);

	if ((IS_TMP_VAR|IS_VAR) == IS_CONST ||
	    ((IS_TMP_VAR|IS_VAR) != IS_UNUSED && UNEXPECTED(C_TYPE_P(container) != IS_OBJECT))) {
		do {
			if (((IS_TMP_VAR|IS_VAR) & (IS_VAR|IS_CV)) && C_ISREF_P(container)) {
				container = C_REFVAL_P(container);
				if (EXPECTED(C_TYPE_P(container) == IS_OBJECT)) {
					break;
				}
			}
			if (IS_CONST == IS_CV && C_TYPE_P(EX_VAR(opline->op2.var)) == IS_UNDEF) {
				ZVAL_UNDEFINED_OP2();
			}
			ZVAL_NULL(EX_VAR(opline->result.var));
			goto fetch_obj_is_finish;
		} while (0);
	}

	/* here we are sure we are dealing with an object */
	do {
		crex_object *zobj = C_OBJ_P(container);
		crex_string *name, *tmp_name;
		zval *retval;

		if (IS_CONST == IS_CONST) {
			cache_slot = CACHE_ADDR(opline->extended_value);

			if (EXPECTED(zobj->ce == CACHED_PTR_EX(cache_slot))) {
				uintptr_t prop_offset = (uintptr_t)CACHED_PTR_EX(cache_slot + 1);

				if (EXPECTED(IS_VALID_PROPERTY_OFFSET(prop_offset))) {
					retval = OBJ_PROP(zobj, prop_offset);
					if (EXPECTED(C_TYPE_P(retval) != IS_UNDEF)) {
						if (0 || ((IS_TMP_VAR|IS_VAR) & (IS_TMP_VAR|IS_VAR)) != 0) {
							goto fetch_obj_is_copy;
						} else {
fetch_obj_is_fast_copy:
							ZVAL_COPY_DEREF(EX_VAR(opline->result.var), retval);
							CREX_VM_NEXT_OPCODE();
						}
					}
				} else if (EXPECTED(zobj->properties != NULL)) {
					name = C_STR_P(RT_CONSTANT(opline, opline->op2));
					if (!IS_UNKNOWN_DYNAMIC_PROPERTY_OFFSET(prop_offset)) {
						uintptr_t idx = CREX_DECODE_DYN_PROP_OFFSET(prop_offset);

						if (EXPECTED(idx < zobj->properties->nNumUsed * sizeof(Bucket))) {
							Bucket *p = (Bucket*)((char*)zobj->properties->arData + idx);

							if (EXPECTED(p->key == name) ||
							    (EXPECTED(p->h == ZSTR_H(name)) &&
							     EXPECTED(p->key != NULL) &&
							     EXPECTED(crex_string_equal_content(p->key, name)))) {
								retval = &p->val;
								if (0 || ((IS_TMP_VAR|IS_VAR) & (IS_TMP_VAR|IS_VAR)) != 0) {
									goto fetch_obj_is_copy;
								} else {
									goto fetch_obj_is_fast_copy;
								}
							}
						}
						CACHE_PTR_EX(cache_slot + 1, (void*)CREX_DYNAMIC_PROPERTY_OFFSET);
					}
					retval = crex_hash_find_known_hash(zobj->properties, name);
					if (EXPECTED(retval)) {
						uintptr_t idx = (char*)retval - (char*)zobj->properties->arData;
						CACHE_PTR_EX(cache_slot + 1, (void*)CREX_ENCODE_DYN_PROP_OFFSET(idx));
						if (0 || ((IS_TMP_VAR|IS_VAR) & (IS_TMP_VAR|IS_VAR)) != 0) {
							goto fetch_obj_is_copy;
						} else {
							goto fetch_obj_is_fast_copy;
						}
					}
				}
			}
			name = C_STR_P(RT_CONSTANT(opline, opline->op2));
		} else {
			name = zval_try_get_tmp_string(RT_CONSTANT(opline, opline->op2), &tmp_name);
			if (UNEXPECTED(!name)) {
				ZVAL_UNDEF(EX_VAR(opline->result.var));
				break;
			}
		}

		retval = zobj->handlers->read_property(zobj, name, BP_VAR_IS, cache_slot, EX_VAR(opline->result.var));

		if (IS_CONST != IS_CONST) {
			crex_tmp_string_release(tmp_name);
		}

		if (retval != EX_VAR(opline->result.var)) {
fetch_obj_is_copy:
			ZVAL_COPY_DEREF(EX_VAR(opline->result.var), retval);
		} else if (UNEXPECTED(C_ISREF_P(retval))) {
			crex_unwrap_reference(retval);
		}
	} while (0);

fetch_obj_is_finish:

	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FAST_CONCAT_SPEC_TMPVAR_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	crex_string *op1_str, *op2_str, *str;


	op1 = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	op2 = RT_CONSTANT(opline, opline->op2);
	if (((IS_TMP_VAR|IS_VAR) == IS_CONST || EXPECTED(C_TYPE_P(op1) == IS_STRING)) &&
	    (IS_CONST == IS_CONST || EXPECTED(C_TYPE_P(op2) == IS_STRING))) {
		crex_string *op1_str = C_STR_P(op1);
		crex_string *op2_str = C_STR_P(op2);
		crex_string *str;
		uint32_t flags = ZSTR_GET_COPYABLE_CONCAT_PROPERTIES_BOTH(op1_str, op2_str);

		if ((IS_TMP_VAR|IS_VAR) != IS_CONST && UNEXPECTED(ZSTR_LEN(op1_str) == 0)) {
			if (IS_CONST == IS_CONST || IS_CONST == IS_CV) {
				ZVAL_STR_COPY(EX_VAR(opline->result.var), op2_str);
			} else {
				ZVAL_STR(EX_VAR(opline->result.var), op2_str);
			}
			if ((IS_TMP_VAR|IS_VAR) & (IS_TMP_VAR|IS_VAR)) {
				crex_string_release_ex(op1_str, 0);
			}
		} else if (IS_CONST != IS_CONST && UNEXPECTED(ZSTR_LEN(op2_str) == 0)) {
			if ((IS_TMP_VAR|IS_VAR) == IS_CONST || (IS_TMP_VAR|IS_VAR) == IS_CV) {
				ZVAL_STR_COPY(EX_VAR(opline->result.var), op1_str);
			} else {
				ZVAL_STR(EX_VAR(opline->result.var), op1_str);
			}
			if (IS_CONST & (IS_TMP_VAR|IS_VAR)) {
				crex_string_release_ex(op2_str, 0);
			}
		} else if ((IS_TMP_VAR|IS_VAR) != IS_CONST && (IS_TMP_VAR|IS_VAR) != IS_CV &&
		    !ZSTR_IS_INTERNED(op1_str) && GC_REFCOUNT(op1_str) == 1) {
			size_t len = ZSTR_LEN(op1_str);

			str = crex_string_extend(op1_str, len + ZSTR_LEN(op2_str), 0);
			memcpy(ZSTR_VAL(str) + len, ZSTR_VAL(op2_str), ZSTR_LEN(op2_str)+1);
			GC_ADD_FLAGS(str, flags);
			ZVAL_NEW_STR(EX_VAR(opline->result.var), str);
			if (IS_CONST & (IS_TMP_VAR|IS_VAR)) {
				crex_string_release_ex(op2_str, 0);
			}
		} else {
			str = crex_string_alloc(ZSTR_LEN(op1_str) + ZSTR_LEN(op2_str), 0);
			memcpy(ZSTR_VAL(str), ZSTR_VAL(op1_str), ZSTR_LEN(op1_str));
			memcpy(ZSTR_VAL(str) + ZSTR_LEN(op1_str), ZSTR_VAL(op2_str), ZSTR_LEN(op2_str)+1);
			GC_ADD_FLAGS(str, flags);
			ZVAL_NEW_STR(EX_VAR(opline->result.var), str);
			if ((IS_TMP_VAR|IS_VAR) & (IS_TMP_VAR|IS_VAR)) {
				crex_string_release_ex(op1_str, 0);
			}
			if (IS_CONST & (IS_TMP_VAR|IS_VAR)) {
				crex_string_release_ex(op2_str, 0);
			}
		}
		CREX_VM_NEXT_OPCODE();
	}

	SAVE_OPLINE();
	if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
		op1_str = C_STR_P(op1);
	} else if (EXPECTED(C_TYPE_P(op1) == IS_STRING)) {
		op1_str = crex_string_copy(C_STR_P(op1));
	} else {
		if ((IS_TMP_VAR|IS_VAR) == IS_CV && UNEXPECTED(C_TYPE_P(op1) == IS_UNDEF)) {
			ZVAL_UNDEFINED_OP1();
		}
		op1_str = zval_get_string_func(op1);
	}
	if (IS_CONST == IS_CONST) {
		op2_str = C_STR_P(op2);
	} else if (EXPECTED(C_TYPE_P(op2) == IS_STRING)) {
		op2_str = crex_string_copy(C_STR_P(op2));
	} else {
		if (IS_CONST == IS_CV && UNEXPECTED(C_TYPE_P(op2) == IS_UNDEF)) {
			ZVAL_UNDEFINED_OP2();
		}
		op2_str = zval_get_string_func(op2);
	}
	do {
		if ((IS_TMP_VAR|IS_VAR) != IS_CONST) {
			if (UNEXPECTED(ZSTR_LEN(op1_str) == 0)) {
				if (IS_CONST == IS_CONST) {
					if (UNEXPECTED(C_REFCOUNTED_P(op2))) {
						GC_ADDREF(op2_str);
					}
				}
				ZVAL_STR(EX_VAR(opline->result.var), op2_str);
				crex_string_release_ex(op1_str, 0);
				break;
			}
		}
		if (IS_CONST != IS_CONST) {
			if (UNEXPECTED(ZSTR_LEN(op2_str) == 0)) {
				if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
					if (UNEXPECTED(C_REFCOUNTED_P(op1))) {
						GC_ADDREF(op1_str);
					}
				}
				ZVAL_STR(EX_VAR(opline->result.var), op1_str);
				crex_string_release_ex(op2_str, 0);
				break;
			}
		}
		str = crex_string_alloc(ZSTR_LEN(op1_str) + ZSTR_LEN(op2_str), 0);
		memcpy(ZSTR_VAL(str), ZSTR_VAL(op1_str), ZSTR_LEN(op1_str));
		memcpy(ZSTR_VAL(str) + ZSTR_LEN(op1_str), ZSTR_VAL(op2_str), ZSTR_LEN(op2_str)+1);

		ZSTR_COPY_CONCAT_PROPERTIES_BOTH(str, op1_str, op2_str);
		ZVAL_NEW_STR(EX_VAR(opline->result.var), str);
		if ((IS_TMP_VAR|IS_VAR) != IS_CONST) {
			crex_string_release_ex(op1_str, 0);
		}
		if (IS_CONST != IS_CONST) {
			crex_string_release_ex(op2_str, 0);
		}
	} while (0);
	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));

	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_INIT_METHOD_CALL_SPEC_TMPVAR_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *function_name;
	zval *object;
	crex_function *fbc;
	crex_class_entry *called_scope;
	crex_object *obj;
	crex_execute_data *call;
	uint32_t call_info;

	SAVE_OPLINE();

	object = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);

	if (IS_CONST != IS_CONST) {
		function_name = RT_CONSTANT(opline, opline->op2);
	}

	if (IS_CONST != IS_CONST &&
	    UNEXPECTED(C_TYPE_P(function_name) != IS_STRING)) {
		do {
			if ((IS_CONST & (IS_VAR|IS_CV)) && C_ISREF_P(function_name)) {
				function_name = C_REFVAL_P(function_name);
				if (EXPECTED(C_TYPE_P(function_name) == IS_STRING)) {
					break;
				}
			} else if (IS_CONST == IS_CV && UNEXPECTED(C_TYPE_P(function_name) == IS_UNDEF)) {
				ZVAL_UNDEFINED_OP2();
				if (UNEXPECTED(EG(exception) != NULL)) {
					zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
					HANDLE_EXCEPTION();
				}
			}
			crex_throw_error(NULL, "Method name must be a string");

			zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
			HANDLE_EXCEPTION();
		} while (0);
	}

	if ((IS_TMP_VAR|IS_VAR) == IS_UNUSED) {
		obj = C_OBJ_P(object);
	} else {
		do {
			if ((IS_TMP_VAR|IS_VAR) != IS_CONST && EXPECTED(C_TYPE_P(object) == IS_OBJECT)) {
				obj = C_OBJ_P(object);
			} else {
				if (((IS_TMP_VAR|IS_VAR) & (IS_VAR|IS_CV)) && EXPECTED(C_ISREF_P(object))) {
					crex_reference *ref = C_REF_P(object);

					object = &ref->val;
					if (EXPECTED(C_TYPE_P(object) == IS_OBJECT)) {
						obj = C_OBJ_P(object);
						if ((IS_TMP_VAR|IS_VAR) & IS_VAR) {
							if (UNEXPECTED(GC_DELREF(ref) == 0)) {
								efree_size(ref, sizeof(crex_reference));
							} else {
								C_ADDREF_P(object);
							}
						}
						break;
					}
				}
				if ((IS_TMP_VAR|IS_VAR) == IS_CV && UNEXPECTED(C_TYPE_P(object) == IS_UNDEF)) {
					object = ZVAL_UNDEFINED_OP1();
					if (UNEXPECTED(EG(exception) != NULL)) {
						if (IS_CONST != IS_CONST) {

						}
						HANDLE_EXCEPTION();
					}
				}
				if (IS_CONST == IS_CONST) {
					function_name = RT_CONSTANT(opline, opline->op2);
				}
				crex_invalid_method_call(object, function_name);

				zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
				HANDLE_EXCEPTION();
			}
		} while (0);
	}

	called_scope = obj->ce;

	if (IS_CONST == IS_CONST &&
	    EXPECTED(CACHED_PTR(opline->result.num) == called_scope)) {
		fbc = CACHED_PTR(opline->result.num + sizeof(void*));
	} else {
		crex_object *orig_obj = obj;

		if (IS_CONST == IS_CONST) {
			function_name = RT_CONSTANT(opline, opline->op2);
		}

		/* First, locate the function. */
		fbc = obj->handlers->get_method(&obj, C_STR_P(function_name), ((IS_CONST == IS_CONST) ? (RT_CONSTANT(opline, opline->op2) + 1) : NULL));
		if (UNEXPECTED(fbc == NULL)) {
			if (EXPECTED(!EG(exception))) {
				crex_undefined_method(obj->ce, C_STR_P(function_name));
			}

			if (((IS_TMP_VAR|IS_VAR) & (IS_VAR|IS_TMP_VAR)) && GC_DELREF(orig_obj) == 0) {
				crex_objects_store_del(orig_obj);
			}
			HANDLE_EXCEPTION();
		}
		if (IS_CONST == IS_CONST &&
		    EXPECTED(!(fbc->common.fn_flags & (CREX_ACC_CALL_VIA_TRAMPOLINE|CREX_ACC_NEVER_CACHE))) &&
		    EXPECTED(obj == orig_obj)) {
			CACHE_POLYMORPHIC_PTR(opline->result.num, called_scope, fbc);
		}
		if (((IS_TMP_VAR|IS_VAR) & (IS_VAR|IS_TMP_VAR)) && UNEXPECTED(obj != orig_obj)) {
			GC_ADDREF(obj); /* For $this pointer */
			if (GC_DELREF(orig_obj) == 0) {
				crex_objects_store_del(orig_obj);
			}
		}
		if (EXPECTED(fbc->type == CREX_USER_FUNCTION) && UNEXPECTED(!RUN_TIME_CACHE(&fbc->op_array))) {
			init_func_run_time_cache(&fbc->op_array);
		}
	}

	if (IS_CONST != IS_CONST) {

	}

	call_info = CREX_CALL_NESTED_FUNCTION | CREX_CALL_HAS_THIS;
	if (UNEXPECTED((fbc->common.fn_flags & CREX_ACC_STATIC) != 0)) {
		if (((IS_TMP_VAR|IS_VAR) & (IS_VAR|IS_TMP_VAR)) && GC_DELREF(obj) == 0) {
			crex_objects_store_del(obj);
			if (UNEXPECTED(EG(exception))) {
				HANDLE_EXCEPTION();
			}
		}
		/* call static method */
		obj = (crex_object*)called_scope;
		call_info = CREX_CALL_NESTED_FUNCTION;
	} else if ((IS_TMP_VAR|IS_VAR) & (IS_VAR|IS_TMP_VAR|IS_CV)) {
		if ((IS_TMP_VAR|IS_VAR) == IS_CV) {
			GC_ADDREF(obj); /* For $this pointer */
		}
		/* CV may be changed indirectly (e.g. when it's a reference) */
		call_info = CREX_CALL_NESTED_FUNCTION | CREX_CALL_HAS_THIS | CREX_CALL_RELEASE_THIS;
	}

	call = crex_vm_stack_push_call_frame(call_info,
		fbc, opline->extended_value, obj);
	call->prev_execute_data = EX(call);
	EX(call) = call;

	CREX_VM_NEXT_OPCODE();
}

static CREX_VM_HOT CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_SEND_VAL_SPEC_TMPVAR_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *value, *arg;

	if (IS_CONST == IS_CONST) {
		SAVE_OPLINE();
		crex_string *arg_name = C_STR_P(RT_CONSTANT(opline, opline->op2));
		uint32_t arg_num;
		arg = crex_handle_named_arg(&EX(call), arg_name, &arg_num, CACHE_ADDR(opline->result.num));
		if (UNEXPECTED(!arg)) {
			zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
			HANDLE_EXCEPTION();
		}
	} else {
		arg = CREX_CALL_VAR(EX(call), opline->result.var);
	}

	value = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	ZVAL_COPY_VALUE(arg, value);
	if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
		if (UNEXPECTED(C_OPT_REFCOUNTED_P(arg))) {
			C_ADDREF_P(arg);
		}
	}
	CREX_VM_NEXT_OPCODE();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_CASE_SPEC_TMPVAR_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	double d1, d2;

	op1 = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	op2 = RT_CONSTANT(opline, opline->op2);
	if (EXPECTED(C_TYPE_P(op1) == IS_LONG)) {
		if (EXPECTED(C_TYPE_P(op2) == IS_LONG)) {
			if (EXPECTED(C_LVAL_P(op1) == C_LVAL_P(op2))) {
case_true:
				CREX_VM_SMART_BRANCH_TRUE();
			} else {
case_false:
				CREX_VM_SMART_BRANCH_FALSE();
			}
		} else if (EXPECTED(C_TYPE_P(op2) == IS_DOUBLE)) {
			d1 = (double)C_LVAL_P(op1);
			d2 = C_DVAL_P(op2);
			goto case_double;
		}
	} else if (EXPECTED(C_TYPE_P(op1) == IS_DOUBLE)) {
		if (EXPECTED(C_TYPE_P(op2) == IS_DOUBLE)) {
			d1 = C_DVAL_P(op1);
			d2 = C_DVAL_P(op2);
case_double:
			if (d1 == d2) {
				goto case_true;
			} else {
				goto case_false;
			}
		} else if (EXPECTED(C_TYPE_P(op2) == IS_LONG)) {
			d1 = C_DVAL_P(op1);
			d2 = (double)C_LVAL_P(op2);
			goto case_double;
		}
	} else if (EXPECTED(C_TYPE_P(op1) == IS_STRING)) {
		if (EXPECTED(C_TYPE_P(op2) == IS_STRING)) {
			bool result = crex_fast_equal_strings(C_STR_P(op1), C_STR_P(op2));

			if (result) {
				goto case_true;
			} else {
				goto case_false;
			}
		}
	}
	CREX_VM_TAIL_CALL(crex_case_helper_SPEC(op1, op2 CREX_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ISSET_ISEMPTY_DIM_OBJ_SPEC_TMPVAR_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;
	bool result;
	crex_ulong hval;
	zval *offset;

	SAVE_OPLINE();
	container = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	offset = RT_CONSTANT(opline, opline->op2);

	if (EXPECTED(C_TYPE_P(container) == IS_ARRAY)) {
		HashTable *ht;
		zval *value;
		crex_string *str;

isset_dim_obj_array:
		ht = C_ARRVAL_P(container);
isset_again:
		if (EXPECTED(C_TYPE_P(offset) == IS_STRING)) {
			str = C_STR_P(offset);
			if (IS_CONST != IS_CONST) {
				if (CREX_HANDLE_NUMERIC(str, hval)) {
					goto num_index_prop;
				}
			}
			value = crex_hash_find_ex(ht, str, IS_CONST == IS_CONST);
		} else if (EXPECTED(C_TYPE_P(offset) == IS_LONG)) {
			hval = C_LVAL_P(offset);
num_index_prop:
			value = crex_hash_index_find(ht, hval);
		} else if ((IS_CONST & (IS_VAR|IS_CV)) && EXPECTED(C_ISREF_P(offset))) {
			offset = C_REFVAL_P(offset);
			goto isset_again;
		} else {
			value = crex_find_array_dim_slow(ht, offset EXECUTE_DATA_CC);
			if (UNEXPECTED(EG(exception))) {
				result = 0;
				goto isset_dim_obj_exit;
			}
		}

		if (!(opline->extended_value & CREX_ISEMPTY)) {
			/* > IS_NULL means not IS_UNDEF and not IS_NULL */
			result = value != NULL && C_TYPE_P(value) > IS_NULL &&
			    (!C_ISREF_P(value) || C_TYPE_P(C_REFVAL_P(value)) != IS_NULL);

			if ((IS_TMP_VAR|IS_VAR) & (IS_CONST|IS_CV)) {
				/* avoid exception check */

				CREX_VM_SMART_BRANCH(result, 0);
			}
		} else {
			result = (value == NULL || !i_crex_is_true(value));
		}
		goto isset_dim_obj_exit;
	} else if (((IS_TMP_VAR|IS_VAR) & (IS_VAR|IS_CV)) && EXPECTED(C_ISREF_P(container))) {
		container = C_REFVAL_P(container);
		if (EXPECTED(C_TYPE_P(container) == IS_ARRAY)) {
			goto isset_dim_obj_array;
		}
	}

	if (IS_CONST == IS_CONST && C_EXTRA_P(offset) == CREX_EXTRA_VALUE) {
		offset++;
	}
	if (!(opline->extended_value & CREX_ISEMPTY)) {
		result = crex_isset_dim_slow(container, offset EXECUTE_DATA_CC);
	} else {
		result = crex_isempty_dim_slow(container, offset EXECUTE_DATA_CC);
	}

isset_dim_obj_exit:

	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	CREX_VM_SMART_BRANCH(result, 1);
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ISSET_ISEMPTY_PROP_OBJ_SPEC_TMPVAR_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;
	int result;
	zval *offset;
	crex_string *name, *tmp_name;

	SAVE_OPLINE();
	container = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	offset = RT_CONSTANT(opline, opline->op2);

	if ((IS_TMP_VAR|IS_VAR) == IS_CONST ||
	    ((IS_TMP_VAR|IS_VAR) != IS_UNUSED && UNEXPECTED(C_TYPE_P(container) != IS_OBJECT))) {
		if (((IS_TMP_VAR|IS_VAR) & (IS_VAR|IS_CV)) && C_ISREF_P(container)) {
			container = C_REFVAL_P(container);
			if (UNEXPECTED(C_TYPE_P(container) != IS_OBJECT)) {
				result = (opline->extended_value & CREX_ISEMPTY);
				goto isset_object_finish;
			}
		} else {
			result = (opline->extended_value & CREX_ISEMPTY);
			goto isset_object_finish;
		}
	}

	if (IS_CONST == IS_CONST) {
		name = C_STR_P(offset);
	} else {
		name = zval_try_get_tmp_string(offset, &tmp_name);
		if (UNEXPECTED(!name)) {
			result = 0;
			goto isset_object_finish;
		}
	}

	result =
		(opline->extended_value & CREX_ISEMPTY) ^
		C_OBJ_HT_P(container)->has_property(C_OBJ_P(container), name, (opline->extended_value & CREX_ISEMPTY), ((IS_CONST == IS_CONST) ? CACHE_ADDR(opline->extended_value & ~CREX_ISEMPTY) : NULL));

	if (IS_CONST != IS_CONST) {
		crex_tmp_string_release(tmp_name);
	}

isset_object_finish:

	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	CREX_VM_SMART_BRANCH(result, 1);
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ARRAY_KEY_EXISTS_SPEC_TMPVAR_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *key, *subject;
	HashTable *ht;
	bool result;

	SAVE_OPLINE();

	key = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	subject = RT_CONSTANT(opline, opline->op2);

	if (EXPECTED(C_TYPE_P(subject) == IS_ARRAY)) {
array_key_exists_array:
		ht = C_ARRVAL_P(subject);
		result = crex_array_key_exists_fast(ht, key OPLINE_CC EXECUTE_DATA_CC);
	} else {
		if ((IS_CONST & (IS_VAR|IS_CV)) && EXPECTED(C_ISREF_P(subject))) {
			subject = C_REFVAL_P(subject);
			if (EXPECTED(C_TYPE_P(subject) == IS_ARRAY)) {
				goto array_key_exists_array;
			}
		}
		crex_array_key_exists_error(subject, key OPLINE_CC EXECUTE_DATA_CC);
		result = 0;
	}

	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	CREX_VM_SMART_BRANCH(result, 1);
}

/* No specialization for op_types (CONST|TMPVAR|UNUSED|CV, ANY) */
static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_INSTANCEOF_SPEC_TMPVAR_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *expr;
	bool result;

	SAVE_OPLINE();
	expr = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);

try_instanceof:
	if (C_TYPE_P(expr) == IS_OBJECT) {
		crex_class_entry *ce;

		if (IS_CONST == IS_CONST) {
			ce = CACHED_PTR(opline->extended_value);
			if (UNEXPECTED(ce == NULL)) {
				ce = crex_lookup_class_ex(C_STR_P(RT_CONSTANT(opline, opline->op2)), C_STR_P(RT_CONSTANT(opline, opline->op2) + 1), CREX_FETCH_CLASS_NO_AUTOLOAD);
				if (EXPECTED(ce)) {
					CACHE_PTR(opline->extended_value, ce);
				}
			}
		} else if (IS_CONST == IS_UNUSED) {
			ce = crex_fetch_class(NULL, opline->op2.num);
			if (UNEXPECTED(ce == NULL)) {
				zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
				ZVAL_UNDEF(EX_VAR(opline->result.var));
				HANDLE_EXCEPTION();
			}
		} else {
			ce = C_CE_P(EX_VAR(opline->op2.var));
		}
		result = ce && instanceof_function(C_OBJCE_P(expr), ce);
	} else if (((IS_TMP_VAR|IS_VAR) & (IS_VAR|IS_CV)) && C_TYPE_P(expr) == IS_REFERENCE) {
		expr = C_REFVAL_P(expr);
		goto try_instanceof;
	} else {
		if ((IS_TMP_VAR|IS_VAR) == IS_CV && UNEXPECTED(C_TYPE_P(expr) == IS_UNDEF)) {
			ZVAL_UNDEFINED_OP1();
		}
		result = 0;
	}
	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	CREX_VM_SMART_BRANCH(result, 1);
}

static CREX_VM_HOT CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FETCH_DIM_R_INDEX_SPEC_TMPVAR_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container, *dim, *value;
	crex_long offset;
	HashTable *ht;

	container = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	dim = RT_CONSTANT(opline, opline->op2);
	if (EXPECTED(C_TYPE_P(container) == IS_ARRAY)) {
fetch_dim_r_index_array:
		if (EXPECTED(C_TYPE_P(dim) == IS_LONG)) {
			offset = C_LVAL_P(dim);
		} else {
			SAVE_OPLINE();
			crex_fetch_dimension_address_read_R(container, dim, IS_CONST OPLINE_CC EXECUTE_DATA_CC);
			zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
			CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
		}
		ht = C_ARRVAL_P(container);
		CREX_HASH_INDEX_FIND(ht, offset, value, fetch_dim_r_index_undef);
		ZVAL_COPY_DEREF(EX_VAR(opline->result.var), value);
		if ((IS_TMP_VAR|IS_VAR) & (IS_TMP_VAR|IS_VAR)) {
			SAVE_OPLINE();
			zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
			CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
		} else {
			CREX_VM_NEXT_OPCODE();
		}
	} else if ((IS_TMP_VAR|IS_VAR) != IS_CONST && EXPECTED(C_TYPE_P(container) == IS_REFERENCE)) {
		container = C_REFVAL_P(container);
		if (EXPECTED(C_TYPE_P(container) == IS_ARRAY)) {
			goto fetch_dim_r_index_array;
		} else {
			goto fetch_dim_r_index_slow;
		}
	} else {
fetch_dim_r_index_slow:
		SAVE_OPLINE();
		if (IS_CONST == IS_CONST && C_EXTRA_P(dim) == CREX_EXTRA_VALUE) {
			dim++;
		}
		crex_fetch_dimension_address_read_R_slow(container, dim OPLINE_CC EXECUTE_DATA_CC);
		zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
		CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
	}

fetch_dim_r_index_undef:
	ZVAL_NULL(EX_VAR(opline->result.var));
	SAVE_OPLINE();
	crex_undefined_offset(offset);
	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_VM_HOT CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FETCH_DIM_R_INDEX_SPEC_TMPVAR_TMPVARCV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container, *dim, *value;
	crex_long offset;
	HashTable *ht;

	container = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	dim = EX_VAR(opline->op2.var);
	if (EXPECTED(C_TYPE_P(container) == IS_ARRAY)) {
fetch_dim_r_index_array:
		if (EXPECTED(C_TYPE_P(dim) == IS_LONG)) {
			offset = C_LVAL_P(dim);
		} else {
			SAVE_OPLINE();
			crex_fetch_dimension_address_read_R(container, dim, (IS_TMP_VAR|IS_VAR|IS_CV) OPLINE_CC EXECUTE_DATA_CC);
			zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
			CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
		}
		ht = C_ARRVAL_P(container);
		CREX_HASH_INDEX_FIND(ht, offset, value, fetch_dim_r_index_undef);
		ZVAL_COPY_DEREF(EX_VAR(opline->result.var), value);
		if ((IS_TMP_VAR|IS_VAR) & (IS_TMP_VAR|IS_VAR)) {
			SAVE_OPLINE();
			zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
			CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
		} else {
			CREX_VM_NEXT_OPCODE();
		}
	} else if ((IS_TMP_VAR|IS_VAR) != IS_CONST && EXPECTED(C_TYPE_P(container) == IS_REFERENCE)) {
		container = C_REFVAL_P(container);
		if (EXPECTED(C_TYPE_P(container) == IS_ARRAY)) {
			goto fetch_dim_r_index_array;
		} else {
			goto fetch_dim_r_index_slow;
		}
	} else {
fetch_dim_r_index_slow:
		SAVE_OPLINE();
		if ((IS_TMP_VAR|IS_VAR|IS_CV) == IS_CONST && C_EXTRA_P(dim) == CREX_EXTRA_VALUE) {
			dim++;
		}
		crex_fetch_dimension_address_read_R_slow(container, dim OPLINE_CC EXECUTE_DATA_CC);
		zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
		CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
	}

fetch_dim_r_index_undef:
	ZVAL_NULL(EX_VAR(opline->result.var));
	SAVE_OPLINE();
	crex_undefined_offset(offset);
	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_DIV_SPEC_TMPVAR_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;

	SAVE_OPLINE();
	op1 = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	op2 = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
	div_function(EX_VAR(opline->result.var), op1, op2);
	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_POW_SPEC_TMPVAR_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;

	SAVE_OPLINE();
	op1 = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	op2 = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
	pow_function(EX_VAR(opline->result.var), op1, op2);
	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_CONCAT_SPEC_TMPVAR_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;

	op1 = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	op2 = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);

	if (((IS_TMP_VAR|IS_VAR) == IS_CONST || EXPECTED(C_TYPE_P(op1) == IS_STRING)) &&
	    ((IS_TMP_VAR|IS_VAR) == IS_CONST || EXPECTED(C_TYPE_P(op2) == IS_STRING))) {
		crex_string *op1_str = C_STR_P(op1);
		crex_string *op2_str = C_STR_P(op2);
		crex_string *str;
		uint32_t flags = ZSTR_GET_COPYABLE_CONCAT_PROPERTIES_BOTH(op1_str, op2_str);

		if ((IS_TMP_VAR|IS_VAR) != IS_CONST && UNEXPECTED(ZSTR_LEN(op1_str) == 0)) {
			if ((IS_TMP_VAR|IS_VAR) == IS_CONST || (IS_TMP_VAR|IS_VAR) == IS_CV) {
				ZVAL_STR_COPY(EX_VAR(opline->result.var), op2_str);
			} else {
				ZVAL_STR(EX_VAR(opline->result.var), op2_str);
			}
			if ((IS_TMP_VAR|IS_VAR) & (IS_TMP_VAR|IS_VAR)) {
				crex_string_release_ex(op1_str, 0);
			}
		} else if ((IS_TMP_VAR|IS_VAR) != IS_CONST && UNEXPECTED(ZSTR_LEN(op2_str) == 0)) {
			if ((IS_TMP_VAR|IS_VAR) == IS_CONST || (IS_TMP_VAR|IS_VAR) == IS_CV) {
				ZVAL_STR_COPY(EX_VAR(opline->result.var), op1_str);
			} else {
				ZVAL_STR(EX_VAR(opline->result.var), op1_str);
			}
			if ((IS_TMP_VAR|IS_VAR) & (IS_TMP_VAR|IS_VAR)) {
				crex_string_release_ex(op2_str, 0);
			}
		} else if ((IS_TMP_VAR|IS_VAR) != IS_CONST && (IS_TMP_VAR|IS_VAR) != IS_CV &&
		    !ZSTR_IS_INTERNED(op1_str) && GC_REFCOUNT(op1_str) == 1) {
			size_t len = ZSTR_LEN(op1_str);

			if (UNEXPECTED(len > ZSTR_MAX_LEN - ZSTR_LEN(op2_str))) {
				crex_error_noreturn(E_ERROR, "Integer overflow in memory allocation");
			}
			str = crex_string_extend(op1_str, len + ZSTR_LEN(op2_str), 0);
			memcpy(ZSTR_VAL(str) + len, ZSTR_VAL(op2_str), ZSTR_LEN(op2_str)+1);
			GC_ADD_FLAGS(str, flags);
			ZVAL_NEW_STR(EX_VAR(opline->result.var), str);
			if ((IS_TMP_VAR|IS_VAR) & (IS_TMP_VAR|IS_VAR)) {
				crex_string_release_ex(op2_str, 0);
			}
		} else {
			str = crex_string_alloc(ZSTR_LEN(op1_str) + ZSTR_LEN(op2_str), 0);
			memcpy(ZSTR_VAL(str), ZSTR_VAL(op1_str), ZSTR_LEN(op1_str));
			memcpy(ZSTR_VAL(str) + ZSTR_LEN(op1_str), ZSTR_VAL(op2_str), ZSTR_LEN(op2_str)+1);
			GC_ADD_FLAGS(str, flags);
			ZVAL_NEW_STR(EX_VAR(opline->result.var), str);
			if ((IS_TMP_VAR|IS_VAR) & (IS_TMP_VAR|IS_VAR)) {
				crex_string_release_ex(op1_str, 0);
			}
			if ((IS_TMP_VAR|IS_VAR) & (IS_TMP_VAR|IS_VAR)) {
				crex_string_release_ex(op2_str, 0);
			}
		}
		CREX_VM_NEXT_OPCODE();
	} else {
		SAVE_OPLINE();

		if ((IS_TMP_VAR|IS_VAR) == IS_CV && UNEXPECTED(C_TYPE_P(op1) == IS_UNDEF)) {
			op1 = ZVAL_UNDEFINED_OP1();
		}
		if ((IS_TMP_VAR|IS_VAR) == IS_CV && UNEXPECTED(C_TYPE_P(op2) == IS_UNDEF)) {
			op2 = ZVAL_UNDEFINED_OP2();
		}
		concat_function(EX_VAR(opline->result.var), op1, op2);
		zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
		zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
		CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
	}
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_IS_EQUAL_SPEC_TMPVAR_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	double d1, d2;

	op1 = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	op2 = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
	if (1 && (IS_TMP_VAR|IS_VAR) == IS_CONST && (IS_TMP_VAR|IS_VAR) == IS_CONST) {
		/* pass */
	} else if (EXPECTED(C_TYPE_P(op1) == IS_LONG)) {
		if (EXPECTED(C_TYPE_P(op2) == IS_LONG)) {
			if (EXPECTED(C_LVAL_P(op1) == C_LVAL_P(op2))) {
is_equal_true:
				CREX_VM_SMART_BRANCH_TRUE_NONE();
			} else {
is_equal_false:
				CREX_VM_SMART_BRANCH_FALSE_NONE();
			}
		} else if (EXPECTED(C_TYPE_P(op2) == IS_DOUBLE)) {
			d1 = (double)C_LVAL_P(op1);
			d2 = C_DVAL_P(op2);
			goto is_equal_double;
		}
	} else if (EXPECTED(C_TYPE_P(op1) == IS_DOUBLE)) {
		if (EXPECTED(C_TYPE_P(op2) == IS_DOUBLE)) {
			d1 = C_DVAL_P(op1);
			d2 = C_DVAL_P(op2);
is_equal_double:
			if (d1 == d2) {
				goto is_equal_true;
			} else {
				goto is_equal_false;
			}
		} else if (EXPECTED(C_TYPE_P(op2) == IS_LONG)) {
			d1 = C_DVAL_P(op1);
			d2 = (double)C_LVAL_P(op2);
			goto is_equal_double;
		}
	} else if (EXPECTED(C_TYPE_P(op1) == IS_STRING)) {
		if (EXPECTED(C_TYPE_P(op2) == IS_STRING)) {
			bool result = crex_fast_equal_strings(C_STR_P(op1), C_STR_P(op2));
			if ((IS_TMP_VAR|IS_VAR) & (IS_TMP_VAR|IS_VAR)) {
				zval_ptr_dtor_str(op1);
			}
			if ((IS_TMP_VAR|IS_VAR) & (IS_TMP_VAR|IS_VAR)) {
				zval_ptr_dtor_str(op2);
			}
			if (result) {
				goto is_equal_true;
			} else {
				goto is_equal_false;
			}
		}
	}
	CREX_VM_TAIL_CALL(crex_is_equal_helper_SPEC(op1, op2 CREX_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_IS_EQUAL_SPEC_TMPVAR_TMPVAR_JMPC_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	double d1, d2;

	op1 = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	op2 = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
	if (1 && (IS_TMP_VAR|IS_VAR) == IS_CONST && (IS_TMP_VAR|IS_VAR) == IS_CONST) {
		/* pass */
	} else if (EXPECTED(C_TYPE_P(op1) == IS_LONG)) {
		if (EXPECTED(C_TYPE_P(op2) == IS_LONG)) {
			if (EXPECTED(C_LVAL_P(op1) == C_LVAL_P(op2))) {
is_equal_true:
				CREX_VM_SMART_BRANCH_TRUE_JMPZ();
			} else {
is_equal_false:
				CREX_VM_SMART_BRANCH_FALSE_JMPZ();
			}
		} else if (EXPECTED(C_TYPE_P(op2) == IS_DOUBLE)) {
			d1 = (double)C_LVAL_P(op1);
			d2 = C_DVAL_P(op2);
			goto is_equal_double;
		}
	} else if (EXPECTED(C_TYPE_P(op1) == IS_DOUBLE)) {
		if (EXPECTED(C_TYPE_P(op2) == IS_DOUBLE)) {
			d1 = C_DVAL_P(op1);
			d2 = C_DVAL_P(op2);
is_equal_double:
			if (d1 == d2) {
				goto is_equal_true;
			} else {
				goto is_equal_false;
			}
		} else if (EXPECTED(C_TYPE_P(op2) == IS_LONG)) {
			d1 = C_DVAL_P(op1);
			d2 = (double)C_LVAL_P(op2);
			goto is_equal_double;
		}
	} else if (EXPECTED(C_TYPE_P(op1) == IS_STRING)) {
		if (EXPECTED(C_TYPE_P(op2) == IS_STRING)) {
			bool result = crex_fast_equal_strings(C_STR_P(op1), C_STR_P(op2));
			if ((IS_TMP_VAR|IS_VAR) & (IS_TMP_VAR|IS_VAR)) {
				zval_ptr_dtor_str(op1);
			}
			if ((IS_TMP_VAR|IS_VAR) & (IS_TMP_VAR|IS_VAR)) {
				zval_ptr_dtor_str(op2);
			}
			if (result) {
				goto is_equal_true;
			} else {
				goto is_equal_false;
			}
		}
	}
	CREX_VM_TAIL_CALL(crex_is_equal_helper_SPEC(op1, op2 CREX_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_IS_EQUAL_SPEC_TMPVAR_TMPVAR_JMPNC_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	double d1, d2;

	op1 = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	op2 = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
	if (1 && (IS_TMP_VAR|IS_VAR) == IS_CONST && (IS_TMP_VAR|IS_VAR) == IS_CONST) {
		/* pass */
	} else if (EXPECTED(C_TYPE_P(op1) == IS_LONG)) {
		if (EXPECTED(C_TYPE_P(op2) == IS_LONG)) {
			if (EXPECTED(C_LVAL_P(op1) == C_LVAL_P(op2))) {
is_equal_true:
				CREX_VM_SMART_BRANCH_TRUE_JMPNZ();
			} else {
is_equal_false:
				CREX_VM_SMART_BRANCH_FALSE_JMPNZ();
			}
		} else if (EXPECTED(C_TYPE_P(op2) == IS_DOUBLE)) {
			d1 = (double)C_LVAL_P(op1);
			d2 = C_DVAL_P(op2);
			goto is_equal_double;
		}
	} else if (EXPECTED(C_TYPE_P(op1) == IS_DOUBLE)) {
		if (EXPECTED(C_TYPE_P(op2) == IS_DOUBLE)) {
			d1 = C_DVAL_P(op1);
			d2 = C_DVAL_P(op2);
is_equal_double:
			if (d1 == d2) {
				goto is_equal_true;
			} else {
				goto is_equal_false;
			}
		} else if (EXPECTED(C_TYPE_P(op2) == IS_LONG)) {
			d1 = C_DVAL_P(op1);
			d2 = (double)C_LVAL_P(op2);
			goto is_equal_double;
		}
	} else if (EXPECTED(C_TYPE_P(op1) == IS_STRING)) {
		if (EXPECTED(C_TYPE_P(op2) == IS_STRING)) {
			bool result = crex_fast_equal_strings(C_STR_P(op1), C_STR_P(op2));
			if ((IS_TMP_VAR|IS_VAR) & (IS_TMP_VAR|IS_VAR)) {
				zval_ptr_dtor_str(op1);
			}
			if ((IS_TMP_VAR|IS_VAR) & (IS_TMP_VAR|IS_VAR)) {
				zval_ptr_dtor_str(op2);
			}
			if (result) {
				goto is_equal_true;
			} else {
				goto is_equal_false;
			}
		}
	}
	CREX_VM_TAIL_CALL(crex_is_equal_helper_SPEC(op1, op2 CREX_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_IS_NOT_EQUAL_SPEC_TMPVAR_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	double d1, d2;

	op1 = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	op2 = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
	if (1 && (IS_TMP_VAR|IS_VAR) == IS_CONST && (IS_TMP_VAR|IS_VAR) == IS_CONST) {
		/* pass */
	} else if (EXPECTED(C_TYPE_P(op1) == IS_LONG)) {
		if (EXPECTED(C_TYPE_P(op2) == IS_LONG)) {
			if (EXPECTED(C_LVAL_P(op1) != C_LVAL_P(op2))) {
is_not_equal_true:
				CREX_VM_SMART_BRANCH_TRUE_NONE();
			} else {
is_not_equal_false:
				CREX_VM_SMART_BRANCH_FALSE_NONE();
			}
		} else if (EXPECTED(C_TYPE_P(op2) == IS_DOUBLE)) {
			d1 = (double)C_LVAL_P(op1);
			d2 = C_DVAL_P(op2);
			goto is_not_equal_double;
		}
	} else if (EXPECTED(C_TYPE_P(op1) == IS_DOUBLE)) {
		if (EXPECTED(C_TYPE_P(op2) == IS_DOUBLE)) {
			d1 = C_DVAL_P(op1);
			d2 = C_DVAL_P(op2);
is_not_equal_double:
			if (d1 != d2) {
				goto is_not_equal_true;
			} else {
				goto is_not_equal_false;
			}
		} else if (EXPECTED(C_TYPE_P(op2) == IS_LONG)) {
			d1 = C_DVAL_P(op1);
			d2 = (double)C_LVAL_P(op2);
			goto is_not_equal_double;
		}
	} else if (EXPECTED(C_TYPE_P(op1) == IS_STRING)) {
		if (EXPECTED(C_TYPE_P(op2) == IS_STRING)) {
			bool result = crex_fast_equal_strings(C_STR_P(op1), C_STR_P(op2));
			if ((IS_TMP_VAR|IS_VAR) & (IS_TMP_VAR|IS_VAR)) {
				zval_ptr_dtor_str(op1);
			}
			if ((IS_TMP_VAR|IS_VAR) & (IS_TMP_VAR|IS_VAR)) {
				zval_ptr_dtor_str(op2);
			}
			if (!result) {
				goto is_not_equal_true;
			} else {
				goto is_not_equal_false;
			}
		}
	}
	CREX_VM_TAIL_CALL(crex_is_not_equal_helper_SPEC(op1, op2 CREX_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_IS_NOT_EQUAL_SPEC_TMPVAR_TMPVAR_JMPC_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	double d1, d2;

	op1 = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	op2 = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
	if (1 && (IS_TMP_VAR|IS_VAR) == IS_CONST && (IS_TMP_VAR|IS_VAR) == IS_CONST) {
		/* pass */
	} else if (EXPECTED(C_TYPE_P(op1) == IS_LONG)) {
		if (EXPECTED(C_TYPE_P(op2) == IS_LONG)) {
			if (EXPECTED(C_LVAL_P(op1) != C_LVAL_P(op2))) {
is_not_equal_true:
				CREX_VM_SMART_BRANCH_TRUE_JMPZ();
			} else {
is_not_equal_false:
				CREX_VM_SMART_BRANCH_FALSE_JMPZ();
			}
		} else if (EXPECTED(C_TYPE_P(op2) == IS_DOUBLE)) {
			d1 = (double)C_LVAL_P(op1);
			d2 = C_DVAL_P(op2);
			goto is_not_equal_double;
		}
	} else if (EXPECTED(C_TYPE_P(op1) == IS_DOUBLE)) {
		if (EXPECTED(C_TYPE_P(op2) == IS_DOUBLE)) {
			d1 = C_DVAL_P(op1);
			d2 = C_DVAL_P(op2);
is_not_equal_double:
			if (d1 != d2) {
				goto is_not_equal_true;
			} else {
				goto is_not_equal_false;
			}
		} else if (EXPECTED(C_TYPE_P(op2) == IS_LONG)) {
			d1 = C_DVAL_P(op1);
			d2 = (double)C_LVAL_P(op2);
			goto is_not_equal_double;
		}
	} else if (EXPECTED(C_TYPE_P(op1) == IS_STRING)) {
		if (EXPECTED(C_TYPE_P(op2) == IS_STRING)) {
			bool result = crex_fast_equal_strings(C_STR_P(op1), C_STR_P(op2));
			if ((IS_TMP_VAR|IS_VAR) & (IS_TMP_VAR|IS_VAR)) {
				zval_ptr_dtor_str(op1);
			}
			if ((IS_TMP_VAR|IS_VAR) & (IS_TMP_VAR|IS_VAR)) {
				zval_ptr_dtor_str(op2);
			}
			if (!result) {
				goto is_not_equal_true;
			} else {
				goto is_not_equal_false;
			}
		}
	}
	CREX_VM_TAIL_CALL(crex_is_not_equal_helper_SPEC(op1, op2 CREX_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_IS_NOT_EQUAL_SPEC_TMPVAR_TMPVAR_JMPNC_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	double d1, d2;

	op1 = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	op2 = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
	if (1 && (IS_TMP_VAR|IS_VAR) == IS_CONST && (IS_TMP_VAR|IS_VAR) == IS_CONST) {
		/* pass */
	} else if (EXPECTED(C_TYPE_P(op1) == IS_LONG)) {
		if (EXPECTED(C_TYPE_P(op2) == IS_LONG)) {
			if (EXPECTED(C_LVAL_P(op1) != C_LVAL_P(op2))) {
is_not_equal_true:
				CREX_VM_SMART_BRANCH_TRUE_JMPNZ();
			} else {
is_not_equal_false:
				CREX_VM_SMART_BRANCH_FALSE_JMPNZ();
			}
		} else if (EXPECTED(C_TYPE_P(op2) == IS_DOUBLE)) {
			d1 = (double)C_LVAL_P(op1);
			d2 = C_DVAL_P(op2);
			goto is_not_equal_double;
		}
	} else if (EXPECTED(C_TYPE_P(op1) == IS_DOUBLE)) {
		if (EXPECTED(C_TYPE_P(op2) == IS_DOUBLE)) {
			d1 = C_DVAL_P(op1);
			d2 = C_DVAL_P(op2);
is_not_equal_double:
			if (d1 != d2) {
				goto is_not_equal_true;
			} else {
				goto is_not_equal_false;
			}
		} else if (EXPECTED(C_TYPE_P(op2) == IS_LONG)) {
			d1 = C_DVAL_P(op1);
			d2 = (double)C_LVAL_P(op2);
			goto is_not_equal_double;
		}
	} else if (EXPECTED(C_TYPE_P(op1) == IS_STRING)) {
		if (EXPECTED(C_TYPE_P(op2) == IS_STRING)) {
			bool result = crex_fast_equal_strings(C_STR_P(op1), C_STR_P(op2));
			if ((IS_TMP_VAR|IS_VAR) & (IS_TMP_VAR|IS_VAR)) {
				zval_ptr_dtor_str(op1);
			}
			if ((IS_TMP_VAR|IS_VAR) & (IS_TMP_VAR|IS_VAR)) {
				zval_ptr_dtor_str(op2);
			}
			if (!result) {
				goto is_not_equal_true;
			} else {
				goto is_not_equal_false;
			}
		}
	}
	CREX_VM_TAIL_CALL(crex_is_not_equal_helper_SPEC(op1, op2 CREX_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_SPACESHIP_SPEC_TMPVAR_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;

	SAVE_OPLINE();
	op1 = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	op2 = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
	compare_function(EX_VAR(opline->result.var), op1, op2);
	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_BOOL_XOR_SPEC_TMPVAR_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;

	SAVE_OPLINE();
	op1 = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	op2 = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
	boolean_xor_function(EX_VAR(opline->result.var), op1, op2);
	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FETCH_DIM_R_SPEC_TMPVAR_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container, *dim, *value;

	SAVE_OPLINE();
	container = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	dim = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
	if ((IS_TMP_VAR|IS_VAR) != IS_CONST) {
		if (EXPECTED(C_TYPE_P(container) == IS_ARRAY)) {
fetch_dim_r_array:
			value = crex_fetch_dimension_address_inner(C_ARRVAL_P(container), dim, (IS_TMP_VAR|IS_VAR), BP_VAR_R EXECUTE_DATA_CC);
			ZVAL_COPY_DEREF(EX_VAR(opline->result.var), value);
		} else if (EXPECTED(C_TYPE_P(container) == IS_REFERENCE)) {
			container = C_REFVAL_P(container);
			if (EXPECTED(C_TYPE_P(container) == IS_ARRAY)) {
				goto fetch_dim_r_array;
			} else {
				goto fetch_dim_r_slow;
			}
		} else {
fetch_dim_r_slow:
			if ((IS_TMP_VAR|IS_VAR) == IS_CONST && C_EXTRA_P(dim) == CREX_EXTRA_VALUE) {
				dim++;
			}
			crex_fetch_dimension_address_read_R_slow(container, dim OPLINE_CC EXECUTE_DATA_CC);
		}
	} else {
		crex_fetch_dimension_address_read_R(container, dim, (IS_TMP_VAR|IS_VAR) OPLINE_CC EXECUTE_DATA_CC);
	}
	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FETCH_DIM_IS_SPEC_TMPVAR_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;

	SAVE_OPLINE();
	container = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	crex_fetch_dimension_address_read_IS(container, _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC), (IS_TMP_VAR|IS_VAR) OPLINE_CC EXECUTE_DATA_CC);
	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FETCH_OBJ_R_SPEC_TMPVAR_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;
	void **cache_slot = NULL;

	SAVE_OPLINE();
	container = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);

	if ((IS_TMP_VAR|IS_VAR) == IS_CONST ||
	    ((IS_TMP_VAR|IS_VAR) != IS_UNUSED && UNEXPECTED(C_TYPE_P(container) != IS_OBJECT))) {
		do {
			if (((IS_TMP_VAR|IS_VAR) & (IS_VAR|IS_CV)) && C_ISREF_P(container)) {
				container = C_REFVAL_P(container);
				if (EXPECTED(C_TYPE_P(container) == IS_OBJECT)) {
					break;
				}
			}
			if ((IS_TMP_VAR|IS_VAR) == IS_CV && UNEXPECTED(C_TYPE_P(container) == IS_UNDEF)) {
				ZVAL_UNDEFINED_OP1();
			}
			crex_wrong_property_read(container, _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC));
			ZVAL_NULL(EX_VAR(opline->result.var));
			goto fetch_obj_r_finish;
		} while (0);
	}

	/* here we are sure we are dealing with an object */
	do {
		crex_object *zobj = C_OBJ_P(container);
		crex_string *name, *tmp_name;
		zval *retval;

		if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
			cache_slot = CACHE_ADDR(opline->extended_value & ~CREX_FETCH_REF /* FUNC_ARG fetch may contain it */);

			if (EXPECTED(zobj->ce == CACHED_PTR_EX(cache_slot))) {
				uintptr_t prop_offset = (uintptr_t)CACHED_PTR_EX(cache_slot + 1);

				if (EXPECTED(IS_VALID_PROPERTY_OFFSET(prop_offset))) {
					retval = OBJ_PROP(zobj, prop_offset);
					if (EXPECTED(C_TYPE_INFO_P(retval) != IS_UNDEF)) {
						if (0 || ((IS_TMP_VAR|IS_VAR) & (IS_TMP_VAR|IS_VAR)) != 0) {
							goto fetch_obj_r_copy;
						} else {
fetch_obj_r_fast_copy:
							ZVAL_COPY_DEREF(EX_VAR(opline->result.var), retval);
							CREX_VM_NEXT_OPCODE();
						}
					}
				} else if (EXPECTED(zobj->properties != NULL)) {
					name = C_STR_P(_get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC));
					if (!IS_UNKNOWN_DYNAMIC_PROPERTY_OFFSET(prop_offset)) {
						uintptr_t idx = CREX_DECODE_DYN_PROP_OFFSET(prop_offset);

						if (EXPECTED(idx < zobj->properties->nNumUsed * sizeof(Bucket))) {
							Bucket *p = (Bucket*)((char*)zobj->properties->arData + idx);

							if (EXPECTED(p->key == name) ||
							    (EXPECTED(p->h == ZSTR_H(name)) &&
							     EXPECTED(p->key != NULL) &&
							     EXPECTED(crex_string_equal_content(p->key, name)))) {
								retval = &p->val;
								if (0 || ((IS_TMP_VAR|IS_VAR) & (IS_TMP_VAR|IS_VAR)) != 0) {
									goto fetch_obj_r_copy;
								} else {
									goto fetch_obj_r_fast_copy;
								}
							}
						}
						CACHE_PTR_EX(cache_slot + 1, (void*)CREX_DYNAMIC_PROPERTY_OFFSET);
					}
					retval = crex_hash_find_known_hash(zobj->properties, name);
					if (EXPECTED(retval)) {
						uintptr_t idx = (char*)retval - (char*)zobj->properties->arData;
						CACHE_PTR_EX(cache_slot + 1, (void*)CREX_ENCODE_DYN_PROP_OFFSET(idx));
						if (0 || ((IS_TMP_VAR|IS_VAR) & (IS_TMP_VAR|IS_VAR)) != 0) {
							goto fetch_obj_r_copy;
						} else {
							goto fetch_obj_r_fast_copy;
						}
					}
				}
			}
			name = C_STR_P(_get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC));
		} else {
			name = zval_try_get_tmp_string(_get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC), &tmp_name);
			if (UNEXPECTED(!name)) {
				ZVAL_UNDEF(EX_VAR(opline->result.var));
				break;
			}
		}

#if CREX_DEBUG
		/* For non-standard object handlers, verify a declared property type in debug builds.
		 * Fetch prop_info before calling read_property(), as it may deallocate the object. */
		crex_property_info *prop_info = NULL;
		if (zobj->handlers->read_property != crex_std_read_property) {
			prop_info = crex_get_property_info(zobj->ce, name, /* silent */ true);
		}
#endif
		retval = zobj->handlers->read_property(zobj, name, BP_VAR_R, cache_slot, EX_VAR(opline->result.var));
#if CREX_DEBUG
		if (!EG(exception) && prop_info && prop_info != CREX_WRONG_PROPERTY_INFO
				&& CREX_TYPE_IS_SET(prop_info->type)) {
			ZVAL_OPT_DEREF(retval);
			crex_verify_property_type(prop_info, retval, /* strict */ true);
		}
#endif

		if ((IS_TMP_VAR|IS_VAR) != IS_CONST) {
			crex_tmp_string_release(tmp_name);
		}

		if (retval != EX_VAR(opline->result.var)) {
fetch_obj_r_copy:
			ZVAL_COPY_DEREF(EX_VAR(opline->result.var), retval);
		} else if (UNEXPECTED(C_ISREF_P(retval))) {
			crex_unwrap_reference(retval);
		}
	} while (0);

fetch_obj_r_finish:
	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FETCH_OBJ_IS_SPEC_TMPVAR_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;
	void **cache_slot = NULL;

	SAVE_OPLINE();
	container = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);

	if ((IS_TMP_VAR|IS_VAR) == IS_CONST ||
	    ((IS_TMP_VAR|IS_VAR) != IS_UNUSED && UNEXPECTED(C_TYPE_P(container) != IS_OBJECT))) {
		do {
			if (((IS_TMP_VAR|IS_VAR) & (IS_VAR|IS_CV)) && C_ISREF_P(container)) {
				container = C_REFVAL_P(container);
				if (EXPECTED(C_TYPE_P(container) == IS_OBJECT)) {
					break;
				}
			}
			if ((IS_TMP_VAR|IS_VAR) == IS_CV && C_TYPE_P(EX_VAR(opline->op2.var)) == IS_UNDEF) {
				ZVAL_UNDEFINED_OP2();
			}
			ZVAL_NULL(EX_VAR(opline->result.var));
			goto fetch_obj_is_finish;
		} while (0);
	}

	/* here we are sure we are dealing with an object */
	do {
		crex_object *zobj = C_OBJ_P(container);
		crex_string *name, *tmp_name;
		zval *retval;

		if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
			cache_slot = CACHE_ADDR(opline->extended_value);

			if (EXPECTED(zobj->ce == CACHED_PTR_EX(cache_slot))) {
				uintptr_t prop_offset = (uintptr_t)CACHED_PTR_EX(cache_slot + 1);

				if (EXPECTED(IS_VALID_PROPERTY_OFFSET(prop_offset))) {
					retval = OBJ_PROP(zobj, prop_offset);
					if (EXPECTED(C_TYPE_P(retval) != IS_UNDEF)) {
						if (0 || ((IS_TMP_VAR|IS_VAR) & (IS_TMP_VAR|IS_VAR)) != 0) {
							goto fetch_obj_is_copy;
						} else {
fetch_obj_is_fast_copy:
							ZVAL_COPY_DEREF(EX_VAR(opline->result.var), retval);
							CREX_VM_NEXT_OPCODE();
						}
					}
				} else if (EXPECTED(zobj->properties != NULL)) {
					name = C_STR_P(_get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC));
					if (!IS_UNKNOWN_DYNAMIC_PROPERTY_OFFSET(prop_offset)) {
						uintptr_t idx = CREX_DECODE_DYN_PROP_OFFSET(prop_offset);

						if (EXPECTED(idx < zobj->properties->nNumUsed * sizeof(Bucket))) {
							Bucket *p = (Bucket*)((char*)zobj->properties->arData + idx);

							if (EXPECTED(p->key == name) ||
							    (EXPECTED(p->h == ZSTR_H(name)) &&
							     EXPECTED(p->key != NULL) &&
							     EXPECTED(crex_string_equal_content(p->key, name)))) {
								retval = &p->val;
								if (0 || ((IS_TMP_VAR|IS_VAR) & (IS_TMP_VAR|IS_VAR)) != 0) {
									goto fetch_obj_is_copy;
								} else {
									goto fetch_obj_is_fast_copy;
								}
							}
						}
						CACHE_PTR_EX(cache_slot + 1, (void*)CREX_DYNAMIC_PROPERTY_OFFSET);
					}
					retval = crex_hash_find_known_hash(zobj->properties, name);
					if (EXPECTED(retval)) {
						uintptr_t idx = (char*)retval - (char*)zobj->properties->arData;
						CACHE_PTR_EX(cache_slot + 1, (void*)CREX_ENCODE_DYN_PROP_OFFSET(idx));
						if (0 || ((IS_TMP_VAR|IS_VAR) & (IS_TMP_VAR|IS_VAR)) != 0) {
							goto fetch_obj_is_copy;
						} else {
							goto fetch_obj_is_fast_copy;
						}
					}
				}
			}
			name = C_STR_P(_get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC));
		} else {
			name = zval_try_get_tmp_string(_get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC), &tmp_name);
			if (UNEXPECTED(!name)) {
				ZVAL_UNDEF(EX_VAR(opline->result.var));
				break;
			}
		}

		retval = zobj->handlers->read_property(zobj, name, BP_VAR_IS, cache_slot, EX_VAR(opline->result.var));

		if ((IS_TMP_VAR|IS_VAR) != IS_CONST) {
			crex_tmp_string_release(tmp_name);
		}

		if (retval != EX_VAR(opline->result.var)) {
fetch_obj_is_copy:
			ZVAL_COPY_DEREF(EX_VAR(opline->result.var), retval);
		} else if (UNEXPECTED(C_ISREF_P(retval))) {
			crex_unwrap_reference(retval);
		}
	} while (0);

fetch_obj_is_finish:
	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FAST_CONCAT_SPEC_TMPVAR_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	crex_string *op1_str, *op2_str, *str;


	op1 = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	op2 = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
	if (((IS_TMP_VAR|IS_VAR) == IS_CONST || EXPECTED(C_TYPE_P(op1) == IS_STRING)) &&
	    ((IS_TMP_VAR|IS_VAR) == IS_CONST || EXPECTED(C_TYPE_P(op2) == IS_STRING))) {
		crex_string *op1_str = C_STR_P(op1);
		crex_string *op2_str = C_STR_P(op2);
		crex_string *str;
		uint32_t flags = ZSTR_GET_COPYABLE_CONCAT_PROPERTIES_BOTH(op1_str, op2_str);

		if ((IS_TMP_VAR|IS_VAR) != IS_CONST && UNEXPECTED(ZSTR_LEN(op1_str) == 0)) {
			if ((IS_TMP_VAR|IS_VAR) == IS_CONST || (IS_TMP_VAR|IS_VAR) == IS_CV) {
				ZVAL_STR_COPY(EX_VAR(opline->result.var), op2_str);
			} else {
				ZVAL_STR(EX_VAR(opline->result.var), op2_str);
			}
			if ((IS_TMP_VAR|IS_VAR) & (IS_TMP_VAR|IS_VAR)) {
				crex_string_release_ex(op1_str, 0);
			}
		} else if ((IS_TMP_VAR|IS_VAR) != IS_CONST && UNEXPECTED(ZSTR_LEN(op2_str) == 0)) {
			if ((IS_TMP_VAR|IS_VAR) == IS_CONST || (IS_TMP_VAR|IS_VAR) == IS_CV) {
				ZVAL_STR_COPY(EX_VAR(opline->result.var), op1_str);
			} else {
				ZVAL_STR(EX_VAR(opline->result.var), op1_str);
			}
			if ((IS_TMP_VAR|IS_VAR) & (IS_TMP_VAR|IS_VAR)) {
				crex_string_release_ex(op2_str, 0);
			}
		} else if ((IS_TMP_VAR|IS_VAR) != IS_CONST && (IS_TMP_VAR|IS_VAR) != IS_CV &&
		    !ZSTR_IS_INTERNED(op1_str) && GC_REFCOUNT(op1_str) == 1) {
			size_t len = ZSTR_LEN(op1_str);

			str = crex_string_extend(op1_str, len + ZSTR_LEN(op2_str), 0);
			memcpy(ZSTR_VAL(str) + len, ZSTR_VAL(op2_str), ZSTR_LEN(op2_str)+1);
			GC_ADD_FLAGS(str, flags);
			ZVAL_NEW_STR(EX_VAR(opline->result.var), str);
			if ((IS_TMP_VAR|IS_VAR) & (IS_TMP_VAR|IS_VAR)) {
				crex_string_release_ex(op2_str, 0);
			}
		} else {
			str = crex_string_alloc(ZSTR_LEN(op1_str) + ZSTR_LEN(op2_str), 0);
			memcpy(ZSTR_VAL(str), ZSTR_VAL(op1_str), ZSTR_LEN(op1_str));
			memcpy(ZSTR_VAL(str) + ZSTR_LEN(op1_str), ZSTR_VAL(op2_str), ZSTR_LEN(op2_str)+1);
			GC_ADD_FLAGS(str, flags);
			ZVAL_NEW_STR(EX_VAR(opline->result.var), str);
			if ((IS_TMP_VAR|IS_VAR) & (IS_TMP_VAR|IS_VAR)) {
				crex_string_release_ex(op1_str, 0);
			}
			if ((IS_TMP_VAR|IS_VAR) & (IS_TMP_VAR|IS_VAR)) {
				crex_string_release_ex(op2_str, 0);
			}
		}
		CREX_VM_NEXT_OPCODE();
	}

	SAVE_OPLINE();
	if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
		op1_str = C_STR_P(op1);
	} else if (EXPECTED(C_TYPE_P(op1) == IS_STRING)) {
		op1_str = crex_string_copy(C_STR_P(op1));
	} else {
		if ((IS_TMP_VAR|IS_VAR) == IS_CV && UNEXPECTED(C_TYPE_P(op1) == IS_UNDEF)) {
			ZVAL_UNDEFINED_OP1();
		}
		op1_str = zval_get_string_func(op1);
	}
	if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
		op2_str = C_STR_P(op2);
	} else if (EXPECTED(C_TYPE_P(op2) == IS_STRING)) {
		op2_str = crex_string_copy(C_STR_P(op2));
	} else {
		if ((IS_TMP_VAR|IS_VAR) == IS_CV && UNEXPECTED(C_TYPE_P(op2) == IS_UNDEF)) {
			ZVAL_UNDEFINED_OP2();
		}
		op2_str = zval_get_string_func(op2);
	}
	do {
		if ((IS_TMP_VAR|IS_VAR) != IS_CONST) {
			if (UNEXPECTED(ZSTR_LEN(op1_str) == 0)) {
				if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
					if (UNEXPECTED(C_REFCOUNTED_P(op2))) {
						GC_ADDREF(op2_str);
					}
				}
				ZVAL_STR(EX_VAR(opline->result.var), op2_str);
				crex_string_release_ex(op1_str, 0);
				break;
			}
		}
		if ((IS_TMP_VAR|IS_VAR) != IS_CONST) {
			if (UNEXPECTED(ZSTR_LEN(op2_str) == 0)) {
				if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
					if (UNEXPECTED(C_REFCOUNTED_P(op1))) {
						GC_ADDREF(op1_str);
					}
				}
				ZVAL_STR(EX_VAR(opline->result.var), op1_str);
				crex_string_release_ex(op2_str, 0);
				break;
			}
		}
		str = crex_string_alloc(ZSTR_LEN(op1_str) + ZSTR_LEN(op2_str), 0);
		memcpy(ZSTR_VAL(str), ZSTR_VAL(op1_str), ZSTR_LEN(op1_str));
		memcpy(ZSTR_VAL(str) + ZSTR_LEN(op1_str), ZSTR_VAL(op2_str), ZSTR_LEN(op2_str)+1);

		ZSTR_COPY_CONCAT_PROPERTIES_BOTH(str, op1_str, op2_str);
		ZVAL_NEW_STR(EX_VAR(opline->result.var), str);
		if ((IS_TMP_VAR|IS_VAR) != IS_CONST) {
			crex_string_release_ex(op1_str, 0);
		}
		if ((IS_TMP_VAR|IS_VAR) != IS_CONST) {
			crex_string_release_ex(op2_str, 0);
		}
	} while (0);
	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_INIT_METHOD_CALL_SPEC_TMPVAR_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *function_name;
	zval *object;
	crex_function *fbc;
	crex_class_entry *called_scope;
	crex_object *obj;
	crex_execute_data *call;
	uint32_t call_info;

	SAVE_OPLINE();

	object = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);

	if ((IS_TMP_VAR|IS_VAR) != IS_CONST) {
		function_name = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
	}

	if ((IS_TMP_VAR|IS_VAR) != IS_CONST &&
	    UNEXPECTED(C_TYPE_P(function_name) != IS_STRING)) {
		do {
			if (((IS_TMP_VAR|IS_VAR) & (IS_VAR|IS_CV)) && C_ISREF_P(function_name)) {
				function_name = C_REFVAL_P(function_name);
				if (EXPECTED(C_TYPE_P(function_name) == IS_STRING)) {
					break;
				}
			} else if ((IS_TMP_VAR|IS_VAR) == IS_CV && UNEXPECTED(C_TYPE_P(function_name) == IS_UNDEF)) {
				ZVAL_UNDEFINED_OP2();
				if (UNEXPECTED(EG(exception) != NULL)) {
					zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
					HANDLE_EXCEPTION();
				}
			}
			crex_throw_error(NULL, "Method name must be a string");
			zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
			zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
			HANDLE_EXCEPTION();
		} while (0);
	}

	if ((IS_TMP_VAR|IS_VAR) == IS_UNUSED) {
		obj = C_OBJ_P(object);
	} else {
		do {
			if ((IS_TMP_VAR|IS_VAR) != IS_CONST && EXPECTED(C_TYPE_P(object) == IS_OBJECT)) {
				obj = C_OBJ_P(object);
			} else {
				if (((IS_TMP_VAR|IS_VAR) & (IS_VAR|IS_CV)) && EXPECTED(C_ISREF_P(object))) {
					crex_reference *ref = C_REF_P(object);

					object = &ref->val;
					if (EXPECTED(C_TYPE_P(object) == IS_OBJECT)) {
						obj = C_OBJ_P(object);
						if ((IS_TMP_VAR|IS_VAR) & IS_VAR) {
							if (UNEXPECTED(GC_DELREF(ref) == 0)) {
								efree_size(ref, sizeof(crex_reference));
							} else {
								C_ADDREF_P(object);
							}
						}
						break;
					}
				}
				if ((IS_TMP_VAR|IS_VAR) == IS_CV && UNEXPECTED(C_TYPE_P(object) == IS_UNDEF)) {
					object = ZVAL_UNDEFINED_OP1();
					if (UNEXPECTED(EG(exception) != NULL)) {
						if ((IS_TMP_VAR|IS_VAR) != IS_CONST) {
							zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
						}
						HANDLE_EXCEPTION();
					}
				}
				if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
					function_name = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
				}
				crex_invalid_method_call(object, function_name);
				zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
				zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
				HANDLE_EXCEPTION();
			}
		} while (0);
	}

	called_scope = obj->ce;

	if ((IS_TMP_VAR|IS_VAR) == IS_CONST &&
	    EXPECTED(CACHED_PTR(opline->result.num) == called_scope)) {
		fbc = CACHED_PTR(opline->result.num + sizeof(void*));
	} else {
		crex_object *orig_obj = obj;

		if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
			function_name = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
		}

		/* First, locate the function. */
		fbc = obj->handlers->get_method(&obj, C_STR_P(function_name), (((IS_TMP_VAR|IS_VAR) == IS_CONST) ? (RT_CONSTANT(opline, opline->op2) + 1) : NULL));
		if (UNEXPECTED(fbc == NULL)) {
			if (EXPECTED(!EG(exception))) {
				crex_undefined_method(obj->ce, C_STR_P(function_name));
			}
			zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
			if (((IS_TMP_VAR|IS_VAR) & (IS_VAR|IS_TMP_VAR)) && GC_DELREF(orig_obj) == 0) {
				crex_objects_store_del(orig_obj);
			}
			HANDLE_EXCEPTION();
		}
		if ((IS_TMP_VAR|IS_VAR) == IS_CONST &&
		    EXPECTED(!(fbc->common.fn_flags & (CREX_ACC_CALL_VIA_TRAMPOLINE|CREX_ACC_NEVER_CACHE))) &&
		    EXPECTED(obj == orig_obj)) {
			CACHE_POLYMORPHIC_PTR(opline->result.num, called_scope, fbc);
		}
		if (((IS_TMP_VAR|IS_VAR) & (IS_VAR|IS_TMP_VAR)) && UNEXPECTED(obj != orig_obj)) {
			GC_ADDREF(obj); /* For $this pointer */
			if (GC_DELREF(orig_obj) == 0) {
				crex_objects_store_del(orig_obj);
			}
		}
		if (EXPECTED(fbc->type == CREX_USER_FUNCTION) && UNEXPECTED(!RUN_TIME_CACHE(&fbc->op_array))) {
			init_func_run_time_cache(&fbc->op_array);
		}
	}

	if ((IS_TMP_VAR|IS_VAR) != IS_CONST) {
		zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
	}

	call_info = CREX_CALL_NESTED_FUNCTION | CREX_CALL_HAS_THIS;
	if (UNEXPECTED((fbc->common.fn_flags & CREX_ACC_STATIC) != 0)) {
		if (((IS_TMP_VAR|IS_VAR) & (IS_VAR|IS_TMP_VAR)) && GC_DELREF(obj) == 0) {
			crex_objects_store_del(obj);
			if (UNEXPECTED(EG(exception))) {
				HANDLE_EXCEPTION();
			}
		}
		/* call static method */
		obj = (crex_object*)called_scope;
		call_info = CREX_CALL_NESTED_FUNCTION;
	} else if ((IS_TMP_VAR|IS_VAR) & (IS_VAR|IS_TMP_VAR|IS_CV)) {
		if ((IS_TMP_VAR|IS_VAR) == IS_CV) {
			GC_ADDREF(obj); /* For $this pointer */
		}
		/* CV may be changed indirectly (e.g. when it's a reference) */
		call_info = CREX_CALL_NESTED_FUNCTION | CREX_CALL_HAS_THIS | CREX_CALL_RELEASE_THIS;
	}

	call = crex_vm_stack_push_call_frame(call_info,
		fbc, opline->extended_value, obj);
	call->prev_execute_data = EX(call);
	EX(call) = call;

	CREX_VM_NEXT_OPCODE();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_CASE_SPEC_TMPVAR_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	double d1, d2;

	op1 = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	op2 = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
	if (EXPECTED(C_TYPE_P(op1) == IS_LONG)) {
		if (EXPECTED(C_TYPE_P(op2) == IS_LONG)) {
			if (EXPECTED(C_LVAL_P(op1) == C_LVAL_P(op2))) {
case_true:
				CREX_VM_SMART_BRANCH_TRUE();
			} else {
case_false:
				CREX_VM_SMART_BRANCH_FALSE();
			}
		} else if (EXPECTED(C_TYPE_P(op2) == IS_DOUBLE)) {
			d1 = (double)C_LVAL_P(op1);
			d2 = C_DVAL_P(op2);
			goto case_double;
		}
	} else if (EXPECTED(C_TYPE_P(op1) == IS_DOUBLE)) {
		if (EXPECTED(C_TYPE_P(op2) == IS_DOUBLE)) {
			d1 = C_DVAL_P(op1);
			d2 = C_DVAL_P(op2);
case_double:
			if (d1 == d2) {
				goto case_true;
			} else {
				goto case_false;
			}
		} else if (EXPECTED(C_TYPE_P(op2) == IS_LONG)) {
			d1 = C_DVAL_P(op1);
			d2 = (double)C_LVAL_P(op2);
			goto case_double;
		}
	} else if (EXPECTED(C_TYPE_P(op1) == IS_STRING)) {
		if (EXPECTED(C_TYPE_P(op2) == IS_STRING)) {
			bool result = crex_fast_equal_strings(C_STR_P(op1), C_STR_P(op2));
			zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
			if (result) {
				goto case_true;
			} else {
				goto case_false;
			}
		}
	}
	CREX_VM_TAIL_CALL(crex_case_helper_SPEC(op1, op2 CREX_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ISSET_ISEMPTY_DIM_OBJ_SPEC_TMPVAR_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;
	bool result;
	crex_ulong hval;
	zval *offset;

	SAVE_OPLINE();
	container = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	offset = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);

	if (EXPECTED(C_TYPE_P(container) == IS_ARRAY)) {
		HashTable *ht;
		zval *value;
		crex_string *str;

isset_dim_obj_array:
		ht = C_ARRVAL_P(container);
isset_again:
		if (EXPECTED(C_TYPE_P(offset) == IS_STRING)) {
			str = C_STR_P(offset);
			if ((IS_TMP_VAR|IS_VAR) != IS_CONST) {
				if (CREX_HANDLE_NUMERIC(str, hval)) {
					goto num_index_prop;
				}
			}
			value = crex_hash_find_ex(ht, str, (IS_TMP_VAR|IS_VAR) == IS_CONST);
		} else if (EXPECTED(C_TYPE_P(offset) == IS_LONG)) {
			hval = C_LVAL_P(offset);
num_index_prop:
			value = crex_hash_index_find(ht, hval);
		} else if (((IS_TMP_VAR|IS_VAR) & (IS_VAR|IS_CV)) && EXPECTED(C_ISREF_P(offset))) {
			offset = C_REFVAL_P(offset);
			goto isset_again;
		} else {
			value = crex_find_array_dim_slow(ht, offset EXECUTE_DATA_CC);
			if (UNEXPECTED(EG(exception))) {
				result = 0;
				goto isset_dim_obj_exit;
			}
		}

		if (!(opline->extended_value & CREX_ISEMPTY)) {
			/* > IS_NULL means not IS_UNDEF and not IS_NULL */
			result = value != NULL && C_TYPE_P(value) > IS_NULL &&
			    (!C_ISREF_P(value) || C_TYPE_P(C_REFVAL_P(value)) != IS_NULL);

			if ((IS_TMP_VAR|IS_VAR) & (IS_CONST|IS_CV)) {
				/* avoid exception check */
				zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
				CREX_VM_SMART_BRANCH(result, 0);
			}
		} else {
			result = (value == NULL || !i_crex_is_true(value));
		}
		goto isset_dim_obj_exit;
	} else if (((IS_TMP_VAR|IS_VAR) & (IS_VAR|IS_CV)) && EXPECTED(C_ISREF_P(container))) {
		container = C_REFVAL_P(container);
		if (EXPECTED(C_TYPE_P(container) == IS_ARRAY)) {
			goto isset_dim_obj_array;
		}
	}

	if ((IS_TMP_VAR|IS_VAR) == IS_CONST && C_EXTRA_P(offset) == CREX_EXTRA_VALUE) {
		offset++;
	}
	if (!(opline->extended_value & CREX_ISEMPTY)) {
		result = crex_isset_dim_slow(container, offset EXECUTE_DATA_CC);
	} else {
		result = crex_isempty_dim_slow(container, offset EXECUTE_DATA_CC);
	}

isset_dim_obj_exit:
	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	CREX_VM_SMART_BRANCH(result, 1);
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ISSET_ISEMPTY_PROP_OBJ_SPEC_TMPVAR_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;
	int result;
	zval *offset;
	crex_string *name, *tmp_name;

	SAVE_OPLINE();
	container = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	offset = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);

	if ((IS_TMP_VAR|IS_VAR) == IS_CONST ||
	    ((IS_TMP_VAR|IS_VAR) != IS_UNUSED && UNEXPECTED(C_TYPE_P(container) != IS_OBJECT))) {
		if (((IS_TMP_VAR|IS_VAR) & (IS_VAR|IS_CV)) && C_ISREF_P(container)) {
			container = C_REFVAL_P(container);
			if (UNEXPECTED(C_TYPE_P(container) != IS_OBJECT)) {
				result = (opline->extended_value & CREX_ISEMPTY);
				goto isset_object_finish;
			}
		} else {
			result = (opline->extended_value & CREX_ISEMPTY);
			goto isset_object_finish;
		}
	}

	if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
		name = C_STR_P(offset);
	} else {
		name = zval_try_get_tmp_string(offset, &tmp_name);
		if (UNEXPECTED(!name)) {
			result = 0;
			goto isset_object_finish;
		}
	}

	result =
		(opline->extended_value & CREX_ISEMPTY) ^
		C_OBJ_HT_P(container)->has_property(C_OBJ_P(container), name, (opline->extended_value & CREX_ISEMPTY), (((IS_TMP_VAR|IS_VAR) == IS_CONST) ? CACHE_ADDR(opline->extended_value & ~CREX_ISEMPTY) : NULL));

	if ((IS_TMP_VAR|IS_VAR) != IS_CONST) {
		crex_tmp_string_release(tmp_name);
	}

isset_object_finish:
	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	CREX_VM_SMART_BRANCH(result, 1);
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ARRAY_KEY_EXISTS_SPEC_TMPVAR_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *key, *subject;
	HashTable *ht;
	bool result;

	SAVE_OPLINE();

	key = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	subject = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);

	if (EXPECTED(C_TYPE_P(subject) == IS_ARRAY)) {
array_key_exists_array:
		ht = C_ARRVAL_P(subject);
		result = crex_array_key_exists_fast(ht, key OPLINE_CC EXECUTE_DATA_CC);
	} else {
		if (((IS_TMP_VAR|IS_VAR) & (IS_VAR|IS_CV)) && EXPECTED(C_ISREF_P(subject))) {
			subject = C_REFVAL_P(subject);
			if (EXPECTED(C_TYPE_P(subject) == IS_ARRAY)) {
				goto array_key_exists_array;
			}
		}
		crex_array_key_exists_error(subject, key OPLINE_CC EXECUTE_DATA_CC);
		result = 0;
	}

	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	CREX_VM_SMART_BRANCH(result, 1);
}

/* No specialization for op_types (CONST|TMPVAR|UNUSED|CV, ANY) */
static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_INSTANCEOF_SPEC_TMPVAR_VAR_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *expr;
	bool result;

	SAVE_OPLINE();
	expr = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);

try_instanceof:
	if (C_TYPE_P(expr) == IS_OBJECT) {
		crex_class_entry *ce;

		if (IS_VAR == IS_CONST) {
			ce = CACHED_PTR(opline->extended_value);
			if (UNEXPECTED(ce == NULL)) {
				ce = crex_lookup_class_ex(C_STR_P(RT_CONSTANT(opline, opline->op2)), C_STR_P(RT_CONSTANT(opline, opline->op2) + 1), CREX_FETCH_CLASS_NO_AUTOLOAD);
				if (EXPECTED(ce)) {
					CACHE_PTR(opline->extended_value, ce);
				}
			}
		} else if (IS_VAR == IS_UNUSED) {
			ce = crex_fetch_class(NULL, opline->op2.num);
			if (UNEXPECTED(ce == NULL)) {
				zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
				ZVAL_UNDEF(EX_VAR(opline->result.var));
				HANDLE_EXCEPTION();
			}
		} else {
			ce = C_CE_P(EX_VAR(opline->op2.var));
		}
		result = ce && instanceof_function(C_OBJCE_P(expr), ce);
	} else if (((IS_TMP_VAR|IS_VAR) & (IS_VAR|IS_CV)) && C_TYPE_P(expr) == IS_REFERENCE) {
		expr = C_REFVAL_P(expr);
		goto try_instanceof;
	} else {
		if ((IS_TMP_VAR|IS_VAR) == IS_CV && UNEXPECTED(C_TYPE_P(expr) == IS_UNDEF)) {
			ZVAL_UNDEFINED_OP1();
		}
		result = 0;
	}
	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	CREX_VM_SMART_BRANCH(result, 1);
}

static crex_never_inline CREX_OPCODE_HANDLER_RET CREX_FASTCALL crex_fetch_var_address_helper_SPEC_TMPVAR_UNUSED(int type CREX_OPCODE_HANDLER_ARGS_DC)
{
	USE_OPLINE
	zval *varname;
	zval *retval;
	crex_string *name, *tmp_name;
	HashTable *target_symbol_table;

	SAVE_OPLINE();
	varname = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);

	if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
		name = C_STR_P(varname);
	} else if (EXPECTED(C_TYPE_P(varname) == IS_STRING)) {
		name = C_STR_P(varname);
		tmp_name = NULL;
	} else {
		if ((IS_TMP_VAR|IS_VAR) == IS_CV && UNEXPECTED(C_TYPE_P(varname) == IS_UNDEF)) {
			ZVAL_UNDEFINED_OP1();
		}
		name = zval_try_get_tmp_string(varname, &tmp_name);
		if (UNEXPECTED(!name)) {
			if (!(opline->extended_value & CREX_FETCH_GLOBAL_LOCK)) {
				zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
			}
			ZVAL_UNDEF(EX_VAR(opline->result.var));
			HANDLE_EXCEPTION();
		}
	}

	target_symbol_table = crex_get_target_symbol_table(opline->extended_value EXECUTE_DATA_CC);
	retval = crex_hash_find_ex(target_symbol_table, name, (IS_TMP_VAR|IS_VAR) == IS_CONST);
	if (retval == NULL) {
		if (UNEXPECTED(crex_string_equals(name, ZSTR_KNOWN(CREX_STR_THIS)))) {
fetch_this:
			crex_fetch_this_var(type OPLINE_CC EXECUTE_DATA_CC);
			if ((IS_TMP_VAR|IS_VAR) != IS_CONST) {
				crex_tmp_string_release(tmp_name);
			}
			CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
		}
		if (type == BP_VAR_W) {
			retval = crex_hash_add_new(target_symbol_table, name, &EG(uninitialized_zval));
		} else if (type == BP_VAR_IS || type == BP_VAR_UNSET) {
			retval = &EG(uninitialized_zval);
		} else {
			if ((IS_TMP_VAR|IS_VAR) == IS_CV) {
				/* Keep name alive in case an error handler tries to free it. */
				crex_string_addref(name);
			}
			crex_error(E_WARNING, "Undefined %svariable $%s",
				(opline->extended_value & CREX_FETCH_GLOBAL ? "global " : ""), ZSTR_VAL(name));
			if (type == BP_VAR_RW && !EG(exception)) {
				retval = crex_hash_update(target_symbol_table, name, &EG(uninitialized_zval));
			} else {
				retval = &EG(uninitialized_zval);
			}
			if ((IS_TMP_VAR|IS_VAR) == IS_CV) {
				crex_string_release(name);
			}
		}
	/* GLOBAL or $$name variable may be an INDIRECT pointer to CV */
	} else if (C_TYPE_P(retval) == IS_INDIRECT) {
		retval = C_INDIRECT_P(retval);
		if (C_TYPE_P(retval) == IS_UNDEF) {
			if (UNEXPECTED(crex_string_equals(name, ZSTR_KNOWN(CREX_STR_THIS)))) {
				goto fetch_this;
			}
			if (type == BP_VAR_W) {
				ZVAL_NULL(retval);
			} else if (type == BP_VAR_IS || type == BP_VAR_UNSET) {
				retval = &EG(uninitialized_zval);
			} else {
				crex_error(E_WARNING, "Undefined %svariable $%s",
					(opline->extended_value & CREX_FETCH_GLOBAL ? "global " : ""), ZSTR_VAL(name));
				if (type == BP_VAR_RW && !EG(exception)) {
					ZVAL_NULL(retval);
				} else {
					retval = &EG(uninitialized_zval);
				}
			}
		}
	}

	if (!(opline->extended_value & CREX_FETCH_GLOBAL_LOCK)) {
		zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	}

	if ((IS_TMP_VAR|IS_VAR) != IS_CONST) {
		crex_tmp_string_release(tmp_name);
	}

	CREX_ASSERT(retval != NULL);
	if (type == BP_VAR_R || type == BP_VAR_IS) {
		ZVAL_COPY_DEREF(EX_VAR(opline->result.var), retval);
	} else {
		ZVAL_INDIRECT(EX_VAR(opline->result.var), retval);
	}
	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FETCH_R_SPEC_TMPVAR_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	CREX_VM_TAIL_CALL(crex_fetch_var_address_helper_SPEC_TMPVAR_UNUSED(BP_VAR_R CREX_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FETCH_W_SPEC_TMPVAR_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	CREX_VM_TAIL_CALL(crex_fetch_var_address_helper_SPEC_TMPVAR_UNUSED(BP_VAR_W CREX_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FETCH_RW_SPEC_TMPVAR_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	CREX_VM_TAIL_CALL(crex_fetch_var_address_helper_SPEC_TMPVAR_UNUSED(BP_VAR_RW CREX_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FETCH_FUNC_ARG_SPEC_TMPVAR_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	int fetch_type =
		(UNEXPECTED(CREX_CALL_INFO(EX(call)) & CREX_CALL_SEND_ARG_BY_REF)) ?
			BP_VAR_W : BP_VAR_R;
	CREX_VM_TAIL_CALL(crex_fetch_var_address_helper_SPEC_TMPVAR_UNUSED(fetch_type CREX_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FETCH_UNSET_SPEC_TMPVAR_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	CREX_VM_TAIL_CALL(crex_fetch_var_address_helper_SPEC_TMPVAR_UNUSED(BP_VAR_UNSET CREX_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FETCH_IS_SPEC_TMPVAR_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	CREX_VM_TAIL_CALL(crex_fetch_var_address_helper_SPEC_TMPVAR_UNUSED(BP_VAR_IS CREX_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

/* No specialization for op_types (CONST|TMPVAR|CV, UNUSED|CONST|VAR) */
static CREX_VM_HOT CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_SEND_VAL_SPEC_TMPVAR_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *value, *arg;

	if (IS_UNUSED == IS_CONST) {
		SAVE_OPLINE();
		crex_string *arg_name = C_STR_P(RT_CONSTANT(opline, opline->op2));
		uint32_t arg_num;
		arg = crex_handle_named_arg(&EX(call), arg_name, &arg_num, CACHE_ADDR(opline->result.num));
		if (UNEXPECTED(!arg)) {
			zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
			HANDLE_EXCEPTION();
		}
	} else {
		arg = CREX_CALL_VAR(EX(call), opline->result.var);
	}

	value = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	ZVAL_COPY_VALUE(arg, value);
	if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
		if (UNEXPECTED(C_OPT_REFCOUNTED_P(arg))) {
			C_ADDREF_P(arg);
		}
	}
	CREX_VM_NEXT_OPCODE();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_UNSET_VAR_SPEC_TMPVAR_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *varname;
	crex_string *name, *tmp_name;
	HashTable *target_symbol_table;

	SAVE_OPLINE();

	varname = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);

	if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
		name = C_STR_P(varname);
	} else if (EXPECTED(C_TYPE_P(varname) == IS_STRING)) {
		name = C_STR_P(varname);
		tmp_name = NULL;
	} else {
		if ((IS_TMP_VAR|IS_VAR) == IS_CV && UNEXPECTED(C_TYPE_P(varname) == IS_UNDEF)) {
			varname = ZVAL_UNDEFINED_OP1();
		}
		name = zval_try_get_tmp_string(varname, &tmp_name);
		if (UNEXPECTED(!name)) {
			zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
			HANDLE_EXCEPTION();
		}
	}

	target_symbol_table = crex_get_target_symbol_table(opline->extended_value EXECUTE_DATA_CC);
	crex_hash_del_ind(target_symbol_table, name);

	if ((IS_TMP_VAR|IS_VAR) != IS_CONST) {
		crex_tmp_string_release(tmp_name);
	}
	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

/* No specialization for op_types (CONST|TMPVAR|CV, UNUSED|CLASS_FETCH|CONST|VAR) */
static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ISSET_ISEMPTY_VAR_SPEC_TMPVAR_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *value;
	/* Should be bool result? as below got: result = (opline->extended_value & CREX_ISEMPTY) */
	int result;
	zval *varname;
	crex_string *name, *tmp_name;
	HashTable *target_symbol_table;

	SAVE_OPLINE();
	varname = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
		name = C_STR_P(varname);
	} else {
		name = zval_get_tmp_string(varname, &tmp_name);
	}

	target_symbol_table = crex_get_target_symbol_table(opline->extended_value EXECUTE_DATA_CC);
	value = crex_hash_find_ex(target_symbol_table, name, (IS_TMP_VAR|IS_VAR) == IS_CONST);

	if ((IS_TMP_VAR|IS_VAR) != IS_CONST) {
		crex_tmp_string_release(tmp_name);
	}
	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));

	if (!value) {
		result = (opline->extended_value & CREX_ISEMPTY);
	} else {
		if (C_TYPE_P(value) == IS_INDIRECT) {
			value = C_INDIRECT_P(value);
		}
		if (!(opline->extended_value & CREX_ISEMPTY)) {
			if (C_ISREF_P(value)) {
				value = C_REFVAL_P(value);
			}
			result = C_TYPE_P(value) > IS_NULL;
		} else {
			result = !i_crex_is_true(value);
		}
	}

	CREX_VM_SMART_BRANCH(result, 1);
}

/* No specialization for op_types (CONST|TMPVAR|CV, UNUSED|CLASS_FETCH|CONST|VAR) */
static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_INSTANCEOF_SPEC_TMPVAR_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *expr;
	bool result;

	SAVE_OPLINE();
	expr = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);

try_instanceof:
	if (C_TYPE_P(expr) == IS_OBJECT) {
		crex_class_entry *ce;

		if (IS_UNUSED == IS_CONST) {
			ce = CACHED_PTR(opline->extended_value);
			if (UNEXPECTED(ce == NULL)) {
				ce = crex_lookup_class_ex(C_STR_P(RT_CONSTANT(opline, opline->op2)), C_STR_P(RT_CONSTANT(opline, opline->op2) + 1), CREX_FETCH_CLASS_NO_AUTOLOAD);
				if (EXPECTED(ce)) {
					CACHE_PTR(opline->extended_value, ce);
				}
			}
		} else if (IS_UNUSED == IS_UNUSED) {
			ce = crex_fetch_class(NULL, opline->op2.num);
			if (UNEXPECTED(ce == NULL)) {
				zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
				ZVAL_UNDEF(EX_VAR(opline->result.var));
				HANDLE_EXCEPTION();
			}
		} else {
			ce = C_CE_P(EX_VAR(opline->op2.var));
		}
		result = ce && instanceof_function(C_OBJCE_P(expr), ce);
	} else if (((IS_TMP_VAR|IS_VAR) & (IS_VAR|IS_CV)) && C_TYPE_P(expr) == IS_REFERENCE) {
		expr = C_REFVAL_P(expr);
		goto try_instanceof;
	} else {
		if ((IS_TMP_VAR|IS_VAR) == IS_CV && UNEXPECTED(C_TYPE_P(expr) == IS_UNDEF)) {
			ZVAL_UNDEFINED_OP1();
		}
		result = 0;
	}
	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	CREX_VM_SMART_BRANCH(result, 1);
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_COUNT_SPEC_TMPVAR_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1;
	crex_long count;

	SAVE_OPLINE();
	op1 = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);

	while (1) {
		if (C_TYPE_P(op1) == IS_ARRAY) {
			count = crex_hash_num_elements(C_ARRVAL_P(op1));
			break;
		} else if (C_TYPE_P(op1) == IS_OBJECT) {
			crex_object *zobj = C_OBJ_P(op1);

			/* first, we check if the handler is defined */
			if (zobj->handlers->count_elements) {
				if (SUCCESS == zobj->handlers->count_elements(zobj, &count)) {
					break;
				}
				if (UNEXPECTED(EG(exception))) {
					count = 0;
					break;
				}
			}

			/* if not and the object implements Countable we call its count() method */
			if (crex_class_implements_interface(zobj->ce, crex_ce_countable)) {
				zval retval;

				crex_function *count_fn = crex_hash_find_ptr(&zobj->ce->function_table, ZSTR_KNOWN(CREX_STR_COUNT));
				crex_call_known_instance_method_with_0_params(count_fn, zobj, &retval);
				count = zval_get_long(&retval);
				zval_ptr_dtor(&retval);
				break;
			}

			/* If There's no handler and it doesn't implement Countable then emit a TypeError */
		} else if (((IS_TMP_VAR|IS_VAR) & (IS_VAR|IS_CV)) != 0 && C_TYPE_P(op1) == IS_REFERENCE) {
			op1 = C_REFVAL_P(op1);
			continue;
		} else if ((IS_TMP_VAR|IS_VAR) == IS_CV && UNEXPECTED(C_TYPE_P(op1) == IS_UNDEF)) {
			ZVAL_UNDEFINED_OP1();
		}
		count = 0;
		crex_type_error("%s(): Argument #1 ($value) must be of type Countable|array, %s given", opline->extended_value ? "sizeof" : "count", crex_zval_value_name(op1));
		break;
	}

	ZVAL_LONG(EX_VAR(opline->result.var), count);
	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_COUNT_ARRAY_SPEC_TMPVAR_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	crex_array *ht = C_ARRVAL_P(_get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC));
	ZVAL_LONG(EX_VAR(opline->result.var), crex_hash_num_elements(ht));
	if ((IS_TMP_VAR|IS_VAR) & (IS_TMP_VAR|IS_VAR) && !(GC_FLAGS(ht) & IS_ARRAY_IMMUTABLE) && !GC_DELREF(ht)) {
		SAVE_OPLINE();
		crex_array_destroy(ht);
		if (EG(exception)) {
			HANDLE_EXCEPTION();
		}
	}
	CREX_VM_NEXT_OPCODE();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_GET_CLASS_SPEC_TMPVAR_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if ((IS_TMP_VAR|IS_VAR) == IS_UNUSED) {
		SAVE_OPLINE();
		if (UNEXPECTED(!EX(func)->common.scope)) {
			crex_throw_error(NULL, "get_class() without arguments must be called from within a class");
			ZVAL_UNDEF(EX_VAR(opline->result.var));
			HANDLE_EXCEPTION();
		} else {
			crex_error(E_DEPRECATED, "Calling get_class() without arguments is deprecated");
			ZVAL_STR_COPY(EX_VAR(opline->result.var), EX(func)->common.scope->name);
			if (UNEXPECTED(EG(exception))) {
				HANDLE_EXCEPTION();
			}
			CREX_VM_NEXT_OPCODE();
		}
	} else {
		zval *op1;

		SAVE_OPLINE();
		op1 = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);
		while (1) {
			if (C_TYPE_P(op1) == IS_OBJECT) {
				ZVAL_STR_COPY(EX_VAR(opline->result.var), C_OBJCE_P(op1)->name);
			} else if (((IS_TMP_VAR|IS_VAR) & (IS_VAR|IS_CV)) != 0 && C_TYPE_P(op1) == IS_REFERENCE) {
				op1 = C_REFVAL_P(op1);
				continue;
			} else {
				if ((IS_TMP_VAR|IS_VAR) == IS_CV && UNEXPECTED(C_TYPE_P(op1) == IS_UNDEF)) {
					ZVAL_UNDEFINED_OP1();
				}
				crex_type_error("get_class(): Argument #1 ($object) must be of type object, %s given", crex_zval_value_name(op1));
				ZVAL_UNDEF(EX_VAR(opline->result.var));
			}
			break;
		}
		zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
		CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
	}
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_COPY_TMP_SPEC_TMPVAR_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *value = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	zval *result = EX_VAR(opline->result.var);
	ZVAL_COPY(result, value);
	CREX_VM_NEXT_OPCODE();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_DIV_SPEC_TMPVAR_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;

	SAVE_OPLINE();
	op1 = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	op2 = _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC);
	div_function(EX_VAR(opline->result.var), op1, op2);
	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));

	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_POW_SPEC_TMPVAR_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;

	SAVE_OPLINE();
	op1 = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	op2 = _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC);
	pow_function(EX_VAR(opline->result.var), op1, op2);
	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));

	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_CONCAT_SPEC_TMPVAR_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;

	op1 = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	op2 = EX_VAR(opline->op2.var);

	if (((IS_TMP_VAR|IS_VAR) == IS_CONST || EXPECTED(C_TYPE_P(op1) == IS_STRING)) &&
	    (IS_CV == IS_CONST || EXPECTED(C_TYPE_P(op2) == IS_STRING))) {
		crex_string *op1_str = C_STR_P(op1);
		crex_string *op2_str = C_STR_P(op2);
		crex_string *str;
		uint32_t flags = ZSTR_GET_COPYABLE_CONCAT_PROPERTIES_BOTH(op1_str, op2_str);

		if ((IS_TMP_VAR|IS_VAR) != IS_CONST && UNEXPECTED(ZSTR_LEN(op1_str) == 0)) {
			if (IS_CV == IS_CONST || IS_CV == IS_CV) {
				ZVAL_STR_COPY(EX_VAR(opline->result.var), op2_str);
			} else {
				ZVAL_STR(EX_VAR(opline->result.var), op2_str);
			}
			if ((IS_TMP_VAR|IS_VAR) & (IS_TMP_VAR|IS_VAR)) {
				crex_string_release_ex(op1_str, 0);
			}
		} else if (IS_CV != IS_CONST && UNEXPECTED(ZSTR_LEN(op2_str) == 0)) {
			if ((IS_TMP_VAR|IS_VAR) == IS_CONST || (IS_TMP_VAR|IS_VAR) == IS_CV) {
				ZVAL_STR_COPY(EX_VAR(opline->result.var), op1_str);
			} else {
				ZVAL_STR(EX_VAR(opline->result.var), op1_str);
			}
			if (IS_CV & (IS_TMP_VAR|IS_VAR)) {
				crex_string_release_ex(op2_str, 0);
			}
		} else if ((IS_TMP_VAR|IS_VAR) != IS_CONST && (IS_TMP_VAR|IS_VAR) != IS_CV &&
		    !ZSTR_IS_INTERNED(op1_str) && GC_REFCOUNT(op1_str) == 1) {
			size_t len = ZSTR_LEN(op1_str);

			if (UNEXPECTED(len > ZSTR_MAX_LEN - ZSTR_LEN(op2_str))) {
				crex_error_noreturn(E_ERROR, "Integer overflow in memory allocation");
			}
			str = crex_string_extend(op1_str, len + ZSTR_LEN(op2_str), 0);
			memcpy(ZSTR_VAL(str) + len, ZSTR_VAL(op2_str), ZSTR_LEN(op2_str)+1);
			GC_ADD_FLAGS(str, flags);
			ZVAL_NEW_STR(EX_VAR(opline->result.var), str);
			if (IS_CV & (IS_TMP_VAR|IS_VAR)) {
				crex_string_release_ex(op2_str, 0);
			}
		} else {
			str = crex_string_alloc(ZSTR_LEN(op1_str) + ZSTR_LEN(op2_str), 0);
			memcpy(ZSTR_VAL(str), ZSTR_VAL(op1_str), ZSTR_LEN(op1_str));
			memcpy(ZSTR_VAL(str) + ZSTR_LEN(op1_str), ZSTR_VAL(op2_str), ZSTR_LEN(op2_str)+1);
			GC_ADD_FLAGS(str, flags);
			ZVAL_NEW_STR(EX_VAR(opline->result.var), str);
			if ((IS_TMP_VAR|IS_VAR) & (IS_TMP_VAR|IS_VAR)) {
				crex_string_release_ex(op1_str, 0);
			}
			if (IS_CV & (IS_TMP_VAR|IS_VAR)) {
				crex_string_release_ex(op2_str, 0);
			}
		}
		CREX_VM_NEXT_OPCODE();
	} else {
		SAVE_OPLINE();

		if ((IS_TMP_VAR|IS_VAR) == IS_CV && UNEXPECTED(C_TYPE_P(op1) == IS_UNDEF)) {
			op1 = ZVAL_UNDEFINED_OP1();
		}
		if (IS_CV == IS_CV && UNEXPECTED(C_TYPE_P(op2) == IS_UNDEF)) {
			op2 = ZVAL_UNDEFINED_OP2();
		}
		concat_function(EX_VAR(opline->result.var), op1, op2);
		zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));

		CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
	}
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_SPACESHIP_SPEC_TMPVAR_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;

	SAVE_OPLINE();
	op1 = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	op2 = _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC);
	compare_function(EX_VAR(opline->result.var), op1, op2);
	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));

	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FETCH_DIM_R_SPEC_TMPVAR_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container, *dim, *value;

	SAVE_OPLINE();
	container = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	dim = EX_VAR(opline->op2.var);
	if ((IS_TMP_VAR|IS_VAR) != IS_CONST) {
		if (EXPECTED(C_TYPE_P(container) == IS_ARRAY)) {
fetch_dim_r_array:
			value = crex_fetch_dimension_address_inner(C_ARRVAL_P(container), dim, IS_CV, BP_VAR_R EXECUTE_DATA_CC);
			ZVAL_COPY_DEREF(EX_VAR(opline->result.var), value);
		} else if (EXPECTED(C_TYPE_P(container) == IS_REFERENCE)) {
			container = C_REFVAL_P(container);
			if (EXPECTED(C_TYPE_P(container) == IS_ARRAY)) {
				goto fetch_dim_r_array;
			} else {
				goto fetch_dim_r_slow;
			}
		} else {
fetch_dim_r_slow:
			if (IS_CV == IS_CONST && C_EXTRA_P(dim) == CREX_EXTRA_VALUE) {
				dim++;
			}
			crex_fetch_dimension_address_read_R_slow(container, dim OPLINE_CC EXECUTE_DATA_CC);
		}
	} else {
		crex_fetch_dimension_address_read_R(container, dim, IS_CV OPLINE_CC EXECUTE_DATA_CC);
	}

	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FETCH_DIM_IS_SPEC_TMPVAR_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;

	SAVE_OPLINE();
	container = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	crex_fetch_dimension_address_read_IS(container, EX_VAR(opline->op2.var), IS_CV OPLINE_CC EXECUTE_DATA_CC);

	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FETCH_OBJ_R_SPEC_TMPVAR_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;
	void **cache_slot = NULL;

	SAVE_OPLINE();
	container = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);

	if ((IS_TMP_VAR|IS_VAR) == IS_CONST ||
	    ((IS_TMP_VAR|IS_VAR) != IS_UNUSED && UNEXPECTED(C_TYPE_P(container) != IS_OBJECT))) {
		do {
			if (((IS_TMP_VAR|IS_VAR) & (IS_VAR|IS_CV)) && C_ISREF_P(container)) {
				container = C_REFVAL_P(container);
				if (EXPECTED(C_TYPE_P(container) == IS_OBJECT)) {
					break;
				}
			}
			if ((IS_TMP_VAR|IS_VAR) == IS_CV && UNEXPECTED(C_TYPE_P(container) == IS_UNDEF)) {
				ZVAL_UNDEFINED_OP1();
			}
			crex_wrong_property_read(container, _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC));
			ZVAL_NULL(EX_VAR(opline->result.var));
			goto fetch_obj_r_finish;
		} while (0);
	}

	/* here we are sure we are dealing with an object */
	do {
		crex_object *zobj = C_OBJ_P(container);
		crex_string *name, *tmp_name;
		zval *retval;

		if (IS_CV == IS_CONST) {
			cache_slot = CACHE_ADDR(opline->extended_value & ~CREX_FETCH_REF /* FUNC_ARG fetch may contain it */);

			if (EXPECTED(zobj->ce == CACHED_PTR_EX(cache_slot))) {
				uintptr_t prop_offset = (uintptr_t)CACHED_PTR_EX(cache_slot + 1);

				if (EXPECTED(IS_VALID_PROPERTY_OFFSET(prop_offset))) {
					retval = OBJ_PROP(zobj, prop_offset);
					if (EXPECTED(C_TYPE_INFO_P(retval) != IS_UNDEF)) {
						if (0 || ((IS_TMP_VAR|IS_VAR) & (IS_TMP_VAR|IS_VAR)) != 0) {
							goto fetch_obj_r_copy;
						} else {
fetch_obj_r_fast_copy:
							ZVAL_COPY_DEREF(EX_VAR(opline->result.var), retval);
							CREX_VM_NEXT_OPCODE();
						}
					}
				} else if (EXPECTED(zobj->properties != NULL)) {
					name = C_STR_P(_get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC));
					if (!IS_UNKNOWN_DYNAMIC_PROPERTY_OFFSET(prop_offset)) {
						uintptr_t idx = CREX_DECODE_DYN_PROP_OFFSET(prop_offset);

						if (EXPECTED(idx < zobj->properties->nNumUsed * sizeof(Bucket))) {
							Bucket *p = (Bucket*)((char*)zobj->properties->arData + idx);

							if (EXPECTED(p->key == name) ||
							    (EXPECTED(p->h == ZSTR_H(name)) &&
							     EXPECTED(p->key != NULL) &&
							     EXPECTED(crex_string_equal_content(p->key, name)))) {
								retval = &p->val;
								if (0 || ((IS_TMP_VAR|IS_VAR) & (IS_TMP_VAR|IS_VAR)) != 0) {
									goto fetch_obj_r_copy;
								} else {
									goto fetch_obj_r_fast_copy;
								}
							}
						}
						CACHE_PTR_EX(cache_slot + 1, (void*)CREX_DYNAMIC_PROPERTY_OFFSET);
					}
					retval = crex_hash_find_known_hash(zobj->properties, name);
					if (EXPECTED(retval)) {
						uintptr_t idx = (char*)retval - (char*)zobj->properties->arData;
						CACHE_PTR_EX(cache_slot + 1, (void*)CREX_ENCODE_DYN_PROP_OFFSET(idx));
						if (0 || ((IS_TMP_VAR|IS_VAR) & (IS_TMP_VAR|IS_VAR)) != 0) {
							goto fetch_obj_r_copy;
						} else {
							goto fetch_obj_r_fast_copy;
						}
					}
				}
			}
			name = C_STR_P(_get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC));
		} else {
			name = zval_try_get_tmp_string(_get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC), &tmp_name);
			if (UNEXPECTED(!name)) {
				ZVAL_UNDEF(EX_VAR(opline->result.var));
				break;
			}
		}

#if CREX_DEBUG
		/* For non-standard object handlers, verify a declared property type in debug builds.
		 * Fetch prop_info before calling read_property(), as it may deallocate the object. */
		crex_property_info *prop_info = NULL;
		if (zobj->handlers->read_property != crex_std_read_property) {
			prop_info = crex_get_property_info(zobj->ce, name, /* silent */ true);
		}
#endif
		retval = zobj->handlers->read_property(zobj, name, BP_VAR_R, cache_slot, EX_VAR(opline->result.var));
#if CREX_DEBUG
		if (!EG(exception) && prop_info && prop_info != CREX_WRONG_PROPERTY_INFO
				&& CREX_TYPE_IS_SET(prop_info->type)) {
			ZVAL_OPT_DEREF(retval);
			crex_verify_property_type(prop_info, retval, /* strict */ true);
		}
#endif

		if (IS_CV != IS_CONST) {
			crex_tmp_string_release(tmp_name);
		}

		if (retval != EX_VAR(opline->result.var)) {
fetch_obj_r_copy:
			ZVAL_COPY_DEREF(EX_VAR(opline->result.var), retval);
		} else if (UNEXPECTED(C_ISREF_P(retval))) {
			crex_unwrap_reference(retval);
		}
	} while (0);

fetch_obj_r_finish:

	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FETCH_OBJ_IS_SPEC_TMPVAR_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;
	void **cache_slot = NULL;

	SAVE_OPLINE();
	container = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);

	if ((IS_TMP_VAR|IS_VAR) == IS_CONST ||
	    ((IS_TMP_VAR|IS_VAR) != IS_UNUSED && UNEXPECTED(C_TYPE_P(container) != IS_OBJECT))) {
		do {
			if (((IS_TMP_VAR|IS_VAR) & (IS_VAR|IS_CV)) && C_ISREF_P(container)) {
				container = C_REFVAL_P(container);
				if (EXPECTED(C_TYPE_P(container) == IS_OBJECT)) {
					break;
				}
			}
			if (IS_CV == IS_CV && C_TYPE_P(EX_VAR(opline->op2.var)) == IS_UNDEF) {
				ZVAL_UNDEFINED_OP2();
			}
			ZVAL_NULL(EX_VAR(opline->result.var));
			goto fetch_obj_is_finish;
		} while (0);
	}

	/* here we are sure we are dealing with an object */
	do {
		crex_object *zobj = C_OBJ_P(container);
		crex_string *name, *tmp_name;
		zval *retval;

		if (IS_CV == IS_CONST) {
			cache_slot = CACHE_ADDR(opline->extended_value);

			if (EXPECTED(zobj->ce == CACHED_PTR_EX(cache_slot))) {
				uintptr_t prop_offset = (uintptr_t)CACHED_PTR_EX(cache_slot + 1);

				if (EXPECTED(IS_VALID_PROPERTY_OFFSET(prop_offset))) {
					retval = OBJ_PROP(zobj, prop_offset);
					if (EXPECTED(C_TYPE_P(retval) != IS_UNDEF)) {
						if (0 || ((IS_TMP_VAR|IS_VAR) & (IS_TMP_VAR|IS_VAR)) != 0) {
							goto fetch_obj_is_copy;
						} else {
fetch_obj_is_fast_copy:
							ZVAL_COPY_DEREF(EX_VAR(opline->result.var), retval);
							CREX_VM_NEXT_OPCODE();
						}
					}
				} else if (EXPECTED(zobj->properties != NULL)) {
					name = C_STR_P(_get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC));
					if (!IS_UNKNOWN_DYNAMIC_PROPERTY_OFFSET(prop_offset)) {
						uintptr_t idx = CREX_DECODE_DYN_PROP_OFFSET(prop_offset);

						if (EXPECTED(idx < zobj->properties->nNumUsed * sizeof(Bucket))) {
							Bucket *p = (Bucket*)((char*)zobj->properties->arData + idx);

							if (EXPECTED(p->key == name) ||
							    (EXPECTED(p->h == ZSTR_H(name)) &&
							     EXPECTED(p->key != NULL) &&
							     EXPECTED(crex_string_equal_content(p->key, name)))) {
								retval = &p->val;
								if (0 || ((IS_TMP_VAR|IS_VAR) & (IS_TMP_VAR|IS_VAR)) != 0) {
									goto fetch_obj_is_copy;
								} else {
									goto fetch_obj_is_fast_copy;
								}
							}
						}
						CACHE_PTR_EX(cache_slot + 1, (void*)CREX_DYNAMIC_PROPERTY_OFFSET);
					}
					retval = crex_hash_find_known_hash(zobj->properties, name);
					if (EXPECTED(retval)) {
						uintptr_t idx = (char*)retval - (char*)zobj->properties->arData;
						CACHE_PTR_EX(cache_slot + 1, (void*)CREX_ENCODE_DYN_PROP_OFFSET(idx));
						if (0 || ((IS_TMP_VAR|IS_VAR) & (IS_TMP_VAR|IS_VAR)) != 0) {
							goto fetch_obj_is_copy;
						} else {
							goto fetch_obj_is_fast_copy;
						}
					}
				}
			}
			name = C_STR_P(_get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC));
		} else {
			name = zval_try_get_tmp_string(_get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC), &tmp_name);
			if (UNEXPECTED(!name)) {
				ZVAL_UNDEF(EX_VAR(opline->result.var));
				break;
			}
		}

		retval = zobj->handlers->read_property(zobj, name, BP_VAR_IS, cache_slot, EX_VAR(opline->result.var));

		if (IS_CV != IS_CONST) {
			crex_tmp_string_release(tmp_name);
		}

		if (retval != EX_VAR(opline->result.var)) {
fetch_obj_is_copy:
			ZVAL_COPY_DEREF(EX_VAR(opline->result.var), retval);
		} else if (UNEXPECTED(C_ISREF_P(retval))) {
			crex_unwrap_reference(retval);
		}
	} while (0);

fetch_obj_is_finish:

	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FAST_CONCAT_SPEC_TMPVAR_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	crex_string *op1_str, *op2_str, *str;


	op1 = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	op2 = EX_VAR(opline->op2.var);
	if (((IS_TMP_VAR|IS_VAR) == IS_CONST || EXPECTED(C_TYPE_P(op1) == IS_STRING)) &&
	    (IS_CV == IS_CONST || EXPECTED(C_TYPE_P(op2) == IS_STRING))) {
		crex_string *op1_str = C_STR_P(op1);
		crex_string *op2_str = C_STR_P(op2);
		crex_string *str;
		uint32_t flags = ZSTR_GET_COPYABLE_CONCAT_PROPERTIES_BOTH(op1_str, op2_str);

		if ((IS_TMP_VAR|IS_VAR) != IS_CONST && UNEXPECTED(ZSTR_LEN(op1_str) == 0)) {
			if (IS_CV == IS_CONST || IS_CV == IS_CV) {
				ZVAL_STR_COPY(EX_VAR(opline->result.var), op2_str);
			} else {
				ZVAL_STR(EX_VAR(opline->result.var), op2_str);
			}
			if ((IS_TMP_VAR|IS_VAR) & (IS_TMP_VAR|IS_VAR)) {
				crex_string_release_ex(op1_str, 0);
			}
		} else if (IS_CV != IS_CONST && UNEXPECTED(ZSTR_LEN(op2_str) == 0)) {
			if ((IS_TMP_VAR|IS_VAR) == IS_CONST || (IS_TMP_VAR|IS_VAR) == IS_CV) {
				ZVAL_STR_COPY(EX_VAR(opline->result.var), op1_str);
			} else {
				ZVAL_STR(EX_VAR(opline->result.var), op1_str);
			}
			if (IS_CV & (IS_TMP_VAR|IS_VAR)) {
				crex_string_release_ex(op2_str, 0);
			}
		} else if ((IS_TMP_VAR|IS_VAR) != IS_CONST && (IS_TMP_VAR|IS_VAR) != IS_CV &&
		    !ZSTR_IS_INTERNED(op1_str) && GC_REFCOUNT(op1_str) == 1) {
			size_t len = ZSTR_LEN(op1_str);

			str = crex_string_extend(op1_str, len + ZSTR_LEN(op2_str), 0);
			memcpy(ZSTR_VAL(str) + len, ZSTR_VAL(op2_str), ZSTR_LEN(op2_str)+1);
			GC_ADD_FLAGS(str, flags);
			ZVAL_NEW_STR(EX_VAR(opline->result.var), str);
			if (IS_CV & (IS_TMP_VAR|IS_VAR)) {
				crex_string_release_ex(op2_str, 0);
			}
		} else {
			str = crex_string_alloc(ZSTR_LEN(op1_str) + ZSTR_LEN(op2_str), 0);
			memcpy(ZSTR_VAL(str), ZSTR_VAL(op1_str), ZSTR_LEN(op1_str));
			memcpy(ZSTR_VAL(str) + ZSTR_LEN(op1_str), ZSTR_VAL(op2_str), ZSTR_LEN(op2_str)+1);
			GC_ADD_FLAGS(str, flags);
			ZVAL_NEW_STR(EX_VAR(opline->result.var), str);
			if ((IS_TMP_VAR|IS_VAR) & (IS_TMP_VAR|IS_VAR)) {
				crex_string_release_ex(op1_str, 0);
			}
			if (IS_CV & (IS_TMP_VAR|IS_VAR)) {
				crex_string_release_ex(op2_str, 0);
			}
		}
		CREX_VM_NEXT_OPCODE();
	}

	SAVE_OPLINE();
	if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
		op1_str = C_STR_P(op1);
	} else if (EXPECTED(C_TYPE_P(op1) == IS_STRING)) {
		op1_str = crex_string_copy(C_STR_P(op1));
	} else {
		if ((IS_TMP_VAR|IS_VAR) == IS_CV && UNEXPECTED(C_TYPE_P(op1) == IS_UNDEF)) {
			ZVAL_UNDEFINED_OP1();
		}
		op1_str = zval_get_string_func(op1);
	}
	if (IS_CV == IS_CONST) {
		op2_str = C_STR_P(op2);
	} else if (EXPECTED(C_TYPE_P(op2) == IS_STRING)) {
		op2_str = crex_string_copy(C_STR_P(op2));
	} else {
		if (IS_CV == IS_CV && UNEXPECTED(C_TYPE_P(op2) == IS_UNDEF)) {
			ZVAL_UNDEFINED_OP2();
		}
		op2_str = zval_get_string_func(op2);
	}
	do {
		if ((IS_TMP_VAR|IS_VAR) != IS_CONST) {
			if (UNEXPECTED(ZSTR_LEN(op1_str) == 0)) {
				if (IS_CV == IS_CONST) {
					if (UNEXPECTED(C_REFCOUNTED_P(op2))) {
						GC_ADDREF(op2_str);
					}
				}
				ZVAL_STR(EX_VAR(opline->result.var), op2_str);
				crex_string_release_ex(op1_str, 0);
				break;
			}
		}
		if (IS_CV != IS_CONST) {
			if (UNEXPECTED(ZSTR_LEN(op2_str) == 0)) {
				if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
					if (UNEXPECTED(C_REFCOUNTED_P(op1))) {
						GC_ADDREF(op1_str);
					}
				}
				ZVAL_STR(EX_VAR(opline->result.var), op1_str);
				crex_string_release_ex(op2_str, 0);
				break;
			}
		}
		str = crex_string_alloc(ZSTR_LEN(op1_str) + ZSTR_LEN(op2_str), 0);
		memcpy(ZSTR_VAL(str), ZSTR_VAL(op1_str), ZSTR_LEN(op1_str));
		memcpy(ZSTR_VAL(str) + ZSTR_LEN(op1_str), ZSTR_VAL(op2_str), ZSTR_LEN(op2_str)+1);

		ZSTR_COPY_CONCAT_PROPERTIES_BOTH(str, op1_str, op2_str);
		ZVAL_NEW_STR(EX_VAR(opline->result.var), str);
		if ((IS_TMP_VAR|IS_VAR) != IS_CONST) {
			crex_string_release_ex(op1_str, 0);
		}
		if (IS_CV != IS_CONST) {
			crex_string_release_ex(op2_str, 0);
		}
	} while (0);
	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));

	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_INIT_METHOD_CALL_SPEC_TMPVAR_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *function_name;
	zval *object;
	crex_function *fbc;
	crex_class_entry *called_scope;
	crex_object *obj;
	crex_execute_data *call;
	uint32_t call_info;

	SAVE_OPLINE();

	object = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);

	if (IS_CV != IS_CONST) {
		function_name = EX_VAR(opline->op2.var);
	}

	if (IS_CV != IS_CONST &&
	    UNEXPECTED(C_TYPE_P(function_name) != IS_STRING)) {
		do {
			if ((IS_CV & (IS_VAR|IS_CV)) && C_ISREF_P(function_name)) {
				function_name = C_REFVAL_P(function_name);
				if (EXPECTED(C_TYPE_P(function_name) == IS_STRING)) {
					break;
				}
			} else if (IS_CV == IS_CV && UNEXPECTED(C_TYPE_P(function_name) == IS_UNDEF)) {
				ZVAL_UNDEFINED_OP2();
				if (UNEXPECTED(EG(exception) != NULL)) {
					zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
					HANDLE_EXCEPTION();
				}
			}
			crex_throw_error(NULL, "Method name must be a string");

			zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
			HANDLE_EXCEPTION();
		} while (0);
	}

	if ((IS_TMP_VAR|IS_VAR) == IS_UNUSED) {
		obj = C_OBJ_P(object);
	} else {
		do {
			if ((IS_TMP_VAR|IS_VAR) != IS_CONST && EXPECTED(C_TYPE_P(object) == IS_OBJECT)) {
				obj = C_OBJ_P(object);
			} else {
				if (((IS_TMP_VAR|IS_VAR) & (IS_VAR|IS_CV)) && EXPECTED(C_ISREF_P(object))) {
					crex_reference *ref = C_REF_P(object);

					object = &ref->val;
					if (EXPECTED(C_TYPE_P(object) == IS_OBJECT)) {
						obj = C_OBJ_P(object);
						if ((IS_TMP_VAR|IS_VAR) & IS_VAR) {
							if (UNEXPECTED(GC_DELREF(ref) == 0)) {
								efree_size(ref, sizeof(crex_reference));
							} else {
								C_ADDREF_P(object);
							}
						}
						break;
					}
				}
				if ((IS_TMP_VAR|IS_VAR) == IS_CV && UNEXPECTED(C_TYPE_P(object) == IS_UNDEF)) {
					object = ZVAL_UNDEFINED_OP1();
					if (UNEXPECTED(EG(exception) != NULL)) {
						if (IS_CV != IS_CONST) {

						}
						HANDLE_EXCEPTION();
					}
				}
				if (IS_CV == IS_CONST) {
					function_name = EX_VAR(opline->op2.var);
				}
				crex_invalid_method_call(object, function_name);

				zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
				HANDLE_EXCEPTION();
			}
		} while (0);
	}

	called_scope = obj->ce;

	if (IS_CV == IS_CONST &&
	    EXPECTED(CACHED_PTR(opline->result.num) == called_scope)) {
		fbc = CACHED_PTR(opline->result.num + sizeof(void*));
	} else {
		crex_object *orig_obj = obj;

		if (IS_CV == IS_CONST) {
			function_name = EX_VAR(opline->op2.var);
		}

		/* First, locate the function. */
		fbc = obj->handlers->get_method(&obj, C_STR_P(function_name), ((IS_CV == IS_CONST) ? (RT_CONSTANT(opline, opline->op2) + 1) : NULL));
		if (UNEXPECTED(fbc == NULL)) {
			if (EXPECTED(!EG(exception))) {
				crex_undefined_method(obj->ce, C_STR_P(function_name));
			}

			if (((IS_TMP_VAR|IS_VAR) & (IS_VAR|IS_TMP_VAR)) && GC_DELREF(orig_obj) == 0) {
				crex_objects_store_del(orig_obj);
			}
			HANDLE_EXCEPTION();
		}
		if (IS_CV == IS_CONST &&
		    EXPECTED(!(fbc->common.fn_flags & (CREX_ACC_CALL_VIA_TRAMPOLINE|CREX_ACC_NEVER_CACHE))) &&
		    EXPECTED(obj == orig_obj)) {
			CACHE_POLYMORPHIC_PTR(opline->result.num, called_scope, fbc);
		}
		if (((IS_TMP_VAR|IS_VAR) & (IS_VAR|IS_TMP_VAR)) && UNEXPECTED(obj != orig_obj)) {
			GC_ADDREF(obj); /* For $this pointer */
			if (GC_DELREF(orig_obj) == 0) {
				crex_objects_store_del(orig_obj);
			}
		}
		if (EXPECTED(fbc->type == CREX_USER_FUNCTION) && UNEXPECTED(!RUN_TIME_CACHE(&fbc->op_array))) {
			init_func_run_time_cache(&fbc->op_array);
		}
	}

	if (IS_CV != IS_CONST) {

	}

	call_info = CREX_CALL_NESTED_FUNCTION | CREX_CALL_HAS_THIS;
	if (UNEXPECTED((fbc->common.fn_flags & CREX_ACC_STATIC) != 0)) {
		if (((IS_TMP_VAR|IS_VAR) & (IS_VAR|IS_TMP_VAR)) && GC_DELREF(obj) == 0) {
			crex_objects_store_del(obj);
			if (UNEXPECTED(EG(exception))) {
				HANDLE_EXCEPTION();
			}
		}
		/* call static method */
		obj = (crex_object*)called_scope;
		call_info = CREX_CALL_NESTED_FUNCTION;
	} else if ((IS_TMP_VAR|IS_VAR) & (IS_VAR|IS_TMP_VAR|IS_CV)) {
		if ((IS_TMP_VAR|IS_VAR) == IS_CV) {
			GC_ADDREF(obj); /* For $this pointer */
		}
		/* CV may be changed indirectly (e.g. when it's a reference) */
		call_info = CREX_CALL_NESTED_FUNCTION | CREX_CALL_HAS_THIS | CREX_CALL_RELEASE_THIS;
	}

	call = crex_vm_stack_push_call_frame(call_info,
		fbc, opline->extended_value, obj);
	call->prev_execute_data = EX(call);
	EX(call) = call;

	CREX_VM_NEXT_OPCODE();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_CASE_SPEC_TMPVAR_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	double d1, d2;

	op1 = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	op2 = EX_VAR(opline->op2.var);
	if (EXPECTED(C_TYPE_P(op1) == IS_LONG)) {
		if (EXPECTED(C_TYPE_P(op2) == IS_LONG)) {
			if (EXPECTED(C_LVAL_P(op1) == C_LVAL_P(op2))) {
case_true:
				CREX_VM_SMART_BRANCH_TRUE();
			} else {
case_false:
				CREX_VM_SMART_BRANCH_FALSE();
			}
		} else if (EXPECTED(C_TYPE_P(op2) == IS_DOUBLE)) {
			d1 = (double)C_LVAL_P(op1);
			d2 = C_DVAL_P(op2);
			goto case_double;
		}
	} else if (EXPECTED(C_TYPE_P(op1) == IS_DOUBLE)) {
		if (EXPECTED(C_TYPE_P(op2) == IS_DOUBLE)) {
			d1 = C_DVAL_P(op1);
			d2 = C_DVAL_P(op2);
case_double:
			if (d1 == d2) {
				goto case_true;
			} else {
				goto case_false;
			}
		} else if (EXPECTED(C_TYPE_P(op2) == IS_LONG)) {
			d1 = C_DVAL_P(op1);
			d2 = (double)C_LVAL_P(op2);
			goto case_double;
		}
	} else if (EXPECTED(C_TYPE_P(op1) == IS_STRING)) {
		if (EXPECTED(C_TYPE_P(op2) == IS_STRING)) {
			bool result = crex_fast_equal_strings(C_STR_P(op1), C_STR_P(op2));

			if (result) {
				goto case_true;
			} else {
				goto case_false;
			}
		}
	}
	CREX_VM_TAIL_CALL(crex_case_helper_SPEC(op1, op2 CREX_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ISSET_ISEMPTY_DIM_OBJ_SPEC_TMPVAR_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;
	bool result;
	crex_ulong hval;
	zval *offset;

	SAVE_OPLINE();
	container = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	offset = EX_VAR(opline->op2.var);

	if (EXPECTED(C_TYPE_P(container) == IS_ARRAY)) {
		HashTable *ht;
		zval *value;
		crex_string *str;

isset_dim_obj_array:
		ht = C_ARRVAL_P(container);
isset_again:
		if (EXPECTED(C_TYPE_P(offset) == IS_STRING)) {
			str = C_STR_P(offset);
			if (IS_CV != IS_CONST) {
				if (CREX_HANDLE_NUMERIC(str, hval)) {
					goto num_index_prop;
				}
			}
			value = crex_hash_find_ex(ht, str, IS_CV == IS_CONST);
		} else if (EXPECTED(C_TYPE_P(offset) == IS_LONG)) {
			hval = C_LVAL_P(offset);
num_index_prop:
			value = crex_hash_index_find(ht, hval);
		} else if ((IS_CV & (IS_VAR|IS_CV)) && EXPECTED(C_ISREF_P(offset))) {
			offset = C_REFVAL_P(offset);
			goto isset_again;
		} else {
			value = crex_find_array_dim_slow(ht, offset EXECUTE_DATA_CC);
			if (UNEXPECTED(EG(exception))) {
				result = 0;
				goto isset_dim_obj_exit;
			}
		}

		if (!(opline->extended_value & CREX_ISEMPTY)) {
			/* > IS_NULL means not IS_UNDEF and not IS_NULL */
			result = value != NULL && C_TYPE_P(value) > IS_NULL &&
			    (!C_ISREF_P(value) || C_TYPE_P(C_REFVAL_P(value)) != IS_NULL);

			if ((IS_TMP_VAR|IS_VAR) & (IS_CONST|IS_CV)) {
				/* avoid exception check */

				CREX_VM_SMART_BRANCH(result, 0);
			}
		} else {
			result = (value == NULL || !i_crex_is_true(value));
		}
		goto isset_dim_obj_exit;
	} else if (((IS_TMP_VAR|IS_VAR) & (IS_VAR|IS_CV)) && EXPECTED(C_ISREF_P(container))) {
		container = C_REFVAL_P(container);
		if (EXPECTED(C_TYPE_P(container) == IS_ARRAY)) {
			goto isset_dim_obj_array;
		}
	}

	if (IS_CV == IS_CONST && C_EXTRA_P(offset) == CREX_EXTRA_VALUE) {
		offset++;
	}
	if (!(opline->extended_value & CREX_ISEMPTY)) {
		result = crex_isset_dim_slow(container, offset EXECUTE_DATA_CC);
	} else {
		result = crex_isempty_dim_slow(container, offset EXECUTE_DATA_CC);
	}

isset_dim_obj_exit:

	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	CREX_VM_SMART_BRANCH(result, 1);
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ISSET_ISEMPTY_PROP_OBJ_SPEC_TMPVAR_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;
	int result;
	zval *offset;
	crex_string *name, *tmp_name;

	SAVE_OPLINE();
	container = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	offset = _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC);

	if ((IS_TMP_VAR|IS_VAR) == IS_CONST ||
	    ((IS_TMP_VAR|IS_VAR) != IS_UNUSED && UNEXPECTED(C_TYPE_P(container) != IS_OBJECT))) {
		if (((IS_TMP_VAR|IS_VAR) & (IS_VAR|IS_CV)) && C_ISREF_P(container)) {
			container = C_REFVAL_P(container);
			if (UNEXPECTED(C_TYPE_P(container) != IS_OBJECT)) {
				result = (opline->extended_value & CREX_ISEMPTY);
				goto isset_object_finish;
			}
		} else {
			result = (opline->extended_value & CREX_ISEMPTY);
			goto isset_object_finish;
		}
	}

	if (IS_CV == IS_CONST) {
		name = C_STR_P(offset);
	} else {
		name = zval_try_get_tmp_string(offset, &tmp_name);
		if (UNEXPECTED(!name)) {
			result = 0;
			goto isset_object_finish;
		}
	}

	result =
		(opline->extended_value & CREX_ISEMPTY) ^
		C_OBJ_HT_P(container)->has_property(C_OBJ_P(container), name, (opline->extended_value & CREX_ISEMPTY), ((IS_CV == IS_CONST) ? CACHE_ADDR(opline->extended_value & ~CREX_ISEMPTY) : NULL));

	if (IS_CV != IS_CONST) {
		crex_tmp_string_release(tmp_name);
	}

isset_object_finish:

	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	CREX_VM_SMART_BRANCH(result, 1);
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ARRAY_KEY_EXISTS_SPEC_TMPVAR_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *key, *subject;
	HashTable *ht;
	bool result;

	SAVE_OPLINE();

	key = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	subject = EX_VAR(opline->op2.var);

	if (EXPECTED(C_TYPE_P(subject) == IS_ARRAY)) {
array_key_exists_array:
		ht = C_ARRVAL_P(subject);
		result = crex_array_key_exists_fast(ht, key OPLINE_CC EXECUTE_DATA_CC);
	} else {
		if ((IS_CV & (IS_VAR|IS_CV)) && EXPECTED(C_ISREF_P(subject))) {
			subject = C_REFVAL_P(subject);
			if (EXPECTED(C_TYPE_P(subject) == IS_ARRAY)) {
				goto array_key_exists_array;
			}
		}
		crex_array_key_exists_error(subject, key OPLINE_CC EXECUTE_DATA_CC);
		result = 0;
	}

	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	CREX_VM_SMART_BRANCH(result, 1);
}

/* No specialization for op_types (CONST|TMPVAR|UNUSED|CV, ANY) */
static CREX_VM_HOT CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_RETURN_SPEC_TMP_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *retval_ptr;
	zval *return_value;

	retval_ptr = _get_zval_ptr_tmp(opline->op1.var EXECUTE_DATA_CC);
	return_value = EX(return_value);

	if (IS_TMP_VAR == IS_CV && UNEXPECTED(C_TYPE_INFO_P(retval_ptr) == IS_UNDEF)) {
		SAVE_OPLINE();
		retval_ptr = ZVAL_UNDEFINED_OP1();
		if (return_value) {
			ZVAL_NULL(return_value);
		}
	} else if (!return_value) {
		if (IS_TMP_VAR & (IS_VAR|IS_TMP_VAR)) {
			if (C_REFCOUNTED_P(retval_ptr) && !C_DELREF_P(retval_ptr)) {
				SAVE_OPLINE();
				rc_dtor_func(C_COUNTED_P(retval_ptr));
			}
		}
	} else {
		if ((IS_TMP_VAR & (IS_CONST|IS_TMP_VAR))) {
			ZVAL_COPY_VALUE(return_value, retval_ptr);
			if (IS_TMP_VAR == IS_CONST) {
				if (UNEXPECTED(C_OPT_REFCOUNTED_P(return_value))) {
					C_ADDREF_P(return_value);
				}
			}
		} else if (IS_TMP_VAR == IS_CV) {
			do {
				if (C_OPT_REFCOUNTED_P(retval_ptr)) {
					if (EXPECTED(!C_OPT_ISREF_P(retval_ptr))) {
						if (EXPECTED(!(EX_CALL_INFO() & (CREX_CALL_CODE|CREX_CALL_OBSERVED)))) {
							crex_refcounted *ref = C_COUNTED_P(retval_ptr);
							ZVAL_COPY_VALUE(return_value, retval_ptr);
							if (GC_MAY_LEAK(ref)) {
								SAVE_OPLINE();
								gc_possible_root(ref);
							}
							ZVAL_NULL(retval_ptr);
							break;
						} else {
							C_ADDREF_P(retval_ptr);
						}
					} else {
						retval_ptr = C_REFVAL_P(retval_ptr);
						if (C_OPT_REFCOUNTED_P(retval_ptr)) {
							C_ADDREF_P(retval_ptr);
						}
					}
				}
				ZVAL_COPY_VALUE(return_value, retval_ptr);
			} while (0);
		} else /* if (IS_TMP_VAR == IS_VAR) */ {
			if (UNEXPECTED(C_ISREF_P(retval_ptr))) {
				crex_refcounted *ref = C_COUNTED_P(retval_ptr);

				retval_ptr = C_REFVAL_P(retval_ptr);
				ZVAL_COPY_VALUE(return_value, retval_ptr);
				if (UNEXPECTED(GC_DELREF(ref) == 0)) {
					efree_size(ref, sizeof(crex_reference));
				} else if (C_OPT_REFCOUNTED_P(retval_ptr)) {
					C_ADDREF_P(retval_ptr);
				}
			} else {
				ZVAL_COPY_VALUE(return_value, retval_ptr);
			}
		}
	}



	CREX_VM_TAIL_CALL(crex_leave_helper_SPEC(CREX_OPCODE_HANDLER_ARGS_PASSTHRU));
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_RETURN_BY_REF_SPEC_TMP_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *retval_ptr;
	zval *return_value;

	SAVE_OPLINE();

	return_value = EX(return_value);

	do {
		if ((IS_TMP_VAR & (IS_CONST|IS_TMP_VAR)) ||
		    (IS_TMP_VAR == IS_VAR && opline->extended_value == CREX_RETURNS_VALUE)) {
			/* Not supposed to happen, but we'll allow it */
			crex_error(E_NOTICE, "Only variable references should be returned by reference");

			retval_ptr = _get_zval_ptr_tmp(opline->op1.var EXECUTE_DATA_CC);
			if (!return_value) {
				zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
			} else {
				if (IS_TMP_VAR == IS_VAR && UNEXPECTED(C_ISREF_P(retval_ptr))) {
					ZVAL_COPY_VALUE(return_value, retval_ptr);
					break;
				}

				ZVAL_NEW_REF(return_value, retval_ptr);
				if (IS_TMP_VAR == IS_CONST) {
					C_TRY_ADDREF_P(retval_ptr);
				}
			}
			break;
		}

		retval_ptr = crex_get_bad_ptr();

		if (IS_TMP_VAR == IS_VAR) {
			CREX_ASSERT(retval_ptr != &EG(uninitialized_zval));
			if (opline->extended_value == CREX_RETURNS_FUNCTION && !C_ISREF_P(retval_ptr)) {
				crex_error(E_NOTICE, "Only variable references should be returned by reference");
				if (return_value) {
					ZVAL_NEW_REF(return_value, retval_ptr);
				} else {
					zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
				}
				break;
			}
		}

		if (return_value) {
			if (C_ISREF_P(retval_ptr)) {
				C_ADDREF_P(retval_ptr);
			} else {
				ZVAL_MAKE_REF_EX(retval_ptr, 2);
			}
			ZVAL_REF(return_value, C_REF_P(retval_ptr));
		}

		zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	} while (0);


	CREX_VM_TAIL_CALL(crex_leave_helper_SPEC(CREX_OPCODE_HANDLER_ARGS_PASSTHRU));
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_GENERATOR_RETURN_SPEC_TMP_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *retval;

	crex_generator *generator = crex_get_running_generator(EXECUTE_DATA_C);

	SAVE_OPLINE();
	retval = _get_zval_ptr_tmp(opline->op1.var EXECUTE_DATA_CC);

	/* Copy return value into generator->retval */
	if ((IS_TMP_VAR & (IS_CONST|IS_TMP_VAR))) {
		ZVAL_COPY_VALUE(&generator->retval, retval);
		if (IS_TMP_VAR == IS_CONST) {
			if (UNEXPECTED(C_OPT_REFCOUNTED(generator->retval))) {
				C_ADDREF(generator->retval);
			}
		}
	} else if (IS_TMP_VAR == IS_CV) {
		ZVAL_COPY_DEREF(&generator->retval, retval);
	} else /* if (IS_TMP_VAR == IS_VAR) */ {
		if (UNEXPECTED(C_ISREF_P(retval))) {
			crex_refcounted *ref = C_COUNTED_P(retval);

			retval = C_REFVAL_P(retval);
			ZVAL_COPY_VALUE(&generator->retval, retval);
			if (UNEXPECTED(GC_DELREF(ref) == 0)) {
				efree_size(ref, sizeof(crex_reference));
			} else if (C_OPT_REFCOUNTED_P(retval)) {
				C_ADDREF_P(retval);
			}
		} else {
			ZVAL_COPY_VALUE(&generator->retval, retval);
		}
	}

	EG(current_execute_data) = EX(prev_execute_data);

	/* Close the generator to free up resources */
	crex_generator_close(generator, 1);

	/* Pass execution back to handling code */
	CREX_VM_RETURN();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_SEND_USER_SPEC_TMP_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *arg, *param;

	SAVE_OPLINE();

	arg = _get_zval_ptr_tmp(opline->op1.var EXECUTE_DATA_CC);
	param = CREX_CALL_VAR(EX(call), opline->result.var);
	if (UNEXPECTED(ARG_MUST_BE_SENT_BY_REF(EX(call)->func, opline->op2.num))) {
		crex_param_must_be_ref(EX(call)->func, opline->op2.num);
		C_TRY_ADDREF_P(arg);
		ZVAL_NEW_REF(param, arg);
	} else {
		ZVAL_COPY(param, arg);
	}

	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_CAST_SPEC_TMP_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *expr;
	zval *result = EX_VAR(opline->result.var);
	HashTable *ht;

	SAVE_OPLINE();
	expr = _get_zval_ptr_tmp(opline->op1.var EXECUTE_DATA_CC);

	switch (opline->extended_value) {
		case IS_LONG:
			ZVAL_LONG(result, zval_get_long(expr));
			break;
		case IS_DOUBLE:
			ZVAL_DOUBLE(result, zval_get_double(expr));
			break;
		case IS_STRING:
			ZVAL_STR(result, zval_get_string(expr));
			break;
		default:
			CREX_ASSERT(opline->extended_value != _IS_BOOL && "Must use CREX_BOOL instead");
			if (IS_TMP_VAR & (IS_VAR|IS_CV)) {
				ZVAL_DEREF(expr);
			}
			/* If value is already of correct type, return it directly */
			if (C_TYPE_P(expr) == opline->extended_value) {
				ZVAL_COPY_VALUE(result, expr);
				if (IS_TMP_VAR == IS_CONST) {
					if (UNEXPECTED(C_OPT_REFCOUNTED_P(result))) C_ADDREF_P(result);
				} else if (IS_TMP_VAR != IS_TMP_VAR) {
					if (C_OPT_REFCOUNTED_P(result)) C_ADDREF_P(result);
				}

				CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
			}

			if (opline->extended_value == IS_ARRAY) {
				if (IS_TMP_VAR == IS_CONST || C_TYPE_P(expr) != IS_OBJECT || C_OBJCE_P(expr) == crex_ce_closure) {
					if (C_TYPE_P(expr) != IS_NULL) {
						ZVAL_ARR(result, crex_new_array(1));
						expr = crex_hash_index_add_new(C_ARRVAL_P(result), 0, expr);
						if (IS_TMP_VAR == IS_CONST) {
							if (UNEXPECTED(C_OPT_REFCOUNTED_P(expr))) C_ADDREF_P(expr);
						} else {
							if (C_OPT_REFCOUNTED_P(expr)) C_ADDREF_P(expr);
						}
					} else {
						ZVAL_EMPTY_ARRAY(result);
					}
				} else if (C_OBJ_P(expr)->properties == NULL
				 && C_OBJ_HT_P(expr)->get_properties_for == NULL
				 && C_OBJ_HT_P(expr)->get_properties == crex_std_get_properties) {
					/* Optimized version without rebuilding properties HashTable */
					ZVAL_ARR(result, crex_std_build_object_properties_array(C_OBJ_P(expr)));
				} else {
					HashTable *obj_ht = crex_get_properties_for(expr, CREX_PROP_PURPOSE_ARRAY_CAST);
					if (obj_ht) {
						/* fast copy */
						ZVAL_ARR(result, crex_proptable_to_symtable(obj_ht,
							(C_OBJCE_P(expr)->default_properties_count ||
							 C_OBJ_P(expr)->handlers != &std_object_handlers ||
							 GC_IS_RECURSIVE(obj_ht))));
						crex_release_properties(obj_ht);
					} else {
						ZVAL_EMPTY_ARRAY(result);
					}
				}
			} else {
				CREX_ASSERT(opline->extended_value == IS_OBJECT);
				ZVAL_OBJ(result, crex_objects_new(crex_standard_class_def));
				if (C_TYPE_P(expr) == IS_ARRAY) {
					ht = crex_symtable_to_proptable(C_ARR_P(expr));
					if (GC_FLAGS(ht) & IS_ARRAY_IMMUTABLE) {
						/* TODO: try not to duplicate immutable arrays as well ??? */
						ht = crex_array_dup(ht);
					}
					C_OBJ_P(result)->properties = ht;
				} else if (C_TYPE_P(expr) != IS_NULL) {
					C_OBJ_P(result)->properties = ht = crex_new_array(1);
					expr = crex_hash_add_new(ht, ZSTR_KNOWN(CREX_STR_SCALAR), expr);
					if (IS_TMP_VAR == IS_CONST) {
						if (UNEXPECTED(C_OPT_REFCOUNTED_P(expr))) C_ADDREF_P(expr);
					} else {
						if (C_OPT_REFCOUNTED_P(expr)) C_ADDREF_P(expr);
					}
				}
			}
	}

	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FE_RESET_R_SPEC_TMP_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *array_ptr, *result;

	SAVE_OPLINE();

	array_ptr = _get_zval_ptr_tmp(opline->op1.var EXECUTE_DATA_CC);
	if (EXPECTED(C_TYPE_P(array_ptr) == IS_ARRAY)) {
		result = EX_VAR(opline->result.var);
		ZVAL_COPY_VALUE(result, array_ptr);
		if (IS_TMP_VAR != IS_TMP_VAR && C_OPT_REFCOUNTED_P(result)) {
			C_ADDREF_P(array_ptr);
		}
		C_FE_POS_P(result) = 0;

		CREX_VM_NEXT_OPCODE();
	} else if (IS_TMP_VAR != IS_CONST && EXPECTED(C_TYPE_P(array_ptr) == IS_OBJECT)) {
		crex_object *zobj = C_OBJ_P(array_ptr);
		if (!zobj->ce->get_iterator) {
			HashTable *properties = zobj->properties;
			if (properties) {
				if (UNEXPECTED(GC_REFCOUNT(properties) > 1)) {
					if (EXPECTED(!(GC_FLAGS(properties) & IS_ARRAY_IMMUTABLE))) {
						GC_DELREF(properties);
					}
					properties = zobj->properties = crex_array_dup(properties);
				}
			} else {
				properties = zobj->handlers->get_properties(zobj);
			}

			result = EX_VAR(opline->result.var);
			ZVAL_COPY_VALUE(result, array_ptr);
			if (IS_TMP_VAR != IS_TMP_VAR) {
				C_ADDREF_P(array_ptr);
			}

			if (crex_hash_num_elements(properties) == 0) {
				C_FE_ITER_P(result) = (uint32_t) -1;

				CREX_VM_JMP(OP_JMP_ADDR(opline, opline->op2));
			}

			C_FE_ITER_P(result) = crex_hash_iterator_add(properties, 0);

			CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
		} else {
			bool is_empty = crex_fe_reset_iterator(array_ptr, 0 OPLINE_CC EXECUTE_DATA_CC);

			zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
			if (UNEXPECTED(EG(exception))) {
				HANDLE_EXCEPTION();
			} else if (is_empty) {
				CREX_VM_JMP_EX(OP_JMP_ADDR(opline, opline->op2), 0);
			} else {
				CREX_VM_NEXT_OPCODE();
			}
		}
	} else {
		crex_error(E_WARNING, "foreach() argument must be of type array|object, %s given", crex_zval_value_name(array_ptr));
		ZVAL_UNDEF(EX_VAR(opline->result.var));
		C_FE_ITER_P(EX_VAR(opline->result.var)) = (uint32_t)-1;
		zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
		CREX_VM_JMP(OP_JMP_ADDR(opline, opline->op2));
	}
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FE_RESET_RW_SPEC_TMP_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *array_ptr, *array_ref;

	SAVE_OPLINE();

	if (IS_TMP_VAR == IS_VAR || IS_TMP_VAR == IS_CV) {
		array_ref = array_ptr = crex_get_bad_ptr();
		if (C_ISREF_P(array_ref)) {
			array_ptr = C_REFVAL_P(array_ref);
		}
	} else {
		array_ref = array_ptr = _get_zval_ptr_tmp(opline->op1.var EXECUTE_DATA_CC);
	}

	if (EXPECTED(C_TYPE_P(array_ptr) == IS_ARRAY)) {
		if (IS_TMP_VAR == IS_VAR || IS_TMP_VAR == IS_CV) {
			if (array_ptr == array_ref) {
				ZVAL_NEW_REF(array_ref, array_ref);
				array_ptr = C_REFVAL_P(array_ref);
			}
			C_ADDREF_P(array_ref);
			ZVAL_COPY_VALUE(EX_VAR(opline->result.var), array_ref);
		} else {
			array_ref = EX_VAR(opline->result.var);
			ZVAL_NEW_REF(array_ref, array_ptr);
			array_ptr = C_REFVAL_P(array_ref);
		}
		if (IS_TMP_VAR == IS_CONST) {
			ZVAL_ARR(array_ptr, crex_array_dup(C_ARRVAL_P(array_ptr)));
		} else {
			SEPARATE_ARRAY(array_ptr);
		}
		C_FE_ITER_P(EX_VAR(opline->result.var)) = crex_hash_iterator_add(C_ARRVAL_P(array_ptr), 0);

		CREX_VM_NEXT_OPCODE();
	} else if (IS_TMP_VAR != IS_CONST && EXPECTED(C_TYPE_P(array_ptr) == IS_OBJECT)) {
		if (!C_OBJCE_P(array_ptr)->get_iterator) {
			HashTable *properties;
			if (IS_TMP_VAR == IS_VAR || IS_TMP_VAR == IS_CV) {
				if (array_ptr == array_ref) {
					ZVAL_NEW_REF(array_ref, array_ref);
					array_ptr = C_REFVAL_P(array_ref);
				}
				C_ADDREF_P(array_ref);
				ZVAL_COPY_VALUE(EX_VAR(opline->result.var), array_ref);
			} else {
				array_ptr = EX_VAR(opline->result.var);
				ZVAL_COPY_VALUE(array_ptr, array_ref);
			}
			if (C_OBJ_P(array_ptr)->properties
			 && UNEXPECTED(GC_REFCOUNT(C_OBJ_P(array_ptr)->properties) > 1)) {
				if (EXPECTED(!(GC_FLAGS(C_OBJ_P(array_ptr)->properties) & IS_ARRAY_IMMUTABLE))) {
					GC_DELREF(C_OBJ_P(array_ptr)->properties);
				}
				C_OBJ_P(array_ptr)->properties = crex_array_dup(C_OBJ_P(array_ptr)->properties);
			}

			properties = C_OBJPROP_P(array_ptr);
			if (crex_hash_num_elements(properties) == 0) {
				C_FE_ITER_P(EX_VAR(opline->result.var)) = (uint32_t) -1;

				CREX_VM_JMP(OP_JMP_ADDR(opline, opline->op2));
			}

			C_FE_ITER_P(EX_VAR(opline->result.var)) = crex_hash_iterator_add(properties, 0);

			CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
		} else {
			bool is_empty = crex_fe_reset_iterator(array_ptr, 1 OPLINE_CC EXECUTE_DATA_CC);
			zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
			if (UNEXPECTED(EG(exception))) {
				HANDLE_EXCEPTION();
			} else if (is_empty) {
				CREX_VM_JMP_EX(OP_JMP_ADDR(opline, opline->op2), 0);
			} else {
				CREX_VM_NEXT_OPCODE();
			}
		}
	} else {
		crex_error(E_WARNING, "foreach() argument must be of type array|object, %s given", crex_zval_value_name(array_ptr));
		ZVAL_UNDEF(EX_VAR(opline->result.var));
		C_FE_ITER_P(EX_VAR(opline->result.var)) = (uint32_t)-1;
		zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
		CREX_VM_JMP(OP_JMP_ADDR(opline, opline->op2));
	}
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_END_SILENCE_SPEC_TMP_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (E_HAS_ONLY_FATAL_ERRORS(EG(error_reporting))
			&& !E_HAS_ONLY_FATAL_ERRORS(C_LVAL_P(EX_VAR(opline->op1.var)))) {
		EG(error_reporting) = C_LVAL_P(EX_VAR(opline->op1.var));
	}
	CREX_VM_NEXT_OPCODE();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_JMP_SET_SPEC_TMP_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *value;
	crex_reference *ref = NULL;
	bool ret;

	SAVE_OPLINE();
	value = _get_zval_ptr_tmp(opline->op1.var EXECUTE_DATA_CC);

	if ((IS_TMP_VAR == IS_VAR || IS_TMP_VAR == IS_CV) && C_ISREF_P(value)) {
		if (IS_TMP_VAR == IS_VAR) {
			ref = C_REF_P(value);
		}
		value = C_REFVAL_P(value);
	}

	ret = i_crex_is_true(value);

	if (UNEXPECTED(EG(exception))) {
		zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
		ZVAL_UNDEF(EX_VAR(opline->result.var));
		HANDLE_EXCEPTION();
	}

	if (ret) {
		zval *result = EX_VAR(opline->result.var);

		ZVAL_COPY_VALUE(result, value);
		if (IS_TMP_VAR == IS_CONST) {
			if (UNEXPECTED(C_OPT_REFCOUNTED_P(result))) C_ADDREF_P(result);
		} else if (IS_TMP_VAR == IS_CV) {
			if (C_OPT_REFCOUNTED_P(result)) C_ADDREF_P(result);
		} else if (IS_TMP_VAR == IS_VAR && ref) {
			if (UNEXPECTED(GC_DELREF(ref) == 0)) {
				efree_size(ref, sizeof(crex_reference));
			} else if (C_OPT_REFCOUNTED_P(result)) {
				C_ADDREF_P(result);
			}
		}
		CREX_VM_JMP_EX(OP_JMP_ADDR(opline, opline->op2), 0);
	}

	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	CREX_VM_NEXT_OPCODE();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_COALESCE_SPEC_TMP_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *value;
	crex_reference *ref = NULL;

	SAVE_OPLINE();
	value = _get_zval_ptr_tmp(opline->op1.var EXECUTE_DATA_CC);

	if ((IS_TMP_VAR & (IS_VAR|IS_CV)) && C_ISREF_P(value)) {
		if (IS_TMP_VAR & IS_VAR) {
			ref = C_REF_P(value);
		}
		value = C_REFVAL_P(value);
	}

	if (C_TYPE_P(value) > IS_NULL) {
		zval *result = EX_VAR(opline->result.var);
		ZVAL_COPY_VALUE(result, value);
		if (IS_TMP_VAR == IS_CONST) {
			if (UNEXPECTED(C_OPT_REFCOUNTED_P(result))) C_ADDREF_P(result);
		} else if (IS_TMP_VAR == IS_CV) {
			if (C_OPT_REFCOUNTED_P(result)) C_ADDREF_P(result);
		} else if ((IS_TMP_VAR & IS_VAR) && ref) {
			if (UNEXPECTED(GC_DELREF(ref) == 0)) {
				efree_size(ref, sizeof(crex_reference));
			} else if (C_OPT_REFCOUNTED_P(result)) {
				C_ADDREF_P(result);
			}
		}
		CREX_VM_JMP_EX(OP_JMP_ADDR(opline, opline->op2), 0);
	}

	if ((IS_TMP_VAR & IS_VAR) && ref) {
		if (UNEXPECTED(GC_DELREF(ref) == 0)) {
			efree_size(ref, sizeof(crex_reference));
		}
	}
	CREX_VM_NEXT_OPCODE();
}

static CREX_VM_HOT CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_JMP_NULL_SPEC_TMP_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *val, *result;

	val = _get_zval_ptr_tmp(opline->op1.var EXECUTE_DATA_CC);

	if (C_TYPE_P(val) > IS_NULL) {
		do {
			if ((IS_TMP_VAR == IS_CV || IS_TMP_VAR == IS_VAR) && C_TYPE_P(val) == IS_REFERENCE) {
				val = C_REFVAL_P(val);
				if (C_TYPE_P(val) <= IS_NULL) {
					zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
					break;
				}
			}
			CREX_VM_NEXT_OPCODE();
		} while (0);
	}

	result = EX_VAR(opline->result.var);
	uint32_t short_circuiting_type = opline->extended_value & CREX_SHORT_CIRCUITING_CHAIN_MASK;
	if (EXPECTED(short_circuiting_type == CREX_SHORT_CIRCUITING_CHAIN_EXPR)) {
		ZVAL_NULL(result);
		if (IS_TMP_VAR == IS_CV
			&& UNEXPECTED(C_TYPE_P(val) == IS_UNDEF)
			&& (opline->extended_value & CREX_JMP_NULL_BP_VAR_IS) == 0
		) {
			SAVE_OPLINE();
			ZVAL_UNDEFINED_OP1();
			if (UNEXPECTED(EG(exception) != NULL)) {
				HANDLE_EXCEPTION();
			}
		}
	} else if (short_circuiting_type == CREX_SHORT_CIRCUITING_CHAIN_ISSET) {
		ZVAL_FALSE(result);
	} else {
		CREX_ASSERT(short_circuiting_type == CREX_SHORT_CIRCUITING_CHAIN_EMPTY);
		ZVAL_TRUE(result);
	}

	CREX_VM_JMP_EX(OP_JMP_ADDR(opline, opline->op2), 0);
}

static CREX_VM_HOT CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_QM_ASSIGN_SPEC_TMP_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *value;
	zval *result = EX_VAR(opline->result.var);

	value = _get_zval_ptr_tmp(opline->op1.var EXECUTE_DATA_CC);
	if (IS_TMP_VAR == IS_CV && UNEXPECTED(C_TYPE_P(value) == IS_UNDEF)) {
		SAVE_OPLINE();
		ZVAL_UNDEFINED_OP1();
		ZVAL_NULL(result);
		CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
	}

	if (IS_TMP_VAR == IS_CV) {
		ZVAL_COPY_DEREF(result, value);
	} else if (IS_TMP_VAR == IS_VAR) {
		if (UNEXPECTED(C_ISREF_P(value))) {
			ZVAL_COPY_VALUE(result, C_REFVAL_P(value));
			if (UNEXPECTED(C_DELREF_P(value) == 0)) {
				efree_size(C_REF_P(value), sizeof(crex_reference));
			} else if (C_OPT_REFCOUNTED_P(result)) {
				C_ADDREF_P(result);
			}
		} else {
			ZVAL_COPY_VALUE(result, value);
		}
	} else {
		ZVAL_COPY_VALUE(result, value);
		if (IS_TMP_VAR == IS_CONST) {
			if (UNEXPECTED(C_OPT_REFCOUNTED_P(result))) {
				C_ADDREF_P(result);
			}
		}
	}
	CREX_VM_NEXT_OPCODE();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_IS_IDENTICAL_SPEC_TMP_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	bool result;

	SAVE_OPLINE();
	op1 = _get_zval_ptr_tmp(opline->op1.var EXECUTE_DATA_CC);
	op2 = RT_CONSTANT(opline, opline->op2);
	result = fast_is_identical_function(op1, op2);
	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));

	CREX_VM_SMART_BRANCH(result, 1);
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_CASE_STRICT_SPEC_TMP_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	bool result;

	SAVE_OPLINE();
	op1 = _get_zval_ptr_tmp(opline->op1.var EXECUTE_DATA_CC);
	op2 = RT_CONSTANT(opline, opline->op2);
	result = fast_is_identical_function(op1, op2);

	CREX_VM_SMART_BRANCH(result, 1);
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_IS_NOT_IDENTICAL_SPEC_TMP_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	bool result;

	SAVE_OPLINE();
	op1 = _get_zval_ptr_tmp(opline->op1.var EXECUTE_DATA_CC);
	op2 = RT_CONSTANT(opline, opline->op2);
	result = fast_is_not_identical_function(op1, op2);
	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));

	CREX_VM_SMART_BRANCH(result, 1);
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FETCH_DIM_FUNC_ARG_SPEC_TMP_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
#if 0
	USE_OPLINE
#endif

	if (UNEXPECTED(CREX_CALL_INFO(EX(call)) & CREX_CALL_SEND_ARG_BY_REF)) {
		if ((IS_TMP_VAR & (IS_CONST|IS_TMP_VAR))) {
			CREX_VM_TAIL_CALL(crex_use_tmp_in_write_context_helper_SPEC(CREX_OPCODE_HANDLER_ARGS_PASSTHRU));
		}
		CREX_VM_TAIL_CALL(CREX_NULL_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU));
	} else {
		if (IS_CONST == IS_UNUSED) {
			CREX_VM_TAIL_CALL(crex_use_undef_in_read_context_helper_SPEC(CREX_OPCODE_HANDLER_ARGS_PASSTHRU));
		}
		CREX_VM_TAIL_CALL(CREX_FETCH_DIM_R_SPEC_TMPVAR_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU));
	}
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FETCH_OBJ_FUNC_ARG_SPEC_TMP_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
#if 0
	USE_OPLINE
#endif

	if (UNEXPECTED(CREX_CALL_INFO(EX(call)) & CREX_CALL_SEND_ARG_BY_REF)) {
		/* Behave like FETCH_OBJ_W */
		if ((IS_TMP_VAR & (IS_CONST|IS_TMP_VAR))) {
			CREX_VM_TAIL_CALL(crex_use_tmp_in_write_context_helper_SPEC(CREX_OPCODE_HANDLER_ARGS_PASSTHRU));
		}
		CREX_VM_TAIL_CALL(CREX_NULL_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU));
	} else {
		CREX_VM_TAIL_CALL(CREX_FETCH_OBJ_R_SPEC_TMPVAR_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU));
	}
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ROPE_ADD_SPEC_TMP_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	crex_string **rope;
	zval *var;

	/* op1 and result are the same */
	rope = (crex_string**)EX_VAR(opline->op1.var);
	if (IS_CONST == IS_CONST) {
		var = RT_CONSTANT(opline, opline->op2);
		rope[opline->extended_value] = C_STR_P(var);
		if (UNEXPECTED(C_REFCOUNTED_P(var))) {
			C_ADDREF_P(var);
		}
	} else {
		var = RT_CONSTANT(opline, opline->op2);
		if (EXPECTED(C_TYPE_P(var) == IS_STRING)) {
			if (IS_CONST == IS_CV) {
				rope[opline->extended_value] = crex_string_copy(C_STR_P(var));
			} else {
				rope[opline->extended_value] = C_STR_P(var);
			}
		} else {
			SAVE_OPLINE();
			if (IS_CONST == IS_CV && UNEXPECTED(C_TYPE_P(var) == IS_UNDEF)) {
				ZVAL_UNDEFINED_OP2();
			}
			rope[opline->extended_value] = zval_get_string_func(var);

			CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
		}
	}
	CREX_VM_NEXT_OPCODE();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ROPE_END_SPEC_TMP_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	crex_string **rope;
	zval *var, *ret;
	uint32_t i;

	rope = (crex_string**)EX_VAR(opline->op1.var);
	if (IS_CONST == IS_CONST) {
		var = RT_CONSTANT(opline, opline->op2);
		rope[opline->extended_value] = C_STR_P(var);
		if (UNEXPECTED(C_REFCOUNTED_P(var))) {
			C_ADDREF_P(var);
		}
	} else {
		var = RT_CONSTANT(opline, opline->op2);
		if (EXPECTED(C_TYPE_P(var) == IS_STRING)) {
			if (IS_CONST == IS_CV) {
				rope[opline->extended_value] = crex_string_copy(C_STR_P(var));
			} else {
				rope[opline->extended_value] = C_STR_P(var);
			}
		} else {
			SAVE_OPLINE();
			if (IS_CONST == IS_CV && UNEXPECTED(C_TYPE_P(var) == IS_UNDEF)) {
				ZVAL_UNDEFINED_OP2();
			}
			rope[opline->extended_value] = zval_get_string_func(var);

			if (UNEXPECTED(EG(exception))) {
				for (i = 0; i <= opline->extended_value; i++) {
					crex_string_release_ex(rope[i], 0);
				}
				ZVAL_UNDEF(EX_VAR(opline->result.var));
				HANDLE_EXCEPTION();
			}
		}
	}

	size_t len = 0;
	uint32_t flags = ZSTR_COPYABLE_CONCAT_PROPERTIES;
	for (i = 0; i <= opline->extended_value; i++) {
		flags &= ZSTR_GET_COPYABLE_CONCAT_PROPERTIES(rope[i]);
		len += ZSTR_LEN(rope[i]);
	}
	ret = EX_VAR(opline->result.var);
	ZVAL_STR(ret, crex_string_alloc(len, 0));
	GC_ADD_FLAGS(C_STR_P(ret), flags);

	char *target = C_STRVAL_P(ret);
	for (i = 0; i <= opline->extended_value; i++) {
		memcpy(target, ZSTR_VAL(rope[i]), ZSTR_LEN(rope[i]));
		target += ZSTR_LEN(rope[i]);
		crex_string_release_ex(rope[i], 0);
	}
	*target = '\0';

	CREX_VM_NEXT_OPCODE();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_SEND_VAL_EX_SPEC_TMP_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *value, *arg;
	uint32_t arg_num;

	if (IS_CONST == IS_CONST) {
		SAVE_OPLINE();
		crex_string *arg_name = C_STR_P(RT_CONSTANT(opline, opline->op2));
		arg = crex_handle_named_arg(&EX(call), arg_name, &arg_num, CACHE_ADDR(opline->result.num));
		if (UNEXPECTED(!arg)) {
			zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
			HANDLE_EXCEPTION();
		}
	} else {
		arg = CREX_CALL_VAR(EX(call), opline->result.var);
		arg_num = opline->op2.num;
	}

	if (EXPECTED(arg_num <= MAX_ARG_FLAG_NUM)) {
		if (QUICK_ARG_MUST_BE_SENT_BY_REF(EX(call)->func, arg_num)) {
			goto send_val_by_ref;
		}
	} else if (ARG_MUST_BE_SENT_BY_REF(EX(call)->func, arg_num)) {
send_val_by_ref:
		CREX_VM_TAIL_CALL(crex_cannot_pass_by_ref_helper_SPEC(arg_num, arg CREX_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
	}
	value = _get_zval_ptr_tmp(opline->op1.var EXECUTE_DATA_CC);
	ZVAL_COPY_VALUE(arg, value);
	if (IS_TMP_VAR == IS_CONST) {
		if (UNEXPECTED(C_OPT_REFCOUNTED_P(arg))) {
			C_ADDREF_P(arg);
		}
	}
	CREX_VM_NEXT_OPCODE();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ADD_ARRAY_ELEMENT_SPEC_TMP_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *expr_ptr, new_expr;

	SAVE_OPLINE();
	if ((IS_TMP_VAR == IS_VAR || IS_TMP_VAR == IS_CV) &&
	    UNEXPECTED(opline->extended_value & CREX_ARRAY_ELEMENT_REF)) {
		expr_ptr = crex_get_bad_ptr();
		if (C_ISREF_P(expr_ptr)) {
			C_ADDREF_P(expr_ptr);
		} else {
			ZVAL_MAKE_REF_EX(expr_ptr, 2);
		}
		zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	} else {
		expr_ptr = _get_zval_ptr_tmp(opline->op1.var EXECUTE_DATA_CC);
		if (IS_TMP_VAR == IS_TMP_VAR) {
			/* pass */
		} else if (IS_TMP_VAR == IS_CONST) {
			C_TRY_ADDREF_P(expr_ptr);
		} else if (IS_TMP_VAR == IS_CV) {
			ZVAL_DEREF(expr_ptr);
			C_TRY_ADDREF_P(expr_ptr);
		} else /* if (IS_TMP_VAR == IS_VAR) */ {
			if (UNEXPECTED(C_ISREF_P(expr_ptr))) {
				crex_refcounted *ref = C_COUNTED_P(expr_ptr);

				expr_ptr = C_REFVAL_P(expr_ptr);
				if (UNEXPECTED(GC_DELREF(ref) == 0)) {
					ZVAL_COPY_VALUE(&new_expr, expr_ptr);
					expr_ptr = &new_expr;
					efree_size(ref, sizeof(crex_reference));
				} else if (C_OPT_REFCOUNTED_P(expr_ptr)) {
					C_ADDREF_P(expr_ptr);
				}
			}
		}
	}

	if (IS_CONST != IS_UNUSED) {
		zval *offset = RT_CONSTANT(opline, opline->op2);
		crex_string *str;
		crex_ulong hval;

add_again:
		if (EXPECTED(C_TYPE_P(offset) == IS_STRING)) {
			str = C_STR_P(offset);
			if (IS_CONST != IS_CONST) {
				if (CREX_HANDLE_NUMERIC(str, hval)) {
					goto num_index;
				}
			}
str_index:
			crex_hash_update(C_ARRVAL_P(EX_VAR(opline->result.var)), str, expr_ptr);
		} else if (EXPECTED(C_TYPE_P(offset) == IS_LONG)) {
			hval = C_LVAL_P(offset);
num_index:
			crex_hash_index_update(C_ARRVAL_P(EX_VAR(opline->result.var)), hval, expr_ptr);
		} else if ((IS_CONST & (IS_VAR|IS_CV)) && EXPECTED(C_TYPE_P(offset) == IS_REFERENCE)) {
			offset = C_REFVAL_P(offset);
			goto add_again;
		} else if (C_TYPE_P(offset) == IS_NULL) {
			str = ZSTR_EMPTY_ALLOC();
			goto str_index;
		} else if (C_TYPE_P(offset) == IS_DOUBLE) {
			hval = crex_dval_to_lval_safe(C_DVAL_P(offset));
			goto num_index;
		} else if (C_TYPE_P(offset) == IS_FALSE) {
			hval = 0;
			goto num_index;
		} else if (C_TYPE_P(offset) == IS_TRUE) {
			hval = 1;
			goto num_index;
		} else if (C_TYPE_P(offset) == IS_RESOURCE) {
			crex_use_resource_as_offset(offset);
			hval = C_RES_HANDLE_P(offset);
			goto num_index;
		} else if (IS_CONST == IS_CV && C_TYPE_P(offset) == IS_UNDEF) {
			ZVAL_UNDEFINED_OP2();
			str = ZSTR_EMPTY_ALLOC();
			goto str_index;
		} else {
			crex_illegal_array_offset_access(offset);
			zval_ptr_dtor_nogc(expr_ptr);
		}

	} else {
		if (!crex_hash_next_index_insert(C_ARRVAL_P(EX_VAR(opline->result.var)), expr_ptr)) {
			crex_cannot_add_element();
			zval_ptr_dtor_nogc(expr_ptr);
		}
	}
	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_INIT_ARRAY_SPEC_TMP_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	zval *array;
	uint32_t size;
	USE_OPLINE

	array = EX_VAR(opline->result.var);
	if (IS_TMP_VAR != IS_UNUSED) {
		size = opline->extended_value >> CREX_ARRAY_SIZE_SHIFT;
		ZVAL_ARR(array, crex_new_array(size));
		/* Explicitly initialize array as not-packed if flag is set */
		if (opline->extended_value & CREX_ARRAY_NOT_PACKED) {
			crex_hash_real_init_mixed(C_ARRVAL_P(array));
		}
		CREX_VM_TAIL_CALL(CREX_ADD_ARRAY_ELEMENT_SPEC_TMP_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU));
	} else {
		ZVAL_ARR(array, crex_new_array(0));
		CREX_VM_NEXT_OPCODE();
	}
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_YIELD_SPEC_TMP_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	crex_generator *generator = crex_get_running_generator(EXECUTE_DATA_C);

	SAVE_OPLINE();
	if (UNEXPECTED(generator->flags & CREX_GENERATOR_FORCED_CLOSE)) {
		CREX_VM_TAIL_CALL(crex_yield_in_closed_generator_helper_SPEC(CREX_OPCODE_HANDLER_ARGS_PASSTHRU));
	}

	/* Destroy the previously yielded value */
	zval_ptr_dtor(&generator->value);

	/* Destroy the previously yielded key */
	zval_ptr_dtor(&generator->key);

	/* Set the new yielded value */
	if (IS_TMP_VAR != IS_UNUSED) {
		if (UNEXPECTED(EX(func)->op_array.fn_flags & CREX_ACC_RETURN_REFERENCE)) {
			/* Constants and temporary variables aren't yieldable by reference,
			 * but we still allow them with a notice. */
			if (IS_TMP_VAR & (IS_CONST|IS_TMP_VAR)) {
				zval *value;

				crex_error(E_NOTICE, "Only variable references should be yielded by reference");

				value = _get_zval_ptr_tmp(opline->op1.var EXECUTE_DATA_CC);
				ZVAL_COPY_VALUE(&generator->value, value);
				if (IS_TMP_VAR == IS_CONST) {
					if (UNEXPECTED(C_OPT_REFCOUNTED(generator->value))) {
						C_ADDREF(generator->value);
					}
				}
			} else {
				zval *value_ptr = crex_get_bad_ptr();

				/* If a function call result is yielded and the function did
				 * not return by reference we throw a notice. */
				do {
					if (IS_TMP_VAR == IS_VAR) {
						CREX_ASSERT(value_ptr != &EG(uninitialized_zval));
						if (opline->extended_value == CREX_RETURNS_FUNCTION
						 && !C_ISREF_P(value_ptr)) {
							crex_error(E_NOTICE, "Only variable references should be yielded by reference");
							ZVAL_COPY(&generator->value, value_ptr);
							break;
						}
					}
					if (C_ISREF_P(value_ptr)) {
						C_ADDREF_P(value_ptr);
					} else {
						ZVAL_MAKE_REF_EX(value_ptr, 2);
					}
					ZVAL_REF(&generator->value, C_REF_P(value_ptr));
				} while (0);

				zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
			}
		} else {
			zval *value = _get_zval_ptr_tmp(opline->op1.var EXECUTE_DATA_CC);

			/* Consts, temporary variables and references need copying */
			if (IS_TMP_VAR == IS_CONST) {
				ZVAL_COPY_VALUE(&generator->value, value);
				if (UNEXPECTED(C_OPT_REFCOUNTED(generator->value))) {
					C_ADDREF(generator->value);
				}
			} else if (IS_TMP_VAR == IS_TMP_VAR) {
				ZVAL_COPY_VALUE(&generator->value, value);
			} else if ((IS_TMP_VAR & (IS_VAR|IS_CV)) && C_ISREF_P(value)) {
				ZVAL_COPY(&generator->value, C_REFVAL_P(value));

			} else {
				ZVAL_COPY_VALUE(&generator->value, value);
				if (IS_TMP_VAR == IS_CV) {
					if (C_OPT_REFCOUNTED_P(value)) C_ADDREF_P(value);
				}
			}
		}
	} else {
		/* If no value was specified yield null */
		ZVAL_NULL(&generator->value);
	}

	/* Set the new yielded key */
	if (IS_CONST != IS_UNUSED) {
		zval *key = RT_CONSTANT(opline, opline->op2);
		if ((IS_CONST & (IS_CV|IS_VAR)) && UNEXPECTED(C_TYPE_P(key) == IS_REFERENCE)) {
			key = C_REFVAL_P(key);
		}
		ZVAL_COPY(&generator->key, key);

		if (C_TYPE(generator->key) == IS_LONG
		    && C_LVAL(generator->key) > generator->largest_used_integer_key
		) {
			generator->largest_used_integer_key = C_LVAL(generator->key);
		}
	} else {
		/* If no key was specified we use auto-increment keys */
		generator->largest_used_integer_key++;
		ZVAL_LONG(&generator->key, generator->largest_used_integer_key);
	}

	if (RETURN_VALUE_USED(opline)) {
		/* If the return value of yield is used set the send
		 * target and initialize it to NULL */
		generator->send_target = EX_VAR(opline->result.var);
		ZVAL_NULL(generator->send_target);
	} else {
		generator->send_target = NULL;
	}

	/* We increment to the next op, so we are at the correct position when the
	 * generator is resumed. */
	CREX_VM_INC_OPCODE();

	/* The GOTO VM uses a local opline variable. We need to set the opline
	 * variable in execute_data so we don't resume at an old position. */
	SAVE_OPLINE();

	CREX_VM_RETURN();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_IN_ARRAY_SPEC_TMP_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1;
	HashTable *ht = C_ARRVAL_P(RT_CONSTANT(opline, opline->op2));
	zval *result;

	op1 = _get_zval_ptr_tmp(opline->op1.var EXECUTE_DATA_CC);
	if (EXPECTED(C_TYPE_P(op1) == IS_STRING)) {
		result = crex_hash_find_ex(ht, C_STR_P(op1), IS_TMP_VAR == IS_CONST);
		if (IS_TMP_VAR & (IS_TMP_VAR|IS_VAR)) {
			zval_ptr_dtor_str(op1);
		}
		CREX_VM_SMART_BRANCH(result, 0);
	}

	if (opline->extended_value) {
		if (EXPECTED(C_TYPE_P(op1) == IS_LONG)) {
			result = crex_hash_index_find(ht, C_LVAL_P(op1));
			CREX_VM_SMART_BRANCH(result, 0);
		}
		SAVE_OPLINE();
		if ((IS_TMP_VAR & (IS_VAR|IS_CV)) && C_TYPE_P(op1) == IS_REFERENCE) {
			op1 = C_REFVAL_P(op1);
			if (EXPECTED(C_TYPE_P(op1) == IS_STRING)) {
				result = crex_hash_find(ht, C_STR_P(op1));
				zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
				CREX_VM_SMART_BRANCH(result, 0);
			} else if (EXPECTED(C_TYPE_P(op1) == IS_LONG)) {
				result = crex_hash_index_find(ht, C_LVAL_P(op1));
				zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
				CREX_VM_SMART_BRANCH(result, 0);
			}
		} else if (IS_TMP_VAR == IS_CV && UNEXPECTED(C_TYPE_P(op1) == IS_UNDEF)) {
			ZVAL_UNDEFINED_OP1();
		}
	} else if (C_TYPE_P(op1) <= IS_FALSE) {
		if (IS_TMP_VAR == IS_CV && UNEXPECTED(C_TYPE_P(op1) == IS_UNDEF)) {
			SAVE_OPLINE();
			ZVAL_UNDEFINED_OP1();
			if (UNEXPECTED(EG(exception) != NULL)) {
				HANDLE_EXCEPTION();
			}
		}
		result = crex_hash_find_known_hash(ht, ZSTR_EMPTY_ALLOC());
		CREX_VM_SMART_BRANCH(result, 0);
	} else {
		crex_string *key;
		zval key_tmp;

		if ((IS_TMP_VAR & (IS_VAR|IS_CV)) && C_TYPE_P(op1) == IS_REFERENCE) {
			op1 = C_REFVAL_P(op1);
			if (EXPECTED(C_TYPE_P(op1) == IS_STRING)) {
				result = crex_hash_find(ht, C_STR_P(op1));
				zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
				CREX_VM_SMART_BRANCH(result, 0);
			}
		}

		SAVE_OPLINE();
		CREX_HASH_MAP_FOREACH_STR_KEY(ht, key) {
			ZVAL_STR(&key_tmp, key);
			if (crex_compare(op1, &key_tmp) == 0) {
				zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
				CREX_VM_SMART_BRANCH(1, 1);
			}
		} CREX_HASH_FOREACH_END();
	}
	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	CREX_VM_SMART_BRANCH(0, 1);
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FETCH_DIM_FUNC_ARG_SPEC_TMP_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
#if 0
	USE_OPLINE
#endif

	if (UNEXPECTED(CREX_CALL_INFO(EX(call)) & CREX_CALL_SEND_ARG_BY_REF)) {
		if ((IS_TMP_VAR & (IS_CONST|IS_TMP_VAR))) {
			CREX_VM_TAIL_CALL(crex_use_tmp_in_write_context_helper_SPEC(CREX_OPCODE_HANDLER_ARGS_PASSTHRU));
		}
		CREX_VM_TAIL_CALL(CREX_NULL_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU));
	} else {
		if ((IS_TMP_VAR|IS_VAR) == IS_UNUSED) {
			CREX_VM_TAIL_CALL(crex_use_undef_in_read_context_helper_SPEC(CREX_OPCODE_HANDLER_ARGS_PASSTHRU));
		}
		CREX_VM_TAIL_CALL(CREX_FETCH_DIM_R_SPEC_TMPVAR_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU));
	}
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FETCH_OBJ_FUNC_ARG_SPEC_TMP_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
#if 0
	USE_OPLINE
#endif

	if (UNEXPECTED(CREX_CALL_INFO(EX(call)) & CREX_CALL_SEND_ARG_BY_REF)) {
		/* Behave like FETCH_OBJ_W */
		if ((IS_TMP_VAR & (IS_CONST|IS_TMP_VAR))) {
			CREX_VM_TAIL_CALL(crex_use_tmp_in_write_context_helper_SPEC(CREX_OPCODE_HANDLER_ARGS_PASSTHRU));
		}
		CREX_VM_TAIL_CALL(CREX_NULL_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU));
	} else {
		CREX_VM_TAIL_CALL(CREX_FETCH_OBJ_R_SPEC_TMPVAR_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU));
	}
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ROPE_ADD_SPEC_TMP_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	crex_string **rope;
	zval *var;

	/* op1 and result are the same */
	rope = (crex_string**)EX_VAR(opline->op1.var);
	if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
		var = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
		rope[opline->extended_value] = C_STR_P(var);
		if (UNEXPECTED(C_REFCOUNTED_P(var))) {
			C_ADDREF_P(var);
		}
	} else {
		var = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
		if (EXPECTED(C_TYPE_P(var) == IS_STRING)) {
			if ((IS_TMP_VAR|IS_VAR) == IS_CV) {
				rope[opline->extended_value] = crex_string_copy(C_STR_P(var));
			} else {
				rope[opline->extended_value] = C_STR_P(var);
			}
		} else {
			SAVE_OPLINE();
			if ((IS_TMP_VAR|IS_VAR) == IS_CV && UNEXPECTED(C_TYPE_P(var) == IS_UNDEF)) {
				ZVAL_UNDEFINED_OP2();
			}
			rope[opline->extended_value] = zval_get_string_func(var);
			zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
			CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
		}
	}
	CREX_VM_NEXT_OPCODE();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ROPE_END_SPEC_TMP_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	crex_string **rope;
	zval *var, *ret;
	uint32_t i;

	rope = (crex_string**)EX_VAR(opline->op1.var);
	if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
		var = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
		rope[opline->extended_value] = C_STR_P(var);
		if (UNEXPECTED(C_REFCOUNTED_P(var))) {
			C_ADDREF_P(var);
		}
	} else {
		var = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
		if (EXPECTED(C_TYPE_P(var) == IS_STRING)) {
			if ((IS_TMP_VAR|IS_VAR) == IS_CV) {
				rope[opline->extended_value] = crex_string_copy(C_STR_P(var));
			} else {
				rope[opline->extended_value] = C_STR_P(var);
			}
		} else {
			SAVE_OPLINE();
			if ((IS_TMP_VAR|IS_VAR) == IS_CV && UNEXPECTED(C_TYPE_P(var) == IS_UNDEF)) {
				ZVAL_UNDEFINED_OP2();
			}
			rope[opline->extended_value] = zval_get_string_func(var);
			zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
			if (UNEXPECTED(EG(exception))) {
				for (i = 0; i <= opline->extended_value; i++) {
					crex_string_release_ex(rope[i], 0);
				}
				ZVAL_UNDEF(EX_VAR(opline->result.var));
				HANDLE_EXCEPTION();
			}
		}
	}

	size_t len = 0;
	uint32_t flags = ZSTR_COPYABLE_CONCAT_PROPERTIES;
	for (i = 0; i <= opline->extended_value; i++) {
		flags &= ZSTR_GET_COPYABLE_CONCAT_PROPERTIES(rope[i]);
		len += ZSTR_LEN(rope[i]);
	}
	ret = EX_VAR(opline->result.var);
	ZVAL_STR(ret, crex_string_alloc(len, 0));
	GC_ADD_FLAGS(C_STR_P(ret), flags);

	char *target = C_STRVAL_P(ret);
	for (i = 0; i <= opline->extended_value; i++) {
		memcpy(target, ZSTR_VAL(rope[i]), ZSTR_LEN(rope[i]));
		target += ZSTR_LEN(rope[i]);
		crex_string_release_ex(rope[i], 0);
	}
	*target = '\0';

	CREX_VM_NEXT_OPCODE();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ADD_ARRAY_ELEMENT_SPEC_TMP_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *expr_ptr, new_expr;

	SAVE_OPLINE();
	if ((IS_TMP_VAR == IS_VAR || IS_TMP_VAR == IS_CV) &&
	    UNEXPECTED(opline->extended_value & CREX_ARRAY_ELEMENT_REF)) {
		expr_ptr = crex_get_bad_ptr();
		if (C_ISREF_P(expr_ptr)) {
			C_ADDREF_P(expr_ptr);
		} else {
			ZVAL_MAKE_REF_EX(expr_ptr, 2);
		}
		zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	} else {
		expr_ptr = _get_zval_ptr_tmp(opline->op1.var EXECUTE_DATA_CC);
		if (IS_TMP_VAR == IS_TMP_VAR) {
			/* pass */
		} else if (IS_TMP_VAR == IS_CONST) {
			C_TRY_ADDREF_P(expr_ptr);
		} else if (IS_TMP_VAR == IS_CV) {
			ZVAL_DEREF(expr_ptr);
			C_TRY_ADDREF_P(expr_ptr);
		} else /* if (IS_TMP_VAR == IS_VAR) */ {
			if (UNEXPECTED(C_ISREF_P(expr_ptr))) {
				crex_refcounted *ref = C_COUNTED_P(expr_ptr);

				expr_ptr = C_REFVAL_P(expr_ptr);
				if (UNEXPECTED(GC_DELREF(ref) == 0)) {
					ZVAL_COPY_VALUE(&new_expr, expr_ptr);
					expr_ptr = &new_expr;
					efree_size(ref, sizeof(crex_reference));
				} else if (C_OPT_REFCOUNTED_P(expr_ptr)) {
					C_ADDREF_P(expr_ptr);
				}
			}
		}
	}

	if ((IS_TMP_VAR|IS_VAR) != IS_UNUSED) {
		zval *offset = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
		crex_string *str;
		crex_ulong hval;

add_again:
		if (EXPECTED(C_TYPE_P(offset) == IS_STRING)) {
			str = C_STR_P(offset);
			if ((IS_TMP_VAR|IS_VAR) != IS_CONST) {
				if (CREX_HANDLE_NUMERIC(str, hval)) {
					goto num_index;
				}
			}
str_index:
			crex_hash_update(C_ARRVAL_P(EX_VAR(opline->result.var)), str, expr_ptr);
		} else if (EXPECTED(C_TYPE_P(offset) == IS_LONG)) {
			hval = C_LVAL_P(offset);
num_index:
			crex_hash_index_update(C_ARRVAL_P(EX_VAR(opline->result.var)), hval, expr_ptr);
		} else if (((IS_TMP_VAR|IS_VAR) & (IS_VAR|IS_CV)) && EXPECTED(C_TYPE_P(offset) == IS_REFERENCE)) {
			offset = C_REFVAL_P(offset);
			goto add_again;
		} else if (C_TYPE_P(offset) == IS_NULL) {
			str = ZSTR_EMPTY_ALLOC();
			goto str_index;
		} else if (C_TYPE_P(offset) == IS_DOUBLE) {
			hval = crex_dval_to_lval_safe(C_DVAL_P(offset));
			goto num_index;
		} else if (C_TYPE_P(offset) == IS_FALSE) {
			hval = 0;
			goto num_index;
		} else if (C_TYPE_P(offset) == IS_TRUE) {
			hval = 1;
			goto num_index;
		} else if (C_TYPE_P(offset) == IS_RESOURCE) {
			crex_use_resource_as_offset(offset);
			hval = C_RES_HANDLE_P(offset);
			goto num_index;
		} else if ((IS_TMP_VAR|IS_VAR) == IS_CV && C_TYPE_P(offset) == IS_UNDEF) {
			ZVAL_UNDEFINED_OP2();
			str = ZSTR_EMPTY_ALLOC();
			goto str_index;
		} else {
			crex_illegal_array_offset_access(offset);
			zval_ptr_dtor_nogc(expr_ptr);
		}
		zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
	} else {
		if (!crex_hash_next_index_insert(C_ARRVAL_P(EX_VAR(opline->result.var)), expr_ptr)) {
			crex_cannot_add_element();
			zval_ptr_dtor_nogc(expr_ptr);
		}
	}
	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_INIT_ARRAY_SPEC_TMP_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	zval *array;
	uint32_t size;
	USE_OPLINE

	array = EX_VAR(opline->result.var);
	if (IS_TMP_VAR != IS_UNUSED) {
		size = opline->extended_value >> CREX_ARRAY_SIZE_SHIFT;
		ZVAL_ARR(array, crex_new_array(size));
		/* Explicitly initialize array as not-packed if flag is set */
		if (opline->extended_value & CREX_ARRAY_NOT_PACKED) {
			crex_hash_real_init_mixed(C_ARRVAL_P(array));
		}
		CREX_VM_TAIL_CALL(CREX_ADD_ARRAY_ELEMENT_SPEC_TMP_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU));
	} else {
		ZVAL_ARR(array, crex_new_array(0));
		CREX_VM_NEXT_OPCODE();
	}
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_YIELD_SPEC_TMP_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	crex_generator *generator = crex_get_running_generator(EXECUTE_DATA_C);

	SAVE_OPLINE();
	if (UNEXPECTED(generator->flags & CREX_GENERATOR_FORCED_CLOSE)) {
		CREX_VM_TAIL_CALL(crex_yield_in_closed_generator_helper_SPEC(CREX_OPCODE_HANDLER_ARGS_PASSTHRU));
	}

	/* Destroy the previously yielded value */
	zval_ptr_dtor(&generator->value);

	/* Destroy the previously yielded key */
	zval_ptr_dtor(&generator->key);

	/* Set the new yielded value */
	if (IS_TMP_VAR != IS_UNUSED) {
		if (UNEXPECTED(EX(func)->op_array.fn_flags & CREX_ACC_RETURN_REFERENCE)) {
			/* Constants and temporary variables aren't yieldable by reference,
			 * but we still allow them with a notice. */
			if (IS_TMP_VAR & (IS_CONST|IS_TMP_VAR)) {
				zval *value;

				crex_error(E_NOTICE, "Only variable references should be yielded by reference");

				value = _get_zval_ptr_tmp(opline->op1.var EXECUTE_DATA_CC);
				ZVAL_COPY_VALUE(&generator->value, value);
				if (IS_TMP_VAR == IS_CONST) {
					if (UNEXPECTED(C_OPT_REFCOUNTED(generator->value))) {
						C_ADDREF(generator->value);
					}
				}
			} else {
				zval *value_ptr = crex_get_bad_ptr();

				/* If a function call result is yielded and the function did
				 * not return by reference we throw a notice. */
				do {
					if (IS_TMP_VAR == IS_VAR) {
						CREX_ASSERT(value_ptr != &EG(uninitialized_zval));
						if (opline->extended_value == CREX_RETURNS_FUNCTION
						 && !C_ISREF_P(value_ptr)) {
							crex_error(E_NOTICE, "Only variable references should be yielded by reference");
							ZVAL_COPY(&generator->value, value_ptr);
							break;
						}
					}
					if (C_ISREF_P(value_ptr)) {
						C_ADDREF_P(value_ptr);
					} else {
						ZVAL_MAKE_REF_EX(value_ptr, 2);
					}
					ZVAL_REF(&generator->value, C_REF_P(value_ptr));
				} while (0);

				zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
			}
		} else {
			zval *value = _get_zval_ptr_tmp(opline->op1.var EXECUTE_DATA_CC);

			/* Consts, temporary variables and references need copying */
			if (IS_TMP_VAR == IS_CONST) {
				ZVAL_COPY_VALUE(&generator->value, value);
				if (UNEXPECTED(C_OPT_REFCOUNTED(generator->value))) {
					C_ADDREF(generator->value);
				}
			} else if (IS_TMP_VAR == IS_TMP_VAR) {
				ZVAL_COPY_VALUE(&generator->value, value);
			} else if ((IS_TMP_VAR & (IS_VAR|IS_CV)) && C_ISREF_P(value)) {
				ZVAL_COPY(&generator->value, C_REFVAL_P(value));

			} else {
				ZVAL_COPY_VALUE(&generator->value, value);
				if (IS_TMP_VAR == IS_CV) {
					if (C_OPT_REFCOUNTED_P(value)) C_ADDREF_P(value);
				}
			}
		}
	} else {
		/* If no value was specified yield null */
		ZVAL_NULL(&generator->value);
	}

	/* Set the new yielded key */
	if ((IS_TMP_VAR|IS_VAR) != IS_UNUSED) {
		zval *key = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
		if (((IS_TMP_VAR|IS_VAR) & (IS_CV|IS_VAR)) && UNEXPECTED(C_TYPE_P(key) == IS_REFERENCE)) {
			key = C_REFVAL_P(key);
		}
		ZVAL_COPY(&generator->key, key);
		zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));

		if (C_TYPE(generator->key) == IS_LONG
		    && C_LVAL(generator->key) > generator->largest_used_integer_key
		) {
			generator->largest_used_integer_key = C_LVAL(generator->key);
		}
	} else {
		/* If no key was specified we use auto-increment keys */
		generator->largest_used_integer_key++;
		ZVAL_LONG(&generator->key, generator->largest_used_integer_key);
	}

	if (RETURN_VALUE_USED(opline)) {
		/* If the return value of yield is used set the send
		 * target and initialize it to NULL */
		generator->send_target = EX_VAR(opline->result.var);
		ZVAL_NULL(generator->send_target);
	} else {
		generator->send_target = NULL;
	}

	/* We increment to the next op, so we are at the correct position when the
	 * generator is resumed. */
	CREX_VM_INC_OPCODE();

	/* The GOTO VM uses a local opline variable. We need to set the opline
	 * variable in execute_data so we don't resume at an old position. */
	SAVE_OPLINE();

	CREX_VM_RETURN();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_IS_IDENTICAL_SPEC_TMP_TMP_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	bool result;

	SAVE_OPLINE();
	op1 = _get_zval_ptr_tmp(opline->op1.var EXECUTE_DATA_CC);
	op2 = _get_zval_ptr_tmp(opline->op2.var EXECUTE_DATA_CC);
	result = fast_is_identical_function(op1, op2);
	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
	CREX_VM_SMART_BRANCH(result, 1);
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_CASE_STRICT_SPEC_TMP_TMP_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	bool result;

	SAVE_OPLINE();
	op1 = _get_zval_ptr_tmp(opline->op1.var EXECUTE_DATA_CC);
	op2 = _get_zval_ptr_tmp(opline->op2.var EXECUTE_DATA_CC);
	result = fast_is_identical_function(op1, op2);
	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
	CREX_VM_SMART_BRANCH(result, 1);
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_IS_NOT_IDENTICAL_SPEC_TMP_TMP_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	bool result;

	SAVE_OPLINE();
	op1 = _get_zval_ptr_tmp(opline->op1.var EXECUTE_DATA_CC);
	op2 = _get_zval_ptr_tmp(opline->op2.var EXECUTE_DATA_CC);
	result = fast_is_not_identical_function(op1, op2);
	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
	CREX_VM_SMART_BRANCH(result, 1);
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_CASE_STRICT_SPEC_TMP_VAR_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	bool result;

	SAVE_OPLINE();
	op1 = _get_zval_ptr_tmp(opline->op1.var EXECUTE_DATA_CC);
	op2 = _get_zval_ptr_var_deref(opline->op2.var EXECUTE_DATA_CC);
	result = fast_is_identical_function(op1, op2);
	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
	CREX_VM_SMART_BRANCH(result, 1);
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FETCH_DIM_FUNC_ARG_SPEC_TMP_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
#if 0
	USE_OPLINE
#endif

	if (UNEXPECTED(CREX_CALL_INFO(EX(call)) & CREX_CALL_SEND_ARG_BY_REF)) {
		if ((IS_TMP_VAR & (IS_CONST|IS_TMP_VAR))) {
			CREX_VM_TAIL_CALL(crex_use_tmp_in_write_context_helper_SPEC(CREX_OPCODE_HANDLER_ARGS_PASSTHRU));
		}
		CREX_VM_TAIL_CALL(CREX_NULL_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU));
	} else {
		if (IS_UNUSED == IS_UNUSED) {
			CREX_VM_TAIL_CALL(crex_use_undef_in_read_context_helper_SPEC(CREX_OPCODE_HANDLER_ARGS_PASSTHRU));
		}
		CREX_VM_TAIL_CALL(CREX_NULL_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU));
	}
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_VERIFY_RETURN_TYPE_SPEC_TMP_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	if (IS_TMP_VAR == IS_UNUSED) {
		SAVE_OPLINE();
		crex_verify_missing_return_type(EX(func));
		HANDLE_EXCEPTION();
	} else {
/* prevents "undefined variable opline" errors */
#if 0 || (IS_TMP_VAR != IS_UNUSED)
		USE_OPLINE
		zval *retval_ref, *retval_ptr;
		crex_arg_info *ret_info = EX(func)->common.arg_info - 1;
		retval_ref = retval_ptr = _get_zval_ptr_tmp(opline->op1.var EXECUTE_DATA_CC);

		if (IS_TMP_VAR == IS_CONST) {
			ZVAL_COPY(EX_VAR(opline->result.var), retval_ptr);
			retval_ref = retval_ptr = EX_VAR(opline->result.var);
		} else if (IS_TMP_VAR == IS_VAR) {
			if (UNEXPECTED(C_TYPE_P(retval_ptr) == IS_INDIRECT)) {
				retval_ref = retval_ptr = C_INDIRECT_P(retval_ptr);
			}
			ZVAL_DEREF(retval_ptr);
		} else if (IS_TMP_VAR == IS_CV) {
			ZVAL_DEREF(retval_ptr);
		}

		if (EXPECTED(CREX_TYPE_CONTAINS_CODE(ret_info->type, C_TYPE_P(retval_ptr)))) {
			CREX_VM_NEXT_OPCODE();
		}

		if (IS_TMP_VAR == IS_CV && UNEXPECTED(C_ISUNDEF_P(retval_ptr))) {
			SAVE_OPLINE();
			retval_ref = retval_ptr = ZVAL_UNDEFINED_OP1();
			if (UNEXPECTED(EG(exception))) {
				HANDLE_EXCEPTION();
			}
			if (CREX_TYPE_FULL_MASK(ret_info->type) & MAY_BE_NULL) {
				CREX_VM_NEXT_OPCODE();
			}
		}

		crex_reference *ref = NULL;
		void *cache_slot = CACHE_ADDR(opline->op2.num);
		if (UNEXPECTED(retval_ref != retval_ptr)) {
			if (UNEXPECTED(EX(func)->op_array.fn_flags & CREX_ACC_RETURN_REFERENCE)) {
				ref = C_REF_P(retval_ref);
			} else {
				/* A cast might happen - unwrap the reference if this is a by-value return */
				if (C_REFCOUNT_P(retval_ref) == 1) {
					ZVAL_UNREF(retval_ref);
				} else {
					C_DELREF_P(retval_ref);
					ZVAL_COPY(retval_ref, retval_ptr);
				}
				retval_ptr = retval_ref;
			}
		}

		SAVE_OPLINE();
		if (UNEXPECTED(!crex_check_type_slow(&ret_info->type, retval_ptr, ref, cache_slot, 1, 0))) {
			crex_verify_return_error(EX(func), retval_ptr);
			HANDLE_EXCEPTION();
		}
		CREX_VM_NEXT_OPCODE();
#endif
	}
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_SEND_VAL_EX_SPEC_TMP_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *value, *arg;
	uint32_t arg_num;

	if (IS_UNUSED == IS_CONST) {
		SAVE_OPLINE();
		crex_string *arg_name = C_STR_P(RT_CONSTANT(opline, opline->op2));
		arg = crex_handle_named_arg(&EX(call), arg_name, &arg_num, CACHE_ADDR(opline->result.num));
		if (UNEXPECTED(!arg)) {
			zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
			HANDLE_EXCEPTION();
		}
	} else {
		arg = CREX_CALL_VAR(EX(call), opline->result.var);
		arg_num = opline->op2.num;
	}

	if (EXPECTED(0)) {
		if (QUICK_ARG_MUST_BE_SENT_BY_REF(EX(call)->func, arg_num)) {
			goto send_val_by_ref;
		}
	} else if (ARG_MUST_BE_SENT_BY_REF(EX(call)->func, arg_num)) {
send_val_by_ref:
		CREX_VM_TAIL_CALL(crex_cannot_pass_by_ref_helper_SPEC(arg_num, arg CREX_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
	}
	value = _get_zval_ptr_tmp(opline->op1.var EXECUTE_DATA_CC);
	ZVAL_COPY_VALUE(arg, value);
	if (IS_TMP_VAR == IS_CONST) {
		if (UNEXPECTED(C_OPT_REFCOUNTED_P(arg))) {
			C_ADDREF_P(arg);
		}
	}
	CREX_VM_NEXT_OPCODE();
}

static CREX_VM_HOT CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_SEND_VAL_EX_SPEC_TMP_UNUSED_QUICK_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *value, *arg;
	uint32_t arg_num;

	if (IS_UNUSED == IS_CONST) {
		SAVE_OPLINE();
		crex_string *arg_name = C_STR_P(RT_CONSTANT(opline, opline->op2));
		arg = crex_handle_named_arg(&EX(call), arg_name, &arg_num, CACHE_ADDR(opline->result.num));
		if (UNEXPECTED(!arg)) {
			zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
			HANDLE_EXCEPTION();
		}
	} else {
		arg = CREX_CALL_VAR(EX(call), opline->result.var);
		arg_num = opline->op2.num;
	}

	if (EXPECTED(1)) {
		if (QUICK_ARG_MUST_BE_SENT_BY_REF(EX(call)->func, arg_num)) {
			goto send_val_by_ref;
		}
	} else if (ARG_MUST_BE_SENT_BY_REF(EX(call)->func, arg_num)) {
send_val_by_ref:
		CREX_VM_TAIL_CALL(crex_cannot_pass_by_ref_helper_SPEC(arg_num, arg CREX_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
	}
	value = _get_zval_ptr_tmp(opline->op1.var EXECUTE_DATA_CC);
	ZVAL_COPY_VALUE(arg, value);
	if (IS_TMP_VAR == IS_CONST) {
		if (UNEXPECTED(C_OPT_REFCOUNTED_P(arg))) {
			C_ADDREF_P(arg);
		}
	}
	CREX_VM_NEXT_OPCODE();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ADD_ARRAY_ELEMENT_SPEC_TMP_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *expr_ptr, new_expr;

	SAVE_OPLINE();
	if ((IS_TMP_VAR == IS_VAR || IS_TMP_VAR == IS_CV) &&
	    UNEXPECTED(opline->extended_value & CREX_ARRAY_ELEMENT_REF)) {
		expr_ptr = crex_get_bad_ptr();
		if (C_ISREF_P(expr_ptr)) {
			C_ADDREF_P(expr_ptr);
		} else {
			ZVAL_MAKE_REF_EX(expr_ptr, 2);
		}
		zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	} else {
		expr_ptr = _get_zval_ptr_tmp(opline->op1.var EXECUTE_DATA_CC);
		if (IS_TMP_VAR == IS_TMP_VAR) {
			/* pass */
		} else if (IS_TMP_VAR == IS_CONST) {
			C_TRY_ADDREF_P(expr_ptr);
		} else if (IS_TMP_VAR == IS_CV) {
			ZVAL_DEREF(expr_ptr);
			C_TRY_ADDREF_P(expr_ptr);
		} else /* if (IS_TMP_VAR == IS_VAR) */ {
			if (UNEXPECTED(C_ISREF_P(expr_ptr))) {
				crex_refcounted *ref = C_COUNTED_P(expr_ptr);

				expr_ptr = C_REFVAL_P(expr_ptr);
				if (UNEXPECTED(GC_DELREF(ref) == 0)) {
					ZVAL_COPY_VALUE(&new_expr, expr_ptr);
					expr_ptr = &new_expr;
					efree_size(ref, sizeof(crex_reference));
				} else if (C_OPT_REFCOUNTED_P(expr_ptr)) {
					C_ADDREF_P(expr_ptr);
				}
			}
		}
	}

	if (IS_UNUSED != IS_UNUSED) {
		zval *offset = NULL;
		crex_string *str;
		crex_ulong hval;

add_again:
		if (EXPECTED(C_TYPE_P(offset) == IS_STRING)) {
			str = C_STR_P(offset);
			if (IS_UNUSED != IS_CONST) {
				if (CREX_HANDLE_NUMERIC(str, hval)) {
					goto num_index;
				}
			}
str_index:
			crex_hash_update(C_ARRVAL_P(EX_VAR(opline->result.var)), str, expr_ptr);
		} else if (EXPECTED(C_TYPE_P(offset) == IS_LONG)) {
			hval = C_LVAL_P(offset);
num_index:
			crex_hash_index_update(C_ARRVAL_P(EX_VAR(opline->result.var)), hval, expr_ptr);
		} else if ((IS_UNUSED & (IS_VAR|IS_CV)) && EXPECTED(C_TYPE_P(offset) == IS_REFERENCE)) {
			offset = C_REFVAL_P(offset);
			goto add_again;
		} else if (C_TYPE_P(offset) == IS_NULL) {
			str = ZSTR_EMPTY_ALLOC();
			goto str_index;
		} else if (C_TYPE_P(offset) == IS_DOUBLE) {
			hval = crex_dval_to_lval_safe(C_DVAL_P(offset));
			goto num_index;
		} else if (C_TYPE_P(offset) == IS_FALSE) {
			hval = 0;
			goto num_index;
		} else if (C_TYPE_P(offset) == IS_TRUE) {
			hval = 1;
			goto num_index;
		} else if (C_TYPE_P(offset) == IS_RESOURCE) {
			crex_use_resource_as_offset(offset);
			hval = C_RES_HANDLE_P(offset);
			goto num_index;
		} else if (IS_UNUSED == IS_CV && C_TYPE_P(offset) == IS_UNDEF) {
			ZVAL_UNDEFINED_OP2();
			str = ZSTR_EMPTY_ALLOC();
			goto str_index;
		} else {
			crex_illegal_array_offset_access(offset);
			zval_ptr_dtor_nogc(expr_ptr);
		}

	} else {
		if (!crex_hash_next_index_insert(C_ARRVAL_P(EX_VAR(opline->result.var)), expr_ptr)) {
			crex_cannot_add_element();
			zval_ptr_dtor_nogc(expr_ptr);
		}
	}
	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_INIT_ARRAY_SPEC_TMP_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	zval *array;
	uint32_t size;
	USE_OPLINE

	array = EX_VAR(opline->result.var);
	if (IS_TMP_VAR != IS_UNUSED) {
		size = opline->extended_value >> CREX_ARRAY_SIZE_SHIFT;
		ZVAL_ARR(array, crex_new_array(size));
		/* Explicitly initialize array as not-packed if flag is set */
		if (opline->extended_value & CREX_ARRAY_NOT_PACKED) {
			crex_hash_real_init_mixed(C_ARRVAL_P(array));
		}
		CREX_VM_TAIL_CALL(CREX_ADD_ARRAY_ELEMENT_SPEC_TMP_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU));
	} else {
		ZVAL_ARR(array, crex_new_array(0));
		CREX_VM_NEXT_OPCODE();
	}
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_YIELD_SPEC_TMP_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	crex_generator *generator = crex_get_running_generator(EXECUTE_DATA_C);

	SAVE_OPLINE();
	if (UNEXPECTED(generator->flags & CREX_GENERATOR_FORCED_CLOSE)) {
		CREX_VM_TAIL_CALL(crex_yield_in_closed_generator_helper_SPEC(CREX_OPCODE_HANDLER_ARGS_PASSTHRU));
	}

	/* Destroy the previously yielded value */
	zval_ptr_dtor(&generator->value);

	/* Destroy the previously yielded key */
	zval_ptr_dtor(&generator->key);

	/* Set the new yielded value */
	if (IS_TMP_VAR != IS_UNUSED) {
		if (UNEXPECTED(EX(func)->op_array.fn_flags & CREX_ACC_RETURN_REFERENCE)) {
			/* Constants and temporary variables aren't yieldable by reference,
			 * but we still allow them with a notice. */
			if (IS_TMP_VAR & (IS_CONST|IS_TMP_VAR)) {
				zval *value;

				crex_error(E_NOTICE, "Only variable references should be yielded by reference");

				value = _get_zval_ptr_tmp(opline->op1.var EXECUTE_DATA_CC);
				ZVAL_COPY_VALUE(&generator->value, value);
				if (IS_TMP_VAR == IS_CONST) {
					if (UNEXPECTED(C_OPT_REFCOUNTED(generator->value))) {
						C_ADDREF(generator->value);
					}
				}
			} else {
				zval *value_ptr = crex_get_bad_ptr();

				/* If a function call result is yielded and the function did
				 * not return by reference we throw a notice. */
				do {
					if (IS_TMP_VAR == IS_VAR) {
						CREX_ASSERT(value_ptr != &EG(uninitialized_zval));
						if (opline->extended_value == CREX_RETURNS_FUNCTION
						 && !C_ISREF_P(value_ptr)) {
							crex_error(E_NOTICE, "Only variable references should be yielded by reference");
							ZVAL_COPY(&generator->value, value_ptr);
							break;
						}
					}
					if (C_ISREF_P(value_ptr)) {
						C_ADDREF_P(value_ptr);
					} else {
						ZVAL_MAKE_REF_EX(value_ptr, 2);
					}
					ZVAL_REF(&generator->value, C_REF_P(value_ptr));
				} while (0);

				zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
			}
		} else {
			zval *value = _get_zval_ptr_tmp(opline->op1.var EXECUTE_DATA_CC);

			/* Consts, temporary variables and references need copying */
			if (IS_TMP_VAR == IS_CONST) {
				ZVAL_COPY_VALUE(&generator->value, value);
				if (UNEXPECTED(C_OPT_REFCOUNTED(generator->value))) {
					C_ADDREF(generator->value);
				}
			} else if (IS_TMP_VAR == IS_TMP_VAR) {
				ZVAL_COPY_VALUE(&generator->value, value);
			} else if ((IS_TMP_VAR & (IS_VAR|IS_CV)) && C_ISREF_P(value)) {
				ZVAL_COPY(&generator->value, C_REFVAL_P(value));

			} else {
				ZVAL_COPY_VALUE(&generator->value, value);
				if (IS_TMP_VAR == IS_CV) {
					if (C_OPT_REFCOUNTED_P(value)) C_ADDREF_P(value);
				}
			}
		}
	} else {
		/* If no value was specified yield null */
		ZVAL_NULL(&generator->value);
	}

	/* Set the new yielded key */
	if (IS_UNUSED != IS_UNUSED) {
		zval *key = NULL;
		if ((IS_UNUSED & (IS_CV|IS_VAR)) && UNEXPECTED(C_TYPE_P(key) == IS_REFERENCE)) {
			key = C_REFVAL_P(key);
		}
		ZVAL_COPY(&generator->key, key);

		if (C_TYPE(generator->key) == IS_LONG
		    && C_LVAL(generator->key) > generator->largest_used_integer_key
		) {
			generator->largest_used_integer_key = C_LVAL(generator->key);
		}
	} else {
		/* If no key was specified we use auto-increment keys */
		generator->largest_used_integer_key++;
		ZVAL_LONG(&generator->key, generator->largest_used_integer_key);
	}

	if (RETURN_VALUE_USED(opline)) {
		/* If the return value of yield is used set the send
		 * target and initialize it to NULL */
		generator->send_target = EX_VAR(opline->result.var);
		ZVAL_NULL(generator->send_target);
	} else {
		generator->send_target = NULL;
	}

	/* We increment to the next op, so we are at the correct position when the
	 * generator is resumed. */
	CREX_VM_INC_OPCODE();

	/* The GOTO VM uses a local opline variable. We need to set the opline
	 * variable in execute_data so we don't resume at an old position. */
	SAVE_OPLINE();

	CREX_VM_RETURN();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_GET_TYPE_SPEC_TMP_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1;
	crex_string *type;

	SAVE_OPLINE();
	op1 = _get_zval_ptr_tmp(opline->op1.var EXECUTE_DATA_CC);
	type = crex_zval_get_legacy_type(op1);
	if (EXPECTED(type)) {
		ZVAL_INTERNED_STR(EX_VAR(opline->result.var), type);
	} else {
		ZVAL_STRING(EX_VAR(opline->result.var), "unknown type");
	}
	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_CASE_STRICT_SPEC_TMP_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	bool result;

	SAVE_OPLINE();
	op1 = _get_zval_ptr_tmp(opline->op1.var EXECUTE_DATA_CC);
	op2 = _get_zval_ptr_cv_deref_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC);
	result = fast_is_identical_function(op1, op2);

	CREX_VM_SMART_BRANCH(result, 1);
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FETCH_DIM_FUNC_ARG_SPEC_TMP_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
#if 0
	USE_OPLINE
#endif

	if (UNEXPECTED(CREX_CALL_INFO(EX(call)) & CREX_CALL_SEND_ARG_BY_REF)) {
		if ((IS_TMP_VAR & (IS_CONST|IS_TMP_VAR))) {
			CREX_VM_TAIL_CALL(crex_use_tmp_in_write_context_helper_SPEC(CREX_OPCODE_HANDLER_ARGS_PASSTHRU));
		}
		CREX_VM_TAIL_CALL(CREX_NULL_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU));
	} else {
		if (IS_CV == IS_UNUSED) {
			CREX_VM_TAIL_CALL(crex_use_undef_in_read_context_helper_SPEC(CREX_OPCODE_HANDLER_ARGS_PASSTHRU));
		}
		CREX_VM_TAIL_CALL(CREX_FETCH_DIM_R_SPEC_TMPVAR_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU));
	}
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FETCH_OBJ_FUNC_ARG_SPEC_TMP_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
#if 0
	USE_OPLINE
#endif

	if (UNEXPECTED(CREX_CALL_INFO(EX(call)) & CREX_CALL_SEND_ARG_BY_REF)) {
		/* Behave like FETCH_OBJ_W */
		if ((IS_TMP_VAR & (IS_CONST|IS_TMP_VAR))) {
			CREX_VM_TAIL_CALL(crex_use_tmp_in_write_context_helper_SPEC(CREX_OPCODE_HANDLER_ARGS_PASSTHRU));
		}
		CREX_VM_TAIL_CALL(CREX_NULL_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU));
	} else {
		CREX_VM_TAIL_CALL(CREX_FETCH_OBJ_R_SPEC_TMPVAR_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU));
	}
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ROPE_ADD_SPEC_TMP_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	crex_string **rope;
	zval *var;

	/* op1 and result are the same */
	rope = (crex_string**)EX_VAR(opline->op1.var);
	if (IS_CV == IS_CONST) {
		var = _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC);
		rope[opline->extended_value] = C_STR_P(var);
		if (UNEXPECTED(C_REFCOUNTED_P(var))) {
			C_ADDREF_P(var);
		}
	} else {
		var = EX_VAR(opline->op2.var);
		if (EXPECTED(C_TYPE_P(var) == IS_STRING)) {
			if (IS_CV == IS_CV) {
				rope[opline->extended_value] = crex_string_copy(C_STR_P(var));
			} else {
				rope[opline->extended_value] = C_STR_P(var);
			}
		} else {
			SAVE_OPLINE();
			if (IS_CV == IS_CV && UNEXPECTED(C_TYPE_P(var) == IS_UNDEF)) {
				ZVAL_UNDEFINED_OP2();
			}
			rope[opline->extended_value] = zval_get_string_func(var);

			CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
		}
	}
	CREX_VM_NEXT_OPCODE();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ROPE_END_SPEC_TMP_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	crex_string **rope;
	zval *var, *ret;
	uint32_t i;

	rope = (crex_string**)EX_VAR(opline->op1.var);
	if (IS_CV == IS_CONST) {
		var = _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC);
		rope[opline->extended_value] = C_STR_P(var);
		if (UNEXPECTED(C_REFCOUNTED_P(var))) {
			C_ADDREF_P(var);
		}
	} else {
		var = EX_VAR(opline->op2.var);
		if (EXPECTED(C_TYPE_P(var) == IS_STRING)) {
			if (IS_CV == IS_CV) {
				rope[opline->extended_value] = crex_string_copy(C_STR_P(var));
			} else {
				rope[opline->extended_value] = C_STR_P(var);
			}
		} else {
			SAVE_OPLINE();
			if (IS_CV == IS_CV && UNEXPECTED(C_TYPE_P(var) == IS_UNDEF)) {
				ZVAL_UNDEFINED_OP2();
			}
			rope[opline->extended_value] = zval_get_string_func(var);

			if (UNEXPECTED(EG(exception))) {
				for (i = 0; i <= opline->extended_value; i++) {
					crex_string_release_ex(rope[i], 0);
				}
				ZVAL_UNDEF(EX_VAR(opline->result.var));
				HANDLE_EXCEPTION();
			}
		}
	}

	size_t len = 0;
	uint32_t flags = ZSTR_COPYABLE_CONCAT_PROPERTIES;
	for (i = 0; i <= opline->extended_value; i++) {
		flags &= ZSTR_GET_COPYABLE_CONCAT_PROPERTIES(rope[i]);
		len += ZSTR_LEN(rope[i]);
	}
	ret = EX_VAR(opline->result.var);
	ZVAL_STR(ret, crex_string_alloc(len, 0));
	GC_ADD_FLAGS(C_STR_P(ret), flags);

	char *target = C_STRVAL_P(ret);
	for (i = 0; i <= opline->extended_value; i++) {
		memcpy(target, ZSTR_VAL(rope[i]), ZSTR_LEN(rope[i]));
		target += ZSTR_LEN(rope[i]);
		crex_string_release_ex(rope[i], 0);
	}
	*target = '\0';

	CREX_VM_NEXT_OPCODE();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ADD_ARRAY_ELEMENT_SPEC_TMP_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *expr_ptr, new_expr;

	SAVE_OPLINE();
	if ((IS_TMP_VAR == IS_VAR || IS_TMP_VAR == IS_CV) &&
	    UNEXPECTED(opline->extended_value & CREX_ARRAY_ELEMENT_REF)) {
		expr_ptr = crex_get_bad_ptr();
		if (C_ISREF_P(expr_ptr)) {
			C_ADDREF_P(expr_ptr);
		} else {
			ZVAL_MAKE_REF_EX(expr_ptr, 2);
		}
		zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	} else {
		expr_ptr = _get_zval_ptr_tmp(opline->op1.var EXECUTE_DATA_CC);
		if (IS_TMP_VAR == IS_TMP_VAR) {
			/* pass */
		} else if (IS_TMP_VAR == IS_CONST) {
			C_TRY_ADDREF_P(expr_ptr);
		} else if (IS_TMP_VAR == IS_CV) {
			ZVAL_DEREF(expr_ptr);
			C_TRY_ADDREF_P(expr_ptr);
		} else /* if (IS_TMP_VAR == IS_VAR) */ {
			if (UNEXPECTED(C_ISREF_P(expr_ptr))) {
				crex_refcounted *ref = C_COUNTED_P(expr_ptr);

				expr_ptr = C_REFVAL_P(expr_ptr);
				if (UNEXPECTED(GC_DELREF(ref) == 0)) {
					ZVAL_COPY_VALUE(&new_expr, expr_ptr);
					expr_ptr = &new_expr;
					efree_size(ref, sizeof(crex_reference));
				} else if (C_OPT_REFCOUNTED_P(expr_ptr)) {
					C_ADDREF_P(expr_ptr);
				}
			}
		}
	}

	if (IS_CV != IS_UNUSED) {
		zval *offset = EX_VAR(opline->op2.var);
		crex_string *str;
		crex_ulong hval;

add_again:
		if (EXPECTED(C_TYPE_P(offset) == IS_STRING)) {
			str = C_STR_P(offset);
			if (IS_CV != IS_CONST) {
				if (CREX_HANDLE_NUMERIC(str, hval)) {
					goto num_index;
				}
			}
str_index:
			crex_hash_update(C_ARRVAL_P(EX_VAR(opline->result.var)), str, expr_ptr);
		} else if (EXPECTED(C_TYPE_P(offset) == IS_LONG)) {
			hval = C_LVAL_P(offset);
num_index:
			crex_hash_index_update(C_ARRVAL_P(EX_VAR(opline->result.var)), hval, expr_ptr);
		} else if ((IS_CV & (IS_VAR|IS_CV)) && EXPECTED(C_TYPE_P(offset) == IS_REFERENCE)) {
			offset = C_REFVAL_P(offset);
			goto add_again;
		} else if (C_TYPE_P(offset) == IS_NULL) {
			str = ZSTR_EMPTY_ALLOC();
			goto str_index;
		} else if (C_TYPE_P(offset) == IS_DOUBLE) {
			hval = crex_dval_to_lval_safe(C_DVAL_P(offset));
			goto num_index;
		} else if (C_TYPE_P(offset) == IS_FALSE) {
			hval = 0;
			goto num_index;
		} else if (C_TYPE_P(offset) == IS_TRUE) {
			hval = 1;
			goto num_index;
		} else if (C_TYPE_P(offset) == IS_RESOURCE) {
			crex_use_resource_as_offset(offset);
			hval = C_RES_HANDLE_P(offset);
			goto num_index;
		} else if (IS_CV == IS_CV && C_TYPE_P(offset) == IS_UNDEF) {
			ZVAL_UNDEFINED_OP2();
			str = ZSTR_EMPTY_ALLOC();
			goto str_index;
		} else {
			crex_illegal_array_offset_access(offset);
			zval_ptr_dtor_nogc(expr_ptr);
		}

	} else {
		if (!crex_hash_next_index_insert(C_ARRVAL_P(EX_VAR(opline->result.var)), expr_ptr)) {
			crex_cannot_add_element();
			zval_ptr_dtor_nogc(expr_ptr);
		}
	}
	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_INIT_ARRAY_SPEC_TMP_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	zval *array;
	uint32_t size;
	USE_OPLINE

	array = EX_VAR(opline->result.var);
	if (IS_TMP_VAR != IS_UNUSED) {
		size = opline->extended_value >> CREX_ARRAY_SIZE_SHIFT;
		ZVAL_ARR(array, crex_new_array(size));
		/* Explicitly initialize array as not-packed if flag is set */
		if (opline->extended_value & CREX_ARRAY_NOT_PACKED) {
			crex_hash_real_init_mixed(C_ARRVAL_P(array));
		}
		CREX_VM_TAIL_CALL(CREX_ADD_ARRAY_ELEMENT_SPEC_TMP_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU));
	} else {
		ZVAL_ARR(array, crex_new_array(0));
		CREX_VM_NEXT_OPCODE();
	}
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_YIELD_SPEC_TMP_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	crex_generator *generator = crex_get_running_generator(EXECUTE_DATA_C);

	SAVE_OPLINE();
	if (UNEXPECTED(generator->flags & CREX_GENERATOR_FORCED_CLOSE)) {
		CREX_VM_TAIL_CALL(crex_yield_in_closed_generator_helper_SPEC(CREX_OPCODE_HANDLER_ARGS_PASSTHRU));
	}

	/* Destroy the previously yielded value */
	zval_ptr_dtor(&generator->value);

	/* Destroy the previously yielded key */
	zval_ptr_dtor(&generator->key);

	/* Set the new yielded value */
	if (IS_TMP_VAR != IS_UNUSED) {
		if (UNEXPECTED(EX(func)->op_array.fn_flags & CREX_ACC_RETURN_REFERENCE)) {
			/* Constants and temporary variables aren't yieldable by reference,
			 * but we still allow them with a notice. */
			if (IS_TMP_VAR & (IS_CONST|IS_TMP_VAR)) {
				zval *value;

				crex_error(E_NOTICE, "Only variable references should be yielded by reference");

				value = _get_zval_ptr_tmp(opline->op1.var EXECUTE_DATA_CC);
				ZVAL_COPY_VALUE(&generator->value, value);
				if (IS_TMP_VAR == IS_CONST) {
					if (UNEXPECTED(C_OPT_REFCOUNTED(generator->value))) {
						C_ADDREF(generator->value);
					}
				}
			} else {
				zval *value_ptr = crex_get_bad_ptr();

				/* If a function call result is yielded and the function did
				 * not return by reference we throw a notice. */
				do {
					if (IS_TMP_VAR == IS_VAR) {
						CREX_ASSERT(value_ptr != &EG(uninitialized_zval));
						if (opline->extended_value == CREX_RETURNS_FUNCTION
						 && !C_ISREF_P(value_ptr)) {
							crex_error(E_NOTICE, "Only variable references should be yielded by reference");
							ZVAL_COPY(&generator->value, value_ptr);
							break;
						}
					}
					if (C_ISREF_P(value_ptr)) {
						C_ADDREF_P(value_ptr);
					} else {
						ZVAL_MAKE_REF_EX(value_ptr, 2);
					}
					ZVAL_REF(&generator->value, C_REF_P(value_ptr));
				} while (0);

				zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
			}
		} else {
			zval *value = _get_zval_ptr_tmp(opline->op1.var EXECUTE_DATA_CC);

			/* Consts, temporary variables and references need copying */
			if (IS_TMP_VAR == IS_CONST) {
				ZVAL_COPY_VALUE(&generator->value, value);
				if (UNEXPECTED(C_OPT_REFCOUNTED(generator->value))) {
					C_ADDREF(generator->value);
				}
			} else if (IS_TMP_VAR == IS_TMP_VAR) {
				ZVAL_COPY_VALUE(&generator->value, value);
			} else if ((IS_TMP_VAR & (IS_VAR|IS_CV)) && C_ISREF_P(value)) {
				ZVAL_COPY(&generator->value, C_REFVAL_P(value));

			} else {
				ZVAL_COPY_VALUE(&generator->value, value);
				if (IS_TMP_VAR == IS_CV) {
					if (C_OPT_REFCOUNTED_P(value)) C_ADDREF_P(value);
				}
			}
		}
	} else {
		/* If no value was specified yield null */
		ZVAL_NULL(&generator->value);
	}

	/* Set the new yielded key */
	if (IS_CV != IS_UNUSED) {
		zval *key = _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC);
		if ((IS_CV & (IS_CV|IS_VAR)) && UNEXPECTED(C_TYPE_P(key) == IS_REFERENCE)) {
			key = C_REFVAL_P(key);
		}
		ZVAL_COPY(&generator->key, key);

		if (C_TYPE(generator->key) == IS_LONG
		    && C_LVAL(generator->key) > generator->largest_used_integer_key
		) {
			generator->largest_used_integer_key = C_LVAL(generator->key);
		}
	} else {
		/* If no key was specified we use auto-increment keys */
		generator->largest_used_integer_key++;
		ZVAL_LONG(&generator->key, generator->largest_used_integer_key);
	}

	if (RETURN_VALUE_USED(opline)) {
		/* If the return value of yield is used set the send
		 * target and initialize it to NULL */
		generator->send_target = EX_VAR(opline->result.var);
		ZVAL_NULL(generator->send_target);
	} else {
		generator->send_target = NULL;
	}

	/* We increment to the next op, so we are at the correct position when the
	 * generator is resumed. */
	CREX_VM_INC_OPCODE();

	/* The GOTO VM uses a local opline variable. We need to set the opline
	 * variable in execute_data so we don't resume at an old position. */
	SAVE_OPLINE();

	CREX_VM_RETURN();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_BIND_LEXICAL_SPEC_TMP_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *closure, *var;

	closure = _get_zval_ptr_tmp(opline->op1.var EXECUTE_DATA_CC);
	if (opline->extended_value & CREX_BIND_REF) {
		/* By-ref binding */
		var = _get_zval_ptr_cv_BP_VAR_W(opline->op2.var EXECUTE_DATA_CC);
		if (C_ISREF_P(var)) {
			C_ADDREF_P(var);
		} else {
			ZVAL_MAKE_REF_EX(var, 2);
		}
	} else {
		var = EX_VAR(opline->op2.var);
		if (UNEXPECTED(C_ISUNDEF_P(var)) && !(opline->extended_value & CREX_BIND_IMPLICIT)) {
			SAVE_OPLINE();
			var = ZVAL_UNDEFINED_OP2();
			if (UNEXPECTED(EG(exception))) {
				HANDLE_EXCEPTION();
			}
		}
		ZVAL_DEREF(var);
		C_TRY_ADDREF_P(var);
	}

	crex_closure_bind_var_ex(closure,
		(opline->extended_value & ~(CREX_BIND_REF|CREX_BIND_IMPLICIT)), var);
	CREX_VM_NEXT_OPCODE();
}

static crex_never_inline CREX_OPCODE_HANDLER_RET CREX_FASTCALL crex_pre_inc_helper_SPEC_VAR(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *var_ptr;

	var_ptr = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);

	SAVE_OPLINE();
	if (IS_VAR == IS_CV && UNEXPECTED(C_TYPE_P(var_ptr) == IS_UNDEF)) {
		ZVAL_UNDEFINED_OP1();
		ZVAL_NULL(var_ptr);
	}

	do {
		if (UNEXPECTED(C_TYPE_P(var_ptr) == IS_REFERENCE)) {
			crex_reference *ref = C_REF_P(var_ptr);
			var_ptr = C_REFVAL_P(var_ptr);
			if (UNEXPECTED(CREX_REF_HAS_TYPE_SOURCES(ref))) {
				crex_incdec_typed_ref(ref, NULL OPLINE_CC EXECUTE_DATA_CC);
				break;
			}
		}
		increment_function(var_ptr);
	} while (0);

	if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
		ZVAL_COPY(EX_VAR(opline->result.var), var_ptr);
	}

	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_VM_HOT CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_PRE_INC_SPEC_VAR_RETVAL_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *var_ptr;

	var_ptr = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);

	if (EXPECTED(C_TYPE_P(var_ptr) == IS_LONG)) {
		fast_long_increment_function(var_ptr);
		if (UNEXPECTED(0)) {
			ZVAL_COPY_VALUE(EX_VAR(opline->result.var), var_ptr);
		}
		CREX_VM_NEXT_OPCODE();
	}

	CREX_VM_TAIL_CALL(crex_pre_inc_helper_SPEC_VAR(CREX_OPCODE_HANDLER_ARGS_PASSTHRU));
}

static CREX_VM_HOT CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_PRE_INC_SPEC_VAR_RETVAL_USED_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *var_ptr;

	var_ptr = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);

	if (EXPECTED(C_TYPE_P(var_ptr) == IS_LONG)) {
		fast_long_increment_function(var_ptr);
		if (UNEXPECTED(1)) {
			ZVAL_COPY_VALUE(EX_VAR(opline->result.var), var_ptr);
		}
		CREX_VM_NEXT_OPCODE();
	}

	CREX_VM_TAIL_CALL(crex_pre_inc_helper_SPEC_VAR(CREX_OPCODE_HANDLER_ARGS_PASSTHRU));
}

static crex_never_inline CREX_OPCODE_HANDLER_RET CREX_FASTCALL crex_pre_dec_helper_SPEC_VAR(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *var_ptr;

	var_ptr = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);

	SAVE_OPLINE();
	if (IS_VAR == IS_CV && UNEXPECTED(C_TYPE_P(var_ptr) == IS_UNDEF)) {
		ZVAL_UNDEFINED_OP1();
		ZVAL_NULL(var_ptr);
	}

	do {
		if (UNEXPECTED(C_TYPE_P(var_ptr) == IS_REFERENCE)) {
			crex_reference *ref = C_REF_P(var_ptr);
			var_ptr = C_REFVAL_P(var_ptr);

			if (UNEXPECTED(CREX_REF_HAS_TYPE_SOURCES(ref))) {
				crex_incdec_typed_ref(ref, NULL OPLINE_CC EXECUTE_DATA_CC);
				break;
			}
		}
		decrement_function(var_ptr);
	} while (0);

	if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
		ZVAL_COPY(EX_VAR(opline->result.var), var_ptr);
	}

	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_VM_HOT CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_PRE_DEC_SPEC_VAR_RETVAL_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *var_ptr;

	var_ptr = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);

	if (EXPECTED(C_TYPE_P(var_ptr) == IS_LONG)) {
		fast_long_decrement_function(var_ptr);
		if (UNEXPECTED(0)) {
			ZVAL_COPY_VALUE(EX_VAR(opline->result.var), var_ptr);
		}
		CREX_VM_NEXT_OPCODE();
	}

	CREX_VM_TAIL_CALL(crex_pre_dec_helper_SPEC_VAR(CREX_OPCODE_HANDLER_ARGS_PASSTHRU));
}

static CREX_VM_HOT CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_PRE_DEC_SPEC_VAR_RETVAL_USED_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *var_ptr;

	var_ptr = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);

	if (EXPECTED(C_TYPE_P(var_ptr) == IS_LONG)) {
		fast_long_decrement_function(var_ptr);
		if (UNEXPECTED(1)) {
			ZVAL_COPY_VALUE(EX_VAR(opline->result.var), var_ptr);
		}
		CREX_VM_NEXT_OPCODE();
	}

	CREX_VM_TAIL_CALL(crex_pre_dec_helper_SPEC_VAR(CREX_OPCODE_HANDLER_ARGS_PASSTHRU));
}

static crex_never_inline CREX_OPCODE_HANDLER_RET CREX_FASTCALL crex_post_inc_helper_SPEC_VAR(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *var_ptr;

	var_ptr = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);

	SAVE_OPLINE();
	if (IS_VAR == IS_CV && UNEXPECTED(C_TYPE_P(var_ptr) == IS_UNDEF)) {
		ZVAL_UNDEFINED_OP1();
		ZVAL_NULL(var_ptr);
	}

	do {
		if (UNEXPECTED(C_TYPE_P(var_ptr) == IS_REFERENCE)) {
			crex_reference *ref = C_REF_P(var_ptr);
			var_ptr = C_REFVAL_P(var_ptr);

			if (UNEXPECTED(CREX_REF_HAS_TYPE_SOURCES(ref))) {
				crex_incdec_typed_ref(ref, EX_VAR(opline->result.var) OPLINE_CC EXECUTE_DATA_CC);
				break;
			}
		}
		ZVAL_COPY(EX_VAR(opline->result.var), var_ptr);

		increment_function(var_ptr);
	} while (0);

	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_VM_HOT CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_POST_INC_SPEC_VAR_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *var_ptr;

	var_ptr = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);

	if (EXPECTED(C_TYPE_P(var_ptr) == IS_LONG)) {
		ZVAL_LONG(EX_VAR(opline->result.var), C_LVAL_P(var_ptr));
		fast_long_increment_function(var_ptr);
		CREX_VM_NEXT_OPCODE();
	}

	CREX_VM_TAIL_CALL(crex_post_inc_helper_SPEC_VAR(CREX_OPCODE_HANDLER_ARGS_PASSTHRU));
}

static crex_never_inline CREX_OPCODE_HANDLER_RET CREX_FASTCALL crex_post_dec_helper_SPEC_VAR(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *var_ptr;

	var_ptr = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);

	SAVE_OPLINE();
	if (IS_VAR == IS_CV && UNEXPECTED(C_TYPE_P(var_ptr) == IS_UNDEF)) {
		ZVAL_UNDEFINED_OP1();
		ZVAL_NULL(var_ptr);
	}

	do {
		if (UNEXPECTED(C_TYPE_P(var_ptr) == IS_REFERENCE)) {
			crex_reference *ref = C_REF_P(var_ptr);
			var_ptr = C_REFVAL_P(var_ptr);

			if (UNEXPECTED(CREX_REF_HAS_TYPE_SOURCES(ref))) {
				crex_incdec_typed_ref(ref, EX_VAR(opline->result.var) OPLINE_CC EXECUTE_DATA_CC);
				break;
			}
		}
		ZVAL_COPY(EX_VAR(opline->result.var), var_ptr);

		decrement_function(var_ptr);
	} while (0);

	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_VM_HOT CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_POST_DEC_SPEC_VAR_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *var_ptr;

	var_ptr = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);

	if (EXPECTED(C_TYPE_P(var_ptr) == IS_LONG)) {
		ZVAL_LONG(EX_VAR(opline->result.var), C_LVAL_P(var_ptr));
		fast_long_decrement_function(var_ptr);
		CREX_VM_NEXT_OPCODE();
	}

	CREX_VM_TAIL_CALL(crex_post_dec_helper_SPEC_VAR(CREX_OPCODE_HANDLER_ARGS_PASSTHRU));
}

static CREX_VM_HOT CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_RETURN_SPEC_VAR_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *retval_ptr;
	zval *return_value;

	retval_ptr = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	return_value = EX(return_value);

	if (IS_VAR == IS_CV && UNEXPECTED(C_TYPE_INFO_P(retval_ptr) == IS_UNDEF)) {
		SAVE_OPLINE();
		retval_ptr = ZVAL_UNDEFINED_OP1();
		if (return_value) {
			ZVAL_NULL(return_value);
		}
	} else if (!return_value) {
		if (IS_VAR & (IS_VAR|IS_TMP_VAR)) {
			if (C_REFCOUNTED_P(retval_ptr) && !C_DELREF_P(retval_ptr)) {
				SAVE_OPLINE();
				rc_dtor_func(C_COUNTED_P(retval_ptr));
			}
		}
	} else {
		if ((IS_VAR & (IS_CONST|IS_TMP_VAR))) {
			ZVAL_COPY_VALUE(return_value, retval_ptr);
			if (IS_VAR == IS_CONST) {
				if (UNEXPECTED(C_OPT_REFCOUNTED_P(return_value))) {
					C_ADDREF_P(return_value);
				}
			}
		} else if (IS_VAR == IS_CV) {
			do {
				if (C_OPT_REFCOUNTED_P(retval_ptr)) {
					if (EXPECTED(!C_OPT_ISREF_P(retval_ptr))) {
						if (EXPECTED(!(EX_CALL_INFO() & (CREX_CALL_CODE|CREX_CALL_OBSERVED)))) {
							crex_refcounted *ref = C_COUNTED_P(retval_ptr);
							ZVAL_COPY_VALUE(return_value, retval_ptr);
							if (GC_MAY_LEAK(ref)) {
								SAVE_OPLINE();
								gc_possible_root(ref);
							}
							ZVAL_NULL(retval_ptr);
							break;
						} else {
							C_ADDREF_P(retval_ptr);
						}
					} else {
						retval_ptr = C_REFVAL_P(retval_ptr);
						if (C_OPT_REFCOUNTED_P(retval_ptr)) {
							C_ADDREF_P(retval_ptr);
						}
					}
				}
				ZVAL_COPY_VALUE(return_value, retval_ptr);
			} while (0);
		} else /* if (IS_VAR == IS_VAR) */ {
			if (UNEXPECTED(C_ISREF_P(retval_ptr))) {
				crex_refcounted *ref = C_COUNTED_P(retval_ptr);

				retval_ptr = C_REFVAL_P(retval_ptr);
				ZVAL_COPY_VALUE(return_value, retval_ptr);
				if (UNEXPECTED(GC_DELREF(ref) == 0)) {
					efree_size(ref, sizeof(crex_reference));
				} else if (C_OPT_REFCOUNTED_P(retval_ptr)) {
					C_ADDREF_P(retval_ptr);
				}
			} else {
				ZVAL_COPY_VALUE(return_value, retval_ptr);
			}
		}
	}



	CREX_VM_TAIL_CALL(crex_leave_helper_SPEC(CREX_OPCODE_HANDLER_ARGS_PASSTHRU));
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_RETURN_BY_REF_SPEC_VAR_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *retval_ptr;
	zval *return_value;

	SAVE_OPLINE();

	return_value = EX(return_value);

	do {
		if ((IS_VAR & (IS_CONST|IS_TMP_VAR)) ||
		    (IS_VAR == IS_VAR && opline->extended_value == CREX_RETURNS_VALUE)) {
			/* Not supposed to happen, but we'll allow it */
			crex_error(E_NOTICE, "Only variable references should be returned by reference");

			retval_ptr = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);
			if (!return_value) {
				zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
			} else {
				if (IS_VAR == IS_VAR && UNEXPECTED(C_ISREF_P(retval_ptr))) {
					ZVAL_COPY_VALUE(return_value, retval_ptr);
					break;
				}

				ZVAL_NEW_REF(return_value, retval_ptr);
				if (IS_VAR == IS_CONST) {
					C_TRY_ADDREF_P(retval_ptr);
				}
			}
			break;
		}

		retval_ptr = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);

		if (IS_VAR == IS_VAR) {
			CREX_ASSERT(retval_ptr != &EG(uninitialized_zval));
			if (opline->extended_value == CREX_RETURNS_FUNCTION && !C_ISREF_P(retval_ptr)) {
				crex_error(E_NOTICE, "Only variable references should be returned by reference");
				if (return_value) {
					ZVAL_NEW_REF(return_value, retval_ptr);
				} else {
					zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
				}
				break;
			}
		}

		if (return_value) {
			if (C_ISREF_P(retval_ptr)) {
				C_ADDREF_P(retval_ptr);
			} else {
				ZVAL_MAKE_REF_EX(retval_ptr, 2);
			}
			ZVAL_REF(return_value, C_REF_P(retval_ptr));
		}

		zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	} while (0);


	CREX_VM_TAIL_CALL(crex_leave_helper_SPEC(CREX_OPCODE_HANDLER_ARGS_PASSTHRU));
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_GENERATOR_RETURN_SPEC_VAR_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *retval;

	crex_generator *generator = crex_get_running_generator(EXECUTE_DATA_C);

	SAVE_OPLINE();
	retval = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);

	/* Copy return value into generator->retval */
	if ((IS_VAR & (IS_CONST|IS_TMP_VAR))) {
		ZVAL_COPY_VALUE(&generator->retval, retval);
		if (IS_VAR == IS_CONST) {
			if (UNEXPECTED(C_OPT_REFCOUNTED(generator->retval))) {
				C_ADDREF(generator->retval);
			}
		}
	} else if (IS_VAR == IS_CV) {
		ZVAL_COPY_DEREF(&generator->retval, retval);
	} else /* if (IS_VAR == IS_VAR) */ {
		if (UNEXPECTED(C_ISREF_P(retval))) {
			crex_refcounted *ref = C_COUNTED_P(retval);

			retval = C_REFVAL_P(retval);
			ZVAL_COPY_VALUE(&generator->retval, retval);
			if (UNEXPECTED(GC_DELREF(ref) == 0)) {
				efree_size(ref, sizeof(crex_reference));
			} else if (C_OPT_REFCOUNTED_P(retval)) {
				C_ADDREF_P(retval);
			}
		} else {
			ZVAL_COPY_VALUE(&generator->retval, retval);
		}
	}

	EG(current_execute_data) = EX(prev_execute_data);

	/* Close the generator to free up resources */
	crex_generator_close(generator, 1);

	/* Pass execution back to handling code */
	CREX_VM_RETURN();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_SEND_USER_SPEC_VAR_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *arg, *param;

	SAVE_OPLINE();

	arg = _get_zval_ptr_var_deref(opline->op1.var EXECUTE_DATA_CC);
	param = CREX_CALL_VAR(EX(call), opline->result.var);
	if (UNEXPECTED(ARG_MUST_BE_SENT_BY_REF(EX(call)->func, opline->op2.num))) {
		crex_param_must_be_ref(EX(call)->func, opline->op2.num);
		C_TRY_ADDREF_P(arg);
		ZVAL_NEW_REF(param, arg);
	} else {
		ZVAL_COPY(param, arg);
	}

	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_CAST_SPEC_VAR_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *expr;
	zval *result = EX_VAR(opline->result.var);
	HashTable *ht;

	SAVE_OPLINE();
	expr = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);

	switch (opline->extended_value) {
		case IS_LONG:
			ZVAL_LONG(result, zval_get_long(expr));
			break;
		case IS_DOUBLE:
			ZVAL_DOUBLE(result, zval_get_double(expr));
			break;
		case IS_STRING:
			ZVAL_STR(result, zval_get_string(expr));
			break;
		default:
			CREX_ASSERT(opline->extended_value != _IS_BOOL && "Must use CREX_BOOL instead");
			if (IS_VAR & (IS_VAR|IS_CV)) {
				ZVAL_DEREF(expr);
			}
			/* If value is already of correct type, return it directly */
			if (C_TYPE_P(expr) == opline->extended_value) {
				ZVAL_COPY_VALUE(result, expr);
				if (IS_VAR == IS_CONST) {
					if (UNEXPECTED(C_OPT_REFCOUNTED_P(result))) C_ADDREF_P(result);
				} else if (IS_VAR != IS_TMP_VAR) {
					if (C_OPT_REFCOUNTED_P(result)) C_ADDREF_P(result);
				}

				zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
				CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
			}

			if (opline->extended_value == IS_ARRAY) {
				if (IS_VAR == IS_CONST || C_TYPE_P(expr) != IS_OBJECT || C_OBJCE_P(expr) == crex_ce_closure) {
					if (C_TYPE_P(expr) != IS_NULL) {
						ZVAL_ARR(result, crex_new_array(1));
						expr = crex_hash_index_add_new(C_ARRVAL_P(result), 0, expr);
						if (IS_VAR == IS_CONST) {
							if (UNEXPECTED(C_OPT_REFCOUNTED_P(expr))) C_ADDREF_P(expr);
						} else {
							if (C_OPT_REFCOUNTED_P(expr)) C_ADDREF_P(expr);
						}
					} else {
						ZVAL_EMPTY_ARRAY(result);
					}
				} else if (C_OBJ_P(expr)->properties == NULL
				 && C_OBJ_HT_P(expr)->get_properties_for == NULL
				 && C_OBJ_HT_P(expr)->get_properties == crex_std_get_properties) {
					/* Optimized version without rebuilding properties HashTable */
					ZVAL_ARR(result, crex_std_build_object_properties_array(C_OBJ_P(expr)));
				} else {
					HashTable *obj_ht = crex_get_properties_for(expr, CREX_PROP_PURPOSE_ARRAY_CAST);
					if (obj_ht) {
						/* fast copy */
						ZVAL_ARR(result, crex_proptable_to_symtable(obj_ht,
							(C_OBJCE_P(expr)->default_properties_count ||
							 C_OBJ_P(expr)->handlers != &std_object_handlers ||
							 GC_IS_RECURSIVE(obj_ht))));
						crex_release_properties(obj_ht);
					} else {
						ZVAL_EMPTY_ARRAY(result);
					}
				}
			} else {
				CREX_ASSERT(opline->extended_value == IS_OBJECT);
				ZVAL_OBJ(result, crex_objects_new(crex_standard_class_def));
				if (C_TYPE_P(expr) == IS_ARRAY) {
					ht = crex_symtable_to_proptable(C_ARR_P(expr));
					if (GC_FLAGS(ht) & IS_ARRAY_IMMUTABLE) {
						/* TODO: try not to duplicate immutable arrays as well ??? */
						ht = crex_array_dup(ht);
					}
					C_OBJ_P(result)->properties = ht;
				} else if (C_TYPE_P(expr) != IS_NULL) {
					C_OBJ_P(result)->properties = ht = crex_new_array(1);
					expr = crex_hash_add_new(ht, ZSTR_KNOWN(CREX_STR_SCALAR), expr);
					if (IS_VAR == IS_CONST) {
						if (UNEXPECTED(C_OPT_REFCOUNTED_P(expr))) C_ADDREF_P(expr);
					} else {
						if (C_OPT_REFCOUNTED_P(expr)) C_ADDREF_P(expr);
					}
				}
			}
	}

	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FE_RESET_R_SPEC_VAR_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *array_ptr, *result;

	SAVE_OPLINE();

	array_ptr = _get_zval_ptr_var_deref(opline->op1.var EXECUTE_DATA_CC);
	if (EXPECTED(C_TYPE_P(array_ptr) == IS_ARRAY)) {
		result = EX_VAR(opline->result.var);
		ZVAL_COPY_VALUE(result, array_ptr);
		if (IS_VAR != IS_TMP_VAR && C_OPT_REFCOUNTED_P(result)) {
			C_ADDREF_P(array_ptr);
		}
		C_FE_POS_P(result) = 0;

		zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
		CREX_VM_NEXT_OPCODE();
	} else if (IS_VAR != IS_CONST && EXPECTED(C_TYPE_P(array_ptr) == IS_OBJECT)) {
		crex_object *zobj = C_OBJ_P(array_ptr);
		if (!zobj->ce->get_iterator) {
			HashTable *properties = zobj->properties;
			if (properties) {
				if (UNEXPECTED(GC_REFCOUNT(properties) > 1)) {
					if (EXPECTED(!(GC_FLAGS(properties) & IS_ARRAY_IMMUTABLE))) {
						GC_DELREF(properties);
					}
					properties = zobj->properties = crex_array_dup(properties);
				}
			} else {
				properties = zobj->handlers->get_properties(zobj);
			}

			result = EX_VAR(opline->result.var);
			ZVAL_COPY_VALUE(result, array_ptr);
			if (IS_VAR != IS_TMP_VAR) {
				C_ADDREF_P(array_ptr);
			}

			if (crex_hash_num_elements(properties) == 0) {
				C_FE_ITER_P(result) = (uint32_t) -1;
				zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
				CREX_VM_JMP(OP_JMP_ADDR(opline, opline->op2));
			}

			C_FE_ITER_P(result) = crex_hash_iterator_add(properties, 0);
			zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
			CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
		} else {
			bool is_empty = crex_fe_reset_iterator(array_ptr, 0 OPLINE_CC EXECUTE_DATA_CC);

			zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
			if (UNEXPECTED(EG(exception))) {
				HANDLE_EXCEPTION();
			} else if (is_empty) {
				CREX_VM_JMP_EX(OP_JMP_ADDR(opline, opline->op2), 0);
			} else {
				CREX_VM_NEXT_OPCODE();
			}
		}
	} else {
		crex_error(E_WARNING, "foreach() argument must be of type array|object, %s given", crex_zval_value_name(array_ptr));
		ZVAL_UNDEF(EX_VAR(opline->result.var));
		C_FE_ITER_P(EX_VAR(opline->result.var)) = (uint32_t)-1;
		zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
		CREX_VM_JMP(OP_JMP_ADDR(opline, opline->op2));
	}
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FE_RESET_RW_SPEC_VAR_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *array_ptr, *array_ref;

	SAVE_OPLINE();

	if (IS_VAR == IS_VAR || IS_VAR == IS_CV) {
		array_ref = array_ptr = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);
		if (C_ISREF_P(array_ref)) {
			array_ptr = C_REFVAL_P(array_ref);
		}
	} else {
		array_ref = array_ptr = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	}

	if (EXPECTED(C_TYPE_P(array_ptr) == IS_ARRAY)) {
		if (IS_VAR == IS_VAR || IS_VAR == IS_CV) {
			if (array_ptr == array_ref) {
				ZVAL_NEW_REF(array_ref, array_ref);
				array_ptr = C_REFVAL_P(array_ref);
			}
			C_ADDREF_P(array_ref);
			ZVAL_COPY_VALUE(EX_VAR(opline->result.var), array_ref);
		} else {
			array_ref = EX_VAR(opline->result.var);
			ZVAL_NEW_REF(array_ref, array_ptr);
			array_ptr = C_REFVAL_P(array_ref);
		}
		if (IS_VAR == IS_CONST) {
			ZVAL_ARR(array_ptr, crex_array_dup(C_ARRVAL_P(array_ptr)));
		} else {
			SEPARATE_ARRAY(array_ptr);
		}
		C_FE_ITER_P(EX_VAR(opline->result.var)) = crex_hash_iterator_add(C_ARRVAL_P(array_ptr), 0);

		zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
		CREX_VM_NEXT_OPCODE();
	} else if (IS_VAR != IS_CONST && EXPECTED(C_TYPE_P(array_ptr) == IS_OBJECT)) {
		if (!C_OBJCE_P(array_ptr)->get_iterator) {
			HashTable *properties;
			if (IS_VAR == IS_VAR || IS_VAR == IS_CV) {
				if (array_ptr == array_ref) {
					ZVAL_NEW_REF(array_ref, array_ref);
					array_ptr = C_REFVAL_P(array_ref);
				}
				C_ADDREF_P(array_ref);
				ZVAL_COPY_VALUE(EX_VAR(opline->result.var), array_ref);
			} else {
				array_ptr = EX_VAR(opline->result.var);
				ZVAL_COPY_VALUE(array_ptr, array_ref);
			}
			if (C_OBJ_P(array_ptr)->properties
			 && UNEXPECTED(GC_REFCOUNT(C_OBJ_P(array_ptr)->properties) > 1)) {
				if (EXPECTED(!(GC_FLAGS(C_OBJ_P(array_ptr)->properties) & IS_ARRAY_IMMUTABLE))) {
					GC_DELREF(C_OBJ_P(array_ptr)->properties);
				}
				C_OBJ_P(array_ptr)->properties = crex_array_dup(C_OBJ_P(array_ptr)->properties);
			}

			properties = C_OBJPROP_P(array_ptr);
			if (crex_hash_num_elements(properties) == 0) {
				C_FE_ITER_P(EX_VAR(opline->result.var)) = (uint32_t) -1;
				zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
				CREX_VM_JMP(OP_JMP_ADDR(opline, opline->op2));
			}

			C_FE_ITER_P(EX_VAR(opline->result.var)) = crex_hash_iterator_add(properties, 0);
			zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
			CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
		} else {
			bool is_empty = crex_fe_reset_iterator(array_ptr, 1 OPLINE_CC EXECUTE_DATA_CC);
			zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
			if (UNEXPECTED(EG(exception))) {
				HANDLE_EXCEPTION();
			} else if (is_empty) {
				CREX_VM_JMP_EX(OP_JMP_ADDR(opline, opline->op2), 0);
			} else {
				CREX_VM_NEXT_OPCODE();
			}
		}
	} else {
		crex_error(E_WARNING, "foreach() argument must be of type array|object, %s given", crex_zval_value_name(array_ptr));
		ZVAL_UNDEF(EX_VAR(opline->result.var));
		C_FE_ITER_P(EX_VAR(opline->result.var)) = (uint32_t)-1;
		zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
		CREX_VM_JMP(OP_JMP_ADDR(opline, opline->op2));
	}
}

static CREX_VM_HOT CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FE_FETCH_R_SPEC_VAR_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *array;
	zval *value;
	uint32_t value_type;
	HashTable *fe_ht;
	HashPosition pos;

	array = EX_VAR(opline->op1.var);
	if (UNEXPECTED(C_TYPE_P(array) != IS_ARRAY)) {
		CREX_VM_TAIL_CALL(crex_fe_fetch_object_helper_SPEC(CREX_OPCODE_HANDLER_ARGS_PASSTHRU));
	}
	fe_ht = C_ARRVAL_P(array);
	pos = C_FE_POS_P(array);
	if (HT_IS_PACKED(fe_ht)) {
		value = fe_ht->arPacked + pos;
		while (1) {
			if (UNEXPECTED(pos >= fe_ht->nNumUsed)) {
				/* reached end of iteration */
				CREX_VM_SET_RELATIVE_OPCODE(opline, opline->extended_value);
				CREX_VM_CONTINUE();
			}
			value_type = C_TYPE_INFO_P(value);
			CREX_ASSERT(value_type != IS_INDIRECT);
			if (EXPECTED(value_type != IS_UNDEF)) {
				break;
			}
			pos++;
			value++;
		}
		C_FE_POS_P(array) = pos + 1;
		if (RETURN_VALUE_USED(opline)) {
			ZVAL_LONG(EX_VAR(opline->result.var), pos);
		}
	} else {
		Bucket *p;

		p = fe_ht->arData + pos;
		while (1) {
			if (UNEXPECTED(pos >= fe_ht->nNumUsed)) {
				/* reached end of iteration */
				CREX_VM_SET_RELATIVE_OPCODE(opline, opline->extended_value);
				CREX_VM_CONTINUE();
			}
			pos++;
			value = &p->val;
			value_type = C_TYPE_INFO_P(value);
			CREX_ASSERT(value_type != IS_INDIRECT);
			if (EXPECTED(value_type != IS_UNDEF)) {
				break;
			}
			p++;
		}
		C_FE_POS_P(array) = pos;
		if (RETURN_VALUE_USED(opline)) {
			if (!p->key) {
				ZVAL_LONG(EX_VAR(opline->result.var), p->h);
			} else {
				ZVAL_STR_COPY(EX_VAR(opline->result.var), p->key);
			}
		}
	}
	if (EXPECTED(opline->op2_type == IS_CV)) {
		zval *variable_ptr = EX_VAR(opline->op2.var);
		SAVE_OPLINE();
		crex_assign_to_variable(variable_ptr, value, IS_CV, EX_USES_STRICT_TYPES());
		CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
	} else {
		zval *res = EX_VAR(opline->op2.var);
		crex_refcounted *gc = C_COUNTED_P(value);

		ZVAL_COPY_VALUE_EX(res, value, gc, value_type);
		if (C_TYPE_INFO_REFCOUNTED(value_type)) {
			GC_ADDREF(gc);
		}
		CREX_VM_NEXT_OPCODE();
	}
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FE_FETCH_RW_SPEC_VAR_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *array;
	zval *value;
	uint32_t value_type;
	HashTable *fe_ht;
	HashPosition pos;
	Bucket *p;

	array = EX_VAR(opline->op1.var);
	SAVE_OPLINE();

	ZVAL_DEREF(array);
	if (EXPECTED(C_TYPE_P(array) == IS_ARRAY)) {
		pos = crex_hash_iterator_pos_ex(C_FE_ITER_P(EX_VAR(opline->op1.var)), array);
		fe_ht = C_ARRVAL_P(array);
		if (HT_IS_PACKED(fe_ht)) {
			value = fe_ht->arPacked + pos;
			while (1) {
				if (UNEXPECTED(pos >= fe_ht->nNumUsed)) {
					/* reached end of iteration */
					goto fe_fetch_w_exit;
				}
				value_type = C_TYPE_INFO_P(value);
				CREX_ASSERT(value_type != IS_INDIRECT);
				if (EXPECTED(value_type != IS_UNDEF)) {
					break;
				}
				pos++;
				value++;
			}
			EG(ht_iterators)[C_FE_ITER_P(EX_VAR(opline->op1.var))].pos = pos + 1;
			if (RETURN_VALUE_USED(opline)) {
				ZVAL_LONG(EX_VAR(opline->result.var), pos);
			}
		} else {
			p = fe_ht->arData + pos;
			while (1) {
				if (UNEXPECTED(pos >= fe_ht->nNumUsed)) {
					/* reached end of iteration */
					goto fe_fetch_w_exit;
				}
				pos++;
				value = &p->val;
				value_type = C_TYPE_INFO_P(value);
				CREX_ASSERT(value_type != IS_INDIRECT);
				if (EXPECTED(value_type != IS_UNDEF)) {
					break;
				}
				p++;
			}
			EG(ht_iterators)[C_FE_ITER_P(EX_VAR(opline->op1.var))].pos = pos;
			if (RETURN_VALUE_USED(opline)) {
				if (!p->key) {
					ZVAL_LONG(EX_VAR(opline->result.var), p->h);
				} else {
					ZVAL_STR_COPY(EX_VAR(opline->result.var), p->key);
				}
			}
		}
	} else if (EXPECTED(C_TYPE_P(array) == IS_OBJECT)) {
		crex_object_iterator *iter;

		if ((iter = crex_iterator_unwrap(array)) == NULL) {
			/* plain object */

			fe_ht = C_OBJPROP_P(array);
			pos = crex_hash_iterator_pos(C_FE_ITER_P(EX_VAR(opline->op1.var)), fe_ht);
			p = fe_ht->arData + pos;
			while (1) {
				if (UNEXPECTED(pos >= fe_ht->nNumUsed)) {
					/* reached end of iteration */
					goto fe_fetch_w_exit;
				}
				pos++;
				value = &p->val;
				value_type = C_TYPE_INFO_P(value);
				if (EXPECTED(value_type != IS_UNDEF)) {
					if (UNEXPECTED(value_type == IS_INDIRECT)) {
						value = C_INDIRECT_P(value);
						value_type = C_TYPE_INFO_P(value);
						if (EXPECTED(value_type != IS_UNDEF)
						 && EXPECTED(crex_check_property_access(C_OBJ_P(array), p->key, 0) == SUCCESS)) {
							if ((value_type & C_TYPE_MASK) != IS_REFERENCE) {
								crex_property_info *prop_info =
									crex_get_property_info_for_slot(C_OBJ_P(array), value);
								if (UNEXPECTED(prop_info)) {
									if (UNEXPECTED(prop_info->flags & CREX_ACC_READONLY)) {
										crex_throw_error(NULL,
											"Cannot acquire reference to readonly property %s::$%s",
											ZSTR_VAL(prop_info->ce->name), ZSTR_VAL(p->key));
										UNDEF_RESULT();
										HANDLE_EXCEPTION();
									}
									if (CREX_TYPE_IS_SET(prop_info->type)) {
										ZVAL_NEW_REF(value, value);
										CREX_REF_ADD_TYPE_SOURCE(C_REF_P(value), prop_info);
										value_type = IS_REFERENCE_EX;
									}
								}
							}
							break;
						}
					} else if (EXPECTED(C_OBJCE_P(array)->default_properties_count == 0)
							|| !p->key
							|| crex_check_property_access(C_OBJ_P(array), p->key, 1) == SUCCESS) {
						break;
					}
				}
				p++;
			}
			EG(ht_iterators)[C_FE_ITER_P(EX_VAR(opline->op1.var))].pos = pos;
			if (RETURN_VALUE_USED(opline)) {
				if (UNEXPECTED(!p->key)) {
					ZVAL_LONG(EX_VAR(opline->result.var), p->h);
				} else if (ZSTR_VAL(p->key)[0]) {
					ZVAL_STR_COPY(EX_VAR(opline->result.var), p->key);
				} else {
					const char *class_name, *prop_name;
					size_t prop_name_len;
					crex_unmangle_property_name_ex(
						p->key, &class_name, &prop_name, &prop_name_len);
					ZVAL_STRINGL(EX_VAR(opline->result.var), prop_name, prop_name_len);
				}
			}
		} else {
			const crex_object_iterator_funcs *funcs = iter->funcs;
			if (++iter->index > 0) {
				/* This could cause an endless loop if index becomes zero again.
				 * In case that ever happens we need an additional flag. */
				funcs->move_forward(iter);
				if (UNEXPECTED(EG(exception) != NULL)) {
					UNDEF_RESULT();
					HANDLE_EXCEPTION();
				}
				if (UNEXPECTED(funcs->valid(iter) == FAILURE)) {
					/* reached end of iteration */
					if (UNEXPECTED(EG(exception) != NULL)) {
						UNDEF_RESULT();
						HANDLE_EXCEPTION();
					}
					goto fe_fetch_w_exit;
				}
			}
			value = funcs->get_current_data(iter);
			if (UNEXPECTED(EG(exception) != NULL)) {
				UNDEF_RESULT();
				HANDLE_EXCEPTION();
			}
			if (!value) {
				/* failure in get_current_data */
				goto fe_fetch_w_exit;
			}
			if (RETURN_VALUE_USED(opline)) {
				if (funcs->get_current_key) {
					funcs->get_current_key(iter, EX_VAR(opline->result.var));
					if (UNEXPECTED(EG(exception) != NULL)) {
						UNDEF_RESULT();
						HANDLE_EXCEPTION();
					}
				} else {
					ZVAL_LONG(EX_VAR(opline->result.var), iter->index);
				}
			}
			value_type = C_TYPE_INFO_P(value);
		}
	} else {
		crex_error(E_WARNING, "foreach() argument must be of type array|object, %s given", crex_zval_value_name(array));
		if (UNEXPECTED(EG(exception))) {
			UNDEF_RESULT();
			HANDLE_EXCEPTION();
		}
fe_fetch_w_exit:
		CREX_VM_SET_RELATIVE_OPCODE(opline, opline->extended_value);
		CREX_VM_CONTINUE();
	}

	if (EXPECTED((value_type & C_TYPE_MASK) != IS_REFERENCE)) {
		crex_refcounted *gc = C_COUNTED_P(value);
		zval *ref;
		ZVAL_NEW_EMPTY_REF(value);
		ref = C_REFVAL_P(value);
		ZVAL_COPY_VALUE_EX(ref, value, gc, value_type);
	}
	if (EXPECTED(opline->op2_type == IS_CV)) {
		zval *variable_ptr = EX_VAR(opline->op2.var);
		if (EXPECTED(variable_ptr != value)) {
			crex_reference *ref;

			ref = C_REF_P(value);
			GC_ADDREF(ref);
			i_zval_ptr_dtor(variable_ptr);
			ZVAL_REF(variable_ptr, ref);
		}
	} else {
		C_ADDREF_P(value);
		ZVAL_REF(EX_VAR(opline->op2.var), C_REF_P(value));
	}
	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_JMP_SET_SPEC_VAR_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *value;
	crex_reference *ref = NULL;
	bool ret;

	SAVE_OPLINE();
	value = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);

	if ((IS_VAR == IS_VAR || IS_VAR == IS_CV) && C_ISREF_P(value)) {
		if (IS_VAR == IS_VAR) {
			ref = C_REF_P(value);
		}
		value = C_REFVAL_P(value);
	}

	ret = i_crex_is_true(value);

	if (UNEXPECTED(EG(exception))) {
		zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
		ZVAL_UNDEF(EX_VAR(opline->result.var));
		HANDLE_EXCEPTION();
	}

	if (ret) {
		zval *result = EX_VAR(opline->result.var);

		ZVAL_COPY_VALUE(result, value);
		if (IS_VAR == IS_CONST) {
			if (UNEXPECTED(C_OPT_REFCOUNTED_P(result))) C_ADDREF_P(result);
		} else if (IS_VAR == IS_CV) {
			if (C_OPT_REFCOUNTED_P(result)) C_ADDREF_P(result);
		} else if (IS_VAR == IS_VAR && ref) {
			if (UNEXPECTED(GC_DELREF(ref) == 0)) {
				efree_size(ref, sizeof(crex_reference));
			} else if (C_OPT_REFCOUNTED_P(result)) {
				C_ADDREF_P(result);
			}
		}
		CREX_VM_JMP_EX(OP_JMP_ADDR(opline, opline->op2), 0);
	}

	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	CREX_VM_NEXT_OPCODE();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_COALESCE_SPEC_VAR_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *value;
	crex_reference *ref = NULL;

	SAVE_OPLINE();
	value = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);

	if ((IS_VAR & (IS_VAR|IS_CV)) && C_ISREF_P(value)) {
		if (IS_VAR & IS_VAR) {
			ref = C_REF_P(value);
		}
		value = C_REFVAL_P(value);
	}

	if (C_TYPE_P(value) > IS_NULL) {
		zval *result = EX_VAR(opline->result.var);
		ZVAL_COPY_VALUE(result, value);
		if (IS_VAR == IS_CONST) {
			if (UNEXPECTED(C_OPT_REFCOUNTED_P(result))) C_ADDREF_P(result);
		} else if (IS_VAR == IS_CV) {
			if (C_OPT_REFCOUNTED_P(result)) C_ADDREF_P(result);
		} else if ((IS_VAR & IS_VAR) && ref) {
			if (UNEXPECTED(GC_DELREF(ref) == 0)) {
				efree_size(ref, sizeof(crex_reference));
			} else if (C_OPT_REFCOUNTED_P(result)) {
				C_ADDREF_P(result);
			}
		}
		CREX_VM_JMP_EX(OP_JMP_ADDR(opline, opline->op2), 0);
	}

	if ((IS_VAR & IS_VAR) && ref) {
		if (UNEXPECTED(GC_DELREF(ref) == 0)) {
			efree_size(ref, sizeof(crex_reference));
		}
	}
	CREX_VM_NEXT_OPCODE();
}

static CREX_VM_HOT CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_JMP_NULL_SPEC_VAR_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *val, *result;

	val = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);

	if (C_TYPE_P(val) > IS_NULL) {
		do {
			if ((IS_VAR == IS_CV || IS_VAR == IS_VAR) && C_TYPE_P(val) == IS_REFERENCE) {
				val = C_REFVAL_P(val);
				if (C_TYPE_P(val) <= IS_NULL) {
					zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
					break;
				}
			}
			CREX_VM_NEXT_OPCODE();
		} while (0);
	}

	result = EX_VAR(opline->result.var);
	uint32_t short_circuiting_type = opline->extended_value & CREX_SHORT_CIRCUITING_CHAIN_MASK;
	if (EXPECTED(short_circuiting_type == CREX_SHORT_CIRCUITING_CHAIN_EXPR)) {
		ZVAL_NULL(result);
		if (IS_VAR == IS_CV
			&& UNEXPECTED(C_TYPE_P(val) == IS_UNDEF)
			&& (opline->extended_value & CREX_JMP_NULL_BP_VAR_IS) == 0
		) {
			SAVE_OPLINE();
			ZVAL_UNDEFINED_OP1();
			if (UNEXPECTED(EG(exception) != NULL)) {
				HANDLE_EXCEPTION();
			}
		}
	} else if (short_circuiting_type == CREX_SHORT_CIRCUITING_CHAIN_ISSET) {
		ZVAL_FALSE(result);
	} else {
		CREX_ASSERT(short_circuiting_type == CREX_SHORT_CIRCUITING_CHAIN_EMPTY);
		ZVAL_TRUE(result);
	}

	CREX_VM_JMP_EX(OP_JMP_ADDR(opline, opline->op2), 0);
}

static CREX_VM_HOT CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_QM_ASSIGN_SPEC_VAR_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *value;
	zval *result = EX_VAR(opline->result.var);

	value = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	if (IS_VAR == IS_CV && UNEXPECTED(C_TYPE_P(value) == IS_UNDEF)) {
		SAVE_OPLINE();
		ZVAL_UNDEFINED_OP1();
		ZVAL_NULL(result);
		CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
	}

	if (IS_VAR == IS_CV) {
		ZVAL_COPY_DEREF(result, value);
	} else if (IS_VAR == IS_VAR) {
		if (UNEXPECTED(C_ISREF_P(value))) {
			ZVAL_COPY_VALUE(result, C_REFVAL_P(value));
			if (UNEXPECTED(C_DELREF_P(value) == 0)) {
				efree_size(C_REF_P(value), sizeof(crex_reference));
			} else if (C_OPT_REFCOUNTED_P(result)) {
				C_ADDREF_P(result);
			}
		} else {
			ZVAL_COPY_VALUE(result, value);
		}
	} else {
		ZVAL_COPY_VALUE(result, value);
		if (IS_VAR == IS_CONST) {
			if (UNEXPECTED(C_OPT_REFCOUNTED_P(result))) {
				C_ADDREF_P(result);
			}
		}
	}
	CREX_VM_NEXT_OPCODE();
}

static CREX_VM_HOT CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_SEND_VAR_SIMPLE_SPEC_VAR_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *varptr, *arg;

	varptr = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	arg = CREX_CALL_VAR(EX(call), opline->result.var);

	if (IS_VAR == IS_CV) {
		ZVAL_COPY(arg, varptr);
	} else /* if (IS_VAR == IS_VAR) */ {
		ZVAL_COPY_VALUE(arg, varptr);
	}

	CREX_VM_NEXT_OPCODE();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_IS_IDENTICAL_SPEC_VAR_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	bool result;

	SAVE_OPLINE();
	op1 = _get_zval_ptr_var_deref(opline->op1.var EXECUTE_DATA_CC);
	op2 = RT_CONSTANT(opline, opline->op2);
	result = fast_is_identical_function(op1, op2);
	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));

	CREX_VM_SMART_BRANCH(result, 1);
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_CASE_STRICT_SPEC_VAR_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	bool result;

	SAVE_OPLINE();
	op1 = _get_zval_ptr_var_deref(opline->op1.var EXECUTE_DATA_CC);
	op2 = RT_CONSTANT(opline, opline->op2);
	result = fast_is_identical_function(op1, op2);

	CREX_VM_SMART_BRANCH(result, 1);
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_IS_NOT_IDENTICAL_SPEC_VAR_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	bool result;

	SAVE_OPLINE();
	op1 = _get_zval_ptr_var_deref(opline->op1.var EXECUTE_DATA_CC);
	op2 = RT_CONSTANT(opline, opline->op2);
	result = fast_is_not_identical_function(op1, op2);
	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));

	CREX_VM_SMART_BRANCH(result, 1);
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ASSIGN_OBJ_OP_SPEC_VAR_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *object;
	zval *property;
	zval *value;
	zval *zptr;
	void **cache_slot;
	crex_property_info *prop_info;
	crex_object *zobj;
	crex_string *name, *tmp_name;

	SAVE_OPLINE();
	object = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	property = RT_CONSTANT(opline, opline->op2);

	do {
		value = get_op_data_zval_ptr_r((opline+1)->op1_type, (opline+1)->op1);

		if (IS_VAR != IS_UNUSED && UNEXPECTED(C_TYPE_P(object) != IS_OBJECT)) {
			if (C_ISREF_P(object) && C_TYPE_P(C_REFVAL_P(object)) == IS_OBJECT) {
				object = C_REFVAL_P(object);
				goto assign_op_object;
			}
			if (IS_VAR == IS_CV
			 && UNEXPECTED(C_TYPE_P(object) == IS_UNDEF)) {
				ZVAL_UNDEFINED_OP1();
			}
			crex_throw_non_object_error(object, property OPLINE_CC EXECUTE_DATA_CC);
			break;
		}

assign_op_object:
		/* here we are sure we are dealing with an object */
		zobj = C_OBJ_P(object);
		if (IS_CONST == IS_CONST) {
			name = C_STR_P(property);
		} else {
			name = zval_try_get_tmp_string(property, &tmp_name);
			if (UNEXPECTED(!name)) {
				UNDEF_RESULT();
				break;
			}
		}
		cache_slot = (IS_CONST == IS_CONST) ? CACHE_ADDR((opline+1)->extended_value) : NULL;
		if (EXPECTED((zptr = zobj->handlers->get_property_ptr_ptr(zobj, name, BP_VAR_RW, cache_slot)) != NULL)) {
			if (UNEXPECTED(C_ISERROR_P(zptr))) {
				if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
					ZVAL_NULL(EX_VAR(opline->result.var));
				}
			} else {
				zval *orig_zptr = zptr;
				crex_reference *ref;

				do {
					if (UNEXPECTED(C_ISREF_P(zptr))) {
						ref = C_REF_P(zptr);
						zptr = C_REFVAL_P(zptr);
						if (UNEXPECTED(CREX_REF_HAS_TYPE_SOURCES(ref))) {
							crex_binary_assign_op_typed_ref(ref, value OPLINE_CC EXECUTE_DATA_CC);
							break;
						}
					}

					if (IS_CONST == IS_CONST) {
						prop_info = (crex_property_info*)CACHED_PTR_EX(cache_slot + 2);
					} else {
						prop_info = crex_object_fetch_property_type_info(C_OBJ_P(object), orig_zptr);
					}
					if (UNEXPECTED(prop_info)) {
						/* special case for typed properties */
						crex_binary_assign_op_typed_prop(prop_info, zptr, value OPLINE_CC EXECUTE_DATA_CC);
					} else {
						crex_binary_op(zptr, zptr, value OPLINE_CC);
					}
				} while (0);

				if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
					ZVAL_COPY(EX_VAR(opline->result.var), zptr);
				}
			}
		} else {
			crex_assign_op_overloaded_property(zobj, name, cache_slot, value OPLINE_CC EXECUTE_DATA_CC);
		}
		if (IS_CONST != IS_CONST) {
			crex_tmp_string_release(tmp_name);
		}
	} while (0);

	FREE_OP((opline+1)->op1_type, (opline+1)->op1.var);

	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	/* assign_obj has two opcodes! */
	CREX_VM_NEXT_OPCODE_EX(1, 2);
}

/* No specialization for op_types (CONST|TMP|VAR|CV, UNUSED|CONST|TMPVAR) */
static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ASSIGN_DIM_OP_SPEC_VAR_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *var_ptr;
	zval *value, *container, *dim;
	HashTable *ht;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);

	if (EXPECTED(C_TYPE_P(container) == IS_ARRAY)) {
assign_dim_op_array:
		SEPARATE_ARRAY(container);
		ht = C_ARRVAL_P(container);
assign_dim_op_new_array:
		dim = RT_CONSTANT(opline, opline->op2);
		if (IS_CONST == IS_UNUSED) {
			var_ptr = crex_hash_next_index_insert(ht, &EG(uninitialized_zval));
			if (UNEXPECTED(!var_ptr)) {
				crex_cannot_add_element();
				goto assign_dim_op_ret_null;
			}
		} else {
			if (IS_CONST == IS_CONST) {
				var_ptr = crex_fetch_dimension_address_inner_RW_CONST(ht, dim EXECUTE_DATA_CC);
			} else {
				var_ptr = crex_fetch_dimension_address_inner_RW(ht, dim EXECUTE_DATA_CC);
			}
			if (UNEXPECTED(!var_ptr)) {
				goto assign_dim_op_ret_null;
			}
		}

		value = get_op_data_zval_ptr_r((opline+1)->op1_type, (opline+1)->op1);

		do {
			if (IS_CONST != IS_UNUSED && UNEXPECTED(C_ISREF_P(var_ptr))) {
				crex_reference *ref = C_REF_P(var_ptr);
				var_ptr = C_REFVAL_P(var_ptr);
				if (UNEXPECTED(CREX_REF_HAS_TYPE_SOURCES(ref))) {
					crex_binary_assign_op_typed_ref(ref, value OPLINE_CC EXECUTE_DATA_CC);
					break;
				}
			}
			crex_binary_op(var_ptr, var_ptr, value OPLINE_CC);
		} while (0);

		if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
			ZVAL_COPY(EX_VAR(opline->result.var), var_ptr);
		}
		FREE_OP((opline+1)->op1_type, (opline+1)->op1.var);
	} else {
		if (EXPECTED(C_ISREF_P(container))) {
			container = C_REFVAL_P(container);
			if (EXPECTED(C_TYPE_P(container) == IS_ARRAY)) {
				goto assign_dim_op_array;
			}
		}

		if (EXPECTED(C_TYPE_P(container) == IS_OBJECT)) {
			crex_object *obj = C_OBJ_P(container);

			dim = RT_CONSTANT(opline, opline->op2);
			if (IS_CONST == IS_CONST && C_EXTRA_P(dim) == CREX_EXTRA_VALUE) {
				dim++;
			}
			crex_binary_assign_op_obj_dim(obj, dim OPLINE_CC EXECUTE_DATA_CC);
		} else if (EXPECTED(C_TYPE_P(container) <= IS_FALSE)) {
			uint8_t old_type;

			if (IS_VAR == IS_CV && UNEXPECTED(C_TYPE_INFO_P(container) == IS_UNDEF)) {
				ZVAL_UNDEFINED_OP1();
			}
			ht = crex_new_array(8);
			old_type = C_TYPE_P(container);
			ZVAL_ARR(container, ht);
			if (UNEXPECTED(old_type == IS_FALSE)) {
				GC_ADDREF(ht);
				crex_false_to_array_deprecated();
				if (UNEXPECTED(GC_DELREF(ht) == 0)) {
					crex_array_destroy(ht);
					goto assign_dim_op_ret_null;
				}
			}
			goto assign_dim_op_new_array;
		} else {
			dim = RT_CONSTANT(opline, opline->op2);
			crex_binary_assign_op_dim_slow(container, dim OPLINE_CC EXECUTE_DATA_CC);
assign_dim_op_ret_null:
			FREE_OP((opline+1)->op1_type, (opline+1)->op1.var);
			if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
				ZVAL_NULL(EX_VAR(opline->result.var));
			}
		}
	}

	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	CREX_VM_NEXT_OPCODE_EX(1, 2);
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ASSIGN_OP_SPEC_VAR_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *var_ptr;
	zval *value;

	SAVE_OPLINE();
	value = RT_CONSTANT(opline, opline->op2);
	var_ptr = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);

	do {
		if (UNEXPECTED(C_TYPE_P(var_ptr) == IS_REFERENCE)) {
			crex_reference *ref = C_REF_P(var_ptr);
			var_ptr = C_REFVAL_P(var_ptr);
			if (UNEXPECTED(CREX_REF_HAS_TYPE_SOURCES(ref))) {
				crex_binary_assign_op_typed_ref(ref, value OPLINE_CC EXECUTE_DATA_CC);
				break;
			}
		}
		crex_binary_op(var_ptr, var_ptr, value OPLINE_CC);
	} while (0);

	if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
		ZVAL_COPY(EX_VAR(opline->result.var), var_ptr);
	}

	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_PRE_INC_OBJ_SPEC_VAR_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *object;
	zval *property;
	zval *zptr;
	void **cache_slot;
	crex_property_info *prop_info;
	crex_object *zobj;
	crex_string *name, *tmp_name;

	SAVE_OPLINE();
	object = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	property = RT_CONSTANT(opline, opline->op2);

	do {
		if (IS_VAR != IS_UNUSED && UNEXPECTED(C_TYPE_P(object) != IS_OBJECT)) {
			if (C_ISREF_P(object) && C_TYPE_P(C_REFVAL_P(object)) == IS_OBJECT) {
				object = C_REFVAL_P(object);
				goto pre_incdec_object;
			}
			if (IS_VAR == IS_CV
			 && UNEXPECTED(C_TYPE_P(object) == IS_UNDEF)) {
				ZVAL_UNDEFINED_OP1();
			}
			crex_throw_non_object_error(object, property OPLINE_CC EXECUTE_DATA_CC);
			break;
		}

pre_incdec_object:
		/* here we are sure we are dealing with an object */
		zobj = C_OBJ_P(object);
		if (IS_CONST == IS_CONST) {
			name = C_STR_P(property);
		} else {
			name = zval_try_get_tmp_string(property, &tmp_name);
			if (UNEXPECTED(!name)) {
				UNDEF_RESULT();
				break;
			}
		}
		cache_slot = (IS_CONST == IS_CONST) ? CACHE_ADDR(opline->extended_value) : NULL;
		if (EXPECTED((zptr = zobj->handlers->get_property_ptr_ptr(zobj, name, BP_VAR_RW, cache_slot)) != NULL)) {
			if (UNEXPECTED(C_ISERROR_P(zptr))) {
				if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
					ZVAL_NULL(EX_VAR(opline->result.var));
				}
			} else {
				if (IS_CONST == IS_CONST) {
					prop_info = (crex_property_info *) CACHED_PTR_EX(cache_slot + 2);
				} else {
					prop_info = crex_object_fetch_property_type_info(C_OBJ_P(object), zptr);
				}
				crex_pre_incdec_property_zval(zptr, prop_info OPLINE_CC EXECUTE_DATA_CC);
			}
		} else {
			crex_pre_incdec_overloaded_property(zobj, name, cache_slot OPLINE_CC EXECUTE_DATA_CC);
		}
		if (IS_CONST != IS_CONST) {
			crex_tmp_string_release(tmp_name);
		}
	} while (0);

	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_POST_INC_OBJ_SPEC_VAR_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *object;
	zval *property;
	zval *zptr;
	void **cache_slot;
	crex_property_info *prop_info;
	crex_object *zobj;
	crex_string *name, *tmp_name;

	SAVE_OPLINE();
	object = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	property = RT_CONSTANT(opline, opline->op2);

	do {
		if (IS_VAR != IS_UNUSED && UNEXPECTED(C_TYPE_P(object) != IS_OBJECT)) {
			if (C_ISREF_P(object) && C_TYPE_P(C_REFVAL_P(object)) == IS_OBJECT) {
				object = C_REFVAL_P(object);
				goto post_incdec_object;
			}
			if (IS_VAR == IS_CV
			 && UNEXPECTED(C_TYPE_P(object) == IS_UNDEF)) {
				ZVAL_UNDEFINED_OP1();
			}
			crex_throw_non_object_error(object, property OPLINE_CC EXECUTE_DATA_CC);
			break;
		}

post_incdec_object:
		/* here we are sure we are dealing with an object */
		zobj = C_OBJ_P(object);
		if (IS_CONST == IS_CONST) {
			name = C_STR_P(property);
		} else {
			name = zval_try_get_tmp_string(property, &tmp_name);
			if (UNEXPECTED(!name)) {
				ZVAL_UNDEF(EX_VAR(opline->result.var));
				break;
			}
		}
		cache_slot = (IS_CONST == IS_CONST) ? CACHE_ADDR(opline->extended_value) : NULL;
		if (EXPECTED((zptr = zobj->handlers->get_property_ptr_ptr(zobj, name, BP_VAR_RW, cache_slot)) != NULL)) {
			if (UNEXPECTED(C_ISERROR_P(zptr))) {
				ZVAL_NULL(EX_VAR(opline->result.var));
			} else {
				if (IS_CONST == IS_CONST) {
					prop_info = (crex_property_info*)CACHED_PTR_EX(cache_slot + 2);
				} else {
					prop_info = crex_object_fetch_property_type_info(C_OBJ_P(object), zptr);
				}

				crex_post_incdec_property_zval(zptr, prop_info OPLINE_CC EXECUTE_DATA_CC);
			}
		} else {
			crex_post_incdec_overloaded_property(zobj, name, cache_slot OPLINE_CC EXECUTE_DATA_CC);
		}
		if (IS_CONST != IS_CONST) {
			crex_tmp_string_release(tmp_name);
		}
	} while (0);

	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FETCH_DIM_W_SPEC_VAR_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	crex_fetch_dimension_address_W(container, RT_CONSTANT(opline, opline->op2), IS_CONST OPLINE_CC EXECUTE_DATA_CC);

	if (IS_VAR == IS_VAR) {
		FREE_VAR_PTR_AND_EXTRACT_RESULT_IF_NECESSARY(opline->op1.var);
	}
	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FETCH_DIM_RW_SPEC_VAR_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	crex_fetch_dimension_address_RW(container, RT_CONSTANT(opline, opline->op2), IS_CONST OPLINE_CC EXECUTE_DATA_CC);

	if (IS_VAR == IS_VAR) {
		FREE_VAR_PTR_AND_EXTRACT_RESULT_IF_NECESSARY(opline->op1.var);
	}
	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FETCH_DIM_FUNC_ARG_SPEC_VAR_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
#if 0
	USE_OPLINE
#endif

	if (UNEXPECTED(CREX_CALL_INFO(EX(call)) & CREX_CALL_SEND_ARG_BY_REF)) {
		if ((IS_VAR & (IS_CONST|IS_TMP_VAR))) {
			CREX_VM_TAIL_CALL(crex_use_tmp_in_write_context_helper_SPEC(CREX_OPCODE_HANDLER_ARGS_PASSTHRU));
		}
		CREX_VM_TAIL_CALL(CREX_FETCH_DIM_W_SPEC_VAR_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU));
	} else {
		if (IS_CONST == IS_UNUSED) {
			CREX_VM_TAIL_CALL(crex_use_undef_in_read_context_helper_SPEC(CREX_OPCODE_HANDLER_ARGS_PASSTHRU));
		}
		CREX_VM_TAIL_CALL(CREX_FETCH_DIM_R_SPEC_TMPVAR_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU));
	}
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FETCH_DIM_UNSET_SPEC_VAR_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	crex_fetch_dimension_address_UNSET(container, RT_CONSTANT(opline, opline->op2), IS_CONST OPLINE_CC EXECUTE_DATA_CC);

	if (IS_VAR == IS_VAR) {
		FREE_VAR_PTR_AND_EXTRACT_RESULT_IF_NECESSARY(opline->op1.var);
	}
	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FETCH_OBJ_W_SPEC_VAR_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *property, *container, *result;

	SAVE_OPLINE();

	container = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	property = RT_CONSTANT(opline, opline->op2);
	result = EX_VAR(opline->result.var);
	crex_fetch_property_address(
		result, container, IS_VAR, property, IS_CONST,
		((IS_CONST == IS_CONST) ? CACHE_ADDR(opline->extended_value & ~CREX_FETCH_OBJ_FLAGS) : NULL),
		BP_VAR_W, opline->extended_value OPLINE_CC EXECUTE_DATA_CC);

	if (IS_VAR == IS_VAR) {
		FREE_VAR_PTR_AND_EXTRACT_RESULT_IF_NECESSARY(opline->op1.var);
	}
	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FETCH_OBJ_RW_SPEC_VAR_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *property, *container, *result;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	property = RT_CONSTANT(opline, opline->op2);
	result = EX_VAR(opline->result.var);
	crex_fetch_property_address(result, container, IS_VAR, property, IS_CONST, ((IS_CONST == IS_CONST) ? CACHE_ADDR(opline->extended_value) : NULL), BP_VAR_RW, 0 OPLINE_CC EXECUTE_DATA_CC);

	if (IS_VAR == IS_VAR) {
		FREE_VAR_PTR_AND_EXTRACT_RESULT_IF_NECESSARY(opline->op1.var);
	}
	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FETCH_OBJ_FUNC_ARG_SPEC_VAR_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
#if 0
	USE_OPLINE
#endif

	if (UNEXPECTED(CREX_CALL_INFO(EX(call)) & CREX_CALL_SEND_ARG_BY_REF)) {
		/* Behave like FETCH_OBJ_W */
		if ((IS_VAR & (IS_CONST|IS_TMP_VAR))) {
			CREX_VM_TAIL_CALL(crex_use_tmp_in_write_context_helper_SPEC(CREX_OPCODE_HANDLER_ARGS_PASSTHRU));
		}
		CREX_VM_TAIL_CALL(CREX_FETCH_OBJ_W_SPEC_VAR_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU));
	} else {
		CREX_VM_TAIL_CALL(CREX_FETCH_OBJ_R_SPEC_TMPVAR_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU));
	}
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FETCH_OBJ_UNSET_SPEC_VAR_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container, *property, *result;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	property = RT_CONSTANT(opline, opline->op2);
	result = EX_VAR(opline->result.var);
	crex_fetch_property_address(result, container, IS_VAR, property, IS_CONST, ((IS_CONST == IS_CONST) ? CACHE_ADDR(opline->extended_value) : NULL), BP_VAR_UNSET, 0 OPLINE_CC EXECUTE_DATA_CC);

	if (IS_VAR == IS_VAR) {
		FREE_VAR_PTR_AND_EXTRACT_RESULT_IF_NECESSARY(opline->op1.var);
	}
	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FETCH_LIST_W_SPEC_VAR_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container, *dim;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	dim = RT_CONSTANT(opline, opline->op2);

	if (IS_VAR == IS_VAR
		&& C_TYPE_P(EX_VAR(opline->op1.var)) != IS_INDIRECT
		&& UNEXPECTED(!C_ISREF_P(container))
	) {
		crex_error(E_NOTICE, "Attempting to set reference to non referenceable value");
		crex_fetch_dimension_address_LIST_r(container, dim, IS_CONST OPLINE_CC EXECUTE_DATA_CC);
	} else {
		crex_fetch_dimension_address_W(container, dim, IS_CONST OPLINE_CC EXECUTE_DATA_CC);
	}

	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ASSIGN_OBJ_SPEC_VAR_CONST_OP_DATA_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *object, *value, tmp;
	crex_object *zobj;
	crex_string *name, *tmp_name;
	crex_refcounted *garbage = NULL;

	SAVE_OPLINE();
	object = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	value = RT_CONSTANT((opline+1), (opline+1)->op1);

	if (IS_VAR != IS_UNUSED && UNEXPECTED(C_TYPE_P(object) != IS_OBJECT)) {
		if (C_ISREF_P(object) && C_TYPE_P(C_REFVAL_P(object)) == IS_OBJECT) {
			object = C_REFVAL_P(object);
			goto assign_object;
		}
		crex_throw_non_object_error(object, RT_CONSTANT(opline, opline->op2) OPLINE_CC EXECUTE_DATA_CC);
		value = &EG(uninitialized_zval);
		goto free_and_exit_assign_obj;
	}

assign_object:
	zobj = C_OBJ_P(object);
	if (IS_CONST == IS_CONST) {
		if (EXPECTED(zobj->ce == CACHED_PTR(opline->extended_value))) {
			void **cache_slot = CACHE_ADDR(opline->extended_value);
			uintptr_t prop_offset = (uintptr_t)CACHED_PTR_EX(cache_slot + 1);
			zval *property_val;

			if (EXPECTED(IS_VALID_PROPERTY_OFFSET(prop_offset))) {
				property_val = OBJ_PROP(zobj, prop_offset);
				if (C_TYPE_P(property_val) != IS_UNDEF) {
					crex_property_info *prop_info = (crex_property_info*) CACHED_PTR_EX(cache_slot + 2);

					if (UNEXPECTED(prop_info != NULL)) {
						value = crex_assign_to_typed_prop(prop_info, property_val, value, &garbage EXECUTE_DATA_CC);
						goto free_and_exit_assign_obj;
					} else {
fast_assign_obj:
						value = crex_assign_to_variable_ex(property_val, value, IS_CONST, EX_USES_STRICT_TYPES(), &garbage);
						if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
							ZVAL_COPY(EX_VAR(opline->result.var), value);
						}
						goto exit_assign_obj;
					}
				}
			} else {
				name = C_STR_P(RT_CONSTANT(opline, opline->op2));
				if (EXPECTED(zobj->properties != NULL)) {
					if (UNEXPECTED(GC_REFCOUNT(zobj->properties) > 1)) {
						if (EXPECTED(!(GC_FLAGS(zobj->properties) & IS_ARRAY_IMMUTABLE))) {
							GC_DELREF(zobj->properties);
						}
						zobj->properties = crex_array_dup(zobj->properties);
					}
					property_val = crex_hash_find_known_hash(zobj->properties, name);
					if (property_val) {
						goto fast_assign_obj;
					}
				}

				if (!zobj->ce->__set && (zobj->ce->ce_flags & CREX_ACC_ALLOW_DYNAMIC_PROPERTIES)) {
					if (EXPECTED(zobj->properties == NULL)) {
						rebuild_object_properties(zobj);
					}
					if (IS_CONST == IS_CONST) {
						if (UNEXPECTED(C_OPT_REFCOUNTED_P(value))) {
							C_ADDREF_P(value);
						}
					} else if (IS_CONST != IS_TMP_VAR) {
						if (C_ISREF_P(value)) {
							if (IS_CONST == IS_VAR) {
								crex_reference *ref = C_REF_P(value);
								if (GC_DELREF(ref) == 0) {
									ZVAL_COPY_VALUE(&tmp, C_REFVAL_P(value));
									efree_size(ref, sizeof(crex_reference));
									value = &tmp;
								} else {
									value = C_REFVAL_P(value);
									C_TRY_ADDREF_P(value);
								}
							} else {
								value = C_REFVAL_P(value);
								C_TRY_ADDREF_P(value);
							}
						} else if (IS_CONST == IS_CV) {
							C_TRY_ADDREF_P(value);
						}
						}
					crex_hash_add_new(zobj->properties, name, value);
					if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
						ZVAL_COPY(EX_VAR(opline->result.var), value);
					}
					goto exit_assign_obj;
				}
			}
		}
		name = C_STR_P(RT_CONSTANT(opline, opline->op2));
	} else {
		name = zval_try_get_tmp_string(RT_CONSTANT(opline, opline->op2), &tmp_name);
		if (UNEXPECTED(!name)) {

			UNDEF_RESULT();
			goto exit_assign_obj;
		}
	}

	if (IS_CONST == IS_CV || IS_CONST == IS_VAR) {
		ZVAL_DEREF(value);
	}

	value = zobj->handlers->write_property(zobj, name, value, (IS_CONST == IS_CONST) ? CACHE_ADDR(opline->extended_value) : NULL);

	if (IS_CONST != IS_CONST) {
		crex_tmp_string_release(tmp_name);
	}

free_and_exit_assign_obj:
	if (UNEXPECTED(RETURN_VALUE_USED(opline)) && value) {
		ZVAL_COPY_DEREF(EX_VAR(opline->result.var), value);
	}

exit_assign_obj:
	if (garbage) {
		GC_DTOR_NO_REF(garbage);
	}

	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	/* assign_obj has two opcodes! */
	CREX_VM_NEXT_OPCODE_EX(1, 2);
}

/* No specialization for op_types (CONST|TMPVAR|CV, UNUSED|CONST|VAR) */
static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ASSIGN_OBJ_SPEC_VAR_CONST_OP_DATA_TMP_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *object, *value, tmp;
	crex_object *zobj;
	crex_string *name, *tmp_name;
	crex_refcounted *garbage = NULL;

	SAVE_OPLINE();
	object = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	value = _get_zval_ptr_tmp((opline+1)->op1.var EXECUTE_DATA_CC);

	if (IS_VAR != IS_UNUSED && UNEXPECTED(C_TYPE_P(object) != IS_OBJECT)) {
		if (C_ISREF_P(object) && C_TYPE_P(C_REFVAL_P(object)) == IS_OBJECT) {
			object = C_REFVAL_P(object);
			goto assign_object;
		}
		crex_throw_non_object_error(object, RT_CONSTANT(opline, opline->op2) OPLINE_CC EXECUTE_DATA_CC);
		value = &EG(uninitialized_zval);
		goto free_and_exit_assign_obj;
	}

assign_object:
	zobj = C_OBJ_P(object);
	if (IS_CONST == IS_CONST) {
		if (EXPECTED(zobj->ce == CACHED_PTR(opline->extended_value))) {
			void **cache_slot = CACHE_ADDR(opline->extended_value);
			uintptr_t prop_offset = (uintptr_t)CACHED_PTR_EX(cache_slot + 1);
			zval *property_val;

			if (EXPECTED(IS_VALID_PROPERTY_OFFSET(prop_offset))) {
				property_val = OBJ_PROP(zobj, prop_offset);
				if (C_TYPE_P(property_val) != IS_UNDEF) {
					crex_property_info *prop_info = (crex_property_info*) CACHED_PTR_EX(cache_slot + 2);

					if (UNEXPECTED(prop_info != NULL)) {
						value = crex_assign_to_typed_prop(prop_info, property_val, value, &garbage EXECUTE_DATA_CC);
						goto free_and_exit_assign_obj;
					} else {
fast_assign_obj:
						value = crex_assign_to_variable_ex(property_val, value, IS_TMP_VAR, EX_USES_STRICT_TYPES(), &garbage);
						if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
							ZVAL_COPY(EX_VAR(opline->result.var), value);
						}
						goto exit_assign_obj;
					}
				}
			} else {
				name = C_STR_P(RT_CONSTANT(opline, opline->op2));
				if (EXPECTED(zobj->properties != NULL)) {
					if (UNEXPECTED(GC_REFCOUNT(zobj->properties) > 1)) {
						if (EXPECTED(!(GC_FLAGS(zobj->properties) & IS_ARRAY_IMMUTABLE))) {
							GC_DELREF(zobj->properties);
						}
						zobj->properties = crex_array_dup(zobj->properties);
					}
					property_val = crex_hash_find_known_hash(zobj->properties, name);
					if (property_val) {
						goto fast_assign_obj;
					}
				}

				if (!zobj->ce->__set && (zobj->ce->ce_flags & CREX_ACC_ALLOW_DYNAMIC_PROPERTIES)) {
					if (EXPECTED(zobj->properties == NULL)) {
						rebuild_object_properties(zobj);
					}
					if (IS_TMP_VAR == IS_CONST) {
						if (UNEXPECTED(C_OPT_REFCOUNTED_P(value))) {
							C_ADDREF_P(value);
						}
					} else if (IS_TMP_VAR != IS_TMP_VAR) {
						if (C_ISREF_P(value)) {
							if (IS_TMP_VAR == IS_VAR) {
								crex_reference *ref = C_REF_P(value);
								if (GC_DELREF(ref) == 0) {
									ZVAL_COPY_VALUE(&tmp, C_REFVAL_P(value));
									efree_size(ref, sizeof(crex_reference));
									value = &tmp;
								} else {
									value = C_REFVAL_P(value);
									C_TRY_ADDREF_P(value);
								}
							} else {
								value = C_REFVAL_P(value);
								C_TRY_ADDREF_P(value);
							}
						} else if (IS_TMP_VAR == IS_CV) {
							C_TRY_ADDREF_P(value);
						}
						}
					crex_hash_add_new(zobj->properties, name, value);
					if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
						ZVAL_COPY(EX_VAR(opline->result.var), value);
					}
					goto exit_assign_obj;
				}
			}
		}
		name = C_STR_P(RT_CONSTANT(opline, opline->op2));
	} else {
		name = zval_try_get_tmp_string(RT_CONSTANT(opline, opline->op2), &tmp_name);
		if (UNEXPECTED(!name)) {
			zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
			UNDEF_RESULT();
			goto exit_assign_obj;
		}
	}

	if (IS_TMP_VAR == IS_CV || IS_TMP_VAR == IS_VAR) {
		ZVAL_DEREF(value);
	}

	value = zobj->handlers->write_property(zobj, name, value, (IS_CONST == IS_CONST) ? CACHE_ADDR(opline->extended_value) : NULL);

	if (IS_CONST != IS_CONST) {
		crex_tmp_string_release(tmp_name);
	}

free_and_exit_assign_obj:
	if (UNEXPECTED(RETURN_VALUE_USED(opline)) && value) {
		ZVAL_COPY_DEREF(EX_VAR(opline->result.var), value);
	}
	zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
exit_assign_obj:
	if (garbage) {
		GC_DTOR_NO_REF(garbage);
	}

	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	/* assign_obj has two opcodes! */
	CREX_VM_NEXT_OPCODE_EX(1, 2);
}

/* No specialization for op_types (CONST|TMPVAR|CV, UNUSED|CONST|VAR) */
static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ASSIGN_OBJ_SPEC_VAR_CONST_OP_DATA_VAR_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *object, *value, tmp;
	crex_object *zobj;
	crex_string *name, *tmp_name;
	crex_refcounted *garbage = NULL;

	SAVE_OPLINE();
	object = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	value = _get_zval_ptr_var((opline+1)->op1.var EXECUTE_DATA_CC);

	if (IS_VAR != IS_UNUSED && UNEXPECTED(C_TYPE_P(object) != IS_OBJECT)) {
		if (C_ISREF_P(object) && C_TYPE_P(C_REFVAL_P(object)) == IS_OBJECT) {
			object = C_REFVAL_P(object);
			goto assign_object;
		}
		crex_throw_non_object_error(object, RT_CONSTANT(opline, opline->op2) OPLINE_CC EXECUTE_DATA_CC);
		value = &EG(uninitialized_zval);
		goto free_and_exit_assign_obj;
	}

assign_object:
	zobj = C_OBJ_P(object);
	if (IS_CONST == IS_CONST) {
		if (EXPECTED(zobj->ce == CACHED_PTR(opline->extended_value))) {
			void **cache_slot = CACHE_ADDR(opline->extended_value);
			uintptr_t prop_offset = (uintptr_t)CACHED_PTR_EX(cache_slot + 1);
			zval *property_val;

			if (EXPECTED(IS_VALID_PROPERTY_OFFSET(prop_offset))) {
				property_val = OBJ_PROP(zobj, prop_offset);
				if (C_TYPE_P(property_val) != IS_UNDEF) {
					crex_property_info *prop_info = (crex_property_info*) CACHED_PTR_EX(cache_slot + 2);

					if (UNEXPECTED(prop_info != NULL)) {
						value = crex_assign_to_typed_prop(prop_info, property_val, value, &garbage EXECUTE_DATA_CC);
						goto free_and_exit_assign_obj;
					} else {
fast_assign_obj:
						value = crex_assign_to_variable_ex(property_val, value, IS_VAR, EX_USES_STRICT_TYPES(), &garbage);
						if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
							ZVAL_COPY(EX_VAR(opline->result.var), value);
						}
						goto exit_assign_obj;
					}
				}
			} else {
				name = C_STR_P(RT_CONSTANT(opline, opline->op2));
				if (EXPECTED(zobj->properties != NULL)) {
					if (UNEXPECTED(GC_REFCOUNT(zobj->properties) > 1)) {
						if (EXPECTED(!(GC_FLAGS(zobj->properties) & IS_ARRAY_IMMUTABLE))) {
							GC_DELREF(zobj->properties);
						}
						zobj->properties = crex_array_dup(zobj->properties);
					}
					property_val = crex_hash_find_known_hash(zobj->properties, name);
					if (property_val) {
						goto fast_assign_obj;
					}
				}

				if (!zobj->ce->__set && (zobj->ce->ce_flags & CREX_ACC_ALLOW_DYNAMIC_PROPERTIES)) {
					if (EXPECTED(zobj->properties == NULL)) {
						rebuild_object_properties(zobj);
					}
					if (IS_VAR == IS_CONST) {
						if (UNEXPECTED(C_OPT_REFCOUNTED_P(value))) {
							C_ADDREF_P(value);
						}
					} else if (IS_VAR != IS_TMP_VAR) {
						if (C_ISREF_P(value)) {
							if (IS_VAR == IS_VAR) {
								crex_reference *ref = C_REF_P(value);
								if (GC_DELREF(ref) == 0) {
									ZVAL_COPY_VALUE(&tmp, C_REFVAL_P(value));
									efree_size(ref, sizeof(crex_reference));
									value = &tmp;
								} else {
									value = C_REFVAL_P(value);
									C_TRY_ADDREF_P(value);
								}
							} else {
								value = C_REFVAL_P(value);
								C_TRY_ADDREF_P(value);
							}
						} else if (IS_VAR == IS_CV) {
							C_TRY_ADDREF_P(value);
						}
						}
					crex_hash_add_new(zobj->properties, name, value);
					if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
						ZVAL_COPY(EX_VAR(opline->result.var), value);
					}
					goto exit_assign_obj;
				}
			}
		}
		name = C_STR_P(RT_CONSTANT(opline, opline->op2));
	} else {
		name = zval_try_get_tmp_string(RT_CONSTANT(opline, opline->op2), &tmp_name);
		if (UNEXPECTED(!name)) {
			zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
			UNDEF_RESULT();
			goto exit_assign_obj;
		}
	}

	if (IS_VAR == IS_CV || IS_VAR == IS_VAR) {
		ZVAL_DEREF(value);
	}

	value = zobj->handlers->write_property(zobj, name, value, (IS_CONST == IS_CONST) ? CACHE_ADDR(opline->extended_value) : NULL);

	if (IS_CONST != IS_CONST) {
		crex_tmp_string_release(tmp_name);
	}

free_and_exit_assign_obj:
	if (UNEXPECTED(RETURN_VALUE_USED(opline)) && value) {
		ZVAL_COPY_DEREF(EX_VAR(opline->result.var), value);
	}
	zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
exit_assign_obj:
	if (garbage) {
		GC_DTOR_NO_REF(garbage);
	}

	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	/* assign_obj has two opcodes! */
	CREX_VM_NEXT_OPCODE_EX(1, 2);
}

/* No specialization for op_types (CONST|TMPVAR|CV, UNUSED|CONST|VAR) */
static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ASSIGN_OBJ_SPEC_VAR_CONST_OP_DATA_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *object, *value, tmp;
	crex_object *zobj;
	crex_string *name, *tmp_name;
	crex_refcounted *garbage = NULL;

	SAVE_OPLINE();
	object = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	value = _get_zval_ptr_cv_BP_VAR_R((opline+1)->op1.var EXECUTE_DATA_CC);

	if (IS_VAR != IS_UNUSED && UNEXPECTED(C_TYPE_P(object) != IS_OBJECT)) {
		if (C_ISREF_P(object) && C_TYPE_P(C_REFVAL_P(object)) == IS_OBJECT) {
			object = C_REFVAL_P(object);
			goto assign_object;
		}
		crex_throw_non_object_error(object, RT_CONSTANT(opline, opline->op2) OPLINE_CC EXECUTE_DATA_CC);
		value = &EG(uninitialized_zval);
		goto free_and_exit_assign_obj;
	}

assign_object:
	zobj = C_OBJ_P(object);
	if (IS_CONST == IS_CONST) {
		if (EXPECTED(zobj->ce == CACHED_PTR(opline->extended_value))) {
			void **cache_slot = CACHE_ADDR(opline->extended_value);
			uintptr_t prop_offset = (uintptr_t)CACHED_PTR_EX(cache_slot + 1);
			zval *property_val;

			if (EXPECTED(IS_VALID_PROPERTY_OFFSET(prop_offset))) {
				property_val = OBJ_PROP(zobj, prop_offset);
				if (C_TYPE_P(property_val) != IS_UNDEF) {
					crex_property_info *prop_info = (crex_property_info*) CACHED_PTR_EX(cache_slot + 2);

					if (UNEXPECTED(prop_info != NULL)) {
						value = crex_assign_to_typed_prop(prop_info, property_val, value, &garbage EXECUTE_DATA_CC);
						goto free_and_exit_assign_obj;
					} else {
fast_assign_obj:
						value = crex_assign_to_variable_ex(property_val, value, IS_CV, EX_USES_STRICT_TYPES(), &garbage);
						if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
							ZVAL_COPY(EX_VAR(opline->result.var), value);
						}
						goto exit_assign_obj;
					}
				}
			} else {
				name = C_STR_P(RT_CONSTANT(opline, opline->op2));
				if (EXPECTED(zobj->properties != NULL)) {
					if (UNEXPECTED(GC_REFCOUNT(zobj->properties) > 1)) {
						if (EXPECTED(!(GC_FLAGS(zobj->properties) & IS_ARRAY_IMMUTABLE))) {
							GC_DELREF(zobj->properties);
						}
						zobj->properties = crex_array_dup(zobj->properties);
					}
					property_val = crex_hash_find_known_hash(zobj->properties, name);
					if (property_val) {
						goto fast_assign_obj;
					}
				}

				if (!zobj->ce->__set && (zobj->ce->ce_flags & CREX_ACC_ALLOW_DYNAMIC_PROPERTIES)) {
					if (EXPECTED(zobj->properties == NULL)) {
						rebuild_object_properties(zobj);
					}
					if (IS_CV == IS_CONST) {
						if (UNEXPECTED(C_OPT_REFCOUNTED_P(value))) {
							C_ADDREF_P(value);
						}
					} else if (IS_CV != IS_TMP_VAR) {
						if (C_ISREF_P(value)) {
							if (IS_CV == IS_VAR) {
								crex_reference *ref = C_REF_P(value);
								if (GC_DELREF(ref) == 0) {
									ZVAL_COPY_VALUE(&tmp, C_REFVAL_P(value));
									efree_size(ref, sizeof(crex_reference));
									value = &tmp;
								} else {
									value = C_REFVAL_P(value);
									C_TRY_ADDREF_P(value);
								}
							} else {
								value = C_REFVAL_P(value);
								C_TRY_ADDREF_P(value);
							}
						} else if (IS_CV == IS_CV) {
							C_TRY_ADDREF_P(value);
						}
						}
					crex_hash_add_new(zobj->properties, name, value);
					if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
						ZVAL_COPY(EX_VAR(opline->result.var), value);
					}
					goto exit_assign_obj;
				}
			}
		}
		name = C_STR_P(RT_CONSTANT(opline, opline->op2));
	} else {
		name = zval_try_get_tmp_string(RT_CONSTANT(opline, opline->op2), &tmp_name);
		if (UNEXPECTED(!name)) {

			UNDEF_RESULT();
			goto exit_assign_obj;
		}
	}

	if (IS_CV == IS_CV || IS_CV == IS_VAR) {
		ZVAL_DEREF(value);
	}

	value = zobj->handlers->write_property(zobj, name, value, (IS_CONST == IS_CONST) ? CACHE_ADDR(opline->extended_value) : NULL);

	if (IS_CONST != IS_CONST) {
		crex_tmp_string_release(tmp_name);
	}

free_and_exit_assign_obj:
	if (UNEXPECTED(RETURN_VALUE_USED(opline)) && value) {
		ZVAL_COPY_DEREF(EX_VAR(opline->result.var), value);
	}

exit_assign_obj:
	if (garbage) {
		GC_DTOR_NO_REF(garbage);
	}

	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	/* assign_obj has two opcodes! */
	CREX_VM_NEXT_OPCODE_EX(1, 2);
}

/* No specialization for op_types (CONST|TMPVAR|CV, UNUSED|CONST|VAR) */
static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ASSIGN_DIM_SPEC_VAR_CONST_OP_DATA_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *object_ptr, *orig_object_ptr;
	zval *value;
	zval *variable_ptr;
	zval *dim;
	crex_refcounted *garbage = NULL;

	SAVE_OPLINE();
	orig_object_ptr = object_ptr = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);

	if (EXPECTED(C_TYPE_P(object_ptr) == IS_ARRAY)) {
try_assign_dim_array:
		SEPARATE_ARRAY(object_ptr);
		if (IS_CONST == IS_UNUSED) {
			value = RT_CONSTANT((opline+1), (opline+1)->op1);
			if (IS_CONST == IS_CV && UNEXPECTED(C_TYPE_P(value) == IS_UNDEF)) {
				HashTable *ht = C_ARRVAL_P(object_ptr);
				if (!(GC_FLAGS(ht) & IS_ARRAY_IMMUTABLE)) {
					GC_ADDREF(ht);
				}
				value = zval_undefined_cv((opline+1)->op1.var EXECUTE_DATA_CC);
				if (!(GC_FLAGS(ht) & IS_ARRAY_IMMUTABLE) && !GC_DELREF(ht)) {
					crex_array_destroy(ht);
					goto assign_dim_error;
				}
			}
			if (IS_CONST == IS_CV || IS_CONST == IS_VAR) {
				ZVAL_DEREF(value);
			}
			value = crex_hash_next_index_insert(C_ARRVAL_P(object_ptr), value);
			if (UNEXPECTED(value == NULL)) {
				crex_cannot_add_element();
				goto assign_dim_error;
			} else if (IS_CONST == IS_CV) {
				if (C_REFCOUNTED_P(value)) {
					C_ADDREF_P(value);
				}
			} else if (IS_CONST == IS_VAR) {
				zval *free_op_data = EX_VAR((opline+1)->op1.var);
				if (C_ISREF_P(free_op_data)) {
					if (C_REFCOUNTED_P(value)) {
						C_ADDREF_P(value);
					}
					zval_ptr_dtor_nogc(free_op_data);
				}
			} else if (IS_CONST == IS_CONST) {
				if (UNEXPECTED(C_REFCOUNTED_P(value))) {
					C_ADDREF_P(value);
				}
			}
		} else {
			dim = RT_CONSTANT(opline, opline->op2);
			if (IS_CONST == IS_CONST) {
				variable_ptr = crex_fetch_dimension_address_inner_W_CONST(C_ARRVAL_P(object_ptr), dim EXECUTE_DATA_CC);
			} else {
				variable_ptr = crex_fetch_dimension_address_inner_W(C_ARRVAL_P(object_ptr), dim EXECUTE_DATA_CC);
			}
			if (UNEXPECTED(variable_ptr == NULL)) {
				goto assign_dim_error;
			}
			value = RT_CONSTANT((opline+1), (opline+1)->op1);
			value = crex_assign_to_variable_ex(variable_ptr, value, IS_CONST, EX_USES_STRICT_TYPES(), &garbage);
		}
		if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
			ZVAL_COPY(EX_VAR(opline->result.var), value);
		}
		if (garbage) {
			GC_DTOR_NO_REF(garbage);
		}
	} else {
		if (EXPECTED(C_ISREF_P(object_ptr))) {
			object_ptr = C_REFVAL_P(object_ptr);
			if (EXPECTED(C_TYPE_P(object_ptr) == IS_ARRAY)) {
				goto try_assign_dim_array;
			}
		}
		if (EXPECTED(C_TYPE_P(object_ptr) == IS_OBJECT)) {
			crex_object *obj = C_OBJ_P(object_ptr);

			GC_ADDREF(obj);
			dim = RT_CONSTANT(opline, opline->op2);
			if (IS_CONST == IS_CV && UNEXPECTED(C_ISUNDEF_P(dim))) {
				dim = ZVAL_UNDEFINED_OP2();
			} else if (IS_CONST == IS_CONST && C_EXTRA_P(dim) == CREX_EXTRA_VALUE) {
				dim++;
			}

			value = RT_CONSTANT((opline+1), (opline+1)->op1);
			if (IS_CONST == IS_CV && UNEXPECTED(C_ISUNDEF_P(value))) {
				value = zval_undefined_cv((opline+1)->op1.var EXECUTE_DATA_CC);
			} else if (IS_CONST & (IS_CV|IS_VAR)) {
				ZVAL_DEREF(value);
			}

			crex_assign_to_object_dim(obj, dim, value OPLINE_CC EXECUTE_DATA_CC);

			if (UNEXPECTED(GC_DELREF(obj) == 0)) {
				crex_objects_store_del(obj);
			}
		} else if (EXPECTED(C_TYPE_P(object_ptr) == IS_STRING)) {
			if (IS_CONST == IS_UNUSED) {
				crex_use_new_element_for_string();

				UNDEF_RESULT();
			} else {
				dim = RT_CONSTANT(opline, opline->op2);
				value = RT_CONSTANT((opline+1), (opline+1)->op1);
				crex_assign_to_string_offset(object_ptr, dim, value OPLINE_CC EXECUTE_DATA_CC);

			}
		} else if (EXPECTED(C_TYPE_P(object_ptr) <= IS_FALSE)) {
			if (C_ISREF_P(orig_object_ptr)
			 && CREX_REF_HAS_TYPE_SOURCES(C_REF_P(orig_object_ptr))
			 && !crex_verify_ref_array_assignable(C_REF_P(orig_object_ptr))) {
				dim = RT_CONSTANT(opline, opline->op2);

				UNDEF_RESULT();
			} else {
				HashTable *ht = crex_new_array(8);
				uint8_t old_type = C_TYPE_P(object_ptr);

				ZVAL_ARR(object_ptr, ht);
				if (UNEXPECTED(old_type == IS_FALSE)) {
					GC_ADDREF(ht);
					crex_false_to_array_deprecated();
					if (UNEXPECTED(GC_DELREF(ht) == 0)) {
						crex_array_destroy(ht);
						goto assign_dim_error;
					}
				}
				goto try_assign_dim_array;
			}
		} else {
			crex_use_scalar_as_array();
			dim = RT_CONSTANT(opline, opline->op2);
assign_dim_error:

			if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
				ZVAL_NULL(EX_VAR(opline->result.var));
			}
		}
	}
	if (IS_CONST != IS_UNUSED) {

	}
	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	/* assign_dim has two opcodes! */
	CREX_VM_NEXT_OPCODE_EX(1, 2);
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ASSIGN_DIM_SPEC_VAR_CONST_OP_DATA_TMP_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *object_ptr, *orig_object_ptr;
	zval *value;
	zval *variable_ptr;
	zval *dim;
	crex_refcounted *garbage = NULL;

	SAVE_OPLINE();
	orig_object_ptr = object_ptr = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);

	if (EXPECTED(C_TYPE_P(object_ptr) == IS_ARRAY)) {
try_assign_dim_array:
		SEPARATE_ARRAY(object_ptr);
		if (IS_CONST == IS_UNUSED) {
			value = _get_zval_ptr_tmp((opline+1)->op1.var EXECUTE_DATA_CC);
			if (IS_TMP_VAR == IS_CV && UNEXPECTED(C_TYPE_P(value) == IS_UNDEF)) {
				HashTable *ht = C_ARRVAL_P(object_ptr);
				if (!(GC_FLAGS(ht) & IS_ARRAY_IMMUTABLE)) {
					GC_ADDREF(ht);
				}
				value = zval_undefined_cv((opline+1)->op1.var EXECUTE_DATA_CC);
				if (!(GC_FLAGS(ht) & IS_ARRAY_IMMUTABLE) && !GC_DELREF(ht)) {
					crex_array_destroy(ht);
					goto assign_dim_error;
				}
			}
			if (IS_TMP_VAR == IS_CV || IS_TMP_VAR == IS_VAR) {
				ZVAL_DEREF(value);
			}
			value = crex_hash_next_index_insert(C_ARRVAL_P(object_ptr), value);
			if (UNEXPECTED(value == NULL)) {
				crex_cannot_add_element();
				goto assign_dim_error;
			} else if (IS_TMP_VAR == IS_CV) {
				if (C_REFCOUNTED_P(value)) {
					C_ADDREF_P(value);
				}
			} else if (IS_TMP_VAR == IS_VAR) {
				zval *free_op_data = EX_VAR((opline+1)->op1.var);
				if (C_ISREF_P(free_op_data)) {
					if (C_REFCOUNTED_P(value)) {
						C_ADDREF_P(value);
					}
					zval_ptr_dtor_nogc(free_op_data);
				}
			} else if (IS_TMP_VAR == IS_CONST) {
				if (UNEXPECTED(C_REFCOUNTED_P(value))) {
					C_ADDREF_P(value);
				}
			}
		} else {
			dim = RT_CONSTANT(opline, opline->op2);
			if (IS_CONST == IS_CONST) {
				variable_ptr = crex_fetch_dimension_address_inner_W_CONST(C_ARRVAL_P(object_ptr), dim EXECUTE_DATA_CC);
			} else {
				variable_ptr = crex_fetch_dimension_address_inner_W(C_ARRVAL_P(object_ptr), dim EXECUTE_DATA_CC);
			}
			if (UNEXPECTED(variable_ptr == NULL)) {
				goto assign_dim_error;
			}
			value = _get_zval_ptr_tmp((opline+1)->op1.var EXECUTE_DATA_CC);
			value = crex_assign_to_variable_ex(variable_ptr, value, IS_TMP_VAR, EX_USES_STRICT_TYPES(), &garbage);
		}
		if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
			ZVAL_COPY(EX_VAR(opline->result.var), value);
		}
		if (garbage) {
			GC_DTOR_NO_REF(garbage);
		}
	} else {
		if (EXPECTED(C_ISREF_P(object_ptr))) {
			object_ptr = C_REFVAL_P(object_ptr);
			if (EXPECTED(C_TYPE_P(object_ptr) == IS_ARRAY)) {
				goto try_assign_dim_array;
			}
		}
		if (EXPECTED(C_TYPE_P(object_ptr) == IS_OBJECT)) {
			crex_object *obj = C_OBJ_P(object_ptr);

			GC_ADDREF(obj);
			dim = RT_CONSTANT(opline, opline->op2);
			if (IS_CONST == IS_CV && UNEXPECTED(C_ISUNDEF_P(dim))) {
				dim = ZVAL_UNDEFINED_OP2();
			} else if (IS_CONST == IS_CONST && C_EXTRA_P(dim) == CREX_EXTRA_VALUE) {
				dim++;
			}

			value = _get_zval_ptr_tmp((opline+1)->op1.var EXECUTE_DATA_CC);
			if (IS_TMP_VAR == IS_CV && UNEXPECTED(C_ISUNDEF_P(value))) {
				value = zval_undefined_cv((opline+1)->op1.var EXECUTE_DATA_CC);
			} else if (IS_TMP_VAR & (IS_CV|IS_VAR)) {
				ZVAL_DEREF(value);
			}

			crex_assign_to_object_dim(obj, dim, value OPLINE_CC EXECUTE_DATA_CC);

			zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
			if (UNEXPECTED(GC_DELREF(obj) == 0)) {
				crex_objects_store_del(obj);
			}
		} else if (EXPECTED(C_TYPE_P(object_ptr) == IS_STRING)) {
			if (IS_CONST == IS_UNUSED) {
				crex_use_new_element_for_string();
				zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
				UNDEF_RESULT();
			} else {
				dim = RT_CONSTANT(opline, opline->op2);
				value = _get_zval_ptr_tmp((opline+1)->op1.var EXECUTE_DATA_CC);
				crex_assign_to_string_offset(object_ptr, dim, value OPLINE_CC EXECUTE_DATA_CC);
				zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
			}
		} else if (EXPECTED(C_TYPE_P(object_ptr) <= IS_FALSE)) {
			if (C_ISREF_P(orig_object_ptr)
			 && CREX_REF_HAS_TYPE_SOURCES(C_REF_P(orig_object_ptr))
			 && !crex_verify_ref_array_assignable(C_REF_P(orig_object_ptr))) {
				dim = RT_CONSTANT(opline, opline->op2);
				zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
				UNDEF_RESULT();
			} else {
				HashTable *ht = crex_new_array(8);
				uint8_t old_type = C_TYPE_P(object_ptr);

				ZVAL_ARR(object_ptr, ht);
				if (UNEXPECTED(old_type == IS_FALSE)) {
					GC_ADDREF(ht);
					crex_false_to_array_deprecated();
					if (UNEXPECTED(GC_DELREF(ht) == 0)) {
						crex_array_destroy(ht);
						goto assign_dim_error;
					}
				}
				goto try_assign_dim_array;
			}
		} else {
			crex_use_scalar_as_array();
			dim = RT_CONSTANT(opline, opline->op2);
assign_dim_error:
			zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
			if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
				ZVAL_NULL(EX_VAR(opline->result.var));
			}
		}
	}
	if (IS_CONST != IS_UNUSED) {

	}
	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	/* assign_dim has two opcodes! */
	CREX_VM_NEXT_OPCODE_EX(1, 2);
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ASSIGN_DIM_SPEC_VAR_CONST_OP_DATA_VAR_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *object_ptr, *orig_object_ptr;
	zval *value;
	zval *variable_ptr;
	zval *dim;
	crex_refcounted *garbage = NULL;

	SAVE_OPLINE();
	orig_object_ptr = object_ptr = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);

	if (EXPECTED(C_TYPE_P(object_ptr) == IS_ARRAY)) {
try_assign_dim_array:
		SEPARATE_ARRAY(object_ptr);
		if (IS_CONST == IS_UNUSED) {
			value = _get_zval_ptr_var((opline+1)->op1.var EXECUTE_DATA_CC);
			if (IS_VAR == IS_CV && UNEXPECTED(C_TYPE_P(value) == IS_UNDEF)) {
				HashTable *ht = C_ARRVAL_P(object_ptr);
				if (!(GC_FLAGS(ht) & IS_ARRAY_IMMUTABLE)) {
					GC_ADDREF(ht);
				}
				value = zval_undefined_cv((opline+1)->op1.var EXECUTE_DATA_CC);
				if (!(GC_FLAGS(ht) & IS_ARRAY_IMMUTABLE) && !GC_DELREF(ht)) {
					crex_array_destroy(ht);
					goto assign_dim_error;
				}
			}
			if (IS_VAR == IS_CV || IS_VAR == IS_VAR) {
				ZVAL_DEREF(value);
			}
			value = crex_hash_next_index_insert(C_ARRVAL_P(object_ptr), value);
			if (UNEXPECTED(value == NULL)) {
				crex_cannot_add_element();
				goto assign_dim_error;
			} else if (IS_VAR == IS_CV) {
				if (C_REFCOUNTED_P(value)) {
					C_ADDREF_P(value);
				}
			} else if (IS_VAR == IS_VAR) {
				zval *free_op_data = EX_VAR((opline+1)->op1.var);
				if (C_ISREF_P(free_op_data)) {
					if (C_REFCOUNTED_P(value)) {
						C_ADDREF_P(value);
					}
					zval_ptr_dtor_nogc(free_op_data);
				}
			} else if (IS_VAR == IS_CONST) {
				if (UNEXPECTED(C_REFCOUNTED_P(value))) {
					C_ADDREF_P(value);
				}
			}
		} else {
			dim = RT_CONSTANT(opline, opline->op2);
			if (IS_CONST == IS_CONST) {
				variable_ptr = crex_fetch_dimension_address_inner_W_CONST(C_ARRVAL_P(object_ptr), dim EXECUTE_DATA_CC);
			} else {
				variable_ptr = crex_fetch_dimension_address_inner_W(C_ARRVAL_P(object_ptr), dim EXECUTE_DATA_CC);
			}
			if (UNEXPECTED(variable_ptr == NULL)) {
				goto assign_dim_error;
			}
			value = _get_zval_ptr_var((opline+1)->op1.var EXECUTE_DATA_CC);
			value = crex_assign_to_variable_ex(variable_ptr, value, IS_VAR, EX_USES_STRICT_TYPES(), &garbage);
		}
		if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
			ZVAL_COPY(EX_VAR(opline->result.var), value);
		}
		if (garbage) {
			GC_DTOR_NO_REF(garbage);
		}
	} else {
		if (EXPECTED(C_ISREF_P(object_ptr))) {
			object_ptr = C_REFVAL_P(object_ptr);
			if (EXPECTED(C_TYPE_P(object_ptr) == IS_ARRAY)) {
				goto try_assign_dim_array;
			}
		}
		if (EXPECTED(C_TYPE_P(object_ptr) == IS_OBJECT)) {
			crex_object *obj = C_OBJ_P(object_ptr);

			GC_ADDREF(obj);
			dim = RT_CONSTANT(opline, opline->op2);
			if (IS_CONST == IS_CV && UNEXPECTED(C_ISUNDEF_P(dim))) {
				dim = ZVAL_UNDEFINED_OP2();
			} else if (IS_CONST == IS_CONST && C_EXTRA_P(dim) == CREX_EXTRA_VALUE) {
				dim++;
			}

			value = _get_zval_ptr_var((opline+1)->op1.var EXECUTE_DATA_CC);
			if (IS_VAR == IS_CV && UNEXPECTED(C_ISUNDEF_P(value))) {
				value = zval_undefined_cv((opline+1)->op1.var EXECUTE_DATA_CC);
			} else if (IS_VAR & (IS_CV|IS_VAR)) {
				ZVAL_DEREF(value);
			}

			crex_assign_to_object_dim(obj, dim, value OPLINE_CC EXECUTE_DATA_CC);

			zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
			if (UNEXPECTED(GC_DELREF(obj) == 0)) {
				crex_objects_store_del(obj);
			}
		} else if (EXPECTED(C_TYPE_P(object_ptr) == IS_STRING)) {
			if (IS_CONST == IS_UNUSED) {
				crex_use_new_element_for_string();
				zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
				UNDEF_RESULT();
			} else {
				dim = RT_CONSTANT(opline, opline->op2);
				value = _get_zval_ptr_var((opline+1)->op1.var EXECUTE_DATA_CC);
				crex_assign_to_string_offset(object_ptr, dim, value OPLINE_CC EXECUTE_DATA_CC);
				zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
			}
		} else if (EXPECTED(C_TYPE_P(object_ptr) <= IS_FALSE)) {
			if (C_ISREF_P(orig_object_ptr)
			 && CREX_REF_HAS_TYPE_SOURCES(C_REF_P(orig_object_ptr))
			 && !crex_verify_ref_array_assignable(C_REF_P(orig_object_ptr))) {
				dim = RT_CONSTANT(opline, opline->op2);
				zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
				UNDEF_RESULT();
			} else {
				HashTable *ht = crex_new_array(8);
				uint8_t old_type = C_TYPE_P(object_ptr);

				ZVAL_ARR(object_ptr, ht);
				if (UNEXPECTED(old_type == IS_FALSE)) {
					GC_ADDREF(ht);
					crex_false_to_array_deprecated();
					if (UNEXPECTED(GC_DELREF(ht) == 0)) {
						crex_array_destroy(ht);
						goto assign_dim_error;
					}
				}
				goto try_assign_dim_array;
			}
		} else {
			crex_use_scalar_as_array();
			dim = RT_CONSTANT(opline, opline->op2);
assign_dim_error:
			zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
			if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
				ZVAL_NULL(EX_VAR(opline->result.var));
			}
		}
	}
	if (IS_CONST != IS_UNUSED) {

	}
	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	/* assign_dim has two opcodes! */
	CREX_VM_NEXT_OPCODE_EX(1, 2);
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ASSIGN_DIM_SPEC_VAR_CONST_OP_DATA_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *object_ptr, *orig_object_ptr;
	zval *value;
	zval *variable_ptr;
	zval *dim;
	crex_refcounted *garbage = NULL;

	SAVE_OPLINE();
	orig_object_ptr = object_ptr = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);

	if (EXPECTED(C_TYPE_P(object_ptr) == IS_ARRAY)) {
try_assign_dim_array:
		SEPARATE_ARRAY(object_ptr);
		if (IS_CONST == IS_UNUSED) {
			value = EX_VAR((opline+1)->op1.var);
			if (IS_CV == IS_CV && UNEXPECTED(C_TYPE_P(value) == IS_UNDEF)) {
				HashTable *ht = C_ARRVAL_P(object_ptr);
				if (!(GC_FLAGS(ht) & IS_ARRAY_IMMUTABLE)) {
					GC_ADDREF(ht);
				}
				value = zval_undefined_cv((opline+1)->op1.var EXECUTE_DATA_CC);
				if (!(GC_FLAGS(ht) & IS_ARRAY_IMMUTABLE) && !GC_DELREF(ht)) {
					crex_array_destroy(ht);
					goto assign_dim_error;
				}
			}
			if (IS_CV == IS_CV || IS_CV == IS_VAR) {
				ZVAL_DEREF(value);
			}
			value = crex_hash_next_index_insert(C_ARRVAL_P(object_ptr), value);
			if (UNEXPECTED(value == NULL)) {
				crex_cannot_add_element();
				goto assign_dim_error;
			} else if (IS_CV == IS_CV) {
				if (C_REFCOUNTED_P(value)) {
					C_ADDREF_P(value);
				}
			} else if (IS_CV == IS_VAR) {
				zval *free_op_data = EX_VAR((opline+1)->op1.var);
				if (C_ISREF_P(free_op_data)) {
					if (C_REFCOUNTED_P(value)) {
						C_ADDREF_P(value);
					}
					zval_ptr_dtor_nogc(free_op_data);
				}
			} else if (IS_CV == IS_CONST) {
				if (UNEXPECTED(C_REFCOUNTED_P(value))) {
					C_ADDREF_P(value);
				}
			}
		} else {
			dim = RT_CONSTANT(opline, opline->op2);
			if (IS_CONST == IS_CONST) {
				variable_ptr = crex_fetch_dimension_address_inner_W_CONST(C_ARRVAL_P(object_ptr), dim EXECUTE_DATA_CC);
			} else {
				variable_ptr = crex_fetch_dimension_address_inner_W(C_ARRVAL_P(object_ptr), dim EXECUTE_DATA_CC);
			}
			if (UNEXPECTED(variable_ptr == NULL)) {
				goto assign_dim_error;
			}
			value = _get_zval_ptr_cv_BP_VAR_R((opline+1)->op1.var EXECUTE_DATA_CC);
			value = crex_assign_to_variable_ex(variable_ptr, value, IS_CV, EX_USES_STRICT_TYPES(), &garbage);
		}
		if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
			ZVAL_COPY(EX_VAR(opline->result.var), value);
		}
		if (garbage) {
			GC_DTOR_NO_REF(garbage);
		}
	} else {
		if (EXPECTED(C_ISREF_P(object_ptr))) {
			object_ptr = C_REFVAL_P(object_ptr);
			if (EXPECTED(C_TYPE_P(object_ptr) == IS_ARRAY)) {
				goto try_assign_dim_array;
			}
		}
		if (EXPECTED(C_TYPE_P(object_ptr) == IS_OBJECT)) {
			crex_object *obj = C_OBJ_P(object_ptr);

			GC_ADDREF(obj);
			dim = RT_CONSTANT(opline, opline->op2);
			if (IS_CONST == IS_CV && UNEXPECTED(C_ISUNDEF_P(dim))) {
				dim = ZVAL_UNDEFINED_OP2();
			} else if (IS_CONST == IS_CONST && C_EXTRA_P(dim) == CREX_EXTRA_VALUE) {
				dim++;
			}

			value = EX_VAR((opline+1)->op1.var);
			if (IS_CV == IS_CV && UNEXPECTED(C_ISUNDEF_P(value))) {
				value = zval_undefined_cv((opline+1)->op1.var EXECUTE_DATA_CC);
			} else if (IS_CV & (IS_CV|IS_VAR)) {
				ZVAL_DEREF(value);
			}

			crex_assign_to_object_dim(obj, dim, value OPLINE_CC EXECUTE_DATA_CC);

			if (UNEXPECTED(GC_DELREF(obj) == 0)) {
				crex_objects_store_del(obj);
			}
		} else if (EXPECTED(C_TYPE_P(object_ptr) == IS_STRING)) {
			if (IS_CONST == IS_UNUSED) {
				crex_use_new_element_for_string();

				UNDEF_RESULT();
			} else {
				dim = RT_CONSTANT(opline, opline->op2);
				value = EX_VAR((opline+1)->op1.var);
				crex_assign_to_string_offset(object_ptr, dim, value OPLINE_CC EXECUTE_DATA_CC);

			}
		} else if (EXPECTED(C_TYPE_P(object_ptr) <= IS_FALSE)) {
			if (C_ISREF_P(orig_object_ptr)
			 && CREX_REF_HAS_TYPE_SOURCES(C_REF_P(orig_object_ptr))
			 && !crex_verify_ref_array_assignable(C_REF_P(orig_object_ptr))) {
				dim = RT_CONSTANT(opline, opline->op2);

				UNDEF_RESULT();
			} else {
				HashTable *ht = crex_new_array(8);
				uint8_t old_type = C_TYPE_P(object_ptr);

				ZVAL_ARR(object_ptr, ht);
				if (UNEXPECTED(old_type == IS_FALSE)) {
					GC_ADDREF(ht);
					crex_false_to_array_deprecated();
					if (UNEXPECTED(GC_DELREF(ht) == 0)) {
						crex_array_destroy(ht);
						goto assign_dim_error;
					}
				}
				goto try_assign_dim_array;
			}
		} else {
			crex_use_scalar_as_array();
			dim = RT_CONSTANT(opline, opline->op2);
assign_dim_error:

			if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
				ZVAL_NULL(EX_VAR(opline->result.var));
			}
		}
	}
	if (IS_CONST != IS_UNUSED) {

	}
	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	/* assign_dim has two opcodes! */
	CREX_VM_NEXT_OPCODE_EX(1, 2);
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ASSIGN_SPEC_VAR_CONST_RETVAL_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *value;
	zval *variable_ptr;

	SAVE_OPLINE();
	value = RT_CONSTANT(opline, opline->op2);
	variable_ptr = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);

	if (0 || UNEXPECTED(0)) {
		crex_refcounted *garbage = NULL;

		value = crex_assign_to_variable_ex(variable_ptr, value, IS_CONST, EX_USES_STRICT_TYPES(), &garbage);
		if (UNEXPECTED(0)) {
			ZVAL_COPY(EX_VAR(opline->result.var), value);
		}
		if (garbage) {
			GC_DTOR_NO_REF(garbage);
		}
	} else {
		value = crex_assign_to_variable(variable_ptr, value, IS_CONST, EX_USES_STRICT_TYPES());
	}
	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	/* crex_assign_to_variable() always takes care of op2, never free it! */

	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ASSIGN_SPEC_VAR_CONST_RETVAL_USED_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *value;
	zval *variable_ptr;

	SAVE_OPLINE();
	value = RT_CONSTANT(opline, opline->op2);
	variable_ptr = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);

	if (0 || UNEXPECTED(1)) {
		crex_refcounted *garbage = NULL;

		value = crex_assign_to_variable_ex(variable_ptr, value, IS_CONST, EX_USES_STRICT_TYPES(), &garbage);
		if (UNEXPECTED(1)) {
			ZVAL_COPY(EX_VAR(opline->result.var), value);
		}
		if (garbage) {
			GC_DTOR_NO_REF(garbage);
		}
	} else {
		value = crex_assign_to_variable(variable_ptr, value, IS_CONST, EX_USES_STRICT_TYPES());
	}
	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	/* crex_assign_to_variable() always takes care of op2, never free it! */

	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ASSIGN_OBJ_REF_SPEC_VAR_CONST_OP_DATA_VAR_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *property, *container, *value_ptr;

	SAVE_OPLINE();

	container = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	property = RT_CONSTANT(opline, opline->op2);

	value_ptr = _get_zval_ptr_ptr_var((opline+1)->op1.var EXECUTE_DATA_CC);

	if (1) {
		if (IS_VAR == IS_UNUSED) {
			if (IS_CONST == IS_CONST) {
				crex_assign_to_property_reference_this_const(container, property, value_ptr OPLINE_CC EXECUTE_DATA_CC);
			} else {
				crex_assign_to_property_reference_this_var(container, property, value_ptr OPLINE_CC EXECUTE_DATA_CC);
			}
		} else {
			if (IS_CONST == IS_CONST) {
				crex_assign_to_property_reference_var_const(container, property, value_ptr OPLINE_CC EXECUTE_DATA_CC);
			} else {
				crex_assign_to_property_reference_var_var(container, property, value_ptr OPLINE_CC EXECUTE_DATA_CC);
			}
		}
	} else {
		crex_assign_to_property_reference(container, IS_VAR, property, IS_CONST, value_ptr OPLINE_CC EXECUTE_DATA_CC);
	}

	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));

	zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
	CREX_VM_NEXT_OPCODE_EX(1, 2);
}

/* No specialization for op_types (CONST|TMPVAR|CV, UNUSED|CONST|VAR) */
static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ASSIGN_OBJ_REF_SPEC_VAR_CONST_OP_DATA_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *property, *container, *value_ptr;

	SAVE_OPLINE();

	container = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	property = RT_CONSTANT(opline, opline->op2);

	value_ptr = _get_zval_ptr_cv_BP_VAR_W((opline+1)->op1.var EXECUTE_DATA_CC);

	if (1) {
		if (IS_VAR == IS_UNUSED) {
			if (IS_CONST == IS_CONST) {
				crex_assign_to_property_reference_this_const(container, property, value_ptr OPLINE_CC EXECUTE_DATA_CC);
			} else {
				crex_assign_to_property_reference_this_var(container, property, value_ptr OPLINE_CC EXECUTE_DATA_CC);
			}
		} else {
			if (IS_CONST == IS_CONST) {
				crex_assign_to_property_reference_var_const(container, property, value_ptr OPLINE_CC EXECUTE_DATA_CC);
			} else {
				crex_assign_to_property_reference_var_var(container, property, value_ptr OPLINE_CC EXECUTE_DATA_CC);
			}
		}
	} else {
		crex_assign_to_property_reference(container, IS_VAR, property, IS_CONST, value_ptr OPLINE_CC EXECUTE_DATA_CC);
	}

	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));


	CREX_VM_NEXT_OPCODE_EX(1, 2);
}

/* No specialization for op_types (CONST|TMPVAR|CV, UNUSED|CONST|VAR) */
static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_INIT_STATIC_METHOD_CALL_SPEC_VAR_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *function_name;
	crex_class_entry *ce;
	uint32_t call_info;
	crex_function *fbc;
	crex_execute_data *call;

	SAVE_OPLINE();

	if (IS_VAR == IS_CONST) {
		/* no function found. try a static method in class */
		ce = CACHED_PTR(opline->result.num);
		if (UNEXPECTED(ce == NULL)) {
			ce = crex_fetch_class_by_name(C_STR_P(RT_CONSTANT(opline, opline->op1)), C_STR_P(RT_CONSTANT(opline, opline->op1) + 1), CREX_FETCH_CLASS_DEFAULT | CREX_FETCH_CLASS_EXCEPTION);
			if (UNEXPECTED(ce == NULL)) {

				HANDLE_EXCEPTION();
			}
			if (IS_CONST != IS_CONST) {
				CACHE_PTR(opline->result.num, ce);
			}
		}
	} else if (IS_VAR == IS_UNUSED) {
		ce = crex_fetch_class(NULL, opline->op1.num);
		if (UNEXPECTED(ce == NULL)) {

			HANDLE_EXCEPTION();
		}
	} else {
		ce = C_CE_P(EX_VAR(opline->op1.var));
	}

	if (IS_VAR == IS_CONST &&
	    IS_CONST == IS_CONST &&
	    EXPECTED((fbc = CACHED_PTR(opline->result.num + sizeof(void*))) != NULL)) {
		/* nothing to do */
	} else if (IS_VAR != IS_CONST &&
	           IS_CONST == IS_CONST &&
	           EXPECTED(CACHED_PTR(opline->result.num) == ce)) {
		fbc = CACHED_PTR(opline->result.num + sizeof(void*));
	} else if (IS_CONST != IS_UNUSED) {
		function_name = RT_CONSTANT(opline, opline->op2);
		if (IS_CONST != IS_CONST) {
			if (UNEXPECTED(C_TYPE_P(function_name) != IS_STRING)) {
				do {
					if (IS_CONST & (IS_VAR|IS_CV) && C_ISREF_P(function_name)) {
						function_name = C_REFVAL_P(function_name);
						if (EXPECTED(C_TYPE_P(function_name) == IS_STRING)) {
							break;
						}
					} else if (IS_CONST == IS_CV && UNEXPECTED(C_TYPE_P(function_name) == IS_UNDEF)) {
						ZVAL_UNDEFINED_OP2();
						if (UNEXPECTED(EG(exception) != NULL)) {
							HANDLE_EXCEPTION();
						}
					}
					crex_throw_error(NULL, "Method name must be a string");

					HANDLE_EXCEPTION();
				} while (0);
			}
		}

		if (ce->get_static_method) {
			fbc = ce->get_static_method(ce, C_STR_P(function_name));
		} else {
			fbc = crex_std_get_static_method(ce, C_STR_P(function_name), ((IS_CONST == IS_CONST) ? (RT_CONSTANT(opline, opline->op2) + 1) : NULL));
		}
		if (UNEXPECTED(fbc == NULL)) {
			if (EXPECTED(!EG(exception))) {
				crex_undefined_method(ce, C_STR_P(function_name));
			}

			HANDLE_EXCEPTION();
		}
		if (IS_CONST == IS_CONST &&
		    EXPECTED(!(fbc->common.fn_flags & (CREX_ACC_CALL_VIA_TRAMPOLINE|CREX_ACC_NEVER_CACHE))) &&
			EXPECTED(!(fbc->common.scope->ce_flags & CREX_ACC_TRAIT))) {
			CACHE_POLYMORPHIC_PTR(opline->result.num, ce, fbc);
		}
		if (EXPECTED(fbc->type == CREX_USER_FUNCTION) && UNEXPECTED(!RUN_TIME_CACHE(&fbc->op_array))) {
			init_func_run_time_cache(&fbc->op_array);
		}
		if (IS_CONST != IS_CONST) {

		}
	} else {
		if (UNEXPECTED(ce->constructor == NULL)) {
			crex_throw_error(NULL, "Cannot call constructor");
			HANDLE_EXCEPTION();
		}
		if (C_TYPE(EX(This)) == IS_OBJECT && C_OBJ(EX(This))->ce != ce->constructor->common.scope && (ce->constructor->common.fn_flags & CREX_ACC_PRIVATE)) {
			crex_throw_error(NULL, "Cannot call private %s::__main()", ZSTR_VAL(ce->name));
			HANDLE_EXCEPTION();
		}
		fbc = ce->constructor;
		if (EXPECTED(fbc->type == CREX_USER_FUNCTION) && UNEXPECTED(!RUN_TIME_CACHE(&fbc->op_array))) {
			init_func_run_time_cache(&fbc->op_array);
		}
	}

	if (!(fbc->common.fn_flags & CREX_ACC_STATIC)) {
		if (C_TYPE(EX(This)) == IS_OBJECT && instanceof_function(C_OBJCE(EX(This)), ce)) {
			ce = (crex_class_entry*)C_OBJ(EX(This));
			call_info = CREX_CALL_NESTED_FUNCTION | CREX_CALL_HAS_THIS;
		} else {
			crex_non_static_method_call(fbc);
			HANDLE_EXCEPTION();
		}
	} else {
		/* previous opcode is CREX_FETCH_CLASS */
		if (IS_VAR == IS_UNUSED
		 && ((opline->op1.num & CREX_FETCH_CLASS_MASK) == CREX_FETCH_CLASS_PARENT ||
		     (opline->op1.num & CREX_FETCH_CLASS_MASK) == CREX_FETCH_CLASS_SELF)) {
			if (C_TYPE(EX(This)) == IS_OBJECT) {
				ce = C_OBJCE(EX(This));
			} else {
				ce = C_CE(EX(This));
			}
		}
		call_info = CREX_CALL_NESTED_FUNCTION;
	}

	call = crex_vm_stack_push_call_frame(call_info,
		fbc, opline->extended_value, ce);
	call->prev_execute_data = EX(call);
	EX(call) = call;

	CREX_VM_NEXT_OPCODE();
}

static CREX_VM_HOT CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_SEND_VAR_SPEC_VAR_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *varptr, *arg;

	if (IS_CONST == IS_CONST) {
		SAVE_OPLINE();
		crex_string *arg_name = C_STR_P(RT_CONSTANT(opline, opline->op2));
		uint32_t arg_num;
		arg = crex_handle_named_arg(&EX(call), arg_name, &arg_num, CACHE_ADDR(opline->result.num));
		if (UNEXPECTED(!arg)) {
			zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
			HANDLE_EXCEPTION();
		}
	} else {
		arg = CREX_CALL_VAR(EX(call), opline->result.var);
	}

	varptr = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	if (IS_VAR == IS_CV && UNEXPECTED(C_TYPE_INFO_P(varptr) == IS_UNDEF)) {
		SAVE_OPLINE();
		ZVAL_UNDEFINED_OP1();
		ZVAL_NULL(arg);
		CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
	}

	if (IS_VAR == IS_CV) {
		ZVAL_COPY_DEREF(arg, varptr);
	} else /* if (IS_VAR == IS_VAR) */ {
		if (UNEXPECTED(C_ISREF_P(varptr))) {
			crex_refcounted *ref = C_COUNTED_P(varptr);

			varptr = C_REFVAL_P(varptr);
			ZVAL_COPY_VALUE(arg, varptr);
			if (UNEXPECTED(GC_DELREF(ref) == 0)) {
				efree_size(ref, sizeof(crex_reference));
			} else if (C_OPT_REFCOUNTED_P(arg)) {
				C_ADDREF_P(arg);
			}
		} else {
			ZVAL_COPY_VALUE(arg, varptr);
		}
	}

	CREX_VM_NEXT_OPCODE();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_SEND_VAR_NO_REF_SPEC_VAR_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *varptr, *arg;

	if (IS_CONST == IS_CONST) {
		SAVE_OPLINE();
		crex_string *arg_name = C_STR_P(RT_CONSTANT(opline, opline->op2));
		uint32_t arg_num;
		arg = crex_handle_named_arg(&EX(call), arg_name, &arg_num, CACHE_ADDR(opline->result.num));
		if (UNEXPECTED(!arg)) {
			zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
			HANDLE_EXCEPTION();
		}
	} else {
		arg = CREX_CALL_VAR(EX(call), opline->result.var);
	}

	varptr = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	ZVAL_COPY_VALUE(arg, varptr);

	if (EXPECTED(C_ISREF_P(varptr))) {
		CREX_VM_NEXT_OPCODE();
	}

	SAVE_OPLINE();
	ZVAL_NEW_REF(arg, arg);
	crex_error(E_NOTICE, "Only variables should be passed by reference");
	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_SEND_VAR_NO_REF_EX_SPEC_VAR_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *varptr, *arg;
	uint32_t arg_num;

	if (IS_CONST == IS_CONST) {
		SAVE_OPLINE();
		crex_string *arg_name = C_STR_P(RT_CONSTANT(opline, opline->op2));
		arg = crex_handle_named_arg(&EX(call), arg_name, &arg_num, CACHE_ADDR(opline->result.num));
		if (UNEXPECTED(!arg)) {
			zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
			HANDLE_EXCEPTION();
		}
	} else {
		arg = CREX_CALL_VAR(EX(call), opline->result.var);
		arg_num = opline->op2.num;
	}

	if (EXPECTED(arg_num <= MAX_ARG_FLAG_NUM)) {
		if (!QUICK_ARG_SHOULD_BE_SENT_BY_REF(EX(call)->func, arg_num)) {
			goto send_var;
		}

		varptr = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);
		ZVAL_COPY_VALUE(arg, varptr);

		if (EXPECTED(C_ISREF_P(varptr) ||
		    QUICK_ARG_MAY_BE_SENT_BY_REF(EX(call)->func, arg_num))) {
			CREX_VM_NEXT_OPCODE();
		}
	} else {
		if (!ARG_SHOULD_BE_SENT_BY_REF(EX(call)->func, arg_num)) {
			goto send_var;
		}

		varptr = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);
		ZVAL_COPY_VALUE(arg, varptr);

		if (EXPECTED(C_ISREF_P(varptr) ||
		    ARG_MAY_BE_SENT_BY_REF(EX(call)->func, arg_num))) {
			CREX_VM_NEXT_OPCODE();
		}
	}

	SAVE_OPLINE();
	ZVAL_NEW_REF(arg, arg);
	crex_error(E_NOTICE, "Only variables should be passed by reference");
	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();

send_var:
	varptr = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	if (UNEXPECTED(C_ISREF_P(varptr))) {
		crex_refcounted *ref = C_COUNTED_P(varptr);

		varptr = C_REFVAL_P(varptr);
		ZVAL_COPY_VALUE(arg, varptr);
		if (UNEXPECTED(GC_DELREF(ref) == 0)) {
			efree_size(ref, sizeof(crex_reference));
		} else if (C_OPT_REFCOUNTED_P(arg)) {
			C_ADDREF_P(arg);
		}
	} else {
		ZVAL_COPY_VALUE(arg, varptr);
	}
	CREX_VM_NEXT_OPCODE();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_SEND_REF_SPEC_VAR_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *varptr, *arg;

	SAVE_OPLINE();
	if (IS_CONST == IS_CONST) {
		crex_string *arg_name = C_STR_P(RT_CONSTANT(opline, opline->op2));
		uint32_t arg_num;
		arg = crex_handle_named_arg(&EX(call), arg_name, &arg_num, CACHE_ADDR(opline->result.num));
		if (UNEXPECTED(!arg)) {
			zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
			HANDLE_EXCEPTION();
		}
	} else {
		arg = CREX_CALL_VAR(EX(call), opline->result.var);
	}

	varptr = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	if (C_ISREF_P(varptr)) {
		C_ADDREF_P(varptr);
	} else {
		ZVAL_MAKE_REF_EX(varptr, 2);
	}
	ZVAL_REF(arg, C_REF_P(varptr));

	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	CREX_VM_NEXT_OPCODE();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_SEND_VAR_EX_SPEC_VAR_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *varptr, *arg;
	uint32_t arg_num;

	if (IS_CONST == IS_CONST) {
		SAVE_OPLINE();
		crex_string *arg_name = C_STR_P(RT_CONSTANT(opline, opline->op2));
		arg = crex_handle_named_arg(&EX(call), arg_name, &arg_num, CACHE_ADDR(opline->result.num));
		if (UNEXPECTED(!arg)) {
			zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
			HANDLE_EXCEPTION();
		}
	} else {
		arg = CREX_CALL_VAR(EX(call), opline->result.var);
		arg_num = opline->op2.num;
	}

	if (EXPECTED(arg_num <= MAX_ARG_FLAG_NUM)) {
		if (QUICK_ARG_SHOULD_BE_SENT_BY_REF(EX(call)->func, arg_num)) {
			goto send_var_by_ref;
		}
	} else if (ARG_SHOULD_BE_SENT_BY_REF(EX(call)->func, arg_num)) {
send_var_by_ref:
		varptr = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);
		if (C_ISREF_P(varptr)) {
			C_ADDREF_P(varptr);
		} else {
			ZVAL_MAKE_REF_EX(varptr, 2);
		}
		ZVAL_REF(arg, C_REF_P(varptr));

		zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
		CREX_VM_NEXT_OPCODE();
	}

	varptr = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	if (IS_VAR == IS_CV && UNEXPECTED(C_TYPE_INFO_P(varptr) == IS_UNDEF)) {
		SAVE_OPLINE();
		ZVAL_UNDEFINED_OP1();
		ZVAL_NULL(arg);
		CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
	}

	if (IS_VAR == IS_CV) {
		ZVAL_COPY_DEREF(arg, varptr);
	} else /* if (IS_VAR == IS_VAR) */ {
		if (UNEXPECTED(C_ISREF_P(varptr))) {
			crex_refcounted *ref = C_COUNTED_P(varptr);

			varptr = C_REFVAL_P(varptr);
			ZVAL_COPY_VALUE(arg, varptr);
			if (UNEXPECTED(GC_DELREF(ref) == 0)) {
				efree_size(ref, sizeof(crex_reference));
			} else if (C_OPT_REFCOUNTED_P(arg)) {
				C_ADDREF_P(arg);
			}
		} else {
			ZVAL_COPY_VALUE(arg, varptr);
		}
	}

	CREX_VM_NEXT_OPCODE();
}

static CREX_VM_HOT CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_SEND_FUNC_ARG_SPEC_VAR_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *varptr, *arg;

	if (IS_CONST == IS_CONST) {
		// TODO: Would it make sense to share the cache slot with CHECK_FUNC_ARG?
		SAVE_OPLINE();
		crex_string *arg_name = C_STR_P(RT_CONSTANT(opline, opline->op2));
		uint32_t arg_num;
		arg = crex_handle_named_arg(&EX(call), arg_name, &arg_num, CACHE_ADDR(opline->result.num));
		if (UNEXPECTED(!arg)) {
			zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
			HANDLE_EXCEPTION();
		}
	} else {
		arg = CREX_CALL_VAR(EX(call), opline->result.var);
	}

	if (UNEXPECTED(CREX_CALL_INFO(EX(call)) & CREX_CALL_SEND_ARG_BY_REF)) {
		varptr = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);
		if (C_ISREF_P(varptr)) {
			C_ADDREF_P(varptr);
		} else {
			ZVAL_MAKE_REF_EX(varptr, 2);
		}
		ZVAL_REF(arg, C_REF_P(varptr));

		zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
		CREX_VM_NEXT_OPCODE();
	}

	varptr = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);

	if (UNEXPECTED(C_ISREF_P(varptr))) {
		crex_refcounted *ref = C_COUNTED_P(varptr);

		varptr = C_REFVAL_P(varptr);
		ZVAL_COPY_VALUE(arg, varptr);
		if (UNEXPECTED(GC_DELREF(ref) == 0)) {
			efree_size(ref, sizeof(crex_reference));
		} else if (C_OPT_REFCOUNTED_P(arg)) {
			C_ADDREF_P(arg);
		}
	} else {
		ZVAL_COPY_VALUE(arg, varptr);
	}

	CREX_VM_NEXT_OPCODE();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FETCH_CLASS_CONSTANT_SPEC_VAR_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	crex_class_entry *ce, *scope;
	crex_class_constant *c;
	zval *value, *zv, *constant_zv;
	crex_string *constant_name;
	USE_OPLINE

	SAVE_OPLINE();

	do {
		if (IS_VAR == IS_CONST && IS_CONST == IS_CONST) {
			if (EXPECTED(CACHED_PTR(opline->extended_value + sizeof(void*)))) {
				value = CACHED_PTR(opline->extended_value + sizeof(void*));
				break;
			}
		}
		if (IS_VAR == IS_CONST) {
			if (EXPECTED(CACHED_PTR(opline->extended_value))) {
				ce = CACHED_PTR(opline->extended_value);
			} else {
				ce = crex_fetch_class_by_name(C_STR_P(RT_CONSTANT(opline, opline->op1)), C_STR_P(RT_CONSTANT(opline, opline->op1) + 1), CREX_FETCH_CLASS_DEFAULT | CREX_FETCH_CLASS_EXCEPTION);
				if (UNEXPECTED(ce == NULL)) {
					ZVAL_UNDEF(EX_VAR(opline->result.var));

					HANDLE_EXCEPTION();
				}
				CACHE_PTR(opline->extended_value, ce);
			}
		} else if (IS_VAR == IS_UNUSED) {
			ce = crex_fetch_class(NULL, opline->op1.num);
			if (UNEXPECTED(ce == NULL)) {
				ZVAL_UNDEF(EX_VAR(opline->result.var));

				HANDLE_EXCEPTION();
			}
		} else {
			ce = C_CE_P(EX_VAR(opline->op1.var));
		}
		if (IS_VAR != IS_CONST
			&& IS_CONST == IS_CONST
			&& EXPECTED(CACHED_PTR(opline->extended_value) == ce)) {
			value = CACHED_PTR(opline->extended_value + sizeof(void*));
			break;
		}

		constant_zv = RT_CONSTANT(opline, opline->op2);
		if (UNEXPECTED(C_TYPE_P(constant_zv) != IS_STRING)) {
			crex_invalid_class_constant_type_error(C_TYPE_P(constant_zv));
			ZVAL_UNDEF(EX_VAR(opline->result.var));

			HANDLE_EXCEPTION();
		}
		constant_name = C_STR_P(constant_zv);
		/* Magic 'class' for constant OP2 is caught at compile-time */
		if (IS_CONST != IS_CONST && UNEXPECTED(crex_string_equals_literal_ci(constant_name, "class"))) {
			ZVAL_STR_COPY(EX_VAR(opline->result.var), ce->name);

			CREX_VM_NEXT_OPCODE();
		}
		zv = IS_CONST == IS_CONST
			? crex_hash_find_known_hash(CE_CONSTANTS_TABLE(ce), constant_name)
			: crex_hash_find(CE_CONSTANTS_TABLE(ce), constant_name);

		if (EXPECTED(zv != NULL)) {
			c = C_PTR_P(zv);
			scope = EX(func)->op_array.scope;
			if (!crex_verify_const_access(c, scope)) {
				crex_throw_error(NULL, "Cannot access %s constant %s::%s", crex_visibility_string(CREX_CLASS_CONST_FLAGS(c)), ZSTR_VAL(ce->name), ZSTR_VAL(constant_name));
				ZVAL_UNDEF(EX_VAR(opline->result.var));

				HANDLE_EXCEPTION();
			}

			if (ce->ce_flags & CREX_ACC_TRAIT) {
				crex_throw_error(NULL, "Cannot access trait constant %s::%s directly", ZSTR_VAL(ce->name), ZSTR_VAL(constant_name));
				ZVAL_UNDEF(EX_VAR(opline->result.var));

				HANDLE_EXCEPTION();
			}

			bool is_constant_deprecated = CREX_CLASS_CONST_FLAGS(c) & CREX_ACC_DEPRECATED;
			if (UNEXPECTED(is_constant_deprecated)) {
				crex_error(E_DEPRECATED, "Constant %s::%s is deprecated", ZSTR_VAL(ce->name), ZSTR_VAL(constant_name));

				if (EG(exception)) {
					ZVAL_UNDEF(EX_VAR(opline->result.var));

					HANDLE_EXCEPTION();
				}
			}

			value = &c->value;
			// Enums require loading of all class constants to build the backed enum table
			if (ce->ce_flags & CREX_ACC_ENUM && ce->enum_backing_type != IS_UNDEF && ce->type == CREX_USER_CLASS && !(ce->ce_flags & CREX_ACC_CONSTANTS_UPDATED)) {
				if (UNEXPECTED(crex_update_class_constants(ce) == FAILURE)) {
					ZVAL_UNDEF(EX_VAR(opline->result.var));

					HANDLE_EXCEPTION();
				}
			}
			if (C_TYPE_P(value) == IS_CONSTANT_AST) {
				if (UNEXPECTED(crex_update_class_constant(c, constant_name, c->ce) != SUCCESS)) {
					ZVAL_UNDEF(EX_VAR(opline->result.var));

					HANDLE_EXCEPTION();
				}
			}
			if (IS_CONST == IS_CONST && !is_constant_deprecated) {
				CACHE_POLYMORPHIC_PTR(opline->extended_value, ce, value);
			}
		} else {
			crex_throw_error(NULL, "Undefined constant %s::%s",
				ZSTR_VAL(ce->name), ZSTR_VAL(constant_name));
			ZVAL_UNDEF(EX_VAR(opline->result.var));

			HANDLE_EXCEPTION();
		}
	} while (0);

	ZVAL_COPY_OR_DUP(EX_VAR(opline->result.var), value);

	CREX_VM_NEXT_OPCODE();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ADD_ARRAY_ELEMENT_SPEC_VAR_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *expr_ptr, new_expr;

	SAVE_OPLINE();
	if ((IS_VAR == IS_VAR || IS_VAR == IS_CV) &&
	    UNEXPECTED(opline->extended_value & CREX_ARRAY_ELEMENT_REF)) {
		expr_ptr = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);
		if (C_ISREF_P(expr_ptr)) {
			C_ADDREF_P(expr_ptr);
		} else {
			ZVAL_MAKE_REF_EX(expr_ptr, 2);
		}
		zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	} else {
		expr_ptr = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);
		if (IS_VAR == IS_TMP_VAR) {
			/* pass */
		} else if (IS_VAR == IS_CONST) {
			C_TRY_ADDREF_P(expr_ptr);
		} else if (IS_VAR == IS_CV) {
			ZVAL_DEREF(expr_ptr);
			C_TRY_ADDREF_P(expr_ptr);
		} else /* if (IS_VAR == IS_VAR) */ {
			if (UNEXPECTED(C_ISREF_P(expr_ptr))) {
				crex_refcounted *ref = C_COUNTED_P(expr_ptr);

				expr_ptr = C_REFVAL_P(expr_ptr);
				if (UNEXPECTED(GC_DELREF(ref) == 0)) {
					ZVAL_COPY_VALUE(&new_expr, expr_ptr);
					expr_ptr = &new_expr;
					efree_size(ref, sizeof(crex_reference));
				} else if (C_OPT_REFCOUNTED_P(expr_ptr)) {
					C_ADDREF_P(expr_ptr);
				}
			}
		}
	}

	if (IS_CONST != IS_UNUSED) {
		zval *offset = RT_CONSTANT(opline, opline->op2);
		crex_string *str;
		crex_ulong hval;

add_again:
		if (EXPECTED(C_TYPE_P(offset) == IS_STRING)) {
			str = C_STR_P(offset);
			if (IS_CONST != IS_CONST) {
				if (CREX_HANDLE_NUMERIC(str, hval)) {
					goto num_index;
				}
			}
str_index:
			crex_hash_update(C_ARRVAL_P(EX_VAR(opline->result.var)), str, expr_ptr);
		} else if (EXPECTED(C_TYPE_P(offset) == IS_LONG)) {
			hval = C_LVAL_P(offset);
num_index:
			crex_hash_index_update(C_ARRVAL_P(EX_VAR(opline->result.var)), hval, expr_ptr);
		} else if ((IS_CONST & (IS_VAR|IS_CV)) && EXPECTED(C_TYPE_P(offset) == IS_REFERENCE)) {
			offset = C_REFVAL_P(offset);
			goto add_again;
		} else if (C_TYPE_P(offset) == IS_NULL) {
			str = ZSTR_EMPTY_ALLOC();
			goto str_index;
		} else if (C_TYPE_P(offset) == IS_DOUBLE) {
			hval = crex_dval_to_lval_safe(C_DVAL_P(offset));
			goto num_index;
		} else if (C_TYPE_P(offset) == IS_FALSE) {
			hval = 0;
			goto num_index;
		} else if (C_TYPE_P(offset) == IS_TRUE) {
			hval = 1;
			goto num_index;
		} else if (C_TYPE_P(offset) == IS_RESOURCE) {
			crex_use_resource_as_offset(offset);
			hval = C_RES_HANDLE_P(offset);
			goto num_index;
		} else if (IS_CONST == IS_CV && C_TYPE_P(offset) == IS_UNDEF) {
			ZVAL_UNDEFINED_OP2();
			str = ZSTR_EMPTY_ALLOC();
			goto str_index;
		} else {
			crex_illegal_array_offset_access(offset);
			zval_ptr_dtor_nogc(expr_ptr);
		}

	} else {
		if (!crex_hash_next_index_insert(C_ARRVAL_P(EX_VAR(opline->result.var)), expr_ptr)) {
			crex_cannot_add_element();
			zval_ptr_dtor_nogc(expr_ptr);
		}
	}
	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_INIT_ARRAY_SPEC_VAR_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	zval *array;
	uint32_t size;
	USE_OPLINE

	array = EX_VAR(opline->result.var);
	if (IS_VAR != IS_UNUSED) {
		size = opline->extended_value >> CREX_ARRAY_SIZE_SHIFT;
		ZVAL_ARR(array, crex_new_array(size));
		/* Explicitly initialize array as not-packed if flag is set */
		if (opline->extended_value & CREX_ARRAY_NOT_PACKED) {
			crex_hash_real_init_mixed(C_ARRVAL_P(array));
		}
		CREX_VM_TAIL_CALL(CREX_ADD_ARRAY_ELEMENT_SPEC_VAR_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU));
	} else {
		ZVAL_ARR(array, crex_new_array(0));
		CREX_VM_NEXT_OPCODE();
	}
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_UNSET_DIM_SPEC_VAR_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;
	zval *offset;
	crex_ulong hval;
	crex_string *key;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	offset = RT_CONSTANT(opline, opline->op2);

	do {
		if (EXPECTED(C_TYPE_P(container) == IS_ARRAY)) {
			HashTable *ht;

unset_dim_array:
			SEPARATE_ARRAY(container);
			ht = C_ARRVAL_P(container);
offset_again:
			if (EXPECTED(C_TYPE_P(offset) == IS_STRING)) {
				key = C_STR_P(offset);
				if (IS_CONST != IS_CONST) {
					if (CREX_HANDLE_NUMERIC(key, hval)) {
						goto num_index_dim;
					}
				}
str_index_dim:
				CREX_ASSERT(ht != &EG(symbol_table));
				crex_hash_del(ht, key);
			} else if (EXPECTED(C_TYPE_P(offset) == IS_LONG)) {
				hval = C_LVAL_P(offset);
num_index_dim:
				crex_hash_index_del(ht, hval);
			} else if ((IS_CONST & (IS_VAR|IS_CV)) && EXPECTED(C_TYPE_P(offset) == IS_REFERENCE)) {
				offset = C_REFVAL_P(offset);
				goto offset_again;
			} else if (C_TYPE_P(offset) == IS_DOUBLE) {
				hval = crex_dval_to_lval_safe(C_DVAL_P(offset));
				goto num_index_dim;
			} else if (C_TYPE_P(offset) == IS_NULL) {
				key = ZSTR_EMPTY_ALLOC();
				goto str_index_dim;
			} else if (C_TYPE_P(offset) == IS_FALSE) {
				hval = 0;
				goto num_index_dim;
			} else if (C_TYPE_P(offset) == IS_TRUE) {
				hval = 1;
				goto num_index_dim;
			} else if (C_TYPE_P(offset) == IS_RESOURCE) {
				crex_use_resource_as_offset(offset);
				hval = C_RES_HANDLE_P(offset);
				goto num_index_dim;
			} else if (IS_CONST == IS_CV && C_TYPE_P(offset) == IS_UNDEF) {
				ZVAL_UNDEFINED_OP2();
				key = ZSTR_EMPTY_ALLOC();
				goto str_index_dim;
			} else {
				crex_illegal_array_offset_unset(offset);
			}
			break;
		} else if (C_ISREF_P(container)) {
			container = C_REFVAL_P(container);
			if (EXPECTED(C_TYPE_P(container) == IS_ARRAY)) {
				goto unset_dim_array;
			}
		}
		if (IS_VAR == IS_CV && UNEXPECTED(C_TYPE_P(container) == IS_UNDEF)) {
			container = ZVAL_UNDEFINED_OP1();
		}
		if (IS_CONST == IS_CV && UNEXPECTED(C_TYPE_P(offset) == IS_UNDEF)) {
			offset = ZVAL_UNDEFINED_OP2();
		}
		if (EXPECTED(C_TYPE_P(container) == IS_OBJECT)) {
			if (IS_CONST == IS_CONST && C_EXTRA_P(offset) == CREX_EXTRA_VALUE) {
				offset++;
			}
			C_OBJ_HT_P(container)->unset_dimension(C_OBJ_P(container), offset);
		} else if (UNEXPECTED(C_TYPE_P(container) == IS_STRING)) {
			crex_throw_error(NULL, "Cannot unset string offsets");
		} else if (UNEXPECTED(C_TYPE_P(container) > IS_FALSE)) {
			crex_throw_error(NULL, "Cannot unset offset in a non-array variable");
		} else if (UNEXPECTED(C_TYPE_P(container) == IS_FALSE)) {
			crex_false_to_array_deprecated();
		}
	} while (0);

	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_UNSET_OBJ_SPEC_VAR_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;
	zval *offset;
	crex_string *name, *tmp_name;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	offset = RT_CONSTANT(opline, opline->op2);

	do {
		if (IS_VAR != IS_UNUSED && UNEXPECTED(C_TYPE_P(container) != IS_OBJECT)) {
			if (C_ISREF_P(container)) {
				container = C_REFVAL_P(container);
				if (C_TYPE_P(container) != IS_OBJECT) {
					if (IS_VAR == IS_CV
					 && UNEXPECTED(C_TYPE_P(container) == IS_UNDEF)) {
						ZVAL_UNDEFINED_OP1();
					}
					break;
				}
			} else {
				break;
			}
		}
		if (IS_CONST == IS_CONST) {
			name = C_STR_P(offset);
		} else {
			name = zval_try_get_tmp_string(offset, &tmp_name);
			if (UNEXPECTED(!name)) {
				break;
			}
		}
		C_OBJ_HT_P(container)->unset_property(C_OBJ_P(container), name, ((IS_CONST == IS_CONST) ? CACHE_ADDR(opline->extended_value) : NULL));
		if (IS_CONST != IS_CONST) {
			crex_tmp_string_release(tmp_name);
		}
	} while (0);

	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_YIELD_SPEC_VAR_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	crex_generator *generator = crex_get_running_generator(EXECUTE_DATA_C);

	SAVE_OPLINE();
	if (UNEXPECTED(generator->flags & CREX_GENERATOR_FORCED_CLOSE)) {
		CREX_VM_TAIL_CALL(crex_yield_in_closed_generator_helper_SPEC(CREX_OPCODE_HANDLER_ARGS_PASSTHRU));
	}

	/* Destroy the previously yielded value */
	zval_ptr_dtor(&generator->value);

	/* Destroy the previously yielded key */
	zval_ptr_dtor(&generator->key);

	/* Set the new yielded value */
	if (IS_VAR != IS_UNUSED) {
		if (UNEXPECTED(EX(func)->op_array.fn_flags & CREX_ACC_RETURN_REFERENCE)) {
			/* Constants and temporary variables aren't yieldable by reference,
			 * but we still allow them with a notice. */
			if (IS_VAR & (IS_CONST|IS_TMP_VAR)) {
				zval *value;

				crex_error(E_NOTICE, "Only variable references should be yielded by reference");

				value = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);
				ZVAL_COPY_VALUE(&generator->value, value);
				if (IS_VAR == IS_CONST) {
					if (UNEXPECTED(C_OPT_REFCOUNTED(generator->value))) {
						C_ADDREF(generator->value);
					}
				}
			} else {
				zval *value_ptr = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);

				/* If a function call result is yielded and the function did
				 * not return by reference we throw a notice. */
				do {
					if (IS_VAR == IS_VAR) {
						CREX_ASSERT(value_ptr != &EG(uninitialized_zval));
						if (opline->extended_value == CREX_RETURNS_FUNCTION
						 && !C_ISREF_P(value_ptr)) {
							crex_error(E_NOTICE, "Only variable references should be yielded by reference");
							ZVAL_COPY(&generator->value, value_ptr);
							break;
						}
					}
					if (C_ISREF_P(value_ptr)) {
						C_ADDREF_P(value_ptr);
					} else {
						ZVAL_MAKE_REF_EX(value_ptr, 2);
					}
					ZVAL_REF(&generator->value, C_REF_P(value_ptr));
				} while (0);

				zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
			}
		} else {
			zval *value = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);

			/* Consts, temporary variables and references need copying */
			if (IS_VAR == IS_CONST) {
				ZVAL_COPY_VALUE(&generator->value, value);
				if (UNEXPECTED(C_OPT_REFCOUNTED(generator->value))) {
					C_ADDREF(generator->value);
				}
			} else if (IS_VAR == IS_TMP_VAR) {
				ZVAL_COPY_VALUE(&generator->value, value);
			} else if ((IS_VAR & (IS_VAR|IS_CV)) && C_ISREF_P(value)) {
				ZVAL_COPY(&generator->value, C_REFVAL_P(value));
				zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
			} else {
				ZVAL_COPY_VALUE(&generator->value, value);
				if (IS_VAR == IS_CV) {
					if (C_OPT_REFCOUNTED_P(value)) C_ADDREF_P(value);
				}
			}
		}
	} else {
		/* If no value was specified yield null */
		ZVAL_NULL(&generator->value);
	}

	/* Set the new yielded key */
	if (IS_CONST != IS_UNUSED) {
		zval *key = RT_CONSTANT(opline, opline->op2);
		if ((IS_CONST & (IS_CV|IS_VAR)) && UNEXPECTED(C_TYPE_P(key) == IS_REFERENCE)) {
			key = C_REFVAL_P(key);
		}
		ZVAL_COPY(&generator->key, key);

		if (C_TYPE(generator->key) == IS_LONG
		    && C_LVAL(generator->key) > generator->largest_used_integer_key
		) {
			generator->largest_used_integer_key = C_LVAL(generator->key);
		}
	} else {
		/* If no key was specified we use auto-increment keys */
		generator->largest_used_integer_key++;
		ZVAL_LONG(&generator->key, generator->largest_used_integer_key);
	}

	if (RETURN_VALUE_USED(opline)) {
		/* If the return value of yield is used set the send
		 * target and initialize it to NULL */
		generator->send_target = EX_VAR(opline->result.var);
		ZVAL_NULL(generator->send_target);
	} else {
		generator->send_target = NULL;
	}

	/* We increment to the next op, so we are at the correct position when the
	 * generator is resumed. */
	CREX_VM_INC_OPCODE();

	/* The GOTO VM uses a local opline variable. We need to set the opline
	 * variable in execute_data so we don't resume at an old position. */
	SAVE_OPLINE();

	CREX_VM_RETURN();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_IN_ARRAY_SPEC_VAR_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1;
	HashTable *ht = C_ARRVAL_P(RT_CONSTANT(opline, opline->op2));
	zval *result;

	op1 = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	if (EXPECTED(C_TYPE_P(op1) == IS_STRING)) {
		result = crex_hash_find_ex(ht, C_STR_P(op1), IS_VAR == IS_CONST);
		if (IS_VAR & (IS_TMP_VAR|IS_VAR)) {
			zval_ptr_dtor_str(op1);
		}
		CREX_VM_SMART_BRANCH(result, 0);
	}

	if (opline->extended_value) {
		if (EXPECTED(C_TYPE_P(op1) == IS_LONG)) {
			result = crex_hash_index_find(ht, C_LVAL_P(op1));
			CREX_VM_SMART_BRANCH(result, 0);
		}
		SAVE_OPLINE();
		if ((IS_VAR & (IS_VAR|IS_CV)) && C_TYPE_P(op1) == IS_REFERENCE) {
			op1 = C_REFVAL_P(op1);
			if (EXPECTED(C_TYPE_P(op1) == IS_STRING)) {
				result = crex_hash_find(ht, C_STR_P(op1));
				zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
				CREX_VM_SMART_BRANCH(result, 0);
			} else if (EXPECTED(C_TYPE_P(op1) == IS_LONG)) {
				result = crex_hash_index_find(ht, C_LVAL_P(op1));
				zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
				CREX_VM_SMART_BRANCH(result, 0);
			}
		} else if (IS_VAR == IS_CV && UNEXPECTED(C_TYPE_P(op1) == IS_UNDEF)) {
			ZVAL_UNDEFINED_OP1();
		}
	} else if (C_TYPE_P(op1) <= IS_FALSE) {
		if (IS_VAR == IS_CV && UNEXPECTED(C_TYPE_P(op1) == IS_UNDEF)) {
			SAVE_OPLINE();
			ZVAL_UNDEFINED_OP1();
			if (UNEXPECTED(EG(exception) != NULL)) {
				HANDLE_EXCEPTION();
			}
		}
		result = crex_hash_find_known_hash(ht, ZSTR_EMPTY_ALLOC());
		CREX_VM_SMART_BRANCH(result, 0);
	} else {
		crex_string *key;
		zval key_tmp;

		if ((IS_VAR & (IS_VAR|IS_CV)) && C_TYPE_P(op1) == IS_REFERENCE) {
			op1 = C_REFVAL_P(op1);
			if (EXPECTED(C_TYPE_P(op1) == IS_STRING)) {
				result = crex_hash_find(ht, C_STR_P(op1));
				zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
				CREX_VM_SMART_BRANCH(result, 0);
			}
		}

		SAVE_OPLINE();
		CREX_HASH_MAP_FOREACH_STR_KEY(ht, key) {
			ZVAL_STR(&key_tmp, key);
			if (crex_compare(op1, &key_tmp) == 0) {
				zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
				CREX_VM_SMART_BRANCH(1, 1);
			}
		} CREX_HASH_FOREACH_END();
	}
	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	CREX_VM_SMART_BRANCH(0, 1);
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FETCH_CLASS_CONSTANT_SPEC_VAR_TMPVARCV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	crex_class_entry *ce, *scope;
	crex_class_constant *c;
	zval *value, *zv, *constant_zv;
	crex_string *constant_name;
	USE_OPLINE

	SAVE_OPLINE();

	do {
		if (IS_VAR == IS_CONST && (IS_TMP_VAR|IS_VAR|IS_CV) == IS_CONST) {
			if (EXPECTED(CACHED_PTR(opline->extended_value + sizeof(void*)))) {
				value = CACHED_PTR(opline->extended_value + sizeof(void*));
				break;
			}
		}
		if (IS_VAR == IS_CONST) {
			if (EXPECTED(CACHED_PTR(opline->extended_value))) {
				ce = CACHED_PTR(opline->extended_value);
			} else {
				ce = crex_fetch_class_by_name(C_STR_P(RT_CONSTANT(opline, opline->op1)), C_STR_P(RT_CONSTANT(opline, opline->op1) + 1), CREX_FETCH_CLASS_DEFAULT | CREX_FETCH_CLASS_EXCEPTION);
				if (UNEXPECTED(ce == NULL)) {
					ZVAL_UNDEF(EX_VAR(opline->result.var));
					FREE_OP(opline->op2_type, opline->op2.var);
					HANDLE_EXCEPTION();
				}
				CACHE_PTR(opline->extended_value, ce);
			}
		} else if (IS_VAR == IS_UNUSED) {
			ce = crex_fetch_class(NULL, opline->op1.num);
			if (UNEXPECTED(ce == NULL)) {
				ZVAL_UNDEF(EX_VAR(opline->result.var));
				FREE_OP(opline->op2_type, opline->op2.var);
				HANDLE_EXCEPTION();
			}
		} else {
			ce = C_CE_P(EX_VAR(opline->op1.var));
		}
		if (IS_VAR != IS_CONST
			&& (IS_TMP_VAR|IS_VAR|IS_CV) == IS_CONST
			&& EXPECTED(CACHED_PTR(opline->extended_value) == ce)) {
			value = CACHED_PTR(opline->extended_value + sizeof(void*));
			break;
		}

		constant_zv = _get_zval_ptr_tmpvarcv(opline->op2_type, opline->op2, BP_VAR_R EXECUTE_DATA_CC);
		if (UNEXPECTED(C_TYPE_P(constant_zv) != IS_STRING)) {
			crex_invalid_class_constant_type_error(C_TYPE_P(constant_zv));
			ZVAL_UNDEF(EX_VAR(opline->result.var));
			FREE_OP(opline->op2_type, opline->op2.var);
			HANDLE_EXCEPTION();
		}
		constant_name = C_STR_P(constant_zv);
		/* Magic 'class' for constant OP2 is caught at compile-time */
		if ((IS_TMP_VAR|IS_VAR|IS_CV) != IS_CONST && UNEXPECTED(crex_string_equals_literal_ci(constant_name, "class"))) {
			ZVAL_STR_COPY(EX_VAR(opline->result.var), ce->name);
			FREE_OP(opline->op2_type, opline->op2.var);
			CREX_VM_NEXT_OPCODE();
		}
		zv = (IS_TMP_VAR|IS_VAR|IS_CV) == IS_CONST
			? crex_hash_find_known_hash(CE_CONSTANTS_TABLE(ce), constant_name)
			: crex_hash_find(CE_CONSTANTS_TABLE(ce), constant_name);

		if (EXPECTED(zv != NULL)) {
			c = C_PTR_P(zv);
			scope = EX(func)->op_array.scope;
			if (!crex_verify_const_access(c, scope)) {
				crex_throw_error(NULL, "Cannot access %s constant %s::%s", crex_visibility_string(CREX_CLASS_CONST_FLAGS(c)), ZSTR_VAL(ce->name), ZSTR_VAL(constant_name));
				ZVAL_UNDEF(EX_VAR(opline->result.var));
				FREE_OP(opline->op2_type, opline->op2.var);
				HANDLE_EXCEPTION();
			}

			if (ce->ce_flags & CREX_ACC_TRAIT) {
				crex_throw_error(NULL, "Cannot access trait constant %s::%s directly", ZSTR_VAL(ce->name), ZSTR_VAL(constant_name));
				ZVAL_UNDEF(EX_VAR(opline->result.var));
				FREE_OP(opline->op2_type, opline->op2.var);
				HANDLE_EXCEPTION();
			}

			bool is_constant_deprecated = CREX_CLASS_CONST_FLAGS(c) & CREX_ACC_DEPRECATED;
			if (UNEXPECTED(is_constant_deprecated)) {
				crex_error(E_DEPRECATED, "Constant %s::%s is deprecated", ZSTR_VAL(ce->name), ZSTR_VAL(constant_name));

				if (EG(exception)) {
					ZVAL_UNDEF(EX_VAR(opline->result.var));
					FREE_OP(opline->op2_type, opline->op2.var);
					HANDLE_EXCEPTION();
				}
			}

			value = &c->value;
			// Enums require loading of all class constants to build the backed enum table
			if (ce->ce_flags & CREX_ACC_ENUM && ce->enum_backing_type != IS_UNDEF && ce->type == CREX_USER_CLASS && !(ce->ce_flags & CREX_ACC_CONSTANTS_UPDATED)) {
				if (UNEXPECTED(crex_update_class_constants(ce) == FAILURE)) {
					ZVAL_UNDEF(EX_VAR(opline->result.var));
					FREE_OP(opline->op2_type, opline->op2.var);
					HANDLE_EXCEPTION();
				}
			}
			if (C_TYPE_P(value) == IS_CONSTANT_AST) {
				if (UNEXPECTED(crex_update_class_constant(c, constant_name, c->ce) != SUCCESS)) {
					ZVAL_UNDEF(EX_VAR(opline->result.var));
					FREE_OP(opline->op2_type, opline->op2.var);
					HANDLE_EXCEPTION();
				}
			}
			if ((IS_TMP_VAR|IS_VAR|IS_CV) == IS_CONST && !is_constant_deprecated) {
				CACHE_POLYMORPHIC_PTR(opline->extended_value, ce, value);
			}
		} else {
			crex_throw_error(NULL, "Undefined constant %s::%s",
				ZSTR_VAL(ce->name), ZSTR_VAL(constant_name));
			ZVAL_UNDEF(EX_VAR(opline->result.var));
			FREE_OP(opline->op2_type, opline->op2.var);
			HANDLE_EXCEPTION();
		}
	} while (0);

	ZVAL_COPY_OR_DUP(EX_VAR(opline->result.var), value);

	FREE_OP(opline->op2_type, opline->op2.var);
	CREX_VM_NEXT_OPCODE();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ASSIGN_OBJ_OP_SPEC_VAR_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *object;
	zval *property;
	zval *value;
	zval *zptr;
	void **cache_slot;
	crex_property_info *prop_info;
	crex_object *zobj;
	crex_string *name, *tmp_name;

	SAVE_OPLINE();
	object = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	property = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);

	do {
		value = get_op_data_zval_ptr_r((opline+1)->op1_type, (opline+1)->op1);

		if (IS_VAR != IS_UNUSED && UNEXPECTED(C_TYPE_P(object) != IS_OBJECT)) {
			if (C_ISREF_P(object) && C_TYPE_P(C_REFVAL_P(object)) == IS_OBJECT) {
				object = C_REFVAL_P(object);
				goto assign_op_object;
			}
			if (IS_VAR == IS_CV
			 && UNEXPECTED(C_TYPE_P(object) == IS_UNDEF)) {
				ZVAL_UNDEFINED_OP1();
			}
			crex_throw_non_object_error(object, property OPLINE_CC EXECUTE_DATA_CC);
			break;
		}

assign_op_object:
		/* here we are sure we are dealing with an object */
		zobj = C_OBJ_P(object);
		if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
			name = C_STR_P(property);
		} else {
			name = zval_try_get_tmp_string(property, &tmp_name);
			if (UNEXPECTED(!name)) {
				UNDEF_RESULT();
				break;
			}
		}
		cache_slot = ((IS_TMP_VAR|IS_VAR) == IS_CONST) ? CACHE_ADDR((opline+1)->extended_value) : NULL;
		if (EXPECTED((zptr = zobj->handlers->get_property_ptr_ptr(zobj, name, BP_VAR_RW, cache_slot)) != NULL)) {
			if (UNEXPECTED(C_ISERROR_P(zptr))) {
				if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
					ZVAL_NULL(EX_VAR(opline->result.var));
				}
			} else {
				zval *orig_zptr = zptr;
				crex_reference *ref;

				do {
					if (UNEXPECTED(C_ISREF_P(zptr))) {
						ref = C_REF_P(zptr);
						zptr = C_REFVAL_P(zptr);
						if (UNEXPECTED(CREX_REF_HAS_TYPE_SOURCES(ref))) {
							crex_binary_assign_op_typed_ref(ref, value OPLINE_CC EXECUTE_DATA_CC);
							break;
						}
					}

					if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
						prop_info = (crex_property_info*)CACHED_PTR_EX(cache_slot + 2);
					} else {
						prop_info = crex_object_fetch_property_type_info(C_OBJ_P(object), orig_zptr);
					}
					if (UNEXPECTED(prop_info)) {
						/* special case for typed properties */
						crex_binary_assign_op_typed_prop(prop_info, zptr, value OPLINE_CC EXECUTE_DATA_CC);
					} else {
						crex_binary_op(zptr, zptr, value OPLINE_CC);
					}
				} while (0);

				if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
					ZVAL_COPY(EX_VAR(opline->result.var), zptr);
				}
			}
		} else {
			crex_assign_op_overloaded_property(zobj, name, cache_slot, value OPLINE_CC EXECUTE_DATA_CC);
		}
		if ((IS_TMP_VAR|IS_VAR) != IS_CONST) {
			crex_tmp_string_release(tmp_name);
		}
	} while (0);

	FREE_OP((opline+1)->op1_type, (opline+1)->op1.var);
	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	/* assign_obj has two opcodes! */
	CREX_VM_NEXT_OPCODE_EX(1, 2);
}

/* No specialization for op_types (CONST|TMP|VAR|CV, UNUSED|CONST|TMPVAR) */
static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ASSIGN_DIM_OP_SPEC_VAR_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *var_ptr;
	zval *value, *container, *dim;
	HashTable *ht;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);

	if (EXPECTED(C_TYPE_P(container) == IS_ARRAY)) {
assign_dim_op_array:
		SEPARATE_ARRAY(container);
		ht = C_ARRVAL_P(container);
assign_dim_op_new_array:
		dim = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
		if ((IS_TMP_VAR|IS_VAR) == IS_UNUSED) {
			var_ptr = crex_hash_next_index_insert(ht, &EG(uninitialized_zval));
			if (UNEXPECTED(!var_ptr)) {
				crex_cannot_add_element();
				goto assign_dim_op_ret_null;
			}
		} else {
			if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
				var_ptr = crex_fetch_dimension_address_inner_RW_CONST(ht, dim EXECUTE_DATA_CC);
			} else {
				var_ptr = crex_fetch_dimension_address_inner_RW(ht, dim EXECUTE_DATA_CC);
			}
			if (UNEXPECTED(!var_ptr)) {
				goto assign_dim_op_ret_null;
			}
		}

		value = get_op_data_zval_ptr_r((opline+1)->op1_type, (opline+1)->op1);

		do {
			if ((IS_TMP_VAR|IS_VAR) != IS_UNUSED && UNEXPECTED(C_ISREF_P(var_ptr))) {
				crex_reference *ref = C_REF_P(var_ptr);
				var_ptr = C_REFVAL_P(var_ptr);
				if (UNEXPECTED(CREX_REF_HAS_TYPE_SOURCES(ref))) {
					crex_binary_assign_op_typed_ref(ref, value OPLINE_CC EXECUTE_DATA_CC);
					break;
				}
			}
			crex_binary_op(var_ptr, var_ptr, value OPLINE_CC);
		} while (0);

		if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
			ZVAL_COPY(EX_VAR(opline->result.var), var_ptr);
		}
		FREE_OP((opline+1)->op1_type, (opline+1)->op1.var);
	} else {
		if (EXPECTED(C_ISREF_P(container))) {
			container = C_REFVAL_P(container);
			if (EXPECTED(C_TYPE_P(container) == IS_ARRAY)) {
				goto assign_dim_op_array;
			}
		}

		if (EXPECTED(C_TYPE_P(container) == IS_OBJECT)) {
			crex_object *obj = C_OBJ_P(container);

			dim = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
			if ((IS_TMP_VAR|IS_VAR) == IS_CONST && C_EXTRA_P(dim) == CREX_EXTRA_VALUE) {
				dim++;
			}
			crex_binary_assign_op_obj_dim(obj, dim OPLINE_CC EXECUTE_DATA_CC);
		} else if (EXPECTED(C_TYPE_P(container) <= IS_FALSE)) {
			uint8_t old_type;

			if (IS_VAR == IS_CV && UNEXPECTED(C_TYPE_INFO_P(container) == IS_UNDEF)) {
				ZVAL_UNDEFINED_OP1();
			}
			ht = crex_new_array(8);
			old_type = C_TYPE_P(container);
			ZVAL_ARR(container, ht);
			if (UNEXPECTED(old_type == IS_FALSE)) {
				GC_ADDREF(ht);
				crex_false_to_array_deprecated();
				if (UNEXPECTED(GC_DELREF(ht) == 0)) {
					crex_array_destroy(ht);
					goto assign_dim_op_ret_null;
				}
			}
			goto assign_dim_op_new_array;
		} else {
			dim = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
			crex_binary_assign_op_dim_slow(container, dim OPLINE_CC EXECUTE_DATA_CC);
assign_dim_op_ret_null:
			FREE_OP((opline+1)->op1_type, (opline+1)->op1.var);
			if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
				ZVAL_NULL(EX_VAR(opline->result.var));
			}
		}
	}

	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	CREX_VM_NEXT_OPCODE_EX(1, 2);
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ASSIGN_OP_SPEC_VAR_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *var_ptr;
	zval *value;

	SAVE_OPLINE();
	value = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
	var_ptr = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);

	do {
		if (UNEXPECTED(C_TYPE_P(var_ptr) == IS_REFERENCE)) {
			crex_reference *ref = C_REF_P(var_ptr);
			var_ptr = C_REFVAL_P(var_ptr);
			if (UNEXPECTED(CREX_REF_HAS_TYPE_SOURCES(ref))) {
				crex_binary_assign_op_typed_ref(ref, value OPLINE_CC EXECUTE_DATA_CC);
				break;
			}
		}
		crex_binary_op(var_ptr, var_ptr, value OPLINE_CC);
	} while (0);

	if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
		ZVAL_COPY(EX_VAR(opline->result.var), var_ptr);
	}

	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_PRE_INC_OBJ_SPEC_VAR_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *object;
	zval *property;
	zval *zptr;
	void **cache_slot;
	crex_property_info *prop_info;
	crex_object *zobj;
	crex_string *name, *tmp_name;

	SAVE_OPLINE();
	object = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	property = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);

	do {
		if (IS_VAR != IS_UNUSED && UNEXPECTED(C_TYPE_P(object) != IS_OBJECT)) {
			if (C_ISREF_P(object) && C_TYPE_P(C_REFVAL_P(object)) == IS_OBJECT) {
				object = C_REFVAL_P(object);
				goto pre_incdec_object;
			}
			if (IS_VAR == IS_CV
			 && UNEXPECTED(C_TYPE_P(object) == IS_UNDEF)) {
				ZVAL_UNDEFINED_OP1();
			}
			crex_throw_non_object_error(object, property OPLINE_CC EXECUTE_DATA_CC);
			break;
		}

pre_incdec_object:
		/* here we are sure we are dealing with an object */
		zobj = C_OBJ_P(object);
		if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
			name = C_STR_P(property);
		} else {
			name = zval_try_get_tmp_string(property, &tmp_name);
			if (UNEXPECTED(!name)) {
				UNDEF_RESULT();
				break;
			}
		}
		cache_slot = ((IS_TMP_VAR|IS_VAR) == IS_CONST) ? CACHE_ADDR(opline->extended_value) : NULL;
		if (EXPECTED((zptr = zobj->handlers->get_property_ptr_ptr(zobj, name, BP_VAR_RW, cache_slot)) != NULL)) {
			if (UNEXPECTED(C_ISERROR_P(zptr))) {
				if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
					ZVAL_NULL(EX_VAR(opline->result.var));
				}
			} else {
				if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
					prop_info = (crex_property_info *) CACHED_PTR_EX(cache_slot + 2);
				} else {
					prop_info = crex_object_fetch_property_type_info(C_OBJ_P(object), zptr);
				}
				crex_pre_incdec_property_zval(zptr, prop_info OPLINE_CC EXECUTE_DATA_CC);
			}
		} else {
			crex_pre_incdec_overloaded_property(zobj, name, cache_slot OPLINE_CC EXECUTE_DATA_CC);
		}
		if ((IS_TMP_VAR|IS_VAR) != IS_CONST) {
			crex_tmp_string_release(tmp_name);
		}
	} while (0);

	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_POST_INC_OBJ_SPEC_VAR_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *object;
	zval *property;
	zval *zptr;
	void **cache_slot;
	crex_property_info *prop_info;
	crex_object *zobj;
	crex_string *name, *tmp_name;

	SAVE_OPLINE();
	object = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	property = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);

	do {
		if (IS_VAR != IS_UNUSED && UNEXPECTED(C_TYPE_P(object) != IS_OBJECT)) {
			if (C_ISREF_P(object) && C_TYPE_P(C_REFVAL_P(object)) == IS_OBJECT) {
				object = C_REFVAL_P(object);
				goto post_incdec_object;
			}
			if (IS_VAR == IS_CV
			 && UNEXPECTED(C_TYPE_P(object) == IS_UNDEF)) {
				ZVAL_UNDEFINED_OP1();
			}
			crex_throw_non_object_error(object, property OPLINE_CC EXECUTE_DATA_CC);
			break;
		}

post_incdec_object:
		/* here we are sure we are dealing with an object */
		zobj = C_OBJ_P(object);
		if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
			name = C_STR_P(property);
		} else {
			name = zval_try_get_tmp_string(property, &tmp_name);
			if (UNEXPECTED(!name)) {
				ZVAL_UNDEF(EX_VAR(opline->result.var));
				break;
			}
		}
		cache_slot = ((IS_TMP_VAR|IS_VAR) == IS_CONST) ? CACHE_ADDR(opline->extended_value) : NULL;
		if (EXPECTED((zptr = zobj->handlers->get_property_ptr_ptr(zobj, name, BP_VAR_RW, cache_slot)) != NULL)) {
			if (UNEXPECTED(C_ISERROR_P(zptr))) {
				ZVAL_NULL(EX_VAR(opline->result.var));
			} else {
				if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
					prop_info = (crex_property_info*)CACHED_PTR_EX(cache_slot + 2);
				} else {
					prop_info = crex_object_fetch_property_type_info(C_OBJ_P(object), zptr);
				}

				crex_post_incdec_property_zval(zptr, prop_info OPLINE_CC EXECUTE_DATA_CC);
			}
		} else {
			crex_post_incdec_overloaded_property(zobj, name, cache_slot OPLINE_CC EXECUTE_DATA_CC);
		}
		if ((IS_TMP_VAR|IS_VAR) != IS_CONST) {
			crex_tmp_string_release(tmp_name);
		}
	} while (0);

	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FETCH_DIM_W_SPEC_VAR_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	crex_fetch_dimension_address_W(container, _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC), (IS_TMP_VAR|IS_VAR) OPLINE_CC EXECUTE_DATA_CC);
	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
	if (IS_VAR == IS_VAR) {
		FREE_VAR_PTR_AND_EXTRACT_RESULT_IF_NECESSARY(opline->op1.var);
	}
	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FETCH_DIM_RW_SPEC_VAR_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	crex_fetch_dimension_address_RW(container, _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC), (IS_TMP_VAR|IS_VAR) OPLINE_CC EXECUTE_DATA_CC);
	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
	if (IS_VAR == IS_VAR) {
		FREE_VAR_PTR_AND_EXTRACT_RESULT_IF_NECESSARY(opline->op1.var);
	}
	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FETCH_DIM_FUNC_ARG_SPEC_VAR_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
#if 0
	USE_OPLINE
#endif

	if (UNEXPECTED(CREX_CALL_INFO(EX(call)) & CREX_CALL_SEND_ARG_BY_REF)) {
		if ((IS_VAR & (IS_CONST|IS_TMP_VAR))) {
			CREX_VM_TAIL_CALL(crex_use_tmp_in_write_context_helper_SPEC(CREX_OPCODE_HANDLER_ARGS_PASSTHRU));
		}
		CREX_VM_TAIL_CALL(CREX_FETCH_DIM_W_SPEC_VAR_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU));
	} else {
		if ((IS_TMP_VAR|IS_VAR) == IS_UNUSED) {
			CREX_VM_TAIL_CALL(crex_use_undef_in_read_context_helper_SPEC(CREX_OPCODE_HANDLER_ARGS_PASSTHRU));
		}
		CREX_VM_TAIL_CALL(CREX_FETCH_DIM_R_SPEC_TMPVAR_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU));
	}
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FETCH_DIM_UNSET_SPEC_VAR_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	crex_fetch_dimension_address_UNSET(container, _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC), (IS_TMP_VAR|IS_VAR) OPLINE_CC EXECUTE_DATA_CC);
	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
	if (IS_VAR == IS_VAR) {
		FREE_VAR_PTR_AND_EXTRACT_RESULT_IF_NECESSARY(opline->op1.var);
	}
	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FETCH_OBJ_W_SPEC_VAR_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *property, *container, *result;

	SAVE_OPLINE();

	container = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	property = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
	result = EX_VAR(opline->result.var);
	crex_fetch_property_address(
		result, container, IS_VAR, property, (IS_TMP_VAR|IS_VAR),
		(((IS_TMP_VAR|IS_VAR) == IS_CONST) ? CACHE_ADDR(opline->extended_value & ~CREX_FETCH_OBJ_FLAGS) : NULL),
		BP_VAR_W, opline->extended_value OPLINE_CC EXECUTE_DATA_CC);
	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
	if (IS_VAR == IS_VAR) {
		FREE_VAR_PTR_AND_EXTRACT_RESULT_IF_NECESSARY(opline->op1.var);
	}
	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FETCH_OBJ_RW_SPEC_VAR_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *property, *container, *result;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	property = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
	result = EX_VAR(opline->result.var);
	crex_fetch_property_address(result, container, IS_VAR, property, (IS_TMP_VAR|IS_VAR), (((IS_TMP_VAR|IS_VAR) == IS_CONST) ? CACHE_ADDR(opline->extended_value) : NULL), BP_VAR_RW, 0 OPLINE_CC EXECUTE_DATA_CC);
	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
	if (IS_VAR == IS_VAR) {
		FREE_VAR_PTR_AND_EXTRACT_RESULT_IF_NECESSARY(opline->op1.var);
	}
	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FETCH_OBJ_FUNC_ARG_SPEC_VAR_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
#if 0
	USE_OPLINE
#endif

	if (UNEXPECTED(CREX_CALL_INFO(EX(call)) & CREX_CALL_SEND_ARG_BY_REF)) {
		/* Behave like FETCH_OBJ_W */
		if ((IS_VAR & (IS_CONST|IS_TMP_VAR))) {
			CREX_VM_TAIL_CALL(crex_use_tmp_in_write_context_helper_SPEC(CREX_OPCODE_HANDLER_ARGS_PASSTHRU));
		}
		CREX_VM_TAIL_CALL(CREX_FETCH_OBJ_W_SPEC_VAR_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU));
	} else {
		CREX_VM_TAIL_CALL(CREX_FETCH_OBJ_R_SPEC_TMPVAR_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU));
	}
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FETCH_OBJ_UNSET_SPEC_VAR_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container, *property, *result;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	property = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
	result = EX_VAR(opline->result.var);
	crex_fetch_property_address(result, container, IS_VAR, property, (IS_TMP_VAR|IS_VAR), (((IS_TMP_VAR|IS_VAR) == IS_CONST) ? CACHE_ADDR(opline->extended_value) : NULL), BP_VAR_UNSET, 0 OPLINE_CC EXECUTE_DATA_CC);
	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
	if (IS_VAR == IS_VAR) {
		FREE_VAR_PTR_AND_EXTRACT_RESULT_IF_NECESSARY(opline->op1.var);
	}
	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FETCH_LIST_W_SPEC_VAR_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container, *dim;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	dim = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);

	if (IS_VAR == IS_VAR
		&& C_TYPE_P(EX_VAR(opline->op1.var)) != IS_INDIRECT
		&& UNEXPECTED(!C_ISREF_P(container))
	) {
		crex_error(E_NOTICE, "Attempting to set reference to non referenceable value");
		crex_fetch_dimension_address_LIST_r(container, dim, (IS_TMP_VAR|IS_VAR) OPLINE_CC EXECUTE_DATA_CC);
	} else {
		crex_fetch_dimension_address_W(container, dim, (IS_TMP_VAR|IS_VAR) OPLINE_CC EXECUTE_DATA_CC);
	}

	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ASSIGN_OBJ_SPEC_VAR_TMPVAR_OP_DATA_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *object, *value, tmp;
	crex_object *zobj;
	crex_string *name, *tmp_name;
	crex_refcounted *garbage = NULL;

	SAVE_OPLINE();
	object = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	value = RT_CONSTANT((opline+1), (opline+1)->op1);

	if (IS_VAR != IS_UNUSED && UNEXPECTED(C_TYPE_P(object) != IS_OBJECT)) {
		if (C_ISREF_P(object) && C_TYPE_P(C_REFVAL_P(object)) == IS_OBJECT) {
			object = C_REFVAL_P(object);
			goto assign_object;
		}
		crex_throw_non_object_error(object, _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC) OPLINE_CC EXECUTE_DATA_CC);
		value = &EG(uninitialized_zval);
		goto free_and_exit_assign_obj;
	}

assign_object:
	zobj = C_OBJ_P(object);
	if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
		if (EXPECTED(zobj->ce == CACHED_PTR(opline->extended_value))) {
			void **cache_slot = CACHE_ADDR(opline->extended_value);
			uintptr_t prop_offset = (uintptr_t)CACHED_PTR_EX(cache_slot + 1);
			zval *property_val;

			if (EXPECTED(IS_VALID_PROPERTY_OFFSET(prop_offset))) {
				property_val = OBJ_PROP(zobj, prop_offset);
				if (C_TYPE_P(property_val) != IS_UNDEF) {
					crex_property_info *prop_info = (crex_property_info*) CACHED_PTR_EX(cache_slot + 2);

					if (UNEXPECTED(prop_info != NULL)) {
						value = crex_assign_to_typed_prop(prop_info, property_val, value, &garbage EXECUTE_DATA_CC);
						goto free_and_exit_assign_obj;
					} else {
fast_assign_obj:
						value = crex_assign_to_variable_ex(property_val, value, IS_CONST, EX_USES_STRICT_TYPES(), &garbage);
						if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
							ZVAL_COPY(EX_VAR(opline->result.var), value);
						}
						goto exit_assign_obj;
					}
				}
			} else {
				name = C_STR_P(_get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC));
				if (EXPECTED(zobj->properties != NULL)) {
					if (UNEXPECTED(GC_REFCOUNT(zobj->properties) > 1)) {
						if (EXPECTED(!(GC_FLAGS(zobj->properties) & IS_ARRAY_IMMUTABLE))) {
							GC_DELREF(zobj->properties);
						}
						zobj->properties = crex_array_dup(zobj->properties);
					}
					property_val = crex_hash_find_known_hash(zobj->properties, name);
					if (property_val) {
						goto fast_assign_obj;
					}
				}

				if (!zobj->ce->__set && (zobj->ce->ce_flags & CREX_ACC_ALLOW_DYNAMIC_PROPERTIES)) {
					if (EXPECTED(zobj->properties == NULL)) {
						rebuild_object_properties(zobj);
					}
					if (IS_CONST == IS_CONST) {
						if (UNEXPECTED(C_OPT_REFCOUNTED_P(value))) {
							C_ADDREF_P(value);
						}
					} else if (IS_CONST != IS_TMP_VAR) {
						if (C_ISREF_P(value)) {
							if (IS_CONST == IS_VAR) {
								crex_reference *ref = C_REF_P(value);
								if (GC_DELREF(ref) == 0) {
									ZVAL_COPY_VALUE(&tmp, C_REFVAL_P(value));
									efree_size(ref, sizeof(crex_reference));
									value = &tmp;
								} else {
									value = C_REFVAL_P(value);
									C_TRY_ADDREF_P(value);
								}
							} else {
								value = C_REFVAL_P(value);
								C_TRY_ADDREF_P(value);
							}
						} else if (IS_CONST == IS_CV) {
							C_TRY_ADDREF_P(value);
						}
						}
					crex_hash_add_new(zobj->properties, name, value);
					if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
						ZVAL_COPY(EX_VAR(opline->result.var), value);
					}
					goto exit_assign_obj;
				}
			}
		}
		name = C_STR_P(_get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC));
	} else {
		name = zval_try_get_tmp_string(_get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC), &tmp_name);
		if (UNEXPECTED(!name)) {

			UNDEF_RESULT();
			goto exit_assign_obj;
		}
	}

	if (IS_CONST == IS_CV || IS_CONST == IS_VAR) {
		ZVAL_DEREF(value);
	}

	value = zobj->handlers->write_property(zobj, name, value, ((IS_TMP_VAR|IS_VAR) == IS_CONST) ? CACHE_ADDR(opline->extended_value) : NULL);

	if ((IS_TMP_VAR|IS_VAR) != IS_CONST) {
		crex_tmp_string_release(tmp_name);
	}

free_and_exit_assign_obj:
	if (UNEXPECTED(RETURN_VALUE_USED(opline)) && value) {
		ZVAL_COPY_DEREF(EX_VAR(opline->result.var), value);
	}

exit_assign_obj:
	if (garbage) {
		GC_DTOR_NO_REF(garbage);
	}
	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	/* assign_obj has two opcodes! */
	CREX_VM_NEXT_OPCODE_EX(1, 2);
}

/* No specialization for op_types (CONST|TMPVAR|CV, UNUSED|CONST|VAR) */
static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ASSIGN_OBJ_SPEC_VAR_TMPVAR_OP_DATA_TMP_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *object, *value, tmp;
	crex_object *zobj;
	crex_string *name, *tmp_name;
	crex_refcounted *garbage = NULL;

	SAVE_OPLINE();
	object = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	value = _get_zval_ptr_tmp((opline+1)->op1.var EXECUTE_DATA_CC);

	if (IS_VAR != IS_UNUSED && UNEXPECTED(C_TYPE_P(object) != IS_OBJECT)) {
		if (C_ISREF_P(object) && C_TYPE_P(C_REFVAL_P(object)) == IS_OBJECT) {
			object = C_REFVAL_P(object);
			goto assign_object;
		}
		crex_throw_non_object_error(object, _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC) OPLINE_CC EXECUTE_DATA_CC);
		value = &EG(uninitialized_zval);
		goto free_and_exit_assign_obj;
	}

assign_object:
	zobj = C_OBJ_P(object);
	if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
		if (EXPECTED(zobj->ce == CACHED_PTR(opline->extended_value))) {
			void **cache_slot = CACHE_ADDR(opline->extended_value);
			uintptr_t prop_offset = (uintptr_t)CACHED_PTR_EX(cache_slot + 1);
			zval *property_val;

			if (EXPECTED(IS_VALID_PROPERTY_OFFSET(prop_offset))) {
				property_val = OBJ_PROP(zobj, prop_offset);
				if (C_TYPE_P(property_val) != IS_UNDEF) {
					crex_property_info *prop_info = (crex_property_info*) CACHED_PTR_EX(cache_slot + 2);

					if (UNEXPECTED(prop_info != NULL)) {
						value = crex_assign_to_typed_prop(prop_info, property_val, value, &garbage EXECUTE_DATA_CC);
						goto free_and_exit_assign_obj;
					} else {
fast_assign_obj:
						value = crex_assign_to_variable_ex(property_val, value, IS_TMP_VAR, EX_USES_STRICT_TYPES(), &garbage);
						if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
							ZVAL_COPY(EX_VAR(opline->result.var), value);
						}
						goto exit_assign_obj;
					}
				}
			} else {
				name = C_STR_P(_get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC));
				if (EXPECTED(zobj->properties != NULL)) {
					if (UNEXPECTED(GC_REFCOUNT(zobj->properties) > 1)) {
						if (EXPECTED(!(GC_FLAGS(zobj->properties) & IS_ARRAY_IMMUTABLE))) {
							GC_DELREF(zobj->properties);
						}
						zobj->properties = crex_array_dup(zobj->properties);
					}
					property_val = crex_hash_find_known_hash(zobj->properties, name);
					if (property_val) {
						goto fast_assign_obj;
					}
				}

				if (!zobj->ce->__set && (zobj->ce->ce_flags & CREX_ACC_ALLOW_DYNAMIC_PROPERTIES)) {
					if (EXPECTED(zobj->properties == NULL)) {
						rebuild_object_properties(zobj);
					}
					if (IS_TMP_VAR == IS_CONST) {
						if (UNEXPECTED(C_OPT_REFCOUNTED_P(value))) {
							C_ADDREF_P(value);
						}
					} else if (IS_TMP_VAR != IS_TMP_VAR) {
						if (C_ISREF_P(value)) {
							if (IS_TMP_VAR == IS_VAR) {
								crex_reference *ref = C_REF_P(value);
								if (GC_DELREF(ref) == 0) {
									ZVAL_COPY_VALUE(&tmp, C_REFVAL_P(value));
									efree_size(ref, sizeof(crex_reference));
									value = &tmp;
								} else {
									value = C_REFVAL_P(value);
									C_TRY_ADDREF_P(value);
								}
							} else {
								value = C_REFVAL_P(value);
								C_TRY_ADDREF_P(value);
							}
						} else if (IS_TMP_VAR == IS_CV) {
							C_TRY_ADDREF_P(value);
						}
						}
					crex_hash_add_new(zobj->properties, name, value);
					if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
						ZVAL_COPY(EX_VAR(opline->result.var), value);
					}
					goto exit_assign_obj;
				}
			}
		}
		name = C_STR_P(_get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC));
	} else {
		name = zval_try_get_tmp_string(_get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC), &tmp_name);
		if (UNEXPECTED(!name)) {
			zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
			UNDEF_RESULT();
			goto exit_assign_obj;
		}
	}

	if (IS_TMP_VAR == IS_CV || IS_TMP_VAR == IS_VAR) {
		ZVAL_DEREF(value);
	}

	value = zobj->handlers->write_property(zobj, name, value, ((IS_TMP_VAR|IS_VAR) == IS_CONST) ? CACHE_ADDR(opline->extended_value) : NULL);

	if ((IS_TMP_VAR|IS_VAR) != IS_CONST) {
		crex_tmp_string_release(tmp_name);
	}

free_and_exit_assign_obj:
	if (UNEXPECTED(RETURN_VALUE_USED(opline)) && value) {
		ZVAL_COPY_DEREF(EX_VAR(opline->result.var), value);
	}
	zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
exit_assign_obj:
	if (garbage) {
		GC_DTOR_NO_REF(garbage);
	}
	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	/* assign_obj has two opcodes! */
	CREX_VM_NEXT_OPCODE_EX(1, 2);
}

/* No specialization for op_types (CONST|TMPVAR|CV, UNUSED|CONST|VAR) */
static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ASSIGN_OBJ_SPEC_VAR_TMPVAR_OP_DATA_VAR_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *object, *value, tmp;
	crex_object *zobj;
	crex_string *name, *tmp_name;
	crex_refcounted *garbage = NULL;

	SAVE_OPLINE();
	object = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	value = _get_zval_ptr_var((opline+1)->op1.var EXECUTE_DATA_CC);

	if (IS_VAR != IS_UNUSED && UNEXPECTED(C_TYPE_P(object) != IS_OBJECT)) {
		if (C_ISREF_P(object) && C_TYPE_P(C_REFVAL_P(object)) == IS_OBJECT) {
			object = C_REFVAL_P(object);
			goto assign_object;
		}
		crex_throw_non_object_error(object, _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC) OPLINE_CC EXECUTE_DATA_CC);
		value = &EG(uninitialized_zval);
		goto free_and_exit_assign_obj;
	}

assign_object:
	zobj = C_OBJ_P(object);
	if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
		if (EXPECTED(zobj->ce == CACHED_PTR(opline->extended_value))) {
			void **cache_slot = CACHE_ADDR(opline->extended_value);
			uintptr_t prop_offset = (uintptr_t)CACHED_PTR_EX(cache_slot + 1);
			zval *property_val;

			if (EXPECTED(IS_VALID_PROPERTY_OFFSET(prop_offset))) {
				property_val = OBJ_PROP(zobj, prop_offset);
				if (C_TYPE_P(property_val) != IS_UNDEF) {
					crex_property_info *prop_info = (crex_property_info*) CACHED_PTR_EX(cache_slot + 2);

					if (UNEXPECTED(prop_info != NULL)) {
						value = crex_assign_to_typed_prop(prop_info, property_val, value, &garbage EXECUTE_DATA_CC);
						goto free_and_exit_assign_obj;
					} else {
fast_assign_obj:
						value = crex_assign_to_variable_ex(property_val, value, IS_VAR, EX_USES_STRICT_TYPES(), &garbage);
						if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
							ZVAL_COPY(EX_VAR(opline->result.var), value);
						}
						goto exit_assign_obj;
					}
				}
			} else {
				name = C_STR_P(_get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC));
				if (EXPECTED(zobj->properties != NULL)) {
					if (UNEXPECTED(GC_REFCOUNT(zobj->properties) > 1)) {
						if (EXPECTED(!(GC_FLAGS(zobj->properties) & IS_ARRAY_IMMUTABLE))) {
							GC_DELREF(zobj->properties);
						}
						zobj->properties = crex_array_dup(zobj->properties);
					}
					property_val = crex_hash_find_known_hash(zobj->properties, name);
					if (property_val) {
						goto fast_assign_obj;
					}
				}

				if (!zobj->ce->__set && (zobj->ce->ce_flags & CREX_ACC_ALLOW_DYNAMIC_PROPERTIES)) {
					if (EXPECTED(zobj->properties == NULL)) {
						rebuild_object_properties(zobj);
					}
					if (IS_VAR == IS_CONST) {
						if (UNEXPECTED(C_OPT_REFCOUNTED_P(value))) {
							C_ADDREF_P(value);
						}
					} else if (IS_VAR != IS_TMP_VAR) {
						if (C_ISREF_P(value)) {
							if (IS_VAR == IS_VAR) {
								crex_reference *ref = C_REF_P(value);
								if (GC_DELREF(ref) == 0) {
									ZVAL_COPY_VALUE(&tmp, C_REFVAL_P(value));
									efree_size(ref, sizeof(crex_reference));
									value = &tmp;
								} else {
									value = C_REFVAL_P(value);
									C_TRY_ADDREF_P(value);
								}
							} else {
								value = C_REFVAL_P(value);
								C_TRY_ADDREF_P(value);
							}
						} else if (IS_VAR == IS_CV) {
							C_TRY_ADDREF_P(value);
						}
						}
					crex_hash_add_new(zobj->properties, name, value);
					if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
						ZVAL_COPY(EX_VAR(opline->result.var), value);
					}
					goto exit_assign_obj;
				}
			}
		}
		name = C_STR_P(_get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC));
	} else {
		name = zval_try_get_tmp_string(_get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC), &tmp_name);
		if (UNEXPECTED(!name)) {
			zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
			UNDEF_RESULT();
			goto exit_assign_obj;
		}
	}

	if (IS_VAR == IS_CV || IS_VAR == IS_VAR) {
		ZVAL_DEREF(value);
	}

	value = zobj->handlers->write_property(zobj, name, value, ((IS_TMP_VAR|IS_VAR) == IS_CONST) ? CACHE_ADDR(opline->extended_value) : NULL);

	if ((IS_TMP_VAR|IS_VAR) != IS_CONST) {
		crex_tmp_string_release(tmp_name);
	}

free_and_exit_assign_obj:
	if (UNEXPECTED(RETURN_VALUE_USED(opline)) && value) {
		ZVAL_COPY_DEREF(EX_VAR(opline->result.var), value);
	}
	zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
exit_assign_obj:
	if (garbage) {
		GC_DTOR_NO_REF(garbage);
	}
	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	/* assign_obj has two opcodes! */
	CREX_VM_NEXT_OPCODE_EX(1, 2);
}

/* No specialization for op_types (CONST|TMPVAR|CV, UNUSED|CONST|VAR) */
static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ASSIGN_OBJ_SPEC_VAR_TMPVAR_OP_DATA_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *object, *value, tmp;
	crex_object *zobj;
	crex_string *name, *tmp_name;
	crex_refcounted *garbage = NULL;

	SAVE_OPLINE();
	object = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	value = _get_zval_ptr_cv_BP_VAR_R((opline+1)->op1.var EXECUTE_DATA_CC);

	if (IS_VAR != IS_UNUSED && UNEXPECTED(C_TYPE_P(object) != IS_OBJECT)) {
		if (C_ISREF_P(object) && C_TYPE_P(C_REFVAL_P(object)) == IS_OBJECT) {
			object = C_REFVAL_P(object);
			goto assign_object;
		}
		crex_throw_non_object_error(object, _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC) OPLINE_CC EXECUTE_DATA_CC);
		value = &EG(uninitialized_zval);
		goto free_and_exit_assign_obj;
	}

assign_object:
	zobj = C_OBJ_P(object);
	if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
		if (EXPECTED(zobj->ce == CACHED_PTR(opline->extended_value))) {
			void **cache_slot = CACHE_ADDR(opline->extended_value);
			uintptr_t prop_offset = (uintptr_t)CACHED_PTR_EX(cache_slot + 1);
			zval *property_val;

			if (EXPECTED(IS_VALID_PROPERTY_OFFSET(prop_offset))) {
				property_val = OBJ_PROP(zobj, prop_offset);
				if (C_TYPE_P(property_val) != IS_UNDEF) {
					crex_property_info *prop_info = (crex_property_info*) CACHED_PTR_EX(cache_slot + 2);

					if (UNEXPECTED(prop_info != NULL)) {
						value = crex_assign_to_typed_prop(prop_info, property_val, value, &garbage EXECUTE_DATA_CC);
						goto free_and_exit_assign_obj;
					} else {
fast_assign_obj:
						value = crex_assign_to_variable_ex(property_val, value, IS_CV, EX_USES_STRICT_TYPES(), &garbage);
						if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
							ZVAL_COPY(EX_VAR(opline->result.var), value);
						}
						goto exit_assign_obj;
					}
				}
			} else {
				name = C_STR_P(_get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC));
				if (EXPECTED(zobj->properties != NULL)) {
					if (UNEXPECTED(GC_REFCOUNT(zobj->properties) > 1)) {
						if (EXPECTED(!(GC_FLAGS(zobj->properties) & IS_ARRAY_IMMUTABLE))) {
							GC_DELREF(zobj->properties);
						}
						zobj->properties = crex_array_dup(zobj->properties);
					}
					property_val = crex_hash_find_known_hash(zobj->properties, name);
					if (property_val) {
						goto fast_assign_obj;
					}
				}

				if (!zobj->ce->__set && (zobj->ce->ce_flags & CREX_ACC_ALLOW_DYNAMIC_PROPERTIES)) {
					if (EXPECTED(zobj->properties == NULL)) {
						rebuild_object_properties(zobj);
					}
					if (IS_CV == IS_CONST) {
						if (UNEXPECTED(C_OPT_REFCOUNTED_P(value))) {
							C_ADDREF_P(value);
						}
					} else if (IS_CV != IS_TMP_VAR) {
						if (C_ISREF_P(value)) {
							if (IS_CV == IS_VAR) {
								crex_reference *ref = C_REF_P(value);
								if (GC_DELREF(ref) == 0) {
									ZVAL_COPY_VALUE(&tmp, C_REFVAL_P(value));
									efree_size(ref, sizeof(crex_reference));
									value = &tmp;
								} else {
									value = C_REFVAL_P(value);
									C_TRY_ADDREF_P(value);
								}
							} else {
								value = C_REFVAL_P(value);
								C_TRY_ADDREF_P(value);
							}
						} else if (IS_CV == IS_CV) {
							C_TRY_ADDREF_P(value);
						}
						}
					crex_hash_add_new(zobj->properties, name, value);
					if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
						ZVAL_COPY(EX_VAR(opline->result.var), value);
					}
					goto exit_assign_obj;
				}
			}
		}
		name = C_STR_P(_get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC));
	} else {
		name = zval_try_get_tmp_string(_get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC), &tmp_name);
		if (UNEXPECTED(!name)) {

			UNDEF_RESULT();
			goto exit_assign_obj;
		}
	}

	if (IS_CV == IS_CV || IS_CV == IS_VAR) {
		ZVAL_DEREF(value);
	}

	value = zobj->handlers->write_property(zobj, name, value, ((IS_TMP_VAR|IS_VAR) == IS_CONST) ? CACHE_ADDR(opline->extended_value) : NULL);

	if ((IS_TMP_VAR|IS_VAR) != IS_CONST) {
		crex_tmp_string_release(tmp_name);
	}

free_and_exit_assign_obj:
	if (UNEXPECTED(RETURN_VALUE_USED(opline)) && value) {
		ZVAL_COPY_DEREF(EX_VAR(opline->result.var), value);
	}

exit_assign_obj:
	if (garbage) {
		GC_DTOR_NO_REF(garbage);
	}
	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	/* assign_obj has two opcodes! */
	CREX_VM_NEXT_OPCODE_EX(1, 2);
}

/* No specialization for op_types (CONST|TMPVAR|CV, UNUSED|CONST|VAR) */
static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ASSIGN_DIM_SPEC_VAR_TMPVAR_OP_DATA_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *object_ptr, *orig_object_ptr;
	zval *value;
	zval *variable_ptr;
	zval *dim;
	crex_refcounted *garbage = NULL;

	SAVE_OPLINE();
	orig_object_ptr = object_ptr = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);

	if (EXPECTED(C_TYPE_P(object_ptr) == IS_ARRAY)) {
try_assign_dim_array:
		SEPARATE_ARRAY(object_ptr);
		if ((IS_TMP_VAR|IS_VAR) == IS_UNUSED) {
			value = RT_CONSTANT((opline+1), (opline+1)->op1);
			if (IS_CONST == IS_CV && UNEXPECTED(C_TYPE_P(value) == IS_UNDEF)) {
				HashTable *ht = C_ARRVAL_P(object_ptr);
				if (!(GC_FLAGS(ht) & IS_ARRAY_IMMUTABLE)) {
					GC_ADDREF(ht);
				}
				value = zval_undefined_cv((opline+1)->op1.var EXECUTE_DATA_CC);
				if (!(GC_FLAGS(ht) & IS_ARRAY_IMMUTABLE) && !GC_DELREF(ht)) {
					crex_array_destroy(ht);
					goto assign_dim_error;
				}
			}
			if (IS_CONST == IS_CV || IS_CONST == IS_VAR) {
				ZVAL_DEREF(value);
			}
			value = crex_hash_next_index_insert(C_ARRVAL_P(object_ptr), value);
			if (UNEXPECTED(value == NULL)) {
				crex_cannot_add_element();
				goto assign_dim_error;
			} else if (IS_CONST == IS_CV) {
				if (C_REFCOUNTED_P(value)) {
					C_ADDREF_P(value);
				}
			} else if (IS_CONST == IS_VAR) {
				zval *free_op_data = EX_VAR((opline+1)->op1.var);
				if (C_ISREF_P(free_op_data)) {
					if (C_REFCOUNTED_P(value)) {
						C_ADDREF_P(value);
					}
					zval_ptr_dtor_nogc(free_op_data);
				}
			} else if (IS_CONST == IS_CONST) {
				if (UNEXPECTED(C_REFCOUNTED_P(value))) {
					C_ADDREF_P(value);
				}
			}
		} else {
			dim = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
			if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
				variable_ptr = crex_fetch_dimension_address_inner_W_CONST(C_ARRVAL_P(object_ptr), dim EXECUTE_DATA_CC);
			} else {
				variable_ptr = crex_fetch_dimension_address_inner_W(C_ARRVAL_P(object_ptr), dim EXECUTE_DATA_CC);
			}
			if (UNEXPECTED(variable_ptr == NULL)) {
				goto assign_dim_error;
			}
			value = RT_CONSTANT((opline+1), (opline+1)->op1);
			value = crex_assign_to_variable_ex(variable_ptr, value, IS_CONST, EX_USES_STRICT_TYPES(), &garbage);
		}
		if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
			ZVAL_COPY(EX_VAR(opline->result.var), value);
		}
		if (garbage) {
			GC_DTOR_NO_REF(garbage);
		}
	} else {
		if (EXPECTED(C_ISREF_P(object_ptr))) {
			object_ptr = C_REFVAL_P(object_ptr);
			if (EXPECTED(C_TYPE_P(object_ptr) == IS_ARRAY)) {
				goto try_assign_dim_array;
			}
		}
		if (EXPECTED(C_TYPE_P(object_ptr) == IS_OBJECT)) {
			crex_object *obj = C_OBJ_P(object_ptr);

			GC_ADDREF(obj);
			dim = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
			if ((IS_TMP_VAR|IS_VAR) == IS_CV && UNEXPECTED(C_ISUNDEF_P(dim))) {
				dim = ZVAL_UNDEFINED_OP2();
			} else if ((IS_TMP_VAR|IS_VAR) == IS_CONST && C_EXTRA_P(dim) == CREX_EXTRA_VALUE) {
				dim++;
			}

			value = RT_CONSTANT((opline+1), (opline+1)->op1);
			if (IS_CONST == IS_CV && UNEXPECTED(C_ISUNDEF_P(value))) {
				value = zval_undefined_cv((opline+1)->op1.var EXECUTE_DATA_CC);
			} else if (IS_CONST & (IS_CV|IS_VAR)) {
				ZVAL_DEREF(value);
			}

			crex_assign_to_object_dim(obj, dim, value OPLINE_CC EXECUTE_DATA_CC);

			if (UNEXPECTED(GC_DELREF(obj) == 0)) {
				crex_objects_store_del(obj);
			}
		} else if (EXPECTED(C_TYPE_P(object_ptr) == IS_STRING)) {
			if ((IS_TMP_VAR|IS_VAR) == IS_UNUSED) {
				crex_use_new_element_for_string();

				UNDEF_RESULT();
			} else {
				dim = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
				value = RT_CONSTANT((opline+1), (opline+1)->op1);
				crex_assign_to_string_offset(object_ptr, dim, value OPLINE_CC EXECUTE_DATA_CC);

			}
		} else if (EXPECTED(C_TYPE_P(object_ptr) <= IS_FALSE)) {
			if (C_ISREF_P(orig_object_ptr)
			 && CREX_REF_HAS_TYPE_SOURCES(C_REF_P(orig_object_ptr))
			 && !crex_verify_ref_array_assignable(C_REF_P(orig_object_ptr))) {
				dim = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);

				UNDEF_RESULT();
			} else {
				HashTable *ht = crex_new_array(8);
				uint8_t old_type = C_TYPE_P(object_ptr);

				ZVAL_ARR(object_ptr, ht);
				if (UNEXPECTED(old_type == IS_FALSE)) {
					GC_ADDREF(ht);
					crex_false_to_array_deprecated();
					if (UNEXPECTED(GC_DELREF(ht) == 0)) {
						crex_array_destroy(ht);
						goto assign_dim_error;
					}
				}
				goto try_assign_dim_array;
			}
		} else {
			crex_use_scalar_as_array();
			dim = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
assign_dim_error:

			if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
				ZVAL_NULL(EX_VAR(opline->result.var));
			}
		}
	}
	if ((IS_TMP_VAR|IS_VAR) != IS_UNUSED) {
		zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
	}
	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	/* assign_dim has two opcodes! */
	CREX_VM_NEXT_OPCODE_EX(1, 2);
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ASSIGN_DIM_SPEC_VAR_TMPVAR_OP_DATA_TMP_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *object_ptr, *orig_object_ptr;
	zval *value;
	zval *variable_ptr;
	zval *dim;
	crex_refcounted *garbage = NULL;

	SAVE_OPLINE();
	orig_object_ptr = object_ptr = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);

	if (EXPECTED(C_TYPE_P(object_ptr) == IS_ARRAY)) {
try_assign_dim_array:
		SEPARATE_ARRAY(object_ptr);
		if ((IS_TMP_VAR|IS_VAR) == IS_UNUSED) {
			value = _get_zval_ptr_tmp((opline+1)->op1.var EXECUTE_DATA_CC);
			if (IS_TMP_VAR == IS_CV && UNEXPECTED(C_TYPE_P(value) == IS_UNDEF)) {
				HashTable *ht = C_ARRVAL_P(object_ptr);
				if (!(GC_FLAGS(ht) & IS_ARRAY_IMMUTABLE)) {
					GC_ADDREF(ht);
				}
				value = zval_undefined_cv((opline+1)->op1.var EXECUTE_DATA_CC);
				if (!(GC_FLAGS(ht) & IS_ARRAY_IMMUTABLE) && !GC_DELREF(ht)) {
					crex_array_destroy(ht);
					goto assign_dim_error;
				}
			}
			if (IS_TMP_VAR == IS_CV || IS_TMP_VAR == IS_VAR) {
				ZVAL_DEREF(value);
			}
			value = crex_hash_next_index_insert(C_ARRVAL_P(object_ptr), value);
			if (UNEXPECTED(value == NULL)) {
				crex_cannot_add_element();
				goto assign_dim_error;
			} else if (IS_TMP_VAR == IS_CV) {
				if (C_REFCOUNTED_P(value)) {
					C_ADDREF_P(value);
				}
			} else if (IS_TMP_VAR == IS_VAR) {
				zval *free_op_data = EX_VAR((opline+1)->op1.var);
				if (C_ISREF_P(free_op_data)) {
					if (C_REFCOUNTED_P(value)) {
						C_ADDREF_P(value);
					}
					zval_ptr_dtor_nogc(free_op_data);
				}
			} else if (IS_TMP_VAR == IS_CONST) {
				if (UNEXPECTED(C_REFCOUNTED_P(value))) {
					C_ADDREF_P(value);
				}
			}
		} else {
			dim = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
			if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
				variable_ptr = crex_fetch_dimension_address_inner_W_CONST(C_ARRVAL_P(object_ptr), dim EXECUTE_DATA_CC);
			} else {
				variable_ptr = crex_fetch_dimension_address_inner_W(C_ARRVAL_P(object_ptr), dim EXECUTE_DATA_CC);
			}
			if (UNEXPECTED(variable_ptr == NULL)) {
				goto assign_dim_error;
			}
			value = _get_zval_ptr_tmp((opline+1)->op1.var EXECUTE_DATA_CC);
			value = crex_assign_to_variable_ex(variable_ptr, value, IS_TMP_VAR, EX_USES_STRICT_TYPES(), &garbage);
		}
		if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
			ZVAL_COPY(EX_VAR(opline->result.var), value);
		}
		if (garbage) {
			GC_DTOR_NO_REF(garbage);
		}
	} else {
		if (EXPECTED(C_ISREF_P(object_ptr))) {
			object_ptr = C_REFVAL_P(object_ptr);
			if (EXPECTED(C_TYPE_P(object_ptr) == IS_ARRAY)) {
				goto try_assign_dim_array;
			}
		}
		if (EXPECTED(C_TYPE_P(object_ptr) == IS_OBJECT)) {
			crex_object *obj = C_OBJ_P(object_ptr);

			GC_ADDREF(obj);
			dim = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
			if ((IS_TMP_VAR|IS_VAR) == IS_CV && UNEXPECTED(C_ISUNDEF_P(dim))) {
				dim = ZVAL_UNDEFINED_OP2();
			} else if ((IS_TMP_VAR|IS_VAR) == IS_CONST && C_EXTRA_P(dim) == CREX_EXTRA_VALUE) {
				dim++;
			}

			value = _get_zval_ptr_tmp((opline+1)->op1.var EXECUTE_DATA_CC);
			if (IS_TMP_VAR == IS_CV && UNEXPECTED(C_ISUNDEF_P(value))) {
				value = zval_undefined_cv((opline+1)->op1.var EXECUTE_DATA_CC);
			} else if (IS_TMP_VAR & (IS_CV|IS_VAR)) {
				ZVAL_DEREF(value);
			}

			crex_assign_to_object_dim(obj, dim, value OPLINE_CC EXECUTE_DATA_CC);

			zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
			if (UNEXPECTED(GC_DELREF(obj) == 0)) {
				crex_objects_store_del(obj);
			}
		} else if (EXPECTED(C_TYPE_P(object_ptr) == IS_STRING)) {
			if ((IS_TMP_VAR|IS_VAR) == IS_UNUSED) {
				crex_use_new_element_for_string();
				zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
				UNDEF_RESULT();
			} else {
				dim = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
				value = _get_zval_ptr_tmp((opline+1)->op1.var EXECUTE_DATA_CC);
				crex_assign_to_string_offset(object_ptr, dim, value OPLINE_CC EXECUTE_DATA_CC);
				zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
			}
		} else if (EXPECTED(C_TYPE_P(object_ptr) <= IS_FALSE)) {
			if (C_ISREF_P(orig_object_ptr)
			 && CREX_REF_HAS_TYPE_SOURCES(C_REF_P(orig_object_ptr))
			 && !crex_verify_ref_array_assignable(C_REF_P(orig_object_ptr))) {
				dim = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
				zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
				UNDEF_RESULT();
			} else {
				HashTable *ht = crex_new_array(8);
				uint8_t old_type = C_TYPE_P(object_ptr);

				ZVAL_ARR(object_ptr, ht);
				if (UNEXPECTED(old_type == IS_FALSE)) {
					GC_ADDREF(ht);
					crex_false_to_array_deprecated();
					if (UNEXPECTED(GC_DELREF(ht) == 0)) {
						crex_array_destroy(ht);
						goto assign_dim_error;
					}
				}
				goto try_assign_dim_array;
			}
		} else {
			crex_use_scalar_as_array();
			dim = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
assign_dim_error:
			zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
			if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
				ZVAL_NULL(EX_VAR(opline->result.var));
			}
		}
	}
	if ((IS_TMP_VAR|IS_VAR) != IS_UNUSED) {
		zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
	}
	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	/* assign_dim has two opcodes! */
	CREX_VM_NEXT_OPCODE_EX(1, 2);
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ASSIGN_DIM_SPEC_VAR_TMPVAR_OP_DATA_VAR_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *object_ptr, *orig_object_ptr;
	zval *value;
	zval *variable_ptr;
	zval *dim;
	crex_refcounted *garbage = NULL;

	SAVE_OPLINE();
	orig_object_ptr = object_ptr = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);

	if (EXPECTED(C_TYPE_P(object_ptr) == IS_ARRAY)) {
try_assign_dim_array:
		SEPARATE_ARRAY(object_ptr);
		if ((IS_TMP_VAR|IS_VAR) == IS_UNUSED) {
			value = _get_zval_ptr_var((opline+1)->op1.var EXECUTE_DATA_CC);
			if (IS_VAR == IS_CV && UNEXPECTED(C_TYPE_P(value) == IS_UNDEF)) {
				HashTable *ht = C_ARRVAL_P(object_ptr);
				if (!(GC_FLAGS(ht) & IS_ARRAY_IMMUTABLE)) {
					GC_ADDREF(ht);
				}
				value = zval_undefined_cv((opline+1)->op1.var EXECUTE_DATA_CC);
				if (!(GC_FLAGS(ht) & IS_ARRAY_IMMUTABLE) && !GC_DELREF(ht)) {
					crex_array_destroy(ht);
					goto assign_dim_error;
				}
			}
			if (IS_VAR == IS_CV || IS_VAR == IS_VAR) {
				ZVAL_DEREF(value);
			}
			value = crex_hash_next_index_insert(C_ARRVAL_P(object_ptr), value);
			if (UNEXPECTED(value == NULL)) {
				crex_cannot_add_element();
				goto assign_dim_error;
			} else if (IS_VAR == IS_CV) {
				if (C_REFCOUNTED_P(value)) {
					C_ADDREF_P(value);
				}
			} else if (IS_VAR == IS_VAR) {
				zval *free_op_data = EX_VAR((opline+1)->op1.var);
				if (C_ISREF_P(free_op_data)) {
					if (C_REFCOUNTED_P(value)) {
						C_ADDREF_P(value);
					}
					zval_ptr_dtor_nogc(free_op_data);
				}
			} else if (IS_VAR == IS_CONST) {
				if (UNEXPECTED(C_REFCOUNTED_P(value))) {
					C_ADDREF_P(value);
				}
			}
		} else {
			dim = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
			if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
				variable_ptr = crex_fetch_dimension_address_inner_W_CONST(C_ARRVAL_P(object_ptr), dim EXECUTE_DATA_CC);
			} else {
				variable_ptr = crex_fetch_dimension_address_inner_W(C_ARRVAL_P(object_ptr), dim EXECUTE_DATA_CC);
			}
			if (UNEXPECTED(variable_ptr == NULL)) {
				goto assign_dim_error;
			}
			value = _get_zval_ptr_var((opline+1)->op1.var EXECUTE_DATA_CC);
			value = crex_assign_to_variable_ex(variable_ptr, value, IS_VAR, EX_USES_STRICT_TYPES(), &garbage);
		}
		if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
			ZVAL_COPY(EX_VAR(opline->result.var), value);
		}
		if (garbage) {
			GC_DTOR_NO_REF(garbage);
		}
	} else {
		if (EXPECTED(C_ISREF_P(object_ptr))) {
			object_ptr = C_REFVAL_P(object_ptr);
			if (EXPECTED(C_TYPE_P(object_ptr) == IS_ARRAY)) {
				goto try_assign_dim_array;
			}
		}
		if (EXPECTED(C_TYPE_P(object_ptr) == IS_OBJECT)) {
			crex_object *obj = C_OBJ_P(object_ptr);

			GC_ADDREF(obj);
			dim = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
			if ((IS_TMP_VAR|IS_VAR) == IS_CV && UNEXPECTED(C_ISUNDEF_P(dim))) {
				dim = ZVAL_UNDEFINED_OP2();
			} else if ((IS_TMP_VAR|IS_VAR) == IS_CONST && C_EXTRA_P(dim) == CREX_EXTRA_VALUE) {
				dim++;
			}

			value = _get_zval_ptr_var((opline+1)->op1.var EXECUTE_DATA_CC);
			if (IS_VAR == IS_CV && UNEXPECTED(C_ISUNDEF_P(value))) {
				value = zval_undefined_cv((opline+1)->op1.var EXECUTE_DATA_CC);
			} else if (IS_VAR & (IS_CV|IS_VAR)) {
				ZVAL_DEREF(value);
			}

			crex_assign_to_object_dim(obj, dim, value OPLINE_CC EXECUTE_DATA_CC);

			zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
			if (UNEXPECTED(GC_DELREF(obj) == 0)) {
				crex_objects_store_del(obj);
			}
		} else if (EXPECTED(C_TYPE_P(object_ptr) == IS_STRING)) {
			if ((IS_TMP_VAR|IS_VAR) == IS_UNUSED) {
				crex_use_new_element_for_string();
				zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
				UNDEF_RESULT();
			} else {
				dim = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
				value = _get_zval_ptr_var((opline+1)->op1.var EXECUTE_DATA_CC);
				crex_assign_to_string_offset(object_ptr, dim, value OPLINE_CC EXECUTE_DATA_CC);
				zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
			}
		} else if (EXPECTED(C_TYPE_P(object_ptr) <= IS_FALSE)) {
			if (C_ISREF_P(orig_object_ptr)
			 && CREX_REF_HAS_TYPE_SOURCES(C_REF_P(orig_object_ptr))
			 && !crex_verify_ref_array_assignable(C_REF_P(orig_object_ptr))) {
				dim = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
				zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
				UNDEF_RESULT();
			} else {
				HashTable *ht = crex_new_array(8);
				uint8_t old_type = C_TYPE_P(object_ptr);

				ZVAL_ARR(object_ptr, ht);
				if (UNEXPECTED(old_type == IS_FALSE)) {
					GC_ADDREF(ht);
					crex_false_to_array_deprecated();
					if (UNEXPECTED(GC_DELREF(ht) == 0)) {
						crex_array_destroy(ht);
						goto assign_dim_error;
					}
				}
				goto try_assign_dim_array;
			}
		} else {
			crex_use_scalar_as_array();
			dim = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
assign_dim_error:
			zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
			if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
				ZVAL_NULL(EX_VAR(opline->result.var));
			}
		}
	}
	if ((IS_TMP_VAR|IS_VAR) != IS_UNUSED) {
		zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
	}
	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	/* assign_dim has two opcodes! */
	CREX_VM_NEXT_OPCODE_EX(1, 2);
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ASSIGN_DIM_SPEC_VAR_TMPVAR_OP_DATA_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *object_ptr, *orig_object_ptr;
	zval *value;
	zval *variable_ptr;
	zval *dim;
	crex_refcounted *garbage = NULL;

	SAVE_OPLINE();
	orig_object_ptr = object_ptr = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);

	if (EXPECTED(C_TYPE_P(object_ptr) == IS_ARRAY)) {
try_assign_dim_array:
		SEPARATE_ARRAY(object_ptr);
		if ((IS_TMP_VAR|IS_VAR) == IS_UNUSED) {
			value = EX_VAR((opline+1)->op1.var);
			if (IS_CV == IS_CV && UNEXPECTED(C_TYPE_P(value) == IS_UNDEF)) {
				HashTable *ht = C_ARRVAL_P(object_ptr);
				if (!(GC_FLAGS(ht) & IS_ARRAY_IMMUTABLE)) {
					GC_ADDREF(ht);
				}
				value = zval_undefined_cv((opline+1)->op1.var EXECUTE_DATA_CC);
				if (!(GC_FLAGS(ht) & IS_ARRAY_IMMUTABLE) && !GC_DELREF(ht)) {
					crex_array_destroy(ht);
					goto assign_dim_error;
				}
			}
			if (IS_CV == IS_CV || IS_CV == IS_VAR) {
				ZVAL_DEREF(value);
			}
			value = crex_hash_next_index_insert(C_ARRVAL_P(object_ptr), value);
			if (UNEXPECTED(value == NULL)) {
				crex_cannot_add_element();
				goto assign_dim_error;
			} else if (IS_CV == IS_CV) {
				if (C_REFCOUNTED_P(value)) {
					C_ADDREF_P(value);
				}
			} else if (IS_CV == IS_VAR) {
				zval *free_op_data = EX_VAR((opline+1)->op1.var);
				if (C_ISREF_P(free_op_data)) {
					if (C_REFCOUNTED_P(value)) {
						C_ADDREF_P(value);
					}
					zval_ptr_dtor_nogc(free_op_data);
				}
			} else if (IS_CV == IS_CONST) {
				if (UNEXPECTED(C_REFCOUNTED_P(value))) {
					C_ADDREF_P(value);
				}
			}
		} else {
			dim = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
			if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
				variable_ptr = crex_fetch_dimension_address_inner_W_CONST(C_ARRVAL_P(object_ptr), dim EXECUTE_DATA_CC);
			} else {
				variable_ptr = crex_fetch_dimension_address_inner_W(C_ARRVAL_P(object_ptr), dim EXECUTE_DATA_CC);
			}
			if (UNEXPECTED(variable_ptr == NULL)) {
				goto assign_dim_error;
			}
			value = _get_zval_ptr_cv_BP_VAR_R((opline+1)->op1.var EXECUTE_DATA_CC);
			value = crex_assign_to_variable_ex(variable_ptr, value, IS_CV, EX_USES_STRICT_TYPES(), &garbage);
		}
		if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
			ZVAL_COPY(EX_VAR(opline->result.var), value);
		}
		if (garbage) {
			GC_DTOR_NO_REF(garbage);
		}
	} else {
		if (EXPECTED(C_ISREF_P(object_ptr))) {
			object_ptr = C_REFVAL_P(object_ptr);
			if (EXPECTED(C_TYPE_P(object_ptr) == IS_ARRAY)) {
				goto try_assign_dim_array;
			}
		}
		if (EXPECTED(C_TYPE_P(object_ptr) == IS_OBJECT)) {
			crex_object *obj = C_OBJ_P(object_ptr);

			GC_ADDREF(obj);
			dim = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
			if ((IS_TMP_VAR|IS_VAR) == IS_CV && UNEXPECTED(C_ISUNDEF_P(dim))) {
				dim = ZVAL_UNDEFINED_OP2();
			} else if ((IS_TMP_VAR|IS_VAR) == IS_CONST && C_EXTRA_P(dim) == CREX_EXTRA_VALUE) {
				dim++;
			}

			value = EX_VAR((opline+1)->op1.var);
			if (IS_CV == IS_CV && UNEXPECTED(C_ISUNDEF_P(value))) {
				value = zval_undefined_cv((opline+1)->op1.var EXECUTE_DATA_CC);
			} else if (IS_CV & (IS_CV|IS_VAR)) {
				ZVAL_DEREF(value);
			}

			crex_assign_to_object_dim(obj, dim, value OPLINE_CC EXECUTE_DATA_CC);

			if (UNEXPECTED(GC_DELREF(obj) == 0)) {
				crex_objects_store_del(obj);
			}
		} else if (EXPECTED(C_TYPE_P(object_ptr) == IS_STRING)) {
			if ((IS_TMP_VAR|IS_VAR) == IS_UNUSED) {
				crex_use_new_element_for_string();

				UNDEF_RESULT();
			} else {
				dim = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
				value = EX_VAR((opline+1)->op1.var);
				crex_assign_to_string_offset(object_ptr, dim, value OPLINE_CC EXECUTE_DATA_CC);

			}
		} else if (EXPECTED(C_TYPE_P(object_ptr) <= IS_FALSE)) {
			if (C_ISREF_P(orig_object_ptr)
			 && CREX_REF_HAS_TYPE_SOURCES(C_REF_P(orig_object_ptr))
			 && !crex_verify_ref_array_assignable(C_REF_P(orig_object_ptr))) {
				dim = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);

				UNDEF_RESULT();
			} else {
				HashTable *ht = crex_new_array(8);
				uint8_t old_type = C_TYPE_P(object_ptr);

				ZVAL_ARR(object_ptr, ht);
				if (UNEXPECTED(old_type == IS_FALSE)) {
					GC_ADDREF(ht);
					crex_false_to_array_deprecated();
					if (UNEXPECTED(GC_DELREF(ht) == 0)) {
						crex_array_destroy(ht);
						goto assign_dim_error;
					}
				}
				goto try_assign_dim_array;
			}
		} else {
			crex_use_scalar_as_array();
			dim = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
assign_dim_error:

			if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
				ZVAL_NULL(EX_VAR(opline->result.var));
			}
		}
	}
	if ((IS_TMP_VAR|IS_VAR) != IS_UNUSED) {
		zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
	}
	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	/* assign_dim has two opcodes! */
	CREX_VM_NEXT_OPCODE_EX(1, 2);
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ASSIGN_OBJ_REF_SPEC_VAR_TMPVAR_OP_DATA_VAR_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *property, *container, *value_ptr;

	SAVE_OPLINE();

	container = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	property = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);

	value_ptr = _get_zval_ptr_ptr_var((opline+1)->op1.var EXECUTE_DATA_CC);

	if (1) {
		if (IS_VAR == IS_UNUSED) {
			if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
				crex_assign_to_property_reference_this_const(container, property, value_ptr OPLINE_CC EXECUTE_DATA_CC);
			} else {
				crex_assign_to_property_reference_this_var(container, property, value_ptr OPLINE_CC EXECUTE_DATA_CC);
			}
		} else {
			if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
				crex_assign_to_property_reference_var_const(container, property, value_ptr OPLINE_CC EXECUTE_DATA_CC);
			} else {
				crex_assign_to_property_reference_var_var(container, property, value_ptr OPLINE_CC EXECUTE_DATA_CC);
			}
		}
	} else {
		crex_assign_to_property_reference(container, IS_VAR, property, (IS_TMP_VAR|IS_VAR), value_ptr OPLINE_CC EXECUTE_DATA_CC);
	}

	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
	zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
	CREX_VM_NEXT_OPCODE_EX(1, 2);
}

/* No specialization for op_types (CONST|TMPVAR|CV, UNUSED|CONST|VAR) */
static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ASSIGN_OBJ_REF_SPEC_VAR_TMPVAR_OP_DATA_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *property, *container, *value_ptr;

	SAVE_OPLINE();

	container = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	property = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);

	value_ptr = _get_zval_ptr_cv_BP_VAR_W((opline+1)->op1.var EXECUTE_DATA_CC);

	if (1) {
		if (IS_VAR == IS_UNUSED) {
			if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
				crex_assign_to_property_reference_this_const(container, property, value_ptr OPLINE_CC EXECUTE_DATA_CC);
			} else {
				crex_assign_to_property_reference_this_var(container, property, value_ptr OPLINE_CC EXECUTE_DATA_CC);
			}
		} else {
			if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
				crex_assign_to_property_reference_var_const(container, property, value_ptr OPLINE_CC EXECUTE_DATA_CC);
			} else {
				crex_assign_to_property_reference_var_var(container, property, value_ptr OPLINE_CC EXECUTE_DATA_CC);
			}
		}
	} else {
		crex_assign_to_property_reference(container, IS_VAR, property, (IS_TMP_VAR|IS_VAR), value_ptr OPLINE_CC EXECUTE_DATA_CC);
	}

	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));

	CREX_VM_NEXT_OPCODE_EX(1, 2);
}

/* No specialization for op_types (CONST|TMPVAR|CV, UNUSED|CONST|VAR) */
static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_INIT_STATIC_METHOD_CALL_SPEC_VAR_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *function_name;
	crex_class_entry *ce;
	uint32_t call_info;
	crex_function *fbc;
	crex_execute_data *call;

	SAVE_OPLINE();

	if (IS_VAR == IS_CONST) {
		/* no function found. try a static method in class */
		ce = CACHED_PTR(opline->result.num);
		if (UNEXPECTED(ce == NULL)) {
			ce = crex_fetch_class_by_name(C_STR_P(RT_CONSTANT(opline, opline->op1)), C_STR_P(RT_CONSTANT(opline, opline->op1) + 1), CREX_FETCH_CLASS_DEFAULT | CREX_FETCH_CLASS_EXCEPTION);
			if (UNEXPECTED(ce == NULL)) {
				zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
				HANDLE_EXCEPTION();
			}
			if ((IS_TMP_VAR|IS_VAR) != IS_CONST) {
				CACHE_PTR(opline->result.num, ce);
			}
		}
	} else if (IS_VAR == IS_UNUSED) {
		ce = crex_fetch_class(NULL, opline->op1.num);
		if (UNEXPECTED(ce == NULL)) {
			zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
			HANDLE_EXCEPTION();
		}
	} else {
		ce = C_CE_P(EX_VAR(opline->op1.var));
	}

	if (IS_VAR == IS_CONST &&
	    (IS_TMP_VAR|IS_VAR) == IS_CONST &&
	    EXPECTED((fbc = CACHED_PTR(opline->result.num + sizeof(void*))) != NULL)) {
		/* nothing to do */
	} else if (IS_VAR != IS_CONST &&
	           (IS_TMP_VAR|IS_VAR) == IS_CONST &&
	           EXPECTED(CACHED_PTR(opline->result.num) == ce)) {
		fbc = CACHED_PTR(opline->result.num + sizeof(void*));
	} else if ((IS_TMP_VAR|IS_VAR) != IS_UNUSED) {
		function_name = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
		if ((IS_TMP_VAR|IS_VAR) != IS_CONST) {
			if (UNEXPECTED(C_TYPE_P(function_name) != IS_STRING)) {
				do {
					if ((IS_TMP_VAR|IS_VAR) & (IS_VAR|IS_CV) && C_ISREF_P(function_name)) {
						function_name = C_REFVAL_P(function_name);
						if (EXPECTED(C_TYPE_P(function_name) == IS_STRING)) {
							break;
						}
					} else if ((IS_TMP_VAR|IS_VAR) == IS_CV && UNEXPECTED(C_TYPE_P(function_name) == IS_UNDEF)) {
						ZVAL_UNDEFINED_OP2();
						if (UNEXPECTED(EG(exception) != NULL)) {
							HANDLE_EXCEPTION();
						}
					}
					crex_throw_error(NULL, "Method name must be a string");
					zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
					HANDLE_EXCEPTION();
				} while (0);
			}
		}

		if (ce->get_static_method) {
			fbc = ce->get_static_method(ce, C_STR_P(function_name));
		} else {
			fbc = crex_std_get_static_method(ce, C_STR_P(function_name), (((IS_TMP_VAR|IS_VAR) == IS_CONST) ? (RT_CONSTANT(opline, opline->op2) + 1) : NULL));
		}
		if (UNEXPECTED(fbc == NULL)) {
			if (EXPECTED(!EG(exception))) {
				crex_undefined_method(ce, C_STR_P(function_name));
			}
			zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
			HANDLE_EXCEPTION();
		}
		if ((IS_TMP_VAR|IS_VAR) == IS_CONST &&
		    EXPECTED(!(fbc->common.fn_flags & (CREX_ACC_CALL_VIA_TRAMPOLINE|CREX_ACC_NEVER_CACHE))) &&
			EXPECTED(!(fbc->common.scope->ce_flags & CREX_ACC_TRAIT))) {
			CACHE_POLYMORPHIC_PTR(opline->result.num, ce, fbc);
		}
		if (EXPECTED(fbc->type == CREX_USER_FUNCTION) && UNEXPECTED(!RUN_TIME_CACHE(&fbc->op_array))) {
			init_func_run_time_cache(&fbc->op_array);
		}
		if ((IS_TMP_VAR|IS_VAR) != IS_CONST) {
			zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
		}
	} else {
		if (UNEXPECTED(ce->constructor == NULL)) {
			crex_throw_error(NULL, "Cannot call constructor");
			HANDLE_EXCEPTION();
		}
		if (C_TYPE(EX(This)) == IS_OBJECT && C_OBJ(EX(This))->ce != ce->constructor->common.scope && (ce->constructor->common.fn_flags & CREX_ACC_PRIVATE)) {
			crex_throw_error(NULL, "Cannot call private %s::__main()", ZSTR_VAL(ce->name));
			HANDLE_EXCEPTION();
		}
		fbc = ce->constructor;
		if (EXPECTED(fbc->type == CREX_USER_FUNCTION) && UNEXPECTED(!RUN_TIME_CACHE(&fbc->op_array))) {
			init_func_run_time_cache(&fbc->op_array);
		}
	}

	if (!(fbc->common.fn_flags & CREX_ACC_STATIC)) {
		if (C_TYPE(EX(This)) == IS_OBJECT && instanceof_function(C_OBJCE(EX(This)), ce)) {
			ce = (crex_class_entry*)C_OBJ(EX(This));
			call_info = CREX_CALL_NESTED_FUNCTION | CREX_CALL_HAS_THIS;
		} else {
			crex_non_static_method_call(fbc);
			HANDLE_EXCEPTION();
		}
	} else {
		/* previous opcode is CREX_FETCH_CLASS */
		if (IS_VAR == IS_UNUSED
		 && ((opline->op1.num & CREX_FETCH_CLASS_MASK) == CREX_FETCH_CLASS_PARENT ||
		     (opline->op1.num & CREX_FETCH_CLASS_MASK) == CREX_FETCH_CLASS_SELF)) {
			if (C_TYPE(EX(This)) == IS_OBJECT) {
				ce = C_OBJCE(EX(This));
			} else {
				ce = C_CE(EX(This));
			}
		}
		call_info = CREX_CALL_NESTED_FUNCTION;
	}

	call = crex_vm_stack_push_call_frame(call_info,
		fbc, opline->extended_value, ce);
	call->prev_execute_data = EX(call);
	EX(call) = call;

	CREX_VM_NEXT_OPCODE();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ADD_ARRAY_ELEMENT_SPEC_VAR_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *expr_ptr, new_expr;

	SAVE_OPLINE();
	if ((IS_VAR == IS_VAR || IS_VAR == IS_CV) &&
	    UNEXPECTED(opline->extended_value & CREX_ARRAY_ELEMENT_REF)) {
		expr_ptr = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);
		if (C_ISREF_P(expr_ptr)) {
			C_ADDREF_P(expr_ptr);
		} else {
			ZVAL_MAKE_REF_EX(expr_ptr, 2);
		}
		zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	} else {
		expr_ptr = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);
		if (IS_VAR == IS_TMP_VAR) {
			/* pass */
		} else if (IS_VAR == IS_CONST) {
			C_TRY_ADDREF_P(expr_ptr);
		} else if (IS_VAR == IS_CV) {
			ZVAL_DEREF(expr_ptr);
			C_TRY_ADDREF_P(expr_ptr);
		} else /* if (IS_VAR == IS_VAR) */ {
			if (UNEXPECTED(C_ISREF_P(expr_ptr))) {
				crex_refcounted *ref = C_COUNTED_P(expr_ptr);

				expr_ptr = C_REFVAL_P(expr_ptr);
				if (UNEXPECTED(GC_DELREF(ref) == 0)) {
					ZVAL_COPY_VALUE(&new_expr, expr_ptr);
					expr_ptr = &new_expr;
					efree_size(ref, sizeof(crex_reference));
				} else if (C_OPT_REFCOUNTED_P(expr_ptr)) {
					C_ADDREF_P(expr_ptr);
				}
			}
		}
	}

	if ((IS_TMP_VAR|IS_VAR) != IS_UNUSED) {
		zval *offset = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
		crex_string *str;
		crex_ulong hval;

add_again:
		if (EXPECTED(C_TYPE_P(offset) == IS_STRING)) {
			str = C_STR_P(offset);
			if ((IS_TMP_VAR|IS_VAR) != IS_CONST) {
				if (CREX_HANDLE_NUMERIC(str, hval)) {
					goto num_index;
				}
			}
str_index:
			crex_hash_update(C_ARRVAL_P(EX_VAR(opline->result.var)), str, expr_ptr);
		} else if (EXPECTED(C_TYPE_P(offset) == IS_LONG)) {
			hval = C_LVAL_P(offset);
num_index:
			crex_hash_index_update(C_ARRVAL_P(EX_VAR(opline->result.var)), hval, expr_ptr);
		} else if (((IS_TMP_VAR|IS_VAR) & (IS_VAR|IS_CV)) && EXPECTED(C_TYPE_P(offset) == IS_REFERENCE)) {
			offset = C_REFVAL_P(offset);
			goto add_again;
		} else if (C_TYPE_P(offset) == IS_NULL) {
			str = ZSTR_EMPTY_ALLOC();
			goto str_index;
		} else if (C_TYPE_P(offset) == IS_DOUBLE) {
			hval = crex_dval_to_lval_safe(C_DVAL_P(offset));
			goto num_index;
		} else if (C_TYPE_P(offset) == IS_FALSE) {
			hval = 0;
			goto num_index;
		} else if (C_TYPE_P(offset) == IS_TRUE) {
			hval = 1;
			goto num_index;
		} else if (C_TYPE_P(offset) == IS_RESOURCE) {
			crex_use_resource_as_offset(offset);
			hval = C_RES_HANDLE_P(offset);
			goto num_index;
		} else if ((IS_TMP_VAR|IS_VAR) == IS_CV && C_TYPE_P(offset) == IS_UNDEF) {
			ZVAL_UNDEFINED_OP2();
			str = ZSTR_EMPTY_ALLOC();
			goto str_index;
		} else {
			crex_illegal_array_offset_access(offset);
			zval_ptr_dtor_nogc(expr_ptr);
		}
		zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
	} else {
		if (!crex_hash_next_index_insert(C_ARRVAL_P(EX_VAR(opline->result.var)), expr_ptr)) {
			crex_cannot_add_element();
			zval_ptr_dtor_nogc(expr_ptr);
		}
	}
	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_INIT_ARRAY_SPEC_VAR_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	zval *array;
	uint32_t size;
	USE_OPLINE

	array = EX_VAR(opline->result.var);
	if (IS_VAR != IS_UNUSED) {
		size = opline->extended_value >> CREX_ARRAY_SIZE_SHIFT;
		ZVAL_ARR(array, crex_new_array(size));
		/* Explicitly initialize array as not-packed if flag is set */
		if (opline->extended_value & CREX_ARRAY_NOT_PACKED) {
			crex_hash_real_init_mixed(C_ARRVAL_P(array));
		}
		CREX_VM_TAIL_CALL(CREX_ADD_ARRAY_ELEMENT_SPEC_VAR_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU));
	} else {
		ZVAL_ARR(array, crex_new_array(0));
		CREX_VM_NEXT_OPCODE();
	}
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_UNSET_DIM_SPEC_VAR_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;
	zval *offset;
	crex_ulong hval;
	crex_string *key;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	offset = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);

	do {
		if (EXPECTED(C_TYPE_P(container) == IS_ARRAY)) {
			HashTable *ht;

unset_dim_array:
			SEPARATE_ARRAY(container);
			ht = C_ARRVAL_P(container);
offset_again:
			if (EXPECTED(C_TYPE_P(offset) == IS_STRING)) {
				key = C_STR_P(offset);
				if ((IS_TMP_VAR|IS_VAR) != IS_CONST) {
					if (CREX_HANDLE_NUMERIC(key, hval)) {
						goto num_index_dim;
					}
				}
str_index_dim:
				CREX_ASSERT(ht != &EG(symbol_table));
				crex_hash_del(ht, key);
			} else if (EXPECTED(C_TYPE_P(offset) == IS_LONG)) {
				hval = C_LVAL_P(offset);
num_index_dim:
				crex_hash_index_del(ht, hval);
			} else if (((IS_TMP_VAR|IS_VAR) & (IS_VAR|IS_CV)) && EXPECTED(C_TYPE_P(offset) == IS_REFERENCE)) {
				offset = C_REFVAL_P(offset);
				goto offset_again;
			} else if (C_TYPE_P(offset) == IS_DOUBLE) {
				hval = crex_dval_to_lval_safe(C_DVAL_P(offset));
				goto num_index_dim;
			} else if (C_TYPE_P(offset) == IS_NULL) {
				key = ZSTR_EMPTY_ALLOC();
				goto str_index_dim;
			} else if (C_TYPE_P(offset) == IS_FALSE) {
				hval = 0;
				goto num_index_dim;
			} else if (C_TYPE_P(offset) == IS_TRUE) {
				hval = 1;
				goto num_index_dim;
			} else if (C_TYPE_P(offset) == IS_RESOURCE) {
				crex_use_resource_as_offset(offset);
				hval = C_RES_HANDLE_P(offset);
				goto num_index_dim;
			} else if ((IS_TMP_VAR|IS_VAR) == IS_CV && C_TYPE_P(offset) == IS_UNDEF) {
				ZVAL_UNDEFINED_OP2();
				key = ZSTR_EMPTY_ALLOC();
				goto str_index_dim;
			} else {
				crex_illegal_array_offset_unset(offset);
			}
			break;
		} else if (C_ISREF_P(container)) {
			container = C_REFVAL_P(container);
			if (EXPECTED(C_TYPE_P(container) == IS_ARRAY)) {
				goto unset_dim_array;
			}
		}
		if (IS_VAR == IS_CV && UNEXPECTED(C_TYPE_P(container) == IS_UNDEF)) {
			container = ZVAL_UNDEFINED_OP1();
		}
		if ((IS_TMP_VAR|IS_VAR) == IS_CV && UNEXPECTED(C_TYPE_P(offset) == IS_UNDEF)) {
			offset = ZVAL_UNDEFINED_OP2();
		}
		if (EXPECTED(C_TYPE_P(container) == IS_OBJECT)) {
			if ((IS_TMP_VAR|IS_VAR) == IS_CONST && C_EXTRA_P(offset) == CREX_EXTRA_VALUE) {
				offset++;
			}
			C_OBJ_HT_P(container)->unset_dimension(C_OBJ_P(container), offset);
		} else if (UNEXPECTED(C_TYPE_P(container) == IS_STRING)) {
			crex_throw_error(NULL, "Cannot unset string offsets");
		} else if (UNEXPECTED(C_TYPE_P(container) > IS_FALSE)) {
			crex_throw_error(NULL, "Cannot unset offset in a non-array variable");
		} else if (UNEXPECTED(C_TYPE_P(container) == IS_FALSE)) {
			crex_false_to_array_deprecated();
		}
	} while (0);

	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_UNSET_OBJ_SPEC_VAR_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;
	zval *offset;
	crex_string *name, *tmp_name;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	offset = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);

	do {
		if (IS_VAR != IS_UNUSED && UNEXPECTED(C_TYPE_P(container) != IS_OBJECT)) {
			if (C_ISREF_P(container)) {
				container = C_REFVAL_P(container);
				if (C_TYPE_P(container) != IS_OBJECT) {
					if (IS_VAR == IS_CV
					 && UNEXPECTED(C_TYPE_P(container) == IS_UNDEF)) {
						ZVAL_UNDEFINED_OP1();
					}
					break;
				}
			} else {
				break;
			}
		}
		if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
			name = C_STR_P(offset);
		} else {
			name = zval_try_get_tmp_string(offset, &tmp_name);
			if (UNEXPECTED(!name)) {
				break;
			}
		}
		C_OBJ_HT_P(container)->unset_property(C_OBJ_P(container), name, (((IS_TMP_VAR|IS_VAR) == IS_CONST) ? CACHE_ADDR(opline->extended_value) : NULL));
		if ((IS_TMP_VAR|IS_VAR) != IS_CONST) {
			crex_tmp_string_release(tmp_name);
		}
	} while (0);

	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_YIELD_SPEC_VAR_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	crex_generator *generator = crex_get_running_generator(EXECUTE_DATA_C);

	SAVE_OPLINE();
	if (UNEXPECTED(generator->flags & CREX_GENERATOR_FORCED_CLOSE)) {
		CREX_VM_TAIL_CALL(crex_yield_in_closed_generator_helper_SPEC(CREX_OPCODE_HANDLER_ARGS_PASSTHRU));
	}

	/* Destroy the previously yielded value */
	zval_ptr_dtor(&generator->value);

	/* Destroy the previously yielded key */
	zval_ptr_dtor(&generator->key);

	/* Set the new yielded value */
	if (IS_VAR != IS_UNUSED) {
		if (UNEXPECTED(EX(func)->op_array.fn_flags & CREX_ACC_RETURN_REFERENCE)) {
			/* Constants and temporary variables aren't yieldable by reference,
			 * but we still allow them with a notice. */
			if (IS_VAR & (IS_CONST|IS_TMP_VAR)) {
				zval *value;

				crex_error(E_NOTICE, "Only variable references should be yielded by reference");

				value = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);
				ZVAL_COPY_VALUE(&generator->value, value);
				if (IS_VAR == IS_CONST) {
					if (UNEXPECTED(C_OPT_REFCOUNTED(generator->value))) {
						C_ADDREF(generator->value);
					}
				}
			} else {
				zval *value_ptr = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);

				/* If a function call result is yielded and the function did
				 * not return by reference we throw a notice. */
				do {
					if (IS_VAR == IS_VAR) {
						CREX_ASSERT(value_ptr != &EG(uninitialized_zval));
						if (opline->extended_value == CREX_RETURNS_FUNCTION
						 && !C_ISREF_P(value_ptr)) {
							crex_error(E_NOTICE, "Only variable references should be yielded by reference");
							ZVAL_COPY(&generator->value, value_ptr);
							break;
						}
					}
					if (C_ISREF_P(value_ptr)) {
						C_ADDREF_P(value_ptr);
					} else {
						ZVAL_MAKE_REF_EX(value_ptr, 2);
					}
					ZVAL_REF(&generator->value, C_REF_P(value_ptr));
				} while (0);

				zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
			}
		} else {
			zval *value = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);

			/* Consts, temporary variables and references need copying */
			if (IS_VAR == IS_CONST) {
				ZVAL_COPY_VALUE(&generator->value, value);
				if (UNEXPECTED(C_OPT_REFCOUNTED(generator->value))) {
					C_ADDREF(generator->value);
				}
			} else if (IS_VAR == IS_TMP_VAR) {
				ZVAL_COPY_VALUE(&generator->value, value);
			} else if ((IS_VAR & (IS_VAR|IS_CV)) && C_ISREF_P(value)) {
				ZVAL_COPY(&generator->value, C_REFVAL_P(value));
				zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
			} else {
				ZVAL_COPY_VALUE(&generator->value, value);
				if (IS_VAR == IS_CV) {
					if (C_OPT_REFCOUNTED_P(value)) C_ADDREF_P(value);
				}
			}
		}
	} else {
		/* If no value was specified yield null */
		ZVAL_NULL(&generator->value);
	}

	/* Set the new yielded key */
	if ((IS_TMP_VAR|IS_VAR) != IS_UNUSED) {
		zval *key = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
		if (((IS_TMP_VAR|IS_VAR) & (IS_CV|IS_VAR)) && UNEXPECTED(C_TYPE_P(key) == IS_REFERENCE)) {
			key = C_REFVAL_P(key);
		}
		ZVAL_COPY(&generator->key, key);
		zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));

		if (C_TYPE(generator->key) == IS_LONG
		    && C_LVAL(generator->key) > generator->largest_used_integer_key
		) {
			generator->largest_used_integer_key = C_LVAL(generator->key);
		}
	} else {
		/* If no key was specified we use auto-increment keys */
		generator->largest_used_integer_key++;
		ZVAL_LONG(&generator->key, generator->largest_used_integer_key);
	}

	if (RETURN_VALUE_USED(opline)) {
		/* If the return value of yield is used set the send
		 * target and initialize it to NULL */
		generator->send_target = EX_VAR(opline->result.var);
		ZVAL_NULL(generator->send_target);
	} else {
		generator->send_target = NULL;
	}

	/* We increment to the next op, so we are at the correct position when the
	 * generator is resumed. */
	CREX_VM_INC_OPCODE();

	/* The GOTO VM uses a local opline variable. We need to set the opline
	 * variable in execute_data so we don't resume at an old position. */
	SAVE_OPLINE();

	CREX_VM_RETURN();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_IS_IDENTICAL_SPEC_VAR_TMP_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	bool result;

	SAVE_OPLINE();
	op1 = _get_zval_ptr_var_deref(opline->op1.var EXECUTE_DATA_CC);
	op2 = _get_zval_ptr_tmp(opline->op2.var EXECUTE_DATA_CC);
	result = fast_is_identical_function(op1, op2);
	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
	CREX_VM_SMART_BRANCH(result, 1);
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_CASE_STRICT_SPEC_VAR_TMP_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	bool result;

	SAVE_OPLINE();
	op1 = _get_zval_ptr_var_deref(opline->op1.var EXECUTE_DATA_CC);
	op2 = _get_zval_ptr_tmp(opline->op2.var EXECUTE_DATA_CC);
	result = fast_is_identical_function(op1, op2);
	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
	CREX_VM_SMART_BRANCH(result, 1);
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_IS_NOT_IDENTICAL_SPEC_VAR_TMP_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	bool result;

	SAVE_OPLINE();
	op1 = _get_zval_ptr_var_deref(opline->op1.var EXECUTE_DATA_CC);
	op2 = _get_zval_ptr_tmp(opline->op2.var EXECUTE_DATA_CC);
	result = fast_is_not_identical_function(op1, op2);
	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
	CREX_VM_SMART_BRANCH(result, 1);
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ASSIGN_SPEC_VAR_TMP_RETVAL_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *value;
	zval *variable_ptr;

	SAVE_OPLINE();
	value = _get_zval_ptr_tmp(opline->op2.var EXECUTE_DATA_CC);
	variable_ptr = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);

	if (0 || UNEXPECTED(0)) {
		crex_refcounted *garbage = NULL;

		value = crex_assign_to_variable_ex(variable_ptr, value, IS_TMP_VAR, EX_USES_STRICT_TYPES(), &garbage);
		if (UNEXPECTED(0)) {
			ZVAL_COPY(EX_VAR(opline->result.var), value);
		}
		if (garbage) {
			GC_DTOR_NO_REF(garbage);
		}
	} else {
		value = crex_assign_to_variable(variable_ptr, value, IS_TMP_VAR, EX_USES_STRICT_TYPES());
	}
	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	/* crex_assign_to_variable() always takes care of op2, never free it! */

	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ASSIGN_SPEC_VAR_TMP_RETVAL_USED_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *value;
	zval *variable_ptr;

	SAVE_OPLINE();
	value = _get_zval_ptr_tmp(opline->op2.var EXECUTE_DATA_CC);
	variable_ptr = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);

	if (0 || UNEXPECTED(1)) {
		crex_refcounted *garbage = NULL;

		value = crex_assign_to_variable_ex(variable_ptr, value, IS_TMP_VAR, EX_USES_STRICT_TYPES(), &garbage);
		if (UNEXPECTED(1)) {
			ZVAL_COPY(EX_VAR(opline->result.var), value);
		}
		if (garbage) {
			GC_DTOR_NO_REF(garbage);
		}
	} else {
		value = crex_assign_to_variable(variable_ptr, value, IS_TMP_VAR, EX_USES_STRICT_TYPES());
	}
	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	/* crex_assign_to_variable() always takes care of op2, never free it! */

	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_IS_IDENTICAL_SPEC_VAR_VAR_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	bool result;

	SAVE_OPLINE();
	op1 = _get_zval_ptr_var_deref(opline->op1.var EXECUTE_DATA_CC);
	op2 = _get_zval_ptr_var_deref(opline->op2.var EXECUTE_DATA_CC);
	result = fast_is_identical_function(op1, op2);
	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
	CREX_VM_SMART_BRANCH(result, 1);
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_CASE_STRICT_SPEC_VAR_VAR_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	bool result;

	SAVE_OPLINE();
	op1 = _get_zval_ptr_var_deref(opline->op1.var EXECUTE_DATA_CC);
	op2 = _get_zval_ptr_var_deref(opline->op2.var EXECUTE_DATA_CC);
	result = fast_is_identical_function(op1, op2);
	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
	CREX_VM_SMART_BRANCH(result, 1);
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_IS_NOT_IDENTICAL_SPEC_VAR_VAR_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	bool result;

	SAVE_OPLINE();
	op1 = _get_zval_ptr_var_deref(opline->op1.var EXECUTE_DATA_CC);
	op2 = _get_zval_ptr_var_deref(opline->op2.var EXECUTE_DATA_CC);
	result = fast_is_not_identical_function(op1, op2);
	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
	CREX_VM_SMART_BRANCH(result, 1);
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ASSIGN_SPEC_VAR_VAR_RETVAL_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *value;
	zval *variable_ptr;

	SAVE_OPLINE();
	value = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
	variable_ptr = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);

	if (0 || UNEXPECTED(0)) {
		crex_refcounted *garbage = NULL;

		value = crex_assign_to_variable_ex(variable_ptr, value, IS_VAR, EX_USES_STRICT_TYPES(), &garbage);
		if (UNEXPECTED(0)) {
			ZVAL_COPY(EX_VAR(opline->result.var), value);
		}
		if (garbage) {
			GC_DTOR_NO_REF(garbage);
		}
	} else {
		value = crex_assign_to_variable(variable_ptr, value, IS_VAR, EX_USES_STRICT_TYPES());
	}
	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	/* crex_assign_to_variable() always takes care of op2, never free it! */

	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ASSIGN_SPEC_VAR_VAR_RETVAL_USED_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *value;
	zval *variable_ptr;

	SAVE_OPLINE();
	value = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
	variable_ptr = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);

	if (0 || UNEXPECTED(1)) {
		crex_refcounted *garbage = NULL;

		value = crex_assign_to_variable_ex(variable_ptr, value, IS_VAR, EX_USES_STRICT_TYPES(), &garbage);
		if (UNEXPECTED(1)) {
			ZVAL_COPY(EX_VAR(opline->result.var), value);
		}
		if (garbage) {
			GC_DTOR_NO_REF(garbage);
		}
	} else {
		value = crex_assign_to_variable(variable_ptr, value, IS_VAR, EX_USES_STRICT_TYPES());
	}
	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	/* crex_assign_to_variable() always takes care of op2, never free it! */

	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ASSIGN_REF_SPEC_VAR_VAR_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *variable_ptr;
	zval *value_ptr;
	crex_refcounted *garbage = NULL;

	SAVE_OPLINE();
	value_ptr = _get_zval_ptr_ptr_var(opline->op2.var EXECUTE_DATA_CC);
	variable_ptr = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);

	if (IS_VAR == IS_VAR &&
	           UNEXPECTED(C_TYPE_P(EX_VAR(opline->op1.var)) != IS_INDIRECT)) {

		crex_throw_error(NULL, "Cannot assign by reference to an array dimension of an object");
		variable_ptr = &EG(uninitialized_zval);
	} else if (IS_VAR == IS_VAR &&
	           opline->extended_value == CREX_RETURNS_FUNCTION &&
			   UNEXPECTED(!C_ISREF_P(value_ptr))) {

		variable_ptr = crex_wrong_assign_to_variable_reference(
			variable_ptr, value_ptr, &garbage OPLINE_CC EXECUTE_DATA_CC);
	} else {
		crex_assign_to_variable_reference(variable_ptr, value_ptr, &garbage);
	}

	if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
		ZVAL_COPY(EX_VAR(opline->result.var), variable_ptr);
	}

	if (garbage) {
		GC_DTOR(garbage);
	}

	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ASSIGN_DIM_OP_SPEC_VAR_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *var_ptr;
	zval *value, *container, *dim;
	HashTable *ht;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);

	if (EXPECTED(C_TYPE_P(container) == IS_ARRAY)) {
assign_dim_op_array:
		SEPARATE_ARRAY(container);
		ht = C_ARRVAL_P(container);
assign_dim_op_new_array:
		dim = NULL;
		if (IS_UNUSED == IS_UNUSED) {
			var_ptr = crex_hash_next_index_insert(ht, &EG(uninitialized_zval));
			if (UNEXPECTED(!var_ptr)) {
				crex_cannot_add_element();
				goto assign_dim_op_ret_null;
			}
		} else {
			if (IS_UNUSED == IS_CONST) {
				var_ptr = crex_fetch_dimension_address_inner_RW_CONST(ht, dim EXECUTE_DATA_CC);
			} else {
				var_ptr = crex_fetch_dimension_address_inner_RW(ht, dim EXECUTE_DATA_CC);
			}
			if (UNEXPECTED(!var_ptr)) {
				goto assign_dim_op_ret_null;
			}
		}

		value = get_op_data_zval_ptr_r((opline+1)->op1_type, (opline+1)->op1);

		do {
			if (IS_UNUSED != IS_UNUSED && UNEXPECTED(C_ISREF_P(var_ptr))) {
				crex_reference *ref = C_REF_P(var_ptr);
				var_ptr = C_REFVAL_P(var_ptr);
				if (UNEXPECTED(CREX_REF_HAS_TYPE_SOURCES(ref))) {
					crex_binary_assign_op_typed_ref(ref, value OPLINE_CC EXECUTE_DATA_CC);
					break;
				}
			}
			crex_binary_op(var_ptr, var_ptr, value OPLINE_CC);
		} while (0);

		if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
			ZVAL_COPY(EX_VAR(opline->result.var), var_ptr);
		}
		FREE_OP((opline+1)->op1_type, (opline+1)->op1.var);
	} else {
		if (EXPECTED(C_ISREF_P(container))) {
			container = C_REFVAL_P(container);
			if (EXPECTED(C_TYPE_P(container) == IS_ARRAY)) {
				goto assign_dim_op_array;
			}
		}

		if (EXPECTED(C_TYPE_P(container) == IS_OBJECT)) {
			crex_object *obj = C_OBJ_P(container);

			dim = NULL;
			if (IS_UNUSED == IS_CONST && C_EXTRA_P(dim) == CREX_EXTRA_VALUE) {
				dim++;
			}
			crex_binary_assign_op_obj_dim(obj, dim OPLINE_CC EXECUTE_DATA_CC);
		} else if (EXPECTED(C_TYPE_P(container) <= IS_FALSE)) {
			uint8_t old_type;

			if (IS_VAR == IS_CV && UNEXPECTED(C_TYPE_INFO_P(container) == IS_UNDEF)) {
				ZVAL_UNDEFINED_OP1();
			}
			ht = crex_new_array(8);
			old_type = C_TYPE_P(container);
			ZVAL_ARR(container, ht);
			if (UNEXPECTED(old_type == IS_FALSE)) {
				GC_ADDREF(ht);
				crex_false_to_array_deprecated();
				if (UNEXPECTED(GC_DELREF(ht) == 0)) {
					crex_array_destroy(ht);
					goto assign_dim_op_ret_null;
				}
			}
			goto assign_dim_op_new_array;
		} else {
			dim = NULL;
			crex_binary_assign_op_dim_slow(container, dim OPLINE_CC EXECUTE_DATA_CC);
assign_dim_op_ret_null:
			FREE_OP((opline+1)->op1_type, (opline+1)->op1.var);
			if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
				ZVAL_NULL(EX_VAR(opline->result.var));
			}
		}
	}

	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	CREX_VM_NEXT_OPCODE_EX(1, 2);
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FETCH_DIM_W_SPEC_VAR_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	crex_fetch_dimension_address_W(container, NULL, IS_UNUSED OPLINE_CC EXECUTE_DATA_CC);

	if (IS_VAR == IS_VAR) {
		FREE_VAR_PTR_AND_EXTRACT_RESULT_IF_NECESSARY(opline->op1.var);
	}
	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FETCH_DIM_RW_SPEC_VAR_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	crex_fetch_dimension_address_RW(container, NULL, IS_UNUSED OPLINE_CC EXECUTE_DATA_CC);

	if (IS_VAR == IS_VAR) {
		FREE_VAR_PTR_AND_EXTRACT_RESULT_IF_NECESSARY(opline->op1.var);
	}
	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FETCH_DIM_FUNC_ARG_SPEC_VAR_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
#if 0
	USE_OPLINE
#endif

	if (UNEXPECTED(CREX_CALL_INFO(EX(call)) & CREX_CALL_SEND_ARG_BY_REF)) {
		if ((IS_VAR & (IS_CONST|IS_TMP_VAR))) {
			CREX_VM_TAIL_CALL(crex_use_tmp_in_write_context_helper_SPEC(CREX_OPCODE_HANDLER_ARGS_PASSTHRU));
		}
		CREX_VM_TAIL_CALL(CREX_FETCH_DIM_W_SPEC_VAR_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU));
	} else {
		if (IS_UNUSED == IS_UNUSED) {
			CREX_VM_TAIL_CALL(crex_use_undef_in_read_context_helper_SPEC(CREX_OPCODE_HANDLER_ARGS_PASSTHRU));
		}
		CREX_VM_TAIL_CALL(CREX_NULL_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU));
	}
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ASSIGN_DIM_SPEC_VAR_UNUSED_OP_DATA_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *object_ptr, *orig_object_ptr;
	zval *value;
	zval *variable_ptr;
	zval *dim;
	crex_refcounted *garbage = NULL;

	SAVE_OPLINE();
	orig_object_ptr = object_ptr = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);

	if (EXPECTED(C_TYPE_P(object_ptr) == IS_ARRAY)) {
try_assign_dim_array:
		SEPARATE_ARRAY(object_ptr);
		if (IS_UNUSED == IS_UNUSED) {
			value = RT_CONSTANT((opline+1), (opline+1)->op1);
			if (IS_CONST == IS_CV && UNEXPECTED(C_TYPE_P(value) == IS_UNDEF)) {
				HashTable *ht = C_ARRVAL_P(object_ptr);
				if (!(GC_FLAGS(ht) & IS_ARRAY_IMMUTABLE)) {
					GC_ADDREF(ht);
				}
				value = zval_undefined_cv((opline+1)->op1.var EXECUTE_DATA_CC);
				if (!(GC_FLAGS(ht) & IS_ARRAY_IMMUTABLE) && !GC_DELREF(ht)) {
					crex_array_destroy(ht);
					goto assign_dim_error;
				}
			}
			if (IS_CONST == IS_CV || IS_CONST == IS_VAR) {
				ZVAL_DEREF(value);
			}
			value = crex_hash_next_index_insert(C_ARRVAL_P(object_ptr), value);
			if (UNEXPECTED(value == NULL)) {
				crex_cannot_add_element();
				goto assign_dim_error;
			} else if (IS_CONST == IS_CV) {
				if (C_REFCOUNTED_P(value)) {
					C_ADDREF_P(value);
				}
			} else if (IS_CONST == IS_VAR) {
				zval *free_op_data = EX_VAR((opline+1)->op1.var);
				if (C_ISREF_P(free_op_data)) {
					if (C_REFCOUNTED_P(value)) {
						C_ADDREF_P(value);
					}
					zval_ptr_dtor_nogc(free_op_data);
				}
			} else if (IS_CONST == IS_CONST) {
				if (UNEXPECTED(C_REFCOUNTED_P(value))) {
					C_ADDREF_P(value);
				}
			}
		} else {
			dim = NULL;
			if (IS_UNUSED == IS_CONST) {
				variable_ptr = crex_fetch_dimension_address_inner_W_CONST(C_ARRVAL_P(object_ptr), dim EXECUTE_DATA_CC);
			} else {
				variable_ptr = crex_fetch_dimension_address_inner_W(C_ARRVAL_P(object_ptr), dim EXECUTE_DATA_CC);
			}
			if (UNEXPECTED(variable_ptr == NULL)) {
				goto assign_dim_error;
			}
			value = RT_CONSTANT((opline+1), (opline+1)->op1);
			value = crex_assign_to_variable_ex(variable_ptr, value, IS_CONST, EX_USES_STRICT_TYPES(), &garbage);
		}
		if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
			ZVAL_COPY(EX_VAR(opline->result.var), value);
		}
		if (garbage) {
			GC_DTOR_NO_REF(garbage);
		}
	} else {
		if (EXPECTED(C_ISREF_P(object_ptr))) {
			object_ptr = C_REFVAL_P(object_ptr);
			if (EXPECTED(C_TYPE_P(object_ptr) == IS_ARRAY)) {
				goto try_assign_dim_array;
			}
		}
		if (EXPECTED(C_TYPE_P(object_ptr) == IS_OBJECT)) {
			crex_object *obj = C_OBJ_P(object_ptr);

			GC_ADDREF(obj);
			dim = NULL;
			if (IS_UNUSED == IS_CV && UNEXPECTED(C_ISUNDEF_P(dim))) {
				dim = ZVAL_UNDEFINED_OP2();
			} else if (IS_UNUSED == IS_CONST && C_EXTRA_P(dim) == CREX_EXTRA_VALUE) {
				dim++;
			}

			value = RT_CONSTANT((opline+1), (opline+1)->op1);
			if (IS_CONST == IS_CV && UNEXPECTED(C_ISUNDEF_P(value))) {
				value = zval_undefined_cv((opline+1)->op1.var EXECUTE_DATA_CC);
			} else if (IS_CONST & (IS_CV|IS_VAR)) {
				ZVAL_DEREF(value);
			}

			crex_assign_to_object_dim(obj, dim, value OPLINE_CC EXECUTE_DATA_CC);

			if (UNEXPECTED(GC_DELREF(obj) == 0)) {
				crex_objects_store_del(obj);
			}
		} else if (EXPECTED(C_TYPE_P(object_ptr) == IS_STRING)) {
			if (IS_UNUSED == IS_UNUSED) {
				crex_use_new_element_for_string();

				UNDEF_RESULT();
			} else {
				dim = NULL;
				value = RT_CONSTANT((opline+1), (opline+1)->op1);
				crex_assign_to_string_offset(object_ptr, dim, value OPLINE_CC EXECUTE_DATA_CC);

			}
		} else if (EXPECTED(C_TYPE_P(object_ptr) <= IS_FALSE)) {
			if (C_ISREF_P(orig_object_ptr)
			 && CREX_REF_HAS_TYPE_SOURCES(C_REF_P(orig_object_ptr))
			 && !crex_verify_ref_array_assignable(C_REF_P(orig_object_ptr))) {
				dim = NULL;

				UNDEF_RESULT();
			} else {
				HashTable *ht = crex_new_array(8);
				uint8_t old_type = C_TYPE_P(object_ptr);

				ZVAL_ARR(object_ptr, ht);
				if (UNEXPECTED(old_type == IS_FALSE)) {
					GC_ADDREF(ht);
					crex_false_to_array_deprecated();
					if (UNEXPECTED(GC_DELREF(ht) == 0)) {
						crex_array_destroy(ht);
						goto assign_dim_error;
					}
				}
				goto try_assign_dim_array;
			}
		} else {
			crex_use_scalar_as_array();
			dim = NULL;
assign_dim_error:

			if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
				ZVAL_NULL(EX_VAR(opline->result.var));
			}
		}
	}
	if (IS_UNUSED != IS_UNUSED) {

	}
	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	/* assign_dim has two opcodes! */
	CREX_VM_NEXT_OPCODE_EX(1, 2);
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ASSIGN_DIM_SPEC_VAR_UNUSED_OP_DATA_TMP_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *object_ptr, *orig_object_ptr;
	zval *value;
	zval *variable_ptr;
	zval *dim;
	crex_refcounted *garbage = NULL;

	SAVE_OPLINE();
	orig_object_ptr = object_ptr = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);

	if (EXPECTED(C_TYPE_P(object_ptr) == IS_ARRAY)) {
try_assign_dim_array:
		SEPARATE_ARRAY(object_ptr);
		if (IS_UNUSED == IS_UNUSED) {
			value = _get_zval_ptr_tmp((opline+1)->op1.var EXECUTE_DATA_CC);
			if (IS_TMP_VAR == IS_CV && UNEXPECTED(C_TYPE_P(value) == IS_UNDEF)) {
				HashTable *ht = C_ARRVAL_P(object_ptr);
				if (!(GC_FLAGS(ht) & IS_ARRAY_IMMUTABLE)) {
					GC_ADDREF(ht);
				}
				value = zval_undefined_cv((opline+1)->op1.var EXECUTE_DATA_CC);
				if (!(GC_FLAGS(ht) & IS_ARRAY_IMMUTABLE) && !GC_DELREF(ht)) {
					crex_array_destroy(ht);
					goto assign_dim_error;
				}
			}
			if (IS_TMP_VAR == IS_CV || IS_TMP_VAR == IS_VAR) {
				ZVAL_DEREF(value);
			}
			value = crex_hash_next_index_insert(C_ARRVAL_P(object_ptr), value);
			if (UNEXPECTED(value == NULL)) {
				crex_cannot_add_element();
				goto assign_dim_error;
			} else if (IS_TMP_VAR == IS_CV) {
				if (C_REFCOUNTED_P(value)) {
					C_ADDREF_P(value);
				}
			} else if (IS_TMP_VAR == IS_VAR) {
				zval *free_op_data = EX_VAR((opline+1)->op1.var);
				if (C_ISREF_P(free_op_data)) {
					if (C_REFCOUNTED_P(value)) {
						C_ADDREF_P(value);
					}
					zval_ptr_dtor_nogc(free_op_data);
				}
			} else if (IS_TMP_VAR == IS_CONST) {
				if (UNEXPECTED(C_REFCOUNTED_P(value))) {
					C_ADDREF_P(value);
				}
			}
		} else {
			dim = NULL;
			if (IS_UNUSED == IS_CONST) {
				variable_ptr = crex_fetch_dimension_address_inner_W_CONST(C_ARRVAL_P(object_ptr), dim EXECUTE_DATA_CC);
			} else {
				variable_ptr = crex_fetch_dimension_address_inner_W(C_ARRVAL_P(object_ptr), dim EXECUTE_DATA_CC);
			}
			if (UNEXPECTED(variable_ptr == NULL)) {
				goto assign_dim_error;
			}
			value = _get_zval_ptr_tmp((opline+1)->op1.var EXECUTE_DATA_CC);
			value = crex_assign_to_variable_ex(variable_ptr, value, IS_TMP_VAR, EX_USES_STRICT_TYPES(), &garbage);
		}
		if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
			ZVAL_COPY(EX_VAR(opline->result.var), value);
		}
		if (garbage) {
			GC_DTOR_NO_REF(garbage);
		}
	} else {
		if (EXPECTED(C_ISREF_P(object_ptr))) {
			object_ptr = C_REFVAL_P(object_ptr);
			if (EXPECTED(C_TYPE_P(object_ptr) == IS_ARRAY)) {
				goto try_assign_dim_array;
			}
		}
		if (EXPECTED(C_TYPE_P(object_ptr) == IS_OBJECT)) {
			crex_object *obj = C_OBJ_P(object_ptr);

			GC_ADDREF(obj);
			dim = NULL;
			if (IS_UNUSED == IS_CV && UNEXPECTED(C_ISUNDEF_P(dim))) {
				dim = ZVAL_UNDEFINED_OP2();
			} else if (IS_UNUSED == IS_CONST && C_EXTRA_P(dim) == CREX_EXTRA_VALUE) {
				dim++;
			}

			value = _get_zval_ptr_tmp((opline+1)->op1.var EXECUTE_DATA_CC);
			if (IS_TMP_VAR == IS_CV && UNEXPECTED(C_ISUNDEF_P(value))) {
				value = zval_undefined_cv((opline+1)->op1.var EXECUTE_DATA_CC);
			} else if (IS_TMP_VAR & (IS_CV|IS_VAR)) {
				ZVAL_DEREF(value);
			}

			crex_assign_to_object_dim(obj, dim, value OPLINE_CC EXECUTE_DATA_CC);

			zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
			if (UNEXPECTED(GC_DELREF(obj) == 0)) {
				crex_objects_store_del(obj);
			}
		} else if (EXPECTED(C_TYPE_P(object_ptr) == IS_STRING)) {
			if (IS_UNUSED == IS_UNUSED) {
				crex_use_new_element_for_string();
				zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
				UNDEF_RESULT();
			} else {
				dim = NULL;
				value = _get_zval_ptr_tmp((opline+1)->op1.var EXECUTE_DATA_CC);
				crex_assign_to_string_offset(object_ptr, dim, value OPLINE_CC EXECUTE_DATA_CC);
				zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
			}
		} else if (EXPECTED(C_TYPE_P(object_ptr) <= IS_FALSE)) {
			if (C_ISREF_P(orig_object_ptr)
			 && CREX_REF_HAS_TYPE_SOURCES(C_REF_P(orig_object_ptr))
			 && !crex_verify_ref_array_assignable(C_REF_P(orig_object_ptr))) {
				dim = NULL;
				zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
				UNDEF_RESULT();
			} else {
				HashTable *ht = crex_new_array(8);
				uint8_t old_type = C_TYPE_P(object_ptr);

				ZVAL_ARR(object_ptr, ht);
				if (UNEXPECTED(old_type == IS_FALSE)) {
					GC_ADDREF(ht);
					crex_false_to_array_deprecated();
					if (UNEXPECTED(GC_DELREF(ht) == 0)) {
						crex_array_destroy(ht);
						goto assign_dim_error;
					}
				}
				goto try_assign_dim_array;
			}
		} else {
			crex_use_scalar_as_array();
			dim = NULL;
assign_dim_error:
			zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
			if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
				ZVAL_NULL(EX_VAR(opline->result.var));
			}
		}
	}
	if (IS_UNUSED != IS_UNUSED) {

	}
	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	/* assign_dim has two opcodes! */
	CREX_VM_NEXT_OPCODE_EX(1, 2);
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ASSIGN_DIM_SPEC_VAR_UNUSED_OP_DATA_VAR_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *object_ptr, *orig_object_ptr;
	zval *value;
	zval *variable_ptr;
	zval *dim;
	crex_refcounted *garbage = NULL;

	SAVE_OPLINE();
	orig_object_ptr = object_ptr = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);

	if (EXPECTED(C_TYPE_P(object_ptr) == IS_ARRAY)) {
try_assign_dim_array:
		SEPARATE_ARRAY(object_ptr);
		if (IS_UNUSED == IS_UNUSED) {
			value = _get_zval_ptr_var((opline+1)->op1.var EXECUTE_DATA_CC);
			if (IS_VAR == IS_CV && UNEXPECTED(C_TYPE_P(value) == IS_UNDEF)) {
				HashTable *ht = C_ARRVAL_P(object_ptr);
				if (!(GC_FLAGS(ht) & IS_ARRAY_IMMUTABLE)) {
					GC_ADDREF(ht);
				}
				value = zval_undefined_cv((opline+1)->op1.var EXECUTE_DATA_CC);
				if (!(GC_FLAGS(ht) & IS_ARRAY_IMMUTABLE) && !GC_DELREF(ht)) {
					crex_array_destroy(ht);
					goto assign_dim_error;
				}
			}
			if (IS_VAR == IS_CV || IS_VAR == IS_VAR) {
				ZVAL_DEREF(value);
			}
			value = crex_hash_next_index_insert(C_ARRVAL_P(object_ptr), value);
			if (UNEXPECTED(value == NULL)) {
				crex_cannot_add_element();
				goto assign_dim_error;
			} else if (IS_VAR == IS_CV) {
				if (C_REFCOUNTED_P(value)) {
					C_ADDREF_P(value);
				}
			} else if (IS_VAR == IS_VAR) {
				zval *free_op_data = EX_VAR((opline+1)->op1.var);
				if (C_ISREF_P(free_op_data)) {
					if (C_REFCOUNTED_P(value)) {
						C_ADDREF_P(value);
					}
					zval_ptr_dtor_nogc(free_op_data);
				}
			} else if (IS_VAR == IS_CONST) {
				if (UNEXPECTED(C_REFCOUNTED_P(value))) {
					C_ADDREF_P(value);
				}
			}
		} else {
			dim = NULL;
			if (IS_UNUSED == IS_CONST) {
				variable_ptr = crex_fetch_dimension_address_inner_W_CONST(C_ARRVAL_P(object_ptr), dim EXECUTE_DATA_CC);
			} else {
				variable_ptr = crex_fetch_dimension_address_inner_W(C_ARRVAL_P(object_ptr), dim EXECUTE_DATA_CC);
			}
			if (UNEXPECTED(variable_ptr == NULL)) {
				goto assign_dim_error;
			}
			value = _get_zval_ptr_var((opline+1)->op1.var EXECUTE_DATA_CC);
			value = crex_assign_to_variable_ex(variable_ptr, value, IS_VAR, EX_USES_STRICT_TYPES(), &garbage);
		}
		if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
			ZVAL_COPY(EX_VAR(opline->result.var), value);
		}
		if (garbage) {
			GC_DTOR_NO_REF(garbage);
		}
	} else {
		if (EXPECTED(C_ISREF_P(object_ptr))) {
			object_ptr = C_REFVAL_P(object_ptr);
			if (EXPECTED(C_TYPE_P(object_ptr) == IS_ARRAY)) {
				goto try_assign_dim_array;
			}
		}
		if (EXPECTED(C_TYPE_P(object_ptr) == IS_OBJECT)) {
			crex_object *obj = C_OBJ_P(object_ptr);

			GC_ADDREF(obj);
			dim = NULL;
			if (IS_UNUSED == IS_CV && UNEXPECTED(C_ISUNDEF_P(dim))) {
				dim = ZVAL_UNDEFINED_OP2();
			} else if (IS_UNUSED == IS_CONST && C_EXTRA_P(dim) == CREX_EXTRA_VALUE) {
				dim++;
			}

			value = _get_zval_ptr_var((opline+1)->op1.var EXECUTE_DATA_CC);
			if (IS_VAR == IS_CV && UNEXPECTED(C_ISUNDEF_P(value))) {
				value = zval_undefined_cv((opline+1)->op1.var EXECUTE_DATA_CC);
			} else if (IS_VAR & (IS_CV|IS_VAR)) {
				ZVAL_DEREF(value);
			}

			crex_assign_to_object_dim(obj, dim, value OPLINE_CC EXECUTE_DATA_CC);

			zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
			if (UNEXPECTED(GC_DELREF(obj) == 0)) {
				crex_objects_store_del(obj);
			}
		} else if (EXPECTED(C_TYPE_P(object_ptr) == IS_STRING)) {
			if (IS_UNUSED == IS_UNUSED) {
				crex_use_new_element_for_string();
				zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
				UNDEF_RESULT();
			} else {
				dim = NULL;
				value = _get_zval_ptr_var((opline+1)->op1.var EXECUTE_DATA_CC);
				crex_assign_to_string_offset(object_ptr, dim, value OPLINE_CC EXECUTE_DATA_CC);
				zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
			}
		} else if (EXPECTED(C_TYPE_P(object_ptr) <= IS_FALSE)) {
			if (C_ISREF_P(orig_object_ptr)
			 && CREX_REF_HAS_TYPE_SOURCES(C_REF_P(orig_object_ptr))
			 && !crex_verify_ref_array_assignable(C_REF_P(orig_object_ptr))) {
				dim = NULL;
				zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
				UNDEF_RESULT();
			} else {
				HashTable *ht = crex_new_array(8);
				uint8_t old_type = C_TYPE_P(object_ptr);

				ZVAL_ARR(object_ptr, ht);
				if (UNEXPECTED(old_type == IS_FALSE)) {
					GC_ADDREF(ht);
					crex_false_to_array_deprecated();
					if (UNEXPECTED(GC_DELREF(ht) == 0)) {
						crex_array_destroy(ht);
						goto assign_dim_error;
					}
				}
				goto try_assign_dim_array;
			}
		} else {
			crex_use_scalar_as_array();
			dim = NULL;
assign_dim_error:
			zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
			if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
				ZVAL_NULL(EX_VAR(opline->result.var));
			}
		}
	}
	if (IS_UNUSED != IS_UNUSED) {

	}
	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	/* assign_dim has two opcodes! */
	CREX_VM_NEXT_OPCODE_EX(1, 2);
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ASSIGN_DIM_SPEC_VAR_UNUSED_OP_DATA_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *object_ptr, *orig_object_ptr;
	zval *value;
	zval *variable_ptr;
	zval *dim;
	crex_refcounted *garbage = NULL;

	SAVE_OPLINE();
	orig_object_ptr = object_ptr = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);

	if (EXPECTED(C_TYPE_P(object_ptr) == IS_ARRAY)) {
try_assign_dim_array:
		SEPARATE_ARRAY(object_ptr);
		if (IS_UNUSED == IS_UNUSED) {
			value = EX_VAR((opline+1)->op1.var);
			if (IS_CV == IS_CV && UNEXPECTED(C_TYPE_P(value) == IS_UNDEF)) {
				HashTable *ht = C_ARRVAL_P(object_ptr);
				if (!(GC_FLAGS(ht) & IS_ARRAY_IMMUTABLE)) {
					GC_ADDREF(ht);
				}
				value = zval_undefined_cv((opline+1)->op1.var EXECUTE_DATA_CC);
				if (!(GC_FLAGS(ht) & IS_ARRAY_IMMUTABLE) && !GC_DELREF(ht)) {
					crex_array_destroy(ht);
					goto assign_dim_error;
				}
			}
			if (IS_CV == IS_CV || IS_CV == IS_VAR) {
				ZVAL_DEREF(value);
			}
			value = crex_hash_next_index_insert(C_ARRVAL_P(object_ptr), value);
			if (UNEXPECTED(value == NULL)) {
				crex_cannot_add_element();
				goto assign_dim_error;
			} else if (IS_CV == IS_CV) {
				if (C_REFCOUNTED_P(value)) {
					C_ADDREF_P(value);
				}
			} else if (IS_CV == IS_VAR) {
				zval *free_op_data = EX_VAR((opline+1)->op1.var);
				if (C_ISREF_P(free_op_data)) {
					if (C_REFCOUNTED_P(value)) {
						C_ADDREF_P(value);
					}
					zval_ptr_dtor_nogc(free_op_data);
				}
			} else if (IS_CV == IS_CONST) {
				if (UNEXPECTED(C_REFCOUNTED_P(value))) {
					C_ADDREF_P(value);
				}
			}
		} else {
			dim = NULL;
			if (IS_UNUSED == IS_CONST) {
				variable_ptr = crex_fetch_dimension_address_inner_W_CONST(C_ARRVAL_P(object_ptr), dim EXECUTE_DATA_CC);
			} else {
				variable_ptr = crex_fetch_dimension_address_inner_W(C_ARRVAL_P(object_ptr), dim EXECUTE_DATA_CC);
			}
			if (UNEXPECTED(variable_ptr == NULL)) {
				goto assign_dim_error;
			}
			value = _get_zval_ptr_cv_BP_VAR_R((opline+1)->op1.var EXECUTE_DATA_CC);
			value = crex_assign_to_variable_ex(variable_ptr, value, IS_CV, EX_USES_STRICT_TYPES(), &garbage);
		}
		if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
			ZVAL_COPY(EX_VAR(opline->result.var), value);
		}
		if (garbage) {
			GC_DTOR_NO_REF(garbage);
		}
	} else {
		if (EXPECTED(C_ISREF_P(object_ptr))) {
			object_ptr = C_REFVAL_P(object_ptr);
			if (EXPECTED(C_TYPE_P(object_ptr) == IS_ARRAY)) {
				goto try_assign_dim_array;
			}
		}
		if (EXPECTED(C_TYPE_P(object_ptr) == IS_OBJECT)) {
			crex_object *obj = C_OBJ_P(object_ptr);

			GC_ADDREF(obj);
			dim = NULL;
			if (IS_UNUSED == IS_CV && UNEXPECTED(C_ISUNDEF_P(dim))) {
				dim = ZVAL_UNDEFINED_OP2();
			} else if (IS_UNUSED == IS_CONST && C_EXTRA_P(dim) == CREX_EXTRA_VALUE) {
				dim++;
			}

			value = EX_VAR((opline+1)->op1.var);
			if (IS_CV == IS_CV && UNEXPECTED(C_ISUNDEF_P(value))) {
				value = zval_undefined_cv((opline+1)->op1.var EXECUTE_DATA_CC);
			} else if (IS_CV & (IS_CV|IS_VAR)) {
				ZVAL_DEREF(value);
			}

			crex_assign_to_object_dim(obj, dim, value OPLINE_CC EXECUTE_DATA_CC);

			if (UNEXPECTED(GC_DELREF(obj) == 0)) {
				crex_objects_store_del(obj);
			}
		} else if (EXPECTED(C_TYPE_P(object_ptr) == IS_STRING)) {
			if (IS_UNUSED == IS_UNUSED) {
				crex_use_new_element_for_string();

				UNDEF_RESULT();
			} else {
				dim = NULL;
				value = EX_VAR((opline+1)->op1.var);
				crex_assign_to_string_offset(object_ptr, dim, value OPLINE_CC EXECUTE_DATA_CC);

			}
		} else if (EXPECTED(C_TYPE_P(object_ptr) <= IS_FALSE)) {
			if (C_ISREF_P(orig_object_ptr)
			 && CREX_REF_HAS_TYPE_SOURCES(C_REF_P(orig_object_ptr))
			 && !crex_verify_ref_array_assignable(C_REF_P(orig_object_ptr))) {
				dim = NULL;

				UNDEF_RESULT();
			} else {
				HashTable *ht = crex_new_array(8);
				uint8_t old_type = C_TYPE_P(object_ptr);

				ZVAL_ARR(object_ptr, ht);
				if (UNEXPECTED(old_type == IS_FALSE)) {
					GC_ADDREF(ht);
					crex_false_to_array_deprecated();
					if (UNEXPECTED(GC_DELREF(ht) == 0)) {
						crex_array_destroy(ht);
						goto assign_dim_error;
					}
				}
				goto try_assign_dim_array;
			}
		} else {
			crex_use_scalar_as_array();
			dim = NULL;
assign_dim_error:

			if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
				ZVAL_NULL(EX_VAR(opline->result.var));
			}
		}
	}
	if (IS_UNUSED != IS_UNUSED) {

	}
	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	/* assign_dim has two opcodes! */
	CREX_VM_NEXT_OPCODE_EX(1, 2);
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_INIT_STATIC_METHOD_CALL_SPEC_VAR_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *function_name;
	crex_class_entry *ce;
	uint32_t call_info;
	crex_function *fbc;
	crex_execute_data *call;

	SAVE_OPLINE();

	if (IS_VAR == IS_CONST) {
		/* no function found. try a static method in class */
		ce = CACHED_PTR(opline->result.num);
		if (UNEXPECTED(ce == NULL)) {
			ce = crex_fetch_class_by_name(C_STR_P(RT_CONSTANT(opline, opline->op1)), C_STR_P(RT_CONSTANT(opline, opline->op1) + 1), CREX_FETCH_CLASS_DEFAULT | CREX_FETCH_CLASS_EXCEPTION);
			if (UNEXPECTED(ce == NULL)) {

				HANDLE_EXCEPTION();
			}
			if (IS_UNUSED != IS_CONST) {
				CACHE_PTR(opline->result.num, ce);
			}
		}
	} else if (IS_VAR == IS_UNUSED) {
		ce = crex_fetch_class(NULL, opline->op1.num);
		if (UNEXPECTED(ce == NULL)) {

			HANDLE_EXCEPTION();
		}
	} else {
		ce = C_CE_P(EX_VAR(opline->op1.var));
	}

	if (IS_VAR == IS_CONST &&
	    IS_UNUSED == IS_CONST &&
	    EXPECTED((fbc = CACHED_PTR(opline->result.num + sizeof(void*))) != NULL)) {
		/* nothing to do */
	} else if (IS_VAR != IS_CONST &&
	           IS_UNUSED == IS_CONST &&
	           EXPECTED(CACHED_PTR(opline->result.num) == ce)) {
		fbc = CACHED_PTR(opline->result.num + sizeof(void*));
	} else if (IS_UNUSED != IS_UNUSED) {
		function_name = NULL;
		if (IS_UNUSED != IS_CONST) {
			if (UNEXPECTED(C_TYPE_P(function_name) != IS_STRING)) {
				do {
					if (IS_UNUSED & (IS_VAR|IS_CV) && C_ISREF_P(function_name)) {
						function_name = C_REFVAL_P(function_name);
						if (EXPECTED(C_TYPE_P(function_name) == IS_STRING)) {
							break;
						}
					} else if (IS_UNUSED == IS_CV && UNEXPECTED(C_TYPE_P(function_name) == IS_UNDEF)) {
						ZVAL_UNDEFINED_OP2();
						if (UNEXPECTED(EG(exception) != NULL)) {
							HANDLE_EXCEPTION();
						}
					}
					crex_throw_error(NULL, "Method name must be a string");

					HANDLE_EXCEPTION();
				} while (0);
			}
		}

		if (ce->get_static_method) {
			fbc = ce->get_static_method(ce, C_STR_P(function_name));
		} else {
			fbc = crex_std_get_static_method(ce, C_STR_P(function_name), ((IS_UNUSED == IS_CONST) ? (RT_CONSTANT(opline, opline->op2) + 1) : NULL));
		}
		if (UNEXPECTED(fbc == NULL)) {
			if (EXPECTED(!EG(exception))) {
				crex_undefined_method(ce, C_STR_P(function_name));
			}

			HANDLE_EXCEPTION();
		}
		if (IS_UNUSED == IS_CONST &&
		    EXPECTED(!(fbc->common.fn_flags & (CREX_ACC_CALL_VIA_TRAMPOLINE|CREX_ACC_NEVER_CACHE))) &&
			EXPECTED(!(fbc->common.scope->ce_flags & CREX_ACC_TRAIT))) {
			CACHE_POLYMORPHIC_PTR(opline->result.num, ce, fbc);
		}
		if (EXPECTED(fbc->type == CREX_USER_FUNCTION) && UNEXPECTED(!RUN_TIME_CACHE(&fbc->op_array))) {
			init_func_run_time_cache(&fbc->op_array);
		}
		if (IS_UNUSED != IS_CONST) {

		}
	} else {
		if (UNEXPECTED(ce->constructor == NULL)) {
			crex_throw_error(NULL, "Cannot call constructor");
			HANDLE_EXCEPTION();
		}
		if (C_TYPE(EX(This)) == IS_OBJECT && C_OBJ(EX(This))->ce != ce->constructor->common.scope && (ce->constructor->common.fn_flags & CREX_ACC_PRIVATE)) {
			crex_throw_error(NULL, "Cannot call private %s::__main()", ZSTR_VAL(ce->name));
			HANDLE_EXCEPTION();
		}
		fbc = ce->constructor;
		if (EXPECTED(fbc->type == CREX_USER_FUNCTION) && UNEXPECTED(!RUN_TIME_CACHE(&fbc->op_array))) {
			init_func_run_time_cache(&fbc->op_array);
		}
	}

	if (!(fbc->common.fn_flags & CREX_ACC_STATIC)) {
		if (C_TYPE(EX(This)) == IS_OBJECT && instanceof_function(C_OBJCE(EX(This)), ce)) {
			ce = (crex_class_entry*)C_OBJ(EX(This));
			call_info = CREX_CALL_NESTED_FUNCTION | CREX_CALL_HAS_THIS;
		} else {
			crex_non_static_method_call(fbc);
			HANDLE_EXCEPTION();
		}
	} else {
		/* previous opcode is CREX_FETCH_CLASS */
		if (IS_VAR == IS_UNUSED
		 && ((opline->op1.num & CREX_FETCH_CLASS_MASK) == CREX_FETCH_CLASS_PARENT ||
		     (opline->op1.num & CREX_FETCH_CLASS_MASK) == CREX_FETCH_CLASS_SELF)) {
			if (C_TYPE(EX(This)) == IS_OBJECT) {
				ce = C_OBJCE(EX(This));
			} else {
				ce = C_CE(EX(This));
			}
		}
		call_info = CREX_CALL_NESTED_FUNCTION;
	}

	call = crex_vm_stack_push_call_frame(call_info,
		fbc, opline->extended_value, ce);
	call->prev_execute_data = EX(call);
	EX(call) = call;

	CREX_VM_NEXT_OPCODE();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_VERIFY_RETURN_TYPE_SPEC_VAR_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	if (IS_VAR == IS_UNUSED) {
		SAVE_OPLINE();
		crex_verify_missing_return_type(EX(func));
		HANDLE_EXCEPTION();
	} else {
/* prevents "undefined variable opline" errors */
#if 0 || (IS_VAR != IS_UNUSED)
		USE_OPLINE
		zval *retval_ref, *retval_ptr;
		crex_arg_info *ret_info = EX(func)->common.arg_info - 1;
		retval_ref = retval_ptr = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);

		if (IS_VAR == IS_CONST) {
			ZVAL_COPY(EX_VAR(opline->result.var), retval_ptr);
			retval_ref = retval_ptr = EX_VAR(opline->result.var);
		} else if (IS_VAR == IS_VAR) {
			if (UNEXPECTED(C_TYPE_P(retval_ptr) == IS_INDIRECT)) {
				retval_ref = retval_ptr = C_INDIRECT_P(retval_ptr);
			}
			ZVAL_DEREF(retval_ptr);
		} else if (IS_VAR == IS_CV) {
			ZVAL_DEREF(retval_ptr);
		}

		if (EXPECTED(CREX_TYPE_CONTAINS_CODE(ret_info->type, C_TYPE_P(retval_ptr)))) {
			CREX_VM_NEXT_OPCODE();
		}

		if (IS_VAR == IS_CV && UNEXPECTED(C_ISUNDEF_P(retval_ptr))) {
			SAVE_OPLINE();
			retval_ref = retval_ptr = ZVAL_UNDEFINED_OP1();
			if (UNEXPECTED(EG(exception))) {
				HANDLE_EXCEPTION();
			}
			if (CREX_TYPE_FULL_MASK(ret_info->type) & MAY_BE_NULL) {
				CREX_VM_NEXT_OPCODE();
			}
		}

		crex_reference *ref = NULL;
		void *cache_slot = CACHE_ADDR(opline->op2.num);
		if (UNEXPECTED(retval_ref != retval_ptr)) {
			if (UNEXPECTED(EX(func)->op_array.fn_flags & CREX_ACC_RETURN_REFERENCE)) {
				ref = C_REF_P(retval_ref);
			} else {
				/* A cast might happen - unwrap the reference if this is a by-value return */
				if (C_REFCOUNT_P(retval_ref) == 1) {
					ZVAL_UNREF(retval_ref);
				} else {
					C_DELREF_P(retval_ref);
					ZVAL_COPY(retval_ref, retval_ptr);
				}
				retval_ptr = retval_ref;
			}
		}

		SAVE_OPLINE();
		if (UNEXPECTED(!crex_check_type_slow(&ret_info->type, retval_ptr, ref, cache_slot, 1, 0))) {
			crex_verify_return_error(EX(func), retval_ptr);
			HANDLE_EXCEPTION();
		}
		CREX_VM_NEXT_OPCODE();
#endif
	}
}

static CREX_VM_HOT CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_SEND_VAR_SPEC_VAR_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *varptr, *arg;

	if (IS_UNUSED == IS_CONST) {
		SAVE_OPLINE();
		crex_string *arg_name = C_STR_P(RT_CONSTANT(opline, opline->op2));
		uint32_t arg_num;
		arg = crex_handle_named_arg(&EX(call), arg_name, &arg_num, CACHE_ADDR(opline->result.num));
		if (UNEXPECTED(!arg)) {
			zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
			HANDLE_EXCEPTION();
		}
	} else {
		arg = CREX_CALL_VAR(EX(call), opline->result.var);
	}

	varptr = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	if (IS_VAR == IS_CV && UNEXPECTED(C_TYPE_INFO_P(varptr) == IS_UNDEF)) {
		SAVE_OPLINE();
		ZVAL_UNDEFINED_OP1();
		ZVAL_NULL(arg);
		CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
	}

	if (IS_VAR == IS_CV) {
		ZVAL_COPY_DEREF(arg, varptr);
	} else /* if (IS_VAR == IS_VAR) */ {
		if (UNEXPECTED(C_ISREF_P(varptr))) {
			crex_refcounted *ref = C_COUNTED_P(varptr);

			varptr = C_REFVAL_P(varptr);
			ZVAL_COPY_VALUE(arg, varptr);
			if (UNEXPECTED(GC_DELREF(ref) == 0)) {
				efree_size(ref, sizeof(crex_reference));
			} else if (C_OPT_REFCOUNTED_P(arg)) {
				C_ADDREF_P(arg);
			}
		} else {
			ZVAL_COPY_VALUE(arg, varptr);
		}
	}

	CREX_VM_NEXT_OPCODE();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_SEND_VAR_NO_REF_SPEC_VAR_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *varptr, *arg;

	if (IS_UNUSED == IS_CONST) {
		SAVE_OPLINE();
		crex_string *arg_name = C_STR_P(RT_CONSTANT(opline, opline->op2));
		uint32_t arg_num;
		arg = crex_handle_named_arg(&EX(call), arg_name, &arg_num, CACHE_ADDR(opline->result.num));
		if (UNEXPECTED(!arg)) {
			zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
			HANDLE_EXCEPTION();
		}
	} else {
		arg = CREX_CALL_VAR(EX(call), opline->result.var);
	}

	varptr = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	ZVAL_COPY_VALUE(arg, varptr);

	if (EXPECTED(C_ISREF_P(varptr))) {
		CREX_VM_NEXT_OPCODE();
	}

	SAVE_OPLINE();
	ZVAL_NEW_REF(arg, arg);
	crex_error(E_NOTICE, "Only variables should be passed by reference");
	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_SEND_VAR_NO_REF_EX_SPEC_VAR_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *varptr, *arg;
	uint32_t arg_num;

	if (IS_UNUSED == IS_CONST) {
		SAVE_OPLINE();
		crex_string *arg_name = C_STR_P(RT_CONSTANT(opline, opline->op2));
		arg = crex_handle_named_arg(&EX(call), arg_name, &arg_num, CACHE_ADDR(opline->result.num));
		if (UNEXPECTED(!arg)) {
			zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
			HANDLE_EXCEPTION();
		}
	} else {
		arg = CREX_CALL_VAR(EX(call), opline->result.var);
		arg_num = opline->op2.num;
	}

	if (EXPECTED(0)) {
		if (!QUICK_ARG_SHOULD_BE_SENT_BY_REF(EX(call)->func, arg_num)) {
			goto send_var;
		}

		varptr = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);
		ZVAL_COPY_VALUE(arg, varptr);

		if (EXPECTED(C_ISREF_P(varptr) ||
		    QUICK_ARG_MAY_BE_SENT_BY_REF(EX(call)->func, arg_num))) {
			CREX_VM_NEXT_OPCODE();
		}
	} else {
		if (!ARG_SHOULD_BE_SENT_BY_REF(EX(call)->func, arg_num)) {
			goto send_var;
		}

		varptr = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);
		ZVAL_COPY_VALUE(arg, varptr);

		if (EXPECTED(C_ISREF_P(varptr) ||
		    ARG_MAY_BE_SENT_BY_REF(EX(call)->func, arg_num))) {
			CREX_VM_NEXT_OPCODE();
		}
	}

	SAVE_OPLINE();
	ZVAL_NEW_REF(arg, arg);
	crex_error(E_NOTICE, "Only variables should be passed by reference");
	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();

send_var:
	varptr = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	if (UNEXPECTED(C_ISREF_P(varptr))) {
		crex_refcounted *ref = C_COUNTED_P(varptr);

		varptr = C_REFVAL_P(varptr);
		ZVAL_COPY_VALUE(arg, varptr);
		if (UNEXPECTED(GC_DELREF(ref) == 0)) {
			efree_size(ref, sizeof(crex_reference));
		} else if (C_OPT_REFCOUNTED_P(arg)) {
			C_ADDREF_P(arg);
		}
	} else {
		ZVAL_COPY_VALUE(arg, varptr);
	}
	CREX_VM_NEXT_OPCODE();
}

static CREX_VM_HOT CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_SEND_VAR_NO_REF_EX_SPEC_VAR_UNUSED_QUICK_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *varptr, *arg;
	uint32_t arg_num;

	if (IS_UNUSED == IS_CONST) {
		SAVE_OPLINE();
		crex_string *arg_name = C_STR_P(RT_CONSTANT(opline, opline->op2));
		arg = crex_handle_named_arg(&EX(call), arg_name, &arg_num, CACHE_ADDR(opline->result.num));
		if (UNEXPECTED(!arg)) {
			zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
			HANDLE_EXCEPTION();
		}
	} else {
		arg = CREX_CALL_VAR(EX(call), opline->result.var);
		arg_num = opline->op2.num;
	}

	if (EXPECTED(1)) {
		if (!QUICK_ARG_SHOULD_BE_SENT_BY_REF(EX(call)->func, arg_num)) {
			goto send_var;
		}

		varptr = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);
		ZVAL_COPY_VALUE(arg, varptr);

		if (EXPECTED(C_ISREF_P(varptr) ||
		    QUICK_ARG_MAY_BE_SENT_BY_REF(EX(call)->func, arg_num))) {
			CREX_VM_NEXT_OPCODE();
		}
	} else {
		if (!ARG_SHOULD_BE_SENT_BY_REF(EX(call)->func, arg_num)) {
			goto send_var;
		}

		varptr = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);
		ZVAL_COPY_VALUE(arg, varptr);

		if (EXPECTED(C_ISREF_P(varptr) ||
		    ARG_MAY_BE_SENT_BY_REF(EX(call)->func, arg_num))) {
			CREX_VM_NEXT_OPCODE();
		}
	}

	SAVE_OPLINE();
	ZVAL_NEW_REF(arg, arg);
	crex_error(E_NOTICE, "Only variables should be passed by reference");
	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();

send_var:
	varptr = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	if (UNEXPECTED(C_ISREF_P(varptr))) {
		crex_refcounted *ref = C_COUNTED_P(varptr);

		varptr = C_REFVAL_P(varptr);
		ZVAL_COPY_VALUE(arg, varptr);
		if (UNEXPECTED(GC_DELREF(ref) == 0)) {
			efree_size(ref, sizeof(crex_reference));
		} else if (C_OPT_REFCOUNTED_P(arg)) {
			C_ADDREF_P(arg);
		}
	} else {
		ZVAL_COPY_VALUE(arg, varptr);
	}
	CREX_VM_NEXT_OPCODE();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_SEND_REF_SPEC_VAR_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *varptr, *arg;

	SAVE_OPLINE();
	if (IS_UNUSED == IS_CONST) {
		crex_string *arg_name = C_STR_P(RT_CONSTANT(opline, opline->op2));
		uint32_t arg_num;
		arg = crex_handle_named_arg(&EX(call), arg_name, &arg_num, CACHE_ADDR(opline->result.num));
		if (UNEXPECTED(!arg)) {
			zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
			HANDLE_EXCEPTION();
		}
	} else {
		arg = CREX_CALL_VAR(EX(call), opline->result.var);
	}

	varptr = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	if (C_ISREF_P(varptr)) {
		C_ADDREF_P(varptr);
	} else {
		ZVAL_MAKE_REF_EX(varptr, 2);
	}
	ZVAL_REF(arg, C_REF_P(varptr));

	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	CREX_VM_NEXT_OPCODE();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_SEND_VAR_EX_SPEC_VAR_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *varptr, *arg;
	uint32_t arg_num;

	if (IS_UNUSED == IS_CONST) {
		SAVE_OPLINE();
		crex_string *arg_name = C_STR_P(RT_CONSTANT(opline, opline->op2));
		arg = crex_handle_named_arg(&EX(call), arg_name, &arg_num, CACHE_ADDR(opline->result.num));
		if (UNEXPECTED(!arg)) {
			zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
			HANDLE_EXCEPTION();
		}
	} else {
		arg = CREX_CALL_VAR(EX(call), opline->result.var);
		arg_num = opline->op2.num;
	}

	if (EXPECTED(0)) {
		if (QUICK_ARG_SHOULD_BE_SENT_BY_REF(EX(call)->func, arg_num)) {
			goto send_var_by_ref;
		}
	} else if (ARG_SHOULD_BE_SENT_BY_REF(EX(call)->func, arg_num)) {
send_var_by_ref:
		varptr = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);
		if (C_ISREF_P(varptr)) {
			C_ADDREF_P(varptr);
		} else {
			ZVAL_MAKE_REF_EX(varptr, 2);
		}
		ZVAL_REF(arg, C_REF_P(varptr));

		zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
		CREX_VM_NEXT_OPCODE();
	}

	varptr = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	if (IS_VAR == IS_CV && UNEXPECTED(C_TYPE_INFO_P(varptr) == IS_UNDEF)) {
		SAVE_OPLINE();
		ZVAL_UNDEFINED_OP1();
		ZVAL_NULL(arg);
		CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
	}

	if (IS_VAR == IS_CV) {
		ZVAL_COPY_DEREF(arg, varptr);
	} else /* if (IS_VAR == IS_VAR) */ {
		if (UNEXPECTED(C_ISREF_P(varptr))) {
			crex_refcounted *ref = C_COUNTED_P(varptr);

			varptr = C_REFVAL_P(varptr);
			ZVAL_COPY_VALUE(arg, varptr);
			if (UNEXPECTED(GC_DELREF(ref) == 0)) {
				efree_size(ref, sizeof(crex_reference));
			} else if (C_OPT_REFCOUNTED_P(arg)) {
				C_ADDREF_P(arg);
			}
		} else {
			ZVAL_COPY_VALUE(arg, varptr);
		}
	}

	CREX_VM_NEXT_OPCODE();
}

static CREX_VM_HOT CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_SEND_VAR_EX_SPEC_VAR_UNUSED_QUICK_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *varptr, *arg;
	uint32_t arg_num;

	if (IS_UNUSED == IS_CONST) {
		SAVE_OPLINE();
		crex_string *arg_name = C_STR_P(RT_CONSTANT(opline, opline->op2));
		arg = crex_handle_named_arg(&EX(call), arg_name, &arg_num, CACHE_ADDR(opline->result.num));
		if (UNEXPECTED(!arg)) {
			zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
			HANDLE_EXCEPTION();
		}
	} else {
		arg = CREX_CALL_VAR(EX(call), opline->result.var);
		arg_num = opline->op2.num;
	}

	if (EXPECTED(1)) {
		if (QUICK_ARG_SHOULD_BE_SENT_BY_REF(EX(call)->func, arg_num)) {
			goto send_var_by_ref;
		}
	} else if (ARG_SHOULD_BE_SENT_BY_REF(EX(call)->func, arg_num)) {
send_var_by_ref:
		varptr = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);
		if (C_ISREF_P(varptr)) {
			C_ADDREF_P(varptr);
		} else {
			ZVAL_MAKE_REF_EX(varptr, 2);
		}
		ZVAL_REF(arg, C_REF_P(varptr));

		zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
		CREX_VM_NEXT_OPCODE();
	}

	varptr = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	if (IS_VAR == IS_CV && UNEXPECTED(C_TYPE_INFO_P(varptr) == IS_UNDEF)) {
		SAVE_OPLINE();
		ZVAL_UNDEFINED_OP1();
		ZVAL_NULL(arg);
		CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
	}

	if (IS_VAR == IS_CV) {
		ZVAL_COPY_DEREF(arg, varptr);
	} else /* if (IS_VAR == IS_VAR) */ {
		if (UNEXPECTED(C_ISREF_P(varptr))) {
			crex_refcounted *ref = C_COUNTED_P(varptr);

			varptr = C_REFVAL_P(varptr);
			ZVAL_COPY_VALUE(arg, varptr);
			if (UNEXPECTED(GC_DELREF(ref) == 0)) {
				efree_size(ref, sizeof(crex_reference));
			} else if (C_OPT_REFCOUNTED_P(arg)) {
				C_ADDREF_P(arg);
			}
		} else {
			ZVAL_COPY_VALUE(arg, varptr);
		}
	}

	CREX_VM_NEXT_OPCODE();
}

static CREX_VM_HOT CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_SEND_FUNC_ARG_SPEC_VAR_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *varptr, *arg;

	if (IS_UNUSED == IS_CONST) {
		// TODO: Would it make sense to share the cache slot with CHECK_FUNC_ARG?
		SAVE_OPLINE();
		crex_string *arg_name = C_STR_P(RT_CONSTANT(opline, opline->op2));
		uint32_t arg_num;
		arg = crex_handle_named_arg(&EX(call), arg_name, &arg_num, CACHE_ADDR(opline->result.num));
		if (UNEXPECTED(!arg)) {
			zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
			HANDLE_EXCEPTION();
		}
	} else {
		arg = CREX_CALL_VAR(EX(call), opline->result.var);
	}

	if (UNEXPECTED(CREX_CALL_INFO(EX(call)) & CREX_CALL_SEND_ARG_BY_REF)) {
		varptr = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);
		if (C_ISREF_P(varptr)) {
			C_ADDREF_P(varptr);
		} else {
			ZVAL_MAKE_REF_EX(varptr, 2);
		}
		ZVAL_REF(arg, C_REF_P(varptr));

		zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
		CREX_VM_NEXT_OPCODE();
	}

	varptr = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);

	if (UNEXPECTED(C_ISREF_P(varptr))) {
		crex_refcounted *ref = C_COUNTED_P(varptr);

		varptr = C_REFVAL_P(varptr);
		ZVAL_COPY_VALUE(arg, varptr);
		if (UNEXPECTED(GC_DELREF(ref) == 0)) {
			efree_size(ref, sizeof(crex_reference));
		} else if (C_OPT_REFCOUNTED_P(arg)) {
			C_ADDREF_P(arg);
		}
	} else {
		ZVAL_COPY_VALUE(arg, varptr);
	}

	CREX_VM_NEXT_OPCODE();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_NEW_SPEC_VAR_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *result;
	crex_function *constructor;
	crex_class_entry *ce;
	crex_execute_data *call;

	SAVE_OPLINE();
	if (IS_VAR == IS_CONST) {
		ce = CACHED_PTR(opline->op2.num);
		if (UNEXPECTED(ce == NULL)) {
			ce = crex_fetch_class_by_name(C_STR_P(RT_CONSTANT(opline, opline->op1)), C_STR_P(RT_CONSTANT(opline, opline->op1) + 1), CREX_FETCH_CLASS_DEFAULT | CREX_FETCH_CLASS_EXCEPTION);
			if (UNEXPECTED(ce == NULL)) {
				ZVAL_UNDEF(EX_VAR(opline->result.var));
				HANDLE_EXCEPTION();
			}
			CACHE_PTR(opline->op2.num, ce);
		}
	} else if (IS_VAR == IS_UNUSED) {
		ce = crex_fetch_class(NULL, opline->op1.num);
		if (UNEXPECTED(ce == NULL)) {
			ZVAL_UNDEF(EX_VAR(opline->result.var));
			HANDLE_EXCEPTION();
		}
	} else {
		ce = C_CE_P(EX_VAR(opline->op1.var));
	}

	result = EX_VAR(opline->result.var);
	if (UNEXPECTED(object_init_ex(result, ce) != SUCCESS)) {
		ZVAL_UNDEF(result);
		HANDLE_EXCEPTION();
	}

	constructor = C_OBJ_HT_P(result)->get_constructor(C_OBJ_P(result));
	if (constructor == NULL) {
		if (UNEXPECTED(EG(exception))) {
			HANDLE_EXCEPTION();
		}

		/* If there are no arguments, skip over the DO_FCALL opcode. We check if the next
		 * opcode is DO_FCALL in case EXT instructions are used. */
		if (EXPECTED(opline->extended_value == 0 && (opline+1)->opcode == CREX_DO_FCALL)) {
			CREX_VM_NEXT_OPCODE_EX(1, 2);
		}

		/* Perform a dummy function call */
		call = crex_vm_stack_push_call_frame(
			CREX_CALL_FUNCTION, (crex_function *) &crex_pass_function,
			opline->extended_value, NULL);
	} else {
		if (EXPECTED(constructor->type == CREX_USER_FUNCTION) && UNEXPECTED(!RUN_TIME_CACHE(&constructor->op_array))) {
			init_func_run_time_cache(&constructor->op_array);
		}
		/* We are not handling overloaded classes right now */
		call = crex_vm_stack_push_call_frame(
			CREX_CALL_FUNCTION | CREX_CALL_RELEASE_THIS | CREX_CALL_HAS_THIS,
			constructor,
			opline->extended_value,
			C_OBJ_P(result));
		C_ADDREF_P(result);
	}

	call->prev_execute_data = EX(call);
	EX(call) = call;
	CREX_VM_NEXT_OPCODE();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ADD_ARRAY_ELEMENT_SPEC_VAR_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *expr_ptr, new_expr;

	SAVE_OPLINE();
	if ((IS_VAR == IS_VAR || IS_VAR == IS_CV) &&
	    UNEXPECTED(opline->extended_value & CREX_ARRAY_ELEMENT_REF)) {
		expr_ptr = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);
		if (C_ISREF_P(expr_ptr)) {
			C_ADDREF_P(expr_ptr);
		} else {
			ZVAL_MAKE_REF_EX(expr_ptr, 2);
		}
		zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	} else {
		expr_ptr = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);
		if (IS_VAR == IS_TMP_VAR) {
			/* pass */
		} else if (IS_VAR == IS_CONST) {
			C_TRY_ADDREF_P(expr_ptr);
		} else if (IS_VAR == IS_CV) {
			ZVAL_DEREF(expr_ptr);
			C_TRY_ADDREF_P(expr_ptr);
		} else /* if (IS_VAR == IS_VAR) */ {
			if (UNEXPECTED(C_ISREF_P(expr_ptr))) {
				crex_refcounted *ref = C_COUNTED_P(expr_ptr);

				expr_ptr = C_REFVAL_P(expr_ptr);
				if (UNEXPECTED(GC_DELREF(ref) == 0)) {
					ZVAL_COPY_VALUE(&new_expr, expr_ptr);
					expr_ptr = &new_expr;
					efree_size(ref, sizeof(crex_reference));
				} else if (C_OPT_REFCOUNTED_P(expr_ptr)) {
					C_ADDREF_P(expr_ptr);
				}
			}
		}
	}

	if (IS_UNUSED != IS_UNUSED) {
		zval *offset = NULL;
		crex_string *str;
		crex_ulong hval;

add_again:
		if (EXPECTED(C_TYPE_P(offset) == IS_STRING)) {
			str = C_STR_P(offset);
			if (IS_UNUSED != IS_CONST) {
				if (CREX_HANDLE_NUMERIC(str, hval)) {
					goto num_index;
				}
			}
str_index:
			crex_hash_update(C_ARRVAL_P(EX_VAR(opline->result.var)), str, expr_ptr);
		} else if (EXPECTED(C_TYPE_P(offset) == IS_LONG)) {
			hval = C_LVAL_P(offset);
num_index:
			crex_hash_index_update(C_ARRVAL_P(EX_VAR(opline->result.var)), hval, expr_ptr);
		} else if ((IS_UNUSED & (IS_VAR|IS_CV)) && EXPECTED(C_TYPE_P(offset) == IS_REFERENCE)) {
			offset = C_REFVAL_P(offset);
			goto add_again;
		} else if (C_TYPE_P(offset) == IS_NULL) {
			str = ZSTR_EMPTY_ALLOC();
			goto str_index;
		} else if (C_TYPE_P(offset) == IS_DOUBLE) {
			hval = crex_dval_to_lval_safe(C_DVAL_P(offset));
			goto num_index;
		} else if (C_TYPE_P(offset) == IS_FALSE) {
			hval = 0;
			goto num_index;
		} else if (C_TYPE_P(offset) == IS_TRUE) {
			hval = 1;
			goto num_index;
		} else if (C_TYPE_P(offset) == IS_RESOURCE) {
			crex_use_resource_as_offset(offset);
			hval = C_RES_HANDLE_P(offset);
			goto num_index;
		} else if (IS_UNUSED == IS_CV && C_TYPE_P(offset) == IS_UNDEF) {
			ZVAL_UNDEFINED_OP2();
			str = ZSTR_EMPTY_ALLOC();
			goto str_index;
		} else {
			crex_illegal_array_offset_access(offset);
			zval_ptr_dtor_nogc(expr_ptr);
		}

	} else {
		if (!crex_hash_next_index_insert(C_ARRVAL_P(EX_VAR(opline->result.var)), expr_ptr)) {
			crex_cannot_add_element();
			zval_ptr_dtor_nogc(expr_ptr);
		}
	}
	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_INIT_ARRAY_SPEC_VAR_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	zval *array;
	uint32_t size;
	USE_OPLINE

	array = EX_VAR(opline->result.var);
	if (IS_VAR != IS_UNUSED) {
		size = opline->extended_value >> CREX_ARRAY_SIZE_SHIFT;
		ZVAL_ARR(array, crex_new_array(size));
		/* Explicitly initialize array as not-packed if flag is set */
		if (opline->extended_value & CREX_ARRAY_NOT_PACKED) {
			crex_hash_real_init_mixed(C_ARRVAL_P(array));
		}
		CREX_VM_TAIL_CALL(CREX_ADD_ARRAY_ELEMENT_SPEC_VAR_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU));
	} else {
		ZVAL_ARR(array, crex_new_array(0));
		CREX_VM_NEXT_OPCODE();
	}
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_SEPARATE_SPEC_VAR_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *var_ptr;

	var_ptr = EX_VAR(opline->op1.var);
	if (UNEXPECTED(C_ISREF_P(var_ptr))) {
		if (UNEXPECTED(C_REFCOUNT_P(var_ptr) == 1)) {
			ZVAL_UNREF(var_ptr);
		}
	}

	CREX_VM_NEXT_OPCODE();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_YIELD_SPEC_VAR_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	crex_generator *generator = crex_get_running_generator(EXECUTE_DATA_C);

	SAVE_OPLINE();
	if (UNEXPECTED(generator->flags & CREX_GENERATOR_FORCED_CLOSE)) {
		CREX_VM_TAIL_CALL(crex_yield_in_closed_generator_helper_SPEC(CREX_OPCODE_HANDLER_ARGS_PASSTHRU));
	}

	/* Destroy the previously yielded value */
	zval_ptr_dtor(&generator->value);

	/* Destroy the previously yielded key */
	zval_ptr_dtor(&generator->key);

	/* Set the new yielded value */
	if (IS_VAR != IS_UNUSED) {
		if (UNEXPECTED(EX(func)->op_array.fn_flags & CREX_ACC_RETURN_REFERENCE)) {
			/* Constants and temporary variables aren't yieldable by reference,
			 * but we still allow them with a notice. */
			if (IS_VAR & (IS_CONST|IS_TMP_VAR)) {
				zval *value;

				crex_error(E_NOTICE, "Only variable references should be yielded by reference");

				value = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);
				ZVAL_COPY_VALUE(&generator->value, value);
				if (IS_VAR == IS_CONST) {
					if (UNEXPECTED(C_OPT_REFCOUNTED(generator->value))) {
						C_ADDREF(generator->value);
					}
				}
			} else {
				zval *value_ptr = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);

				/* If a function call result is yielded and the function did
				 * not return by reference we throw a notice. */
				do {
					if (IS_VAR == IS_VAR) {
						CREX_ASSERT(value_ptr != &EG(uninitialized_zval));
						if (opline->extended_value == CREX_RETURNS_FUNCTION
						 && !C_ISREF_P(value_ptr)) {
							crex_error(E_NOTICE, "Only variable references should be yielded by reference");
							ZVAL_COPY(&generator->value, value_ptr);
							break;
						}
					}
					if (C_ISREF_P(value_ptr)) {
						C_ADDREF_P(value_ptr);
					} else {
						ZVAL_MAKE_REF_EX(value_ptr, 2);
					}
					ZVAL_REF(&generator->value, C_REF_P(value_ptr));
				} while (0);

				zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
			}
		} else {
			zval *value = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);

			/* Consts, temporary variables and references need copying */
			if (IS_VAR == IS_CONST) {
				ZVAL_COPY_VALUE(&generator->value, value);
				if (UNEXPECTED(C_OPT_REFCOUNTED(generator->value))) {
					C_ADDREF(generator->value);
				}
			} else if (IS_VAR == IS_TMP_VAR) {
				ZVAL_COPY_VALUE(&generator->value, value);
			} else if ((IS_VAR & (IS_VAR|IS_CV)) && C_ISREF_P(value)) {
				ZVAL_COPY(&generator->value, C_REFVAL_P(value));
				zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
			} else {
				ZVAL_COPY_VALUE(&generator->value, value);
				if (IS_VAR == IS_CV) {
					if (C_OPT_REFCOUNTED_P(value)) C_ADDREF_P(value);
				}
			}
		}
	} else {
		/* If no value was specified yield null */
		ZVAL_NULL(&generator->value);
	}

	/* Set the new yielded key */
	if (IS_UNUSED != IS_UNUSED) {
		zval *key = NULL;
		if ((IS_UNUSED & (IS_CV|IS_VAR)) && UNEXPECTED(C_TYPE_P(key) == IS_REFERENCE)) {
			key = C_REFVAL_P(key);
		}
		ZVAL_COPY(&generator->key, key);

		if (C_TYPE(generator->key) == IS_LONG
		    && C_LVAL(generator->key) > generator->largest_used_integer_key
		) {
			generator->largest_used_integer_key = C_LVAL(generator->key);
		}
	} else {
		/* If no key was specified we use auto-increment keys */
		generator->largest_used_integer_key++;
		ZVAL_LONG(&generator->key, generator->largest_used_integer_key);
	}

	if (RETURN_VALUE_USED(opline)) {
		/* If the return value of yield is used set the send
		 * target and initialize it to NULL */
		generator->send_target = EX_VAR(opline->result.var);
		ZVAL_NULL(generator->send_target);
	} else {
		generator->send_target = NULL;
	}

	/* We increment to the next op, so we are at the correct position when the
	 * generator is resumed. */
	CREX_VM_INC_OPCODE();

	/* The GOTO VM uses a local opline variable. We need to set the opline
	 * variable in execute_data so we don't resume at an old position. */
	SAVE_OPLINE();

	CREX_VM_RETURN();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_MAKE_REF_SPEC_VAR_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1 = EX_VAR(opline->op1.var);

	if (IS_VAR == IS_CV) {
		if (UNEXPECTED(C_TYPE_P(op1) == IS_UNDEF)) {
			ZVAL_NEW_EMPTY_REF(op1);
			C_SET_REFCOUNT_P(op1, 2);
			ZVAL_NULL(C_REFVAL_P(op1));
			ZVAL_REF(EX_VAR(opline->result.var), C_REF_P(op1));
		} else {
			if (C_ISREF_P(op1)) {
				C_ADDREF_P(op1);
			} else {
				ZVAL_MAKE_REF_EX(op1, 2);
			}
			ZVAL_REF(EX_VAR(opline->result.var), C_REF_P(op1));
		}
	} else if (EXPECTED(C_TYPE_P(op1) == IS_INDIRECT)) {
		op1 = C_INDIRECT_P(op1);
		if (EXPECTED(!C_ISREF_P(op1))) {
			ZVAL_MAKE_REF_EX(op1, 2);
		} else {
			GC_ADDREF(C_REF_P(op1));
		}
		ZVAL_REF(EX_VAR(opline->result.var), C_REF_P(op1));
	} else {
		ZVAL_COPY_VALUE(EX_VAR(opline->result.var), op1);
	}
	CREX_VM_NEXT_OPCODE();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_GET_TYPE_SPEC_VAR_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1;
	crex_string *type;

	SAVE_OPLINE();
	op1 = _get_zval_ptr_var_deref(opline->op1.var EXECUTE_DATA_CC);
	type = crex_zval_get_legacy_type(op1);
	if (EXPECTED(type)) {
		ZVAL_INTERNED_STR(EX_VAR(opline->result.var), type);
	} else {
		ZVAL_STRING(EX_VAR(opline->result.var), "unknown type");
	}
	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_VM_HOT CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_SEND_VAR_EX_SIMPLE_SPEC_VAR_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *varptr, *arg;
	uint32_t arg_num = opline->op2.num;

	if (QUICK_ARG_SHOULD_BE_SENT_BY_REF(EX(call)->func, arg_num)) {
		CREX_VM_TAIL_CALL(CREX_SEND_REF_SPEC_VAR_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU));
	}

	varptr = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	arg = CREX_CALL_VAR(EX(call), opline->result.var);

	if (IS_VAR == IS_CV) {
		ZVAL_COPY(arg, varptr);
	} else /* if (IS_VAR == IS_VAR) */ {
		ZVAL_COPY_VALUE(arg, varptr);
	}

	CREX_VM_NEXT_OPCODE();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_CASE_STRICT_SPEC_VAR_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	bool result;

	SAVE_OPLINE();
	op1 = _get_zval_ptr_var_deref(opline->op1.var EXECUTE_DATA_CC);
	op2 = _get_zval_ptr_cv_deref_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC);
	result = fast_is_identical_function(op1, op2);

	CREX_VM_SMART_BRANCH(result, 1);
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ASSIGN_OBJ_OP_SPEC_VAR_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *object;
	zval *property;
	zval *value;
	zval *zptr;
	void **cache_slot;
	crex_property_info *prop_info;
	crex_object *zobj;
	crex_string *name, *tmp_name;

	SAVE_OPLINE();
	object = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	property = _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC);

	do {
		value = get_op_data_zval_ptr_r((opline+1)->op1_type, (opline+1)->op1);

		if (IS_VAR != IS_UNUSED && UNEXPECTED(C_TYPE_P(object) != IS_OBJECT)) {
			if (C_ISREF_P(object) && C_TYPE_P(C_REFVAL_P(object)) == IS_OBJECT) {
				object = C_REFVAL_P(object);
				goto assign_op_object;
			}
			if (IS_VAR == IS_CV
			 && UNEXPECTED(C_TYPE_P(object) == IS_UNDEF)) {
				ZVAL_UNDEFINED_OP1();
			}
			crex_throw_non_object_error(object, property OPLINE_CC EXECUTE_DATA_CC);
			break;
		}

assign_op_object:
		/* here we are sure we are dealing with an object */
		zobj = C_OBJ_P(object);
		if (IS_CV == IS_CONST) {
			name = C_STR_P(property);
		} else {
			name = zval_try_get_tmp_string(property, &tmp_name);
			if (UNEXPECTED(!name)) {
				UNDEF_RESULT();
				break;
			}
		}
		cache_slot = (IS_CV == IS_CONST) ? CACHE_ADDR((opline+1)->extended_value) : NULL;
		if (EXPECTED((zptr = zobj->handlers->get_property_ptr_ptr(zobj, name, BP_VAR_RW, cache_slot)) != NULL)) {
			if (UNEXPECTED(C_ISERROR_P(zptr))) {
				if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
					ZVAL_NULL(EX_VAR(opline->result.var));
				}
			} else {
				zval *orig_zptr = zptr;
				crex_reference *ref;

				do {
					if (UNEXPECTED(C_ISREF_P(zptr))) {
						ref = C_REF_P(zptr);
						zptr = C_REFVAL_P(zptr);
						if (UNEXPECTED(CREX_REF_HAS_TYPE_SOURCES(ref))) {
							crex_binary_assign_op_typed_ref(ref, value OPLINE_CC EXECUTE_DATA_CC);
							break;
						}
					}

					if (IS_CV == IS_CONST) {
						prop_info = (crex_property_info*)CACHED_PTR_EX(cache_slot + 2);
					} else {
						prop_info = crex_object_fetch_property_type_info(C_OBJ_P(object), orig_zptr);
					}
					if (UNEXPECTED(prop_info)) {
						/* special case for typed properties */
						crex_binary_assign_op_typed_prop(prop_info, zptr, value OPLINE_CC EXECUTE_DATA_CC);
					} else {
						crex_binary_op(zptr, zptr, value OPLINE_CC);
					}
				} while (0);

				if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
					ZVAL_COPY(EX_VAR(opline->result.var), zptr);
				}
			}
		} else {
			crex_assign_op_overloaded_property(zobj, name, cache_slot, value OPLINE_CC EXECUTE_DATA_CC);
		}
		if (IS_CV != IS_CONST) {
			crex_tmp_string_release(tmp_name);
		}
	} while (0);

	FREE_OP((opline+1)->op1_type, (opline+1)->op1.var);

	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	/* assign_obj has two opcodes! */
	CREX_VM_NEXT_OPCODE_EX(1, 2);
}

/* No specialization for op_types (CONST|TMP|VAR|CV, UNUSED|CONST|TMPVAR) */
static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ASSIGN_DIM_OP_SPEC_VAR_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *var_ptr;
	zval *value, *container, *dim;
	HashTable *ht;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);

	if (EXPECTED(C_TYPE_P(container) == IS_ARRAY)) {
assign_dim_op_array:
		SEPARATE_ARRAY(container);
		ht = C_ARRVAL_P(container);
assign_dim_op_new_array:
		dim = EX_VAR(opline->op2.var);
		if (IS_CV == IS_UNUSED) {
			var_ptr = crex_hash_next_index_insert(ht, &EG(uninitialized_zval));
			if (UNEXPECTED(!var_ptr)) {
				crex_cannot_add_element();
				goto assign_dim_op_ret_null;
			}
		} else {
			if (IS_CV == IS_CONST) {
				var_ptr = crex_fetch_dimension_address_inner_RW_CONST(ht, dim EXECUTE_DATA_CC);
			} else {
				var_ptr = crex_fetch_dimension_address_inner_RW(ht, dim EXECUTE_DATA_CC);
			}
			if (UNEXPECTED(!var_ptr)) {
				goto assign_dim_op_ret_null;
			}
		}

		value = get_op_data_zval_ptr_r((opline+1)->op1_type, (opline+1)->op1);

		do {
			if (IS_CV != IS_UNUSED && UNEXPECTED(C_ISREF_P(var_ptr))) {
				crex_reference *ref = C_REF_P(var_ptr);
				var_ptr = C_REFVAL_P(var_ptr);
				if (UNEXPECTED(CREX_REF_HAS_TYPE_SOURCES(ref))) {
					crex_binary_assign_op_typed_ref(ref, value OPLINE_CC EXECUTE_DATA_CC);
					break;
				}
			}
			crex_binary_op(var_ptr, var_ptr, value OPLINE_CC);
		} while (0);

		if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
			ZVAL_COPY(EX_VAR(opline->result.var), var_ptr);
		}
		FREE_OP((opline+1)->op1_type, (opline+1)->op1.var);
	} else {
		if (EXPECTED(C_ISREF_P(container))) {
			container = C_REFVAL_P(container);
			if (EXPECTED(C_TYPE_P(container) == IS_ARRAY)) {
				goto assign_dim_op_array;
			}
		}

		if (EXPECTED(C_TYPE_P(container) == IS_OBJECT)) {
			crex_object *obj = C_OBJ_P(container);

			dim = EX_VAR(opline->op2.var);
			if (IS_CV == IS_CONST && C_EXTRA_P(dim) == CREX_EXTRA_VALUE) {
				dim++;
			}
			crex_binary_assign_op_obj_dim(obj, dim OPLINE_CC EXECUTE_DATA_CC);
		} else if (EXPECTED(C_TYPE_P(container) <= IS_FALSE)) {
			uint8_t old_type;

			if (IS_VAR == IS_CV && UNEXPECTED(C_TYPE_INFO_P(container) == IS_UNDEF)) {
				ZVAL_UNDEFINED_OP1();
			}
			ht = crex_new_array(8);
			old_type = C_TYPE_P(container);
			ZVAL_ARR(container, ht);
			if (UNEXPECTED(old_type == IS_FALSE)) {
				GC_ADDREF(ht);
				crex_false_to_array_deprecated();
				if (UNEXPECTED(GC_DELREF(ht) == 0)) {
					crex_array_destroy(ht);
					goto assign_dim_op_ret_null;
				}
			}
			goto assign_dim_op_new_array;
		} else {
			dim = _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC);
			crex_binary_assign_op_dim_slow(container, dim OPLINE_CC EXECUTE_DATA_CC);
assign_dim_op_ret_null:
			FREE_OP((opline+1)->op1_type, (opline+1)->op1.var);
			if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
				ZVAL_NULL(EX_VAR(opline->result.var));
			}
		}
	}

	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	CREX_VM_NEXT_OPCODE_EX(1, 2);
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ASSIGN_OP_SPEC_VAR_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *var_ptr;
	zval *value;

	SAVE_OPLINE();
	value = _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC);
	var_ptr = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);

	do {
		if (UNEXPECTED(C_TYPE_P(var_ptr) == IS_REFERENCE)) {
			crex_reference *ref = C_REF_P(var_ptr);
			var_ptr = C_REFVAL_P(var_ptr);
			if (UNEXPECTED(CREX_REF_HAS_TYPE_SOURCES(ref))) {
				crex_binary_assign_op_typed_ref(ref, value OPLINE_CC EXECUTE_DATA_CC);
				break;
			}
		}
		crex_binary_op(var_ptr, var_ptr, value OPLINE_CC);
	} while (0);

	if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
		ZVAL_COPY(EX_VAR(opline->result.var), var_ptr);
	}

	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_PRE_INC_OBJ_SPEC_VAR_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *object;
	zval *property;
	zval *zptr;
	void **cache_slot;
	crex_property_info *prop_info;
	crex_object *zobj;
	crex_string *name, *tmp_name;

	SAVE_OPLINE();
	object = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	property = _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC);

	do {
		if (IS_VAR != IS_UNUSED && UNEXPECTED(C_TYPE_P(object) != IS_OBJECT)) {
			if (C_ISREF_P(object) && C_TYPE_P(C_REFVAL_P(object)) == IS_OBJECT) {
				object = C_REFVAL_P(object);
				goto pre_incdec_object;
			}
			if (IS_VAR == IS_CV
			 && UNEXPECTED(C_TYPE_P(object) == IS_UNDEF)) {
				ZVAL_UNDEFINED_OP1();
			}
			crex_throw_non_object_error(object, property OPLINE_CC EXECUTE_DATA_CC);
			break;
		}

pre_incdec_object:
		/* here we are sure we are dealing with an object */
		zobj = C_OBJ_P(object);
		if (IS_CV == IS_CONST) {
			name = C_STR_P(property);
		} else {
			name = zval_try_get_tmp_string(property, &tmp_name);
			if (UNEXPECTED(!name)) {
				UNDEF_RESULT();
				break;
			}
		}
		cache_slot = (IS_CV == IS_CONST) ? CACHE_ADDR(opline->extended_value) : NULL;
		if (EXPECTED((zptr = zobj->handlers->get_property_ptr_ptr(zobj, name, BP_VAR_RW, cache_slot)) != NULL)) {
			if (UNEXPECTED(C_ISERROR_P(zptr))) {
				if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
					ZVAL_NULL(EX_VAR(opline->result.var));
				}
			} else {
				if (IS_CV == IS_CONST) {
					prop_info = (crex_property_info *) CACHED_PTR_EX(cache_slot + 2);
				} else {
					prop_info = crex_object_fetch_property_type_info(C_OBJ_P(object), zptr);
				}
				crex_pre_incdec_property_zval(zptr, prop_info OPLINE_CC EXECUTE_DATA_CC);
			}
		} else {
			crex_pre_incdec_overloaded_property(zobj, name, cache_slot OPLINE_CC EXECUTE_DATA_CC);
		}
		if (IS_CV != IS_CONST) {
			crex_tmp_string_release(tmp_name);
		}
	} while (0);

	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_POST_INC_OBJ_SPEC_VAR_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *object;
	zval *property;
	zval *zptr;
	void **cache_slot;
	crex_property_info *prop_info;
	crex_object *zobj;
	crex_string *name, *tmp_name;

	SAVE_OPLINE();
	object = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	property = _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC);

	do {
		if (IS_VAR != IS_UNUSED && UNEXPECTED(C_TYPE_P(object) != IS_OBJECT)) {
			if (C_ISREF_P(object) && C_TYPE_P(C_REFVAL_P(object)) == IS_OBJECT) {
				object = C_REFVAL_P(object);
				goto post_incdec_object;
			}
			if (IS_VAR == IS_CV
			 && UNEXPECTED(C_TYPE_P(object) == IS_UNDEF)) {
				ZVAL_UNDEFINED_OP1();
			}
			crex_throw_non_object_error(object, property OPLINE_CC EXECUTE_DATA_CC);
			break;
		}

post_incdec_object:
		/* here we are sure we are dealing with an object */
		zobj = C_OBJ_P(object);
		if (IS_CV == IS_CONST) {
			name = C_STR_P(property);
		} else {
			name = zval_try_get_tmp_string(property, &tmp_name);
			if (UNEXPECTED(!name)) {
				ZVAL_UNDEF(EX_VAR(opline->result.var));
				break;
			}
		}
		cache_slot = (IS_CV == IS_CONST) ? CACHE_ADDR(opline->extended_value) : NULL;
		if (EXPECTED((zptr = zobj->handlers->get_property_ptr_ptr(zobj, name, BP_VAR_RW, cache_slot)) != NULL)) {
			if (UNEXPECTED(C_ISERROR_P(zptr))) {
				ZVAL_NULL(EX_VAR(opline->result.var));
			} else {
				if (IS_CV == IS_CONST) {
					prop_info = (crex_property_info*)CACHED_PTR_EX(cache_slot + 2);
				} else {
					prop_info = crex_object_fetch_property_type_info(C_OBJ_P(object), zptr);
				}

				crex_post_incdec_property_zval(zptr, prop_info OPLINE_CC EXECUTE_DATA_CC);
			}
		} else {
			crex_post_incdec_overloaded_property(zobj, name, cache_slot OPLINE_CC EXECUTE_DATA_CC);
		}
		if (IS_CV != IS_CONST) {
			crex_tmp_string_release(tmp_name);
		}
	} while (0);

	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FETCH_DIM_W_SPEC_VAR_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	crex_fetch_dimension_address_W(container, EX_VAR(opline->op2.var), IS_CV OPLINE_CC EXECUTE_DATA_CC);

	if (IS_VAR == IS_VAR) {
		FREE_VAR_PTR_AND_EXTRACT_RESULT_IF_NECESSARY(opline->op1.var);
	}
	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FETCH_DIM_RW_SPEC_VAR_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	crex_fetch_dimension_address_RW(container, EX_VAR(opline->op2.var), IS_CV OPLINE_CC EXECUTE_DATA_CC);

	if (IS_VAR == IS_VAR) {
		FREE_VAR_PTR_AND_EXTRACT_RESULT_IF_NECESSARY(opline->op1.var);
	}
	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FETCH_DIM_FUNC_ARG_SPEC_VAR_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
#if 0
	USE_OPLINE
#endif

	if (UNEXPECTED(CREX_CALL_INFO(EX(call)) & CREX_CALL_SEND_ARG_BY_REF)) {
		if ((IS_VAR & (IS_CONST|IS_TMP_VAR))) {
			CREX_VM_TAIL_CALL(crex_use_tmp_in_write_context_helper_SPEC(CREX_OPCODE_HANDLER_ARGS_PASSTHRU));
		}
		CREX_VM_TAIL_CALL(CREX_FETCH_DIM_W_SPEC_VAR_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU));
	} else {
		if (IS_CV == IS_UNUSED) {
			CREX_VM_TAIL_CALL(crex_use_undef_in_read_context_helper_SPEC(CREX_OPCODE_HANDLER_ARGS_PASSTHRU));
		}
		CREX_VM_TAIL_CALL(CREX_FETCH_DIM_R_SPEC_TMPVAR_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU));
	}
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FETCH_DIM_UNSET_SPEC_VAR_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	crex_fetch_dimension_address_UNSET(container, EX_VAR(opline->op2.var), IS_CV OPLINE_CC EXECUTE_DATA_CC);

	if (IS_VAR == IS_VAR) {
		FREE_VAR_PTR_AND_EXTRACT_RESULT_IF_NECESSARY(opline->op1.var);
	}
	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FETCH_OBJ_W_SPEC_VAR_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *property, *container, *result;

	SAVE_OPLINE();

	container = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	property = _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC);
	result = EX_VAR(opline->result.var);
	crex_fetch_property_address(
		result, container, IS_VAR, property, IS_CV,
		((IS_CV == IS_CONST) ? CACHE_ADDR(opline->extended_value & ~CREX_FETCH_OBJ_FLAGS) : NULL),
		BP_VAR_W, opline->extended_value OPLINE_CC EXECUTE_DATA_CC);

	if (IS_VAR == IS_VAR) {
		FREE_VAR_PTR_AND_EXTRACT_RESULT_IF_NECESSARY(opline->op1.var);
	}
	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FETCH_OBJ_RW_SPEC_VAR_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *property, *container, *result;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	property = _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC);
	result = EX_VAR(opline->result.var);
	crex_fetch_property_address(result, container, IS_VAR, property, IS_CV, ((IS_CV == IS_CONST) ? CACHE_ADDR(opline->extended_value) : NULL), BP_VAR_RW, 0 OPLINE_CC EXECUTE_DATA_CC);

	if (IS_VAR == IS_VAR) {
		FREE_VAR_PTR_AND_EXTRACT_RESULT_IF_NECESSARY(opline->op1.var);
	}
	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FETCH_OBJ_FUNC_ARG_SPEC_VAR_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
#if 0
	USE_OPLINE
#endif

	if (UNEXPECTED(CREX_CALL_INFO(EX(call)) & CREX_CALL_SEND_ARG_BY_REF)) {
		/* Behave like FETCH_OBJ_W */
		if ((IS_VAR & (IS_CONST|IS_TMP_VAR))) {
			CREX_VM_TAIL_CALL(crex_use_tmp_in_write_context_helper_SPEC(CREX_OPCODE_HANDLER_ARGS_PASSTHRU));
		}
		CREX_VM_TAIL_CALL(CREX_FETCH_OBJ_W_SPEC_VAR_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU));
	} else {
		CREX_VM_TAIL_CALL(CREX_FETCH_OBJ_R_SPEC_TMPVAR_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU));
	}
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FETCH_OBJ_UNSET_SPEC_VAR_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container, *property, *result;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	property = _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC);
	result = EX_VAR(opline->result.var);
	crex_fetch_property_address(result, container, IS_VAR, property, IS_CV, ((IS_CV == IS_CONST) ? CACHE_ADDR(opline->extended_value) : NULL), BP_VAR_UNSET, 0 OPLINE_CC EXECUTE_DATA_CC);

	if (IS_VAR == IS_VAR) {
		FREE_VAR_PTR_AND_EXTRACT_RESULT_IF_NECESSARY(opline->op1.var);
	}
	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FETCH_LIST_W_SPEC_VAR_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container, *dim;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	dim = EX_VAR(opline->op2.var);

	if (IS_VAR == IS_VAR
		&& C_TYPE_P(EX_VAR(opline->op1.var)) != IS_INDIRECT
		&& UNEXPECTED(!C_ISREF_P(container))
	) {
		crex_error(E_NOTICE, "Attempting to set reference to non referenceable value");
		crex_fetch_dimension_address_LIST_r(container, dim, IS_CV OPLINE_CC EXECUTE_DATA_CC);
	} else {
		crex_fetch_dimension_address_W(container, dim, IS_CV OPLINE_CC EXECUTE_DATA_CC);
	}

	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ASSIGN_OBJ_SPEC_VAR_CV_OP_DATA_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *object, *value, tmp;
	crex_object *zobj;
	crex_string *name, *tmp_name;
	crex_refcounted *garbage = NULL;

	SAVE_OPLINE();
	object = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	value = RT_CONSTANT((opline+1), (opline+1)->op1);

	if (IS_VAR != IS_UNUSED && UNEXPECTED(C_TYPE_P(object) != IS_OBJECT)) {
		if (C_ISREF_P(object) && C_TYPE_P(C_REFVAL_P(object)) == IS_OBJECT) {
			object = C_REFVAL_P(object);
			goto assign_object;
		}
		crex_throw_non_object_error(object, _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC) OPLINE_CC EXECUTE_DATA_CC);
		value = &EG(uninitialized_zval);
		goto free_and_exit_assign_obj;
	}

assign_object:
	zobj = C_OBJ_P(object);
	if (IS_CV == IS_CONST) {
		if (EXPECTED(zobj->ce == CACHED_PTR(opline->extended_value))) {
			void **cache_slot = CACHE_ADDR(opline->extended_value);
			uintptr_t prop_offset = (uintptr_t)CACHED_PTR_EX(cache_slot + 1);
			zval *property_val;

			if (EXPECTED(IS_VALID_PROPERTY_OFFSET(prop_offset))) {
				property_val = OBJ_PROP(zobj, prop_offset);
				if (C_TYPE_P(property_val) != IS_UNDEF) {
					crex_property_info *prop_info = (crex_property_info*) CACHED_PTR_EX(cache_slot + 2);

					if (UNEXPECTED(prop_info != NULL)) {
						value = crex_assign_to_typed_prop(prop_info, property_val, value, &garbage EXECUTE_DATA_CC);
						goto free_and_exit_assign_obj;
					} else {
fast_assign_obj:
						value = crex_assign_to_variable_ex(property_val, value, IS_CONST, EX_USES_STRICT_TYPES(), &garbage);
						if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
							ZVAL_COPY(EX_VAR(opline->result.var), value);
						}
						goto exit_assign_obj;
					}
				}
			} else {
				name = C_STR_P(_get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC));
				if (EXPECTED(zobj->properties != NULL)) {
					if (UNEXPECTED(GC_REFCOUNT(zobj->properties) > 1)) {
						if (EXPECTED(!(GC_FLAGS(zobj->properties) & IS_ARRAY_IMMUTABLE))) {
							GC_DELREF(zobj->properties);
						}
						zobj->properties = crex_array_dup(zobj->properties);
					}
					property_val = crex_hash_find_known_hash(zobj->properties, name);
					if (property_val) {
						goto fast_assign_obj;
					}
				}

				if (!zobj->ce->__set && (zobj->ce->ce_flags & CREX_ACC_ALLOW_DYNAMIC_PROPERTIES)) {
					if (EXPECTED(zobj->properties == NULL)) {
						rebuild_object_properties(zobj);
					}
					if (IS_CONST == IS_CONST) {
						if (UNEXPECTED(C_OPT_REFCOUNTED_P(value))) {
							C_ADDREF_P(value);
						}
					} else if (IS_CONST != IS_TMP_VAR) {
						if (C_ISREF_P(value)) {
							if (IS_CONST == IS_VAR) {
								crex_reference *ref = C_REF_P(value);
								if (GC_DELREF(ref) == 0) {
									ZVAL_COPY_VALUE(&tmp, C_REFVAL_P(value));
									efree_size(ref, sizeof(crex_reference));
									value = &tmp;
								} else {
									value = C_REFVAL_P(value);
									C_TRY_ADDREF_P(value);
								}
							} else {
								value = C_REFVAL_P(value);
								C_TRY_ADDREF_P(value);
							}
						} else if (IS_CONST == IS_CV) {
							C_TRY_ADDREF_P(value);
						}
						}
					crex_hash_add_new(zobj->properties, name, value);
					if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
						ZVAL_COPY(EX_VAR(opline->result.var), value);
					}
					goto exit_assign_obj;
				}
			}
		}
		name = C_STR_P(_get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC));
	} else {
		name = zval_try_get_tmp_string(_get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC), &tmp_name);
		if (UNEXPECTED(!name)) {

			UNDEF_RESULT();
			goto exit_assign_obj;
		}
	}

	if (IS_CONST == IS_CV || IS_CONST == IS_VAR) {
		ZVAL_DEREF(value);
	}

	value = zobj->handlers->write_property(zobj, name, value, (IS_CV == IS_CONST) ? CACHE_ADDR(opline->extended_value) : NULL);

	if (IS_CV != IS_CONST) {
		crex_tmp_string_release(tmp_name);
	}

free_and_exit_assign_obj:
	if (UNEXPECTED(RETURN_VALUE_USED(opline)) && value) {
		ZVAL_COPY_DEREF(EX_VAR(opline->result.var), value);
	}

exit_assign_obj:
	if (garbage) {
		GC_DTOR_NO_REF(garbage);
	}

	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	/* assign_obj has two opcodes! */
	CREX_VM_NEXT_OPCODE_EX(1, 2);
}

/* No specialization for op_types (CONST|TMPVAR|CV, UNUSED|CONST|VAR) */
static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ASSIGN_OBJ_SPEC_VAR_CV_OP_DATA_TMP_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *object, *value, tmp;
	crex_object *zobj;
	crex_string *name, *tmp_name;
	crex_refcounted *garbage = NULL;

	SAVE_OPLINE();
	object = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	value = _get_zval_ptr_tmp((opline+1)->op1.var EXECUTE_DATA_CC);

	if (IS_VAR != IS_UNUSED && UNEXPECTED(C_TYPE_P(object) != IS_OBJECT)) {
		if (C_ISREF_P(object) && C_TYPE_P(C_REFVAL_P(object)) == IS_OBJECT) {
			object = C_REFVAL_P(object);
			goto assign_object;
		}
		crex_throw_non_object_error(object, _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC) OPLINE_CC EXECUTE_DATA_CC);
		value = &EG(uninitialized_zval);
		goto free_and_exit_assign_obj;
	}

assign_object:
	zobj = C_OBJ_P(object);
	if (IS_CV == IS_CONST) {
		if (EXPECTED(zobj->ce == CACHED_PTR(opline->extended_value))) {
			void **cache_slot = CACHE_ADDR(opline->extended_value);
			uintptr_t prop_offset = (uintptr_t)CACHED_PTR_EX(cache_slot + 1);
			zval *property_val;

			if (EXPECTED(IS_VALID_PROPERTY_OFFSET(prop_offset))) {
				property_val = OBJ_PROP(zobj, prop_offset);
				if (C_TYPE_P(property_val) != IS_UNDEF) {
					crex_property_info *prop_info = (crex_property_info*) CACHED_PTR_EX(cache_slot + 2);

					if (UNEXPECTED(prop_info != NULL)) {
						value = crex_assign_to_typed_prop(prop_info, property_val, value, &garbage EXECUTE_DATA_CC);
						goto free_and_exit_assign_obj;
					} else {
fast_assign_obj:
						value = crex_assign_to_variable_ex(property_val, value, IS_TMP_VAR, EX_USES_STRICT_TYPES(), &garbage);
						if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
							ZVAL_COPY(EX_VAR(opline->result.var), value);
						}
						goto exit_assign_obj;
					}
				}
			} else {
				name = C_STR_P(_get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC));
				if (EXPECTED(zobj->properties != NULL)) {
					if (UNEXPECTED(GC_REFCOUNT(zobj->properties) > 1)) {
						if (EXPECTED(!(GC_FLAGS(zobj->properties) & IS_ARRAY_IMMUTABLE))) {
							GC_DELREF(zobj->properties);
						}
						zobj->properties = crex_array_dup(zobj->properties);
					}
					property_val = crex_hash_find_known_hash(zobj->properties, name);
					if (property_val) {
						goto fast_assign_obj;
					}
				}

				if (!zobj->ce->__set && (zobj->ce->ce_flags & CREX_ACC_ALLOW_DYNAMIC_PROPERTIES)) {
					if (EXPECTED(zobj->properties == NULL)) {
						rebuild_object_properties(zobj);
					}
					if (IS_TMP_VAR == IS_CONST) {
						if (UNEXPECTED(C_OPT_REFCOUNTED_P(value))) {
							C_ADDREF_P(value);
						}
					} else if (IS_TMP_VAR != IS_TMP_VAR) {
						if (C_ISREF_P(value)) {
							if (IS_TMP_VAR == IS_VAR) {
								crex_reference *ref = C_REF_P(value);
								if (GC_DELREF(ref) == 0) {
									ZVAL_COPY_VALUE(&tmp, C_REFVAL_P(value));
									efree_size(ref, sizeof(crex_reference));
									value = &tmp;
								} else {
									value = C_REFVAL_P(value);
									C_TRY_ADDREF_P(value);
								}
							} else {
								value = C_REFVAL_P(value);
								C_TRY_ADDREF_P(value);
							}
						} else if (IS_TMP_VAR == IS_CV) {
							C_TRY_ADDREF_P(value);
						}
						}
					crex_hash_add_new(zobj->properties, name, value);
					if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
						ZVAL_COPY(EX_VAR(opline->result.var), value);
					}
					goto exit_assign_obj;
				}
			}
		}
		name = C_STR_P(_get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC));
	} else {
		name = zval_try_get_tmp_string(_get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC), &tmp_name);
		if (UNEXPECTED(!name)) {
			zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
			UNDEF_RESULT();
			goto exit_assign_obj;
		}
	}

	if (IS_TMP_VAR == IS_CV || IS_TMP_VAR == IS_VAR) {
		ZVAL_DEREF(value);
	}

	value = zobj->handlers->write_property(zobj, name, value, (IS_CV == IS_CONST) ? CACHE_ADDR(opline->extended_value) : NULL);

	if (IS_CV != IS_CONST) {
		crex_tmp_string_release(tmp_name);
	}

free_and_exit_assign_obj:
	if (UNEXPECTED(RETURN_VALUE_USED(opline)) && value) {
		ZVAL_COPY_DEREF(EX_VAR(opline->result.var), value);
	}
	zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
exit_assign_obj:
	if (garbage) {
		GC_DTOR_NO_REF(garbage);
	}

	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	/* assign_obj has two opcodes! */
	CREX_VM_NEXT_OPCODE_EX(1, 2);
}

/* No specialization for op_types (CONST|TMPVAR|CV, UNUSED|CONST|VAR) */
static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ASSIGN_OBJ_SPEC_VAR_CV_OP_DATA_VAR_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *object, *value, tmp;
	crex_object *zobj;
	crex_string *name, *tmp_name;
	crex_refcounted *garbage = NULL;

	SAVE_OPLINE();
	object = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	value = _get_zval_ptr_var((opline+1)->op1.var EXECUTE_DATA_CC);

	if (IS_VAR != IS_UNUSED && UNEXPECTED(C_TYPE_P(object) != IS_OBJECT)) {
		if (C_ISREF_P(object) && C_TYPE_P(C_REFVAL_P(object)) == IS_OBJECT) {
			object = C_REFVAL_P(object);
			goto assign_object;
		}
		crex_throw_non_object_error(object, _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC) OPLINE_CC EXECUTE_DATA_CC);
		value = &EG(uninitialized_zval);
		goto free_and_exit_assign_obj;
	}

assign_object:
	zobj = C_OBJ_P(object);
	if (IS_CV == IS_CONST) {
		if (EXPECTED(zobj->ce == CACHED_PTR(opline->extended_value))) {
			void **cache_slot = CACHE_ADDR(opline->extended_value);
			uintptr_t prop_offset = (uintptr_t)CACHED_PTR_EX(cache_slot + 1);
			zval *property_val;

			if (EXPECTED(IS_VALID_PROPERTY_OFFSET(prop_offset))) {
				property_val = OBJ_PROP(zobj, prop_offset);
				if (C_TYPE_P(property_val) != IS_UNDEF) {
					crex_property_info *prop_info = (crex_property_info*) CACHED_PTR_EX(cache_slot + 2);

					if (UNEXPECTED(prop_info != NULL)) {
						value = crex_assign_to_typed_prop(prop_info, property_val, value, &garbage EXECUTE_DATA_CC);
						goto free_and_exit_assign_obj;
					} else {
fast_assign_obj:
						value = crex_assign_to_variable_ex(property_val, value, IS_VAR, EX_USES_STRICT_TYPES(), &garbage);
						if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
							ZVAL_COPY(EX_VAR(opline->result.var), value);
						}
						goto exit_assign_obj;
					}
				}
			} else {
				name = C_STR_P(_get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC));
				if (EXPECTED(zobj->properties != NULL)) {
					if (UNEXPECTED(GC_REFCOUNT(zobj->properties) > 1)) {
						if (EXPECTED(!(GC_FLAGS(zobj->properties) & IS_ARRAY_IMMUTABLE))) {
							GC_DELREF(zobj->properties);
						}
						zobj->properties = crex_array_dup(zobj->properties);
					}
					property_val = crex_hash_find_known_hash(zobj->properties, name);
					if (property_val) {
						goto fast_assign_obj;
					}
				}

				if (!zobj->ce->__set && (zobj->ce->ce_flags & CREX_ACC_ALLOW_DYNAMIC_PROPERTIES)) {
					if (EXPECTED(zobj->properties == NULL)) {
						rebuild_object_properties(zobj);
					}
					if (IS_VAR == IS_CONST) {
						if (UNEXPECTED(C_OPT_REFCOUNTED_P(value))) {
							C_ADDREF_P(value);
						}
					} else if (IS_VAR != IS_TMP_VAR) {
						if (C_ISREF_P(value)) {
							if (IS_VAR == IS_VAR) {
								crex_reference *ref = C_REF_P(value);
								if (GC_DELREF(ref) == 0) {
									ZVAL_COPY_VALUE(&tmp, C_REFVAL_P(value));
									efree_size(ref, sizeof(crex_reference));
									value = &tmp;
								} else {
									value = C_REFVAL_P(value);
									C_TRY_ADDREF_P(value);
								}
							} else {
								value = C_REFVAL_P(value);
								C_TRY_ADDREF_P(value);
							}
						} else if (IS_VAR == IS_CV) {
							C_TRY_ADDREF_P(value);
						}
						}
					crex_hash_add_new(zobj->properties, name, value);
					if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
						ZVAL_COPY(EX_VAR(opline->result.var), value);
					}
					goto exit_assign_obj;
				}
			}
		}
		name = C_STR_P(_get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC));
	} else {
		name = zval_try_get_tmp_string(_get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC), &tmp_name);
		if (UNEXPECTED(!name)) {
			zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
			UNDEF_RESULT();
			goto exit_assign_obj;
		}
	}

	if (IS_VAR == IS_CV || IS_VAR == IS_VAR) {
		ZVAL_DEREF(value);
	}

	value = zobj->handlers->write_property(zobj, name, value, (IS_CV == IS_CONST) ? CACHE_ADDR(opline->extended_value) : NULL);

	if (IS_CV != IS_CONST) {
		crex_tmp_string_release(tmp_name);
	}

free_and_exit_assign_obj:
	if (UNEXPECTED(RETURN_VALUE_USED(opline)) && value) {
		ZVAL_COPY_DEREF(EX_VAR(opline->result.var), value);
	}
	zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
exit_assign_obj:
	if (garbage) {
		GC_DTOR_NO_REF(garbage);
	}

	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	/* assign_obj has two opcodes! */
	CREX_VM_NEXT_OPCODE_EX(1, 2);
}

/* No specialization for op_types (CONST|TMPVAR|CV, UNUSED|CONST|VAR) */
static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ASSIGN_OBJ_SPEC_VAR_CV_OP_DATA_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *object, *value, tmp;
	crex_object *zobj;
	crex_string *name, *tmp_name;
	crex_refcounted *garbage = NULL;

	SAVE_OPLINE();
	object = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	value = _get_zval_ptr_cv_BP_VAR_R((opline+1)->op1.var EXECUTE_DATA_CC);

	if (IS_VAR != IS_UNUSED && UNEXPECTED(C_TYPE_P(object) != IS_OBJECT)) {
		if (C_ISREF_P(object) && C_TYPE_P(C_REFVAL_P(object)) == IS_OBJECT) {
			object = C_REFVAL_P(object);
			goto assign_object;
		}
		crex_throw_non_object_error(object, _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC) OPLINE_CC EXECUTE_DATA_CC);
		value = &EG(uninitialized_zval);
		goto free_and_exit_assign_obj;
	}

assign_object:
	zobj = C_OBJ_P(object);
	if (IS_CV == IS_CONST) {
		if (EXPECTED(zobj->ce == CACHED_PTR(opline->extended_value))) {
			void **cache_slot = CACHE_ADDR(opline->extended_value);
			uintptr_t prop_offset = (uintptr_t)CACHED_PTR_EX(cache_slot + 1);
			zval *property_val;

			if (EXPECTED(IS_VALID_PROPERTY_OFFSET(prop_offset))) {
				property_val = OBJ_PROP(zobj, prop_offset);
				if (C_TYPE_P(property_val) != IS_UNDEF) {
					crex_property_info *prop_info = (crex_property_info*) CACHED_PTR_EX(cache_slot + 2);

					if (UNEXPECTED(prop_info != NULL)) {
						value = crex_assign_to_typed_prop(prop_info, property_val, value, &garbage EXECUTE_DATA_CC);
						goto free_and_exit_assign_obj;
					} else {
fast_assign_obj:
						value = crex_assign_to_variable_ex(property_val, value, IS_CV, EX_USES_STRICT_TYPES(), &garbage);
						if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
							ZVAL_COPY(EX_VAR(opline->result.var), value);
						}
						goto exit_assign_obj;
					}
				}
			} else {
				name = C_STR_P(_get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC));
				if (EXPECTED(zobj->properties != NULL)) {
					if (UNEXPECTED(GC_REFCOUNT(zobj->properties) > 1)) {
						if (EXPECTED(!(GC_FLAGS(zobj->properties) & IS_ARRAY_IMMUTABLE))) {
							GC_DELREF(zobj->properties);
						}
						zobj->properties = crex_array_dup(zobj->properties);
					}
					property_val = crex_hash_find_known_hash(zobj->properties, name);
					if (property_val) {
						goto fast_assign_obj;
					}
				}

				if (!zobj->ce->__set && (zobj->ce->ce_flags & CREX_ACC_ALLOW_DYNAMIC_PROPERTIES)) {
					if (EXPECTED(zobj->properties == NULL)) {
						rebuild_object_properties(zobj);
					}
					if (IS_CV == IS_CONST) {
						if (UNEXPECTED(C_OPT_REFCOUNTED_P(value))) {
							C_ADDREF_P(value);
						}
					} else if (IS_CV != IS_TMP_VAR) {
						if (C_ISREF_P(value)) {
							if (IS_CV == IS_VAR) {
								crex_reference *ref = C_REF_P(value);
								if (GC_DELREF(ref) == 0) {
									ZVAL_COPY_VALUE(&tmp, C_REFVAL_P(value));
									efree_size(ref, sizeof(crex_reference));
									value = &tmp;
								} else {
									value = C_REFVAL_P(value);
									C_TRY_ADDREF_P(value);
								}
							} else {
								value = C_REFVAL_P(value);
								C_TRY_ADDREF_P(value);
							}
						} else if (IS_CV == IS_CV) {
							C_TRY_ADDREF_P(value);
						}
						}
					crex_hash_add_new(zobj->properties, name, value);
					if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
						ZVAL_COPY(EX_VAR(opline->result.var), value);
					}
					goto exit_assign_obj;
				}
			}
		}
		name = C_STR_P(_get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC));
	} else {
		name = zval_try_get_tmp_string(_get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC), &tmp_name);
		if (UNEXPECTED(!name)) {

			UNDEF_RESULT();
			goto exit_assign_obj;
		}
	}

	if (IS_CV == IS_CV || IS_CV == IS_VAR) {
		ZVAL_DEREF(value);
	}

	value = zobj->handlers->write_property(zobj, name, value, (IS_CV == IS_CONST) ? CACHE_ADDR(opline->extended_value) : NULL);

	if (IS_CV != IS_CONST) {
		crex_tmp_string_release(tmp_name);
	}

free_and_exit_assign_obj:
	if (UNEXPECTED(RETURN_VALUE_USED(opline)) && value) {
		ZVAL_COPY_DEREF(EX_VAR(opline->result.var), value);
	}

exit_assign_obj:
	if (garbage) {
		GC_DTOR_NO_REF(garbage);
	}

	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	/* assign_obj has two opcodes! */
	CREX_VM_NEXT_OPCODE_EX(1, 2);
}

/* No specialization for op_types (CONST|TMPVAR|CV, UNUSED|CONST|VAR) */
static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ASSIGN_DIM_SPEC_VAR_CV_OP_DATA_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *object_ptr, *orig_object_ptr;
	zval *value;
	zval *variable_ptr;
	zval *dim;
	crex_refcounted *garbage = NULL;

	SAVE_OPLINE();
	orig_object_ptr = object_ptr = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);

	if (EXPECTED(C_TYPE_P(object_ptr) == IS_ARRAY)) {
try_assign_dim_array:
		SEPARATE_ARRAY(object_ptr);
		if (IS_CV == IS_UNUSED) {
			value = RT_CONSTANT((opline+1), (opline+1)->op1);
			if (IS_CONST == IS_CV && UNEXPECTED(C_TYPE_P(value) == IS_UNDEF)) {
				HashTable *ht = C_ARRVAL_P(object_ptr);
				if (!(GC_FLAGS(ht) & IS_ARRAY_IMMUTABLE)) {
					GC_ADDREF(ht);
				}
				value = zval_undefined_cv((opline+1)->op1.var EXECUTE_DATA_CC);
				if (!(GC_FLAGS(ht) & IS_ARRAY_IMMUTABLE) && !GC_DELREF(ht)) {
					crex_array_destroy(ht);
					goto assign_dim_error;
				}
			}
			if (IS_CONST == IS_CV || IS_CONST == IS_VAR) {
				ZVAL_DEREF(value);
			}
			value = crex_hash_next_index_insert(C_ARRVAL_P(object_ptr), value);
			if (UNEXPECTED(value == NULL)) {
				crex_cannot_add_element();
				goto assign_dim_error;
			} else if (IS_CONST == IS_CV) {
				if (C_REFCOUNTED_P(value)) {
					C_ADDREF_P(value);
				}
			} else if (IS_CONST == IS_VAR) {
				zval *free_op_data = EX_VAR((opline+1)->op1.var);
				if (C_ISREF_P(free_op_data)) {
					if (C_REFCOUNTED_P(value)) {
						C_ADDREF_P(value);
					}
					zval_ptr_dtor_nogc(free_op_data);
				}
			} else if (IS_CONST == IS_CONST) {
				if (UNEXPECTED(C_REFCOUNTED_P(value))) {
					C_ADDREF_P(value);
				}
			}
		} else {
			dim = EX_VAR(opline->op2.var);
			if (IS_CV == IS_CONST) {
				variable_ptr = crex_fetch_dimension_address_inner_W_CONST(C_ARRVAL_P(object_ptr), dim EXECUTE_DATA_CC);
			} else {
				variable_ptr = crex_fetch_dimension_address_inner_W(C_ARRVAL_P(object_ptr), dim EXECUTE_DATA_CC);
			}
			if (UNEXPECTED(variable_ptr == NULL)) {
				goto assign_dim_error;
			}
			value = RT_CONSTANT((opline+1), (opline+1)->op1);
			value = crex_assign_to_variable_ex(variable_ptr, value, IS_CONST, EX_USES_STRICT_TYPES(), &garbage);
		}
		if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
			ZVAL_COPY(EX_VAR(opline->result.var), value);
		}
		if (garbage) {
			GC_DTOR_NO_REF(garbage);
		}
	} else {
		if (EXPECTED(C_ISREF_P(object_ptr))) {
			object_ptr = C_REFVAL_P(object_ptr);
			if (EXPECTED(C_TYPE_P(object_ptr) == IS_ARRAY)) {
				goto try_assign_dim_array;
			}
		}
		if (EXPECTED(C_TYPE_P(object_ptr) == IS_OBJECT)) {
			crex_object *obj = C_OBJ_P(object_ptr);

			GC_ADDREF(obj);
			dim = EX_VAR(opline->op2.var);
			if (IS_CV == IS_CV && UNEXPECTED(C_ISUNDEF_P(dim))) {
				dim = ZVAL_UNDEFINED_OP2();
			} else if (IS_CV == IS_CONST && C_EXTRA_P(dim) == CREX_EXTRA_VALUE) {
				dim++;
			}

			value = RT_CONSTANT((opline+1), (opline+1)->op1);
			if (IS_CONST == IS_CV && UNEXPECTED(C_ISUNDEF_P(value))) {
				value = zval_undefined_cv((opline+1)->op1.var EXECUTE_DATA_CC);
			} else if (IS_CONST & (IS_CV|IS_VAR)) {
				ZVAL_DEREF(value);
			}

			crex_assign_to_object_dim(obj, dim, value OPLINE_CC EXECUTE_DATA_CC);

			if (UNEXPECTED(GC_DELREF(obj) == 0)) {
				crex_objects_store_del(obj);
			}
		} else if (EXPECTED(C_TYPE_P(object_ptr) == IS_STRING)) {
			if (IS_CV == IS_UNUSED) {
				crex_use_new_element_for_string();

				UNDEF_RESULT();
			} else {
				dim = EX_VAR(opline->op2.var);
				value = RT_CONSTANT((opline+1), (opline+1)->op1);
				crex_assign_to_string_offset(object_ptr, dim, value OPLINE_CC EXECUTE_DATA_CC);

			}
		} else if (EXPECTED(C_TYPE_P(object_ptr) <= IS_FALSE)) {
			if (C_ISREF_P(orig_object_ptr)
			 && CREX_REF_HAS_TYPE_SOURCES(C_REF_P(orig_object_ptr))
			 && !crex_verify_ref_array_assignable(C_REF_P(orig_object_ptr))) {
				dim = _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC);

				UNDEF_RESULT();
			} else {
				HashTable *ht = crex_new_array(8);
				uint8_t old_type = C_TYPE_P(object_ptr);

				ZVAL_ARR(object_ptr, ht);
				if (UNEXPECTED(old_type == IS_FALSE)) {
					GC_ADDREF(ht);
					crex_false_to_array_deprecated();
					if (UNEXPECTED(GC_DELREF(ht) == 0)) {
						crex_array_destroy(ht);
						goto assign_dim_error;
					}
				}
				goto try_assign_dim_array;
			}
		} else {
			crex_use_scalar_as_array();
			dim = _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC);
assign_dim_error:

			if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
				ZVAL_NULL(EX_VAR(opline->result.var));
			}
		}
	}
	if (IS_CV != IS_UNUSED) {

	}
	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	/* assign_dim has two opcodes! */
	CREX_VM_NEXT_OPCODE_EX(1, 2);
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ASSIGN_DIM_SPEC_VAR_CV_OP_DATA_TMP_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *object_ptr, *orig_object_ptr;
	zval *value;
	zval *variable_ptr;
	zval *dim;
	crex_refcounted *garbage = NULL;

	SAVE_OPLINE();
	orig_object_ptr = object_ptr = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);

	if (EXPECTED(C_TYPE_P(object_ptr) == IS_ARRAY)) {
try_assign_dim_array:
		SEPARATE_ARRAY(object_ptr);
		if (IS_CV == IS_UNUSED) {
			value = _get_zval_ptr_tmp((opline+1)->op1.var EXECUTE_DATA_CC);
			if (IS_TMP_VAR == IS_CV && UNEXPECTED(C_TYPE_P(value) == IS_UNDEF)) {
				HashTable *ht = C_ARRVAL_P(object_ptr);
				if (!(GC_FLAGS(ht) & IS_ARRAY_IMMUTABLE)) {
					GC_ADDREF(ht);
				}
				value = zval_undefined_cv((opline+1)->op1.var EXECUTE_DATA_CC);
				if (!(GC_FLAGS(ht) & IS_ARRAY_IMMUTABLE) && !GC_DELREF(ht)) {
					crex_array_destroy(ht);
					goto assign_dim_error;
				}
			}
			if (IS_TMP_VAR == IS_CV || IS_TMP_VAR == IS_VAR) {
				ZVAL_DEREF(value);
			}
			value = crex_hash_next_index_insert(C_ARRVAL_P(object_ptr), value);
			if (UNEXPECTED(value == NULL)) {
				crex_cannot_add_element();
				goto assign_dim_error;
			} else if (IS_TMP_VAR == IS_CV) {
				if (C_REFCOUNTED_P(value)) {
					C_ADDREF_P(value);
				}
			} else if (IS_TMP_VAR == IS_VAR) {
				zval *free_op_data = EX_VAR((opline+1)->op1.var);
				if (C_ISREF_P(free_op_data)) {
					if (C_REFCOUNTED_P(value)) {
						C_ADDREF_P(value);
					}
					zval_ptr_dtor_nogc(free_op_data);
				}
			} else if (IS_TMP_VAR == IS_CONST) {
				if (UNEXPECTED(C_REFCOUNTED_P(value))) {
					C_ADDREF_P(value);
				}
			}
		} else {
			dim = EX_VAR(opline->op2.var);
			if (IS_CV == IS_CONST) {
				variable_ptr = crex_fetch_dimension_address_inner_W_CONST(C_ARRVAL_P(object_ptr), dim EXECUTE_DATA_CC);
			} else {
				variable_ptr = crex_fetch_dimension_address_inner_W(C_ARRVAL_P(object_ptr), dim EXECUTE_DATA_CC);
			}
			if (UNEXPECTED(variable_ptr == NULL)) {
				goto assign_dim_error;
			}
			value = _get_zval_ptr_tmp((opline+1)->op1.var EXECUTE_DATA_CC);
			value = crex_assign_to_variable_ex(variable_ptr, value, IS_TMP_VAR, EX_USES_STRICT_TYPES(), &garbage);
		}
		if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
			ZVAL_COPY(EX_VAR(opline->result.var), value);
		}
		if (garbage) {
			GC_DTOR_NO_REF(garbage);
		}
	} else {
		if (EXPECTED(C_ISREF_P(object_ptr))) {
			object_ptr = C_REFVAL_P(object_ptr);
			if (EXPECTED(C_TYPE_P(object_ptr) == IS_ARRAY)) {
				goto try_assign_dim_array;
			}
		}
		if (EXPECTED(C_TYPE_P(object_ptr) == IS_OBJECT)) {
			crex_object *obj = C_OBJ_P(object_ptr);

			GC_ADDREF(obj);
			dim = EX_VAR(opline->op2.var);
			if (IS_CV == IS_CV && UNEXPECTED(C_ISUNDEF_P(dim))) {
				dim = ZVAL_UNDEFINED_OP2();
			} else if (IS_CV == IS_CONST && C_EXTRA_P(dim) == CREX_EXTRA_VALUE) {
				dim++;
			}

			value = _get_zval_ptr_tmp((opline+1)->op1.var EXECUTE_DATA_CC);
			if (IS_TMP_VAR == IS_CV && UNEXPECTED(C_ISUNDEF_P(value))) {
				value = zval_undefined_cv((opline+1)->op1.var EXECUTE_DATA_CC);
			} else if (IS_TMP_VAR & (IS_CV|IS_VAR)) {
				ZVAL_DEREF(value);
			}

			crex_assign_to_object_dim(obj, dim, value OPLINE_CC EXECUTE_DATA_CC);

			zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
			if (UNEXPECTED(GC_DELREF(obj) == 0)) {
				crex_objects_store_del(obj);
			}
		} else if (EXPECTED(C_TYPE_P(object_ptr) == IS_STRING)) {
			if (IS_CV == IS_UNUSED) {
				crex_use_new_element_for_string();
				zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
				UNDEF_RESULT();
			} else {
				dim = EX_VAR(opline->op2.var);
				value = _get_zval_ptr_tmp((opline+1)->op1.var EXECUTE_DATA_CC);
				crex_assign_to_string_offset(object_ptr, dim, value OPLINE_CC EXECUTE_DATA_CC);
				zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
			}
		} else if (EXPECTED(C_TYPE_P(object_ptr) <= IS_FALSE)) {
			if (C_ISREF_P(orig_object_ptr)
			 && CREX_REF_HAS_TYPE_SOURCES(C_REF_P(orig_object_ptr))
			 && !crex_verify_ref_array_assignable(C_REF_P(orig_object_ptr))) {
				dim = _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC);
				zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
				UNDEF_RESULT();
			} else {
				HashTable *ht = crex_new_array(8);
				uint8_t old_type = C_TYPE_P(object_ptr);

				ZVAL_ARR(object_ptr, ht);
				if (UNEXPECTED(old_type == IS_FALSE)) {
					GC_ADDREF(ht);
					crex_false_to_array_deprecated();
					if (UNEXPECTED(GC_DELREF(ht) == 0)) {
						crex_array_destroy(ht);
						goto assign_dim_error;
					}
				}
				goto try_assign_dim_array;
			}
		} else {
			crex_use_scalar_as_array();
			dim = _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC);
assign_dim_error:
			zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
			if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
				ZVAL_NULL(EX_VAR(opline->result.var));
			}
		}
	}
	if (IS_CV != IS_UNUSED) {

	}
	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	/* assign_dim has two opcodes! */
	CREX_VM_NEXT_OPCODE_EX(1, 2);
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ASSIGN_DIM_SPEC_VAR_CV_OP_DATA_VAR_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *object_ptr, *orig_object_ptr;
	zval *value;
	zval *variable_ptr;
	zval *dim;
	crex_refcounted *garbage = NULL;

	SAVE_OPLINE();
	orig_object_ptr = object_ptr = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);

	if (EXPECTED(C_TYPE_P(object_ptr) == IS_ARRAY)) {
try_assign_dim_array:
		SEPARATE_ARRAY(object_ptr);
		if (IS_CV == IS_UNUSED) {
			value = _get_zval_ptr_var((opline+1)->op1.var EXECUTE_DATA_CC);
			if (IS_VAR == IS_CV && UNEXPECTED(C_TYPE_P(value) == IS_UNDEF)) {
				HashTable *ht = C_ARRVAL_P(object_ptr);
				if (!(GC_FLAGS(ht) & IS_ARRAY_IMMUTABLE)) {
					GC_ADDREF(ht);
				}
				value = zval_undefined_cv((opline+1)->op1.var EXECUTE_DATA_CC);
				if (!(GC_FLAGS(ht) & IS_ARRAY_IMMUTABLE) && !GC_DELREF(ht)) {
					crex_array_destroy(ht);
					goto assign_dim_error;
				}
			}
			if (IS_VAR == IS_CV || IS_VAR == IS_VAR) {
				ZVAL_DEREF(value);
			}
			value = crex_hash_next_index_insert(C_ARRVAL_P(object_ptr), value);
			if (UNEXPECTED(value == NULL)) {
				crex_cannot_add_element();
				goto assign_dim_error;
			} else if (IS_VAR == IS_CV) {
				if (C_REFCOUNTED_P(value)) {
					C_ADDREF_P(value);
				}
			} else if (IS_VAR == IS_VAR) {
				zval *free_op_data = EX_VAR((opline+1)->op1.var);
				if (C_ISREF_P(free_op_data)) {
					if (C_REFCOUNTED_P(value)) {
						C_ADDREF_P(value);
					}
					zval_ptr_dtor_nogc(free_op_data);
				}
			} else if (IS_VAR == IS_CONST) {
				if (UNEXPECTED(C_REFCOUNTED_P(value))) {
					C_ADDREF_P(value);
				}
			}
		} else {
			dim = EX_VAR(opline->op2.var);
			if (IS_CV == IS_CONST) {
				variable_ptr = crex_fetch_dimension_address_inner_W_CONST(C_ARRVAL_P(object_ptr), dim EXECUTE_DATA_CC);
			} else {
				variable_ptr = crex_fetch_dimension_address_inner_W(C_ARRVAL_P(object_ptr), dim EXECUTE_DATA_CC);
			}
			if (UNEXPECTED(variable_ptr == NULL)) {
				goto assign_dim_error;
			}
			value = _get_zval_ptr_var((opline+1)->op1.var EXECUTE_DATA_CC);
			value = crex_assign_to_variable_ex(variable_ptr, value, IS_VAR, EX_USES_STRICT_TYPES(), &garbage);
		}
		if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
			ZVAL_COPY(EX_VAR(opline->result.var), value);
		}
		if (garbage) {
			GC_DTOR_NO_REF(garbage);
		}
	} else {
		if (EXPECTED(C_ISREF_P(object_ptr))) {
			object_ptr = C_REFVAL_P(object_ptr);
			if (EXPECTED(C_TYPE_P(object_ptr) == IS_ARRAY)) {
				goto try_assign_dim_array;
			}
		}
		if (EXPECTED(C_TYPE_P(object_ptr) == IS_OBJECT)) {
			crex_object *obj = C_OBJ_P(object_ptr);

			GC_ADDREF(obj);
			dim = EX_VAR(opline->op2.var);
			if (IS_CV == IS_CV && UNEXPECTED(C_ISUNDEF_P(dim))) {
				dim = ZVAL_UNDEFINED_OP2();
			} else if (IS_CV == IS_CONST && C_EXTRA_P(dim) == CREX_EXTRA_VALUE) {
				dim++;
			}

			value = _get_zval_ptr_var((opline+1)->op1.var EXECUTE_DATA_CC);
			if (IS_VAR == IS_CV && UNEXPECTED(C_ISUNDEF_P(value))) {
				value = zval_undefined_cv((opline+1)->op1.var EXECUTE_DATA_CC);
			} else if (IS_VAR & (IS_CV|IS_VAR)) {
				ZVAL_DEREF(value);
			}

			crex_assign_to_object_dim(obj, dim, value OPLINE_CC EXECUTE_DATA_CC);

			zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
			if (UNEXPECTED(GC_DELREF(obj) == 0)) {
				crex_objects_store_del(obj);
			}
		} else if (EXPECTED(C_TYPE_P(object_ptr) == IS_STRING)) {
			if (IS_CV == IS_UNUSED) {
				crex_use_new_element_for_string();
				zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
				UNDEF_RESULT();
			} else {
				dim = EX_VAR(opline->op2.var);
				value = _get_zval_ptr_var((opline+1)->op1.var EXECUTE_DATA_CC);
				crex_assign_to_string_offset(object_ptr, dim, value OPLINE_CC EXECUTE_DATA_CC);
				zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
			}
		} else if (EXPECTED(C_TYPE_P(object_ptr) <= IS_FALSE)) {
			if (C_ISREF_P(orig_object_ptr)
			 && CREX_REF_HAS_TYPE_SOURCES(C_REF_P(orig_object_ptr))
			 && !crex_verify_ref_array_assignable(C_REF_P(orig_object_ptr))) {
				dim = _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC);
				zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
				UNDEF_RESULT();
			} else {
				HashTable *ht = crex_new_array(8);
				uint8_t old_type = C_TYPE_P(object_ptr);

				ZVAL_ARR(object_ptr, ht);
				if (UNEXPECTED(old_type == IS_FALSE)) {
					GC_ADDREF(ht);
					crex_false_to_array_deprecated();
					if (UNEXPECTED(GC_DELREF(ht) == 0)) {
						crex_array_destroy(ht);
						goto assign_dim_error;
					}
				}
				goto try_assign_dim_array;
			}
		} else {
			crex_use_scalar_as_array();
			dim = _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC);
assign_dim_error:
			zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
			if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
				ZVAL_NULL(EX_VAR(opline->result.var));
			}
		}
	}
	if (IS_CV != IS_UNUSED) {

	}
	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	/* assign_dim has two opcodes! */
	CREX_VM_NEXT_OPCODE_EX(1, 2);
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ASSIGN_DIM_SPEC_VAR_CV_OP_DATA_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *object_ptr, *orig_object_ptr;
	zval *value;
	zval *variable_ptr;
	zval *dim;
	crex_refcounted *garbage = NULL;

	SAVE_OPLINE();
	orig_object_ptr = object_ptr = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);

	if (EXPECTED(C_TYPE_P(object_ptr) == IS_ARRAY)) {
try_assign_dim_array:
		SEPARATE_ARRAY(object_ptr);
		if (IS_CV == IS_UNUSED) {
			value = EX_VAR((opline+1)->op1.var);
			if (IS_CV == IS_CV && UNEXPECTED(C_TYPE_P(value) == IS_UNDEF)) {
				HashTable *ht = C_ARRVAL_P(object_ptr);
				if (!(GC_FLAGS(ht) & IS_ARRAY_IMMUTABLE)) {
					GC_ADDREF(ht);
				}
				value = zval_undefined_cv((opline+1)->op1.var EXECUTE_DATA_CC);
				if (!(GC_FLAGS(ht) & IS_ARRAY_IMMUTABLE) && !GC_DELREF(ht)) {
					crex_array_destroy(ht);
					goto assign_dim_error;
				}
			}
			if (IS_CV == IS_CV || IS_CV == IS_VAR) {
				ZVAL_DEREF(value);
			}
			value = crex_hash_next_index_insert(C_ARRVAL_P(object_ptr), value);
			if (UNEXPECTED(value == NULL)) {
				crex_cannot_add_element();
				goto assign_dim_error;
			} else if (IS_CV == IS_CV) {
				if (C_REFCOUNTED_P(value)) {
					C_ADDREF_P(value);
				}
			} else if (IS_CV == IS_VAR) {
				zval *free_op_data = EX_VAR((opline+1)->op1.var);
				if (C_ISREF_P(free_op_data)) {
					if (C_REFCOUNTED_P(value)) {
						C_ADDREF_P(value);
					}
					zval_ptr_dtor_nogc(free_op_data);
				}
			} else if (IS_CV == IS_CONST) {
				if (UNEXPECTED(C_REFCOUNTED_P(value))) {
					C_ADDREF_P(value);
				}
			}
		} else {
			dim = EX_VAR(opline->op2.var);
			if (IS_CV == IS_CONST) {
				variable_ptr = crex_fetch_dimension_address_inner_W_CONST(C_ARRVAL_P(object_ptr), dim EXECUTE_DATA_CC);
			} else {
				variable_ptr = crex_fetch_dimension_address_inner_W(C_ARRVAL_P(object_ptr), dim EXECUTE_DATA_CC);
			}
			if (UNEXPECTED(variable_ptr == NULL)) {
				goto assign_dim_error;
			}
			value = _get_zval_ptr_cv_BP_VAR_R((opline+1)->op1.var EXECUTE_DATA_CC);
			value = crex_assign_to_variable_ex(variable_ptr, value, IS_CV, EX_USES_STRICT_TYPES(), &garbage);
		}
		if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
			ZVAL_COPY(EX_VAR(opline->result.var), value);
		}
		if (garbage) {
			GC_DTOR_NO_REF(garbage);
		}
	} else {
		if (EXPECTED(C_ISREF_P(object_ptr))) {
			object_ptr = C_REFVAL_P(object_ptr);
			if (EXPECTED(C_TYPE_P(object_ptr) == IS_ARRAY)) {
				goto try_assign_dim_array;
			}
		}
		if (EXPECTED(C_TYPE_P(object_ptr) == IS_OBJECT)) {
			crex_object *obj = C_OBJ_P(object_ptr);

			GC_ADDREF(obj);
			dim = EX_VAR(opline->op2.var);
			if (IS_CV == IS_CV && UNEXPECTED(C_ISUNDEF_P(dim))) {
				dim = ZVAL_UNDEFINED_OP2();
			} else if (IS_CV == IS_CONST && C_EXTRA_P(dim) == CREX_EXTRA_VALUE) {
				dim++;
			}

			value = EX_VAR((opline+1)->op1.var);
			if (IS_CV == IS_CV && UNEXPECTED(C_ISUNDEF_P(value))) {
				value = zval_undefined_cv((opline+1)->op1.var EXECUTE_DATA_CC);
			} else if (IS_CV & (IS_CV|IS_VAR)) {
				ZVAL_DEREF(value);
			}

			crex_assign_to_object_dim(obj, dim, value OPLINE_CC EXECUTE_DATA_CC);

			if (UNEXPECTED(GC_DELREF(obj) == 0)) {
				crex_objects_store_del(obj);
			}
		} else if (EXPECTED(C_TYPE_P(object_ptr) == IS_STRING)) {
			if (IS_CV == IS_UNUSED) {
				crex_use_new_element_for_string();

				UNDEF_RESULT();
			} else {
				dim = EX_VAR(opline->op2.var);
				value = EX_VAR((opline+1)->op1.var);
				crex_assign_to_string_offset(object_ptr, dim, value OPLINE_CC EXECUTE_DATA_CC);

			}
		} else if (EXPECTED(C_TYPE_P(object_ptr) <= IS_FALSE)) {
			if (C_ISREF_P(orig_object_ptr)
			 && CREX_REF_HAS_TYPE_SOURCES(C_REF_P(orig_object_ptr))
			 && !crex_verify_ref_array_assignable(C_REF_P(orig_object_ptr))) {
				dim = _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC);

				UNDEF_RESULT();
			} else {
				HashTable *ht = crex_new_array(8);
				uint8_t old_type = C_TYPE_P(object_ptr);

				ZVAL_ARR(object_ptr, ht);
				if (UNEXPECTED(old_type == IS_FALSE)) {
					GC_ADDREF(ht);
					crex_false_to_array_deprecated();
					if (UNEXPECTED(GC_DELREF(ht) == 0)) {
						crex_array_destroy(ht);
						goto assign_dim_error;
					}
				}
				goto try_assign_dim_array;
			}
		} else {
			crex_use_scalar_as_array();
			dim = _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC);
assign_dim_error:

			if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
				ZVAL_NULL(EX_VAR(opline->result.var));
			}
		}
	}
	if (IS_CV != IS_UNUSED) {

	}
	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	/* assign_dim has two opcodes! */
	CREX_VM_NEXT_OPCODE_EX(1, 2);
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ASSIGN_SPEC_VAR_CV_RETVAL_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *value;
	zval *variable_ptr;

	SAVE_OPLINE();
	value = _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC);
	variable_ptr = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);

	if (0 || UNEXPECTED(0)) {
		crex_refcounted *garbage = NULL;

		value = crex_assign_to_variable_ex(variable_ptr, value, IS_CV, EX_USES_STRICT_TYPES(), &garbage);
		if (UNEXPECTED(0)) {
			ZVAL_COPY(EX_VAR(opline->result.var), value);
		}
		if (garbage) {
			GC_DTOR_NO_REF(garbage);
		}
	} else {
		value = crex_assign_to_variable(variable_ptr, value, IS_CV, EX_USES_STRICT_TYPES());
	}
	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	/* crex_assign_to_variable() always takes care of op2, never free it! */

	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ASSIGN_SPEC_VAR_CV_RETVAL_USED_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *value;
	zval *variable_ptr;

	SAVE_OPLINE();
	value = _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC);
	variable_ptr = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);

	if (0 || UNEXPECTED(1)) {
		crex_refcounted *garbage = NULL;

		value = crex_assign_to_variable_ex(variable_ptr, value, IS_CV, EX_USES_STRICT_TYPES(), &garbage);
		if (UNEXPECTED(1)) {
			ZVAL_COPY(EX_VAR(opline->result.var), value);
		}
		if (garbage) {
			GC_DTOR_NO_REF(garbage);
		}
	} else {
		value = crex_assign_to_variable(variable_ptr, value, IS_CV, EX_USES_STRICT_TYPES());
	}
	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	/* crex_assign_to_variable() always takes care of op2, never free it! */

	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ASSIGN_REF_SPEC_VAR_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *variable_ptr;
	zval *value_ptr;
	crex_refcounted *garbage = NULL;

	SAVE_OPLINE();
	value_ptr = _get_zval_ptr_cv_BP_VAR_W(opline->op2.var EXECUTE_DATA_CC);
	variable_ptr = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);

	if (IS_VAR == IS_VAR &&
	           UNEXPECTED(C_TYPE_P(EX_VAR(opline->op1.var)) != IS_INDIRECT)) {

		crex_throw_error(NULL, "Cannot assign by reference to an array dimension of an object");
		variable_ptr = &EG(uninitialized_zval);
	} else if (IS_CV == IS_VAR &&
	           opline->extended_value == CREX_RETURNS_FUNCTION &&
			   UNEXPECTED(!C_ISREF_P(value_ptr))) {

		variable_ptr = crex_wrong_assign_to_variable_reference(
			variable_ptr, value_ptr, &garbage OPLINE_CC EXECUTE_DATA_CC);
	} else {
		crex_assign_to_variable_reference(variable_ptr, value_ptr, &garbage);
	}

	if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
		ZVAL_COPY(EX_VAR(opline->result.var), variable_ptr);
	}

	if (garbage) {
		GC_DTOR(garbage);
	}

	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ASSIGN_OBJ_REF_SPEC_VAR_CV_OP_DATA_VAR_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *property, *container, *value_ptr;

	SAVE_OPLINE();

	container = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	property = _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC);

	value_ptr = _get_zval_ptr_ptr_var((opline+1)->op1.var EXECUTE_DATA_CC);

	if (1) {
		if (IS_VAR == IS_UNUSED) {
			if (IS_CV == IS_CONST) {
				crex_assign_to_property_reference_this_const(container, property, value_ptr OPLINE_CC EXECUTE_DATA_CC);
			} else {
				crex_assign_to_property_reference_this_var(container, property, value_ptr OPLINE_CC EXECUTE_DATA_CC);
			}
		} else {
			if (IS_CV == IS_CONST) {
				crex_assign_to_property_reference_var_const(container, property, value_ptr OPLINE_CC EXECUTE_DATA_CC);
			} else {
				crex_assign_to_property_reference_var_var(container, property, value_ptr OPLINE_CC EXECUTE_DATA_CC);
			}
		}
	} else {
		crex_assign_to_property_reference(container, IS_VAR, property, IS_CV, value_ptr OPLINE_CC EXECUTE_DATA_CC);
	}

	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));

	zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
	CREX_VM_NEXT_OPCODE_EX(1, 2);
}

/* No specialization for op_types (CONST|TMPVAR|CV, UNUSED|CONST|VAR) */
static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ASSIGN_OBJ_REF_SPEC_VAR_CV_OP_DATA_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *property, *container, *value_ptr;

	SAVE_OPLINE();

	container = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	property = _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC);

	value_ptr = _get_zval_ptr_cv_BP_VAR_W((opline+1)->op1.var EXECUTE_DATA_CC);

	if (1) {
		if (IS_VAR == IS_UNUSED) {
			if (IS_CV == IS_CONST) {
				crex_assign_to_property_reference_this_const(container, property, value_ptr OPLINE_CC EXECUTE_DATA_CC);
			} else {
				crex_assign_to_property_reference_this_var(container, property, value_ptr OPLINE_CC EXECUTE_DATA_CC);
			}
		} else {
			if (IS_CV == IS_CONST) {
				crex_assign_to_property_reference_var_const(container, property, value_ptr OPLINE_CC EXECUTE_DATA_CC);
			} else {
				crex_assign_to_property_reference_var_var(container, property, value_ptr OPLINE_CC EXECUTE_DATA_CC);
			}
		}
	} else {
		crex_assign_to_property_reference(container, IS_VAR, property, IS_CV, value_ptr OPLINE_CC EXECUTE_DATA_CC);
	}

	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));


	CREX_VM_NEXT_OPCODE_EX(1, 2);
}

/* No specialization for op_types (CONST|TMPVAR|CV, UNUSED|CONST|VAR) */
static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_INIT_STATIC_METHOD_CALL_SPEC_VAR_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *function_name;
	crex_class_entry *ce;
	uint32_t call_info;
	crex_function *fbc;
	crex_execute_data *call;

	SAVE_OPLINE();

	if (IS_VAR == IS_CONST) {
		/* no function found. try a static method in class */
		ce = CACHED_PTR(opline->result.num);
		if (UNEXPECTED(ce == NULL)) {
			ce = crex_fetch_class_by_name(C_STR_P(RT_CONSTANT(opline, opline->op1)), C_STR_P(RT_CONSTANT(opline, opline->op1) + 1), CREX_FETCH_CLASS_DEFAULT | CREX_FETCH_CLASS_EXCEPTION);
			if (UNEXPECTED(ce == NULL)) {

				HANDLE_EXCEPTION();
			}
			if (IS_CV != IS_CONST) {
				CACHE_PTR(opline->result.num, ce);
			}
		}
	} else if (IS_VAR == IS_UNUSED) {
		ce = crex_fetch_class(NULL, opline->op1.num);
		if (UNEXPECTED(ce == NULL)) {

			HANDLE_EXCEPTION();
		}
	} else {
		ce = C_CE_P(EX_VAR(opline->op1.var));
	}

	if (IS_VAR == IS_CONST &&
	    IS_CV == IS_CONST &&
	    EXPECTED((fbc = CACHED_PTR(opline->result.num + sizeof(void*))) != NULL)) {
		/* nothing to do */
	} else if (IS_VAR != IS_CONST &&
	           IS_CV == IS_CONST &&
	           EXPECTED(CACHED_PTR(opline->result.num) == ce)) {
		fbc = CACHED_PTR(opline->result.num + sizeof(void*));
	} else if (IS_CV != IS_UNUSED) {
		function_name = EX_VAR(opline->op2.var);
		if (IS_CV != IS_CONST) {
			if (UNEXPECTED(C_TYPE_P(function_name) != IS_STRING)) {
				do {
					if (IS_CV & (IS_VAR|IS_CV) && C_ISREF_P(function_name)) {
						function_name = C_REFVAL_P(function_name);
						if (EXPECTED(C_TYPE_P(function_name) == IS_STRING)) {
							break;
						}
					} else if (IS_CV == IS_CV && UNEXPECTED(C_TYPE_P(function_name) == IS_UNDEF)) {
						ZVAL_UNDEFINED_OP2();
						if (UNEXPECTED(EG(exception) != NULL)) {
							HANDLE_EXCEPTION();
						}
					}
					crex_throw_error(NULL, "Method name must be a string");

					HANDLE_EXCEPTION();
				} while (0);
			}
		}

		if (ce->get_static_method) {
			fbc = ce->get_static_method(ce, C_STR_P(function_name));
		} else {
			fbc = crex_std_get_static_method(ce, C_STR_P(function_name), ((IS_CV == IS_CONST) ? (RT_CONSTANT(opline, opline->op2) + 1) : NULL));
		}
		if (UNEXPECTED(fbc == NULL)) {
			if (EXPECTED(!EG(exception))) {
				crex_undefined_method(ce, C_STR_P(function_name));
			}

			HANDLE_EXCEPTION();
		}
		if (IS_CV == IS_CONST &&
		    EXPECTED(!(fbc->common.fn_flags & (CREX_ACC_CALL_VIA_TRAMPOLINE|CREX_ACC_NEVER_CACHE))) &&
			EXPECTED(!(fbc->common.scope->ce_flags & CREX_ACC_TRAIT))) {
			CACHE_POLYMORPHIC_PTR(opline->result.num, ce, fbc);
		}
		if (EXPECTED(fbc->type == CREX_USER_FUNCTION) && UNEXPECTED(!RUN_TIME_CACHE(&fbc->op_array))) {
			init_func_run_time_cache(&fbc->op_array);
		}
		if (IS_CV != IS_CONST) {

		}
	} else {
		if (UNEXPECTED(ce->constructor == NULL)) {
			crex_throw_error(NULL, "Cannot call constructor");
			HANDLE_EXCEPTION();
		}
		if (C_TYPE(EX(This)) == IS_OBJECT && C_OBJ(EX(This))->ce != ce->constructor->common.scope && (ce->constructor->common.fn_flags & CREX_ACC_PRIVATE)) {
			crex_throw_error(NULL, "Cannot call private %s::__main()", ZSTR_VAL(ce->name));
			HANDLE_EXCEPTION();
		}
		fbc = ce->constructor;
		if (EXPECTED(fbc->type == CREX_USER_FUNCTION) && UNEXPECTED(!RUN_TIME_CACHE(&fbc->op_array))) {
			init_func_run_time_cache(&fbc->op_array);
		}
	}

	if (!(fbc->common.fn_flags & CREX_ACC_STATIC)) {
		if (C_TYPE(EX(This)) == IS_OBJECT && instanceof_function(C_OBJCE(EX(This)), ce)) {
			ce = (crex_class_entry*)C_OBJ(EX(This));
			call_info = CREX_CALL_NESTED_FUNCTION | CREX_CALL_HAS_THIS;
		} else {
			crex_non_static_method_call(fbc);
			HANDLE_EXCEPTION();
		}
	} else {
		/* previous opcode is CREX_FETCH_CLASS */
		if (IS_VAR == IS_UNUSED
		 && ((opline->op1.num & CREX_FETCH_CLASS_MASK) == CREX_FETCH_CLASS_PARENT ||
		     (opline->op1.num & CREX_FETCH_CLASS_MASK) == CREX_FETCH_CLASS_SELF)) {
			if (C_TYPE(EX(This)) == IS_OBJECT) {
				ce = C_OBJCE(EX(This));
			} else {
				ce = C_CE(EX(This));
			}
		}
		call_info = CREX_CALL_NESTED_FUNCTION;
	}

	call = crex_vm_stack_push_call_frame(call_info,
		fbc, opline->extended_value, ce);
	call->prev_execute_data = EX(call);
	EX(call) = call;

	CREX_VM_NEXT_OPCODE();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ADD_ARRAY_ELEMENT_SPEC_VAR_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *expr_ptr, new_expr;

	SAVE_OPLINE();
	if ((IS_VAR == IS_VAR || IS_VAR == IS_CV) &&
	    UNEXPECTED(opline->extended_value & CREX_ARRAY_ELEMENT_REF)) {
		expr_ptr = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);
		if (C_ISREF_P(expr_ptr)) {
			C_ADDREF_P(expr_ptr);
		} else {
			ZVAL_MAKE_REF_EX(expr_ptr, 2);
		}
		zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	} else {
		expr_ptr = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);
		if (IS_VAR == IS_TMP_VAR) {
			/* pass */
		} else if (IS_VAR == IS_CONST) {
			C_TRY_ADDREF_P(expr_ptr);
		} else if (IS_VAR == IS_CV) {
			ZVAL_DEREF(expr_ptr);
			C_TRY_ADDREF_P(expr_ptr);
		} else /* if (IS_VAR == IS_VAR) */ {
			if (UNEXPECTED(C_ISREF_P(expr_ptr))) {
				crex_refcounted *ref = C_COUNTED_P(expr_ptr);

				expr_ptr = C_REFVAL_P(expr_ptr);
				if (UNEXPECTED(GC_DELREF(ref) == 0)) {
					ZVAL_COPY_VALUE(&new_expr, expr_ptr);
					expr_ptr = &new_expr;
					efree_size(ref, sizeof(crex_reference));
				} else if (C_OPT_REFCOUNTED_P(expr_ptr)) {
					C_ADDREF_P(expr_ptr);
				}
			}
		}
	}

	if (IS_CV != IS_UNUSED) {
		zval *offset = EX_VAR(opline->op2.var);
		crex_string *str;
		crex_ulong hval;

add_again:
		if (EXPECTED(C_TYPE_P(offset) == IS_STRING)) {
			str = C_STR_P(offset);
			if (IS_CV != IS_CONST) {
				if (CREX_HANDLE_NUMERIC(str, hval)) {
					goto num_index;
				}
			}
str_index:
			crex_hash_update(C_ARRVAL_P(EX_VAR(opline->result.var)), str, expr_ptr);
		} else if (EXPECTED(C_TYPE_P(offset) == IS_LONG)) {
			hval = C_LVAL_P(offset);
num_index:
			crex_hash_index_update(C_ARRVAL_P(EX_VAR(opline->result.var)), hval, expr_ptr);
		} else if ((IS_CV & (IS_VAR|IS_CV)) && EXPECTED(C_TYPE_P(offset) == IS_REFERENCE)) {
			offset = C_REFVAL_P(offset);
			goto add_again;
		} else if (C_TYPE_P(offset) == IS_NULL) {
			str = ZSTR_EMPTY_ALLOC();
			goto str_index;
		} else if (C_TYPE_P(offset) == IS_DOUBLE) {
			hval = crex_dval_to_lval_safe(C_DVAL_P(offset));
			goto num_index;
		} else if (C_TYPE_P(offset) == IS_FALSE) {
			hval = 0;
			goto num_index;
		} else if (C_TYPE_P(offset) == IS_TRUE) {
			hval = 1;
			goto num_index;
		} else if (C_TYPE_P(offset) == IS_RESOURCE) {
			crex_use_resource_as_offset(offset);
			hval = C_RES_HANDLE_P(offset);
			goto num_index;
		} else if (IS_CV == IS_CV && C_TYPE_P(offset) == IS_UNDEF) {
			ZVAL_UNDEFINED_OP2();
			str = ZSTR_EMPTY_ALLOC();
			goto str_index;
		} else {
			crex_illegal_array_offset_access(offset);
			zval_ptr_dtor_nogc(expr_ptr);
		}

	} else {
		if (!crex_hash_next_index_insert(C_ARRVAL_P(EX_VAR(opline->result.var)), expr_ptr)) {
			crex_cannot_add_element();
			zval_ptr_dtor_nogc(expr_ptr);
		}
	}
	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_INIT_ARRAY_SPEC_VAR_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	zval *array;
	uint32_t size;
	USE_OPLINE

	array = EX_VAR(opline->result.var);
	if (IS_VAR != IS_UNUSED) {
		size = opline->extended_value >> CREX_ARRAY_SIZE_SHIFT;
		ZVAL_ARR(array, crex_new_array(size));
		/* Explicitly initialize array as not-packed if flag is set */
		if (opline->extended_value & CREX_ARRAY_NOT_PACKED) {
			crex_hash_real_init_mixed(C_ARRVAL_P(array));
		}
		CREX_VM_TAIL_CALL(CREX_ADD_ARRAY_ELEMENT_SPEC_VAR_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU));
	} else {
		ZVAL_ARR(array, crex_new_array(0));
		CREX_VM_NEXT_OPCODE();
	}
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_UNSET_DIM_SPEC_VAR_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;
	zval *offset;
	crex_ulong hval;
	crex_string *key;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	offset = EX_VAR(opline->op2.var);

	do {
		if (EXPECTED(C_TYPE_P(container) == IS_ARRAY)) {
			HashTable *ht;

unset_dim_array:
			SEPARATE_ARRAY(container);
			ht = C_ARRVAL_P(container);
offset_again:
			if (EXPECTED(C_TYPE_P(offset) == IS_STRING)) {
				key = C_STR_P(offset);
				if (IS_CV != IS_CONST) {
					if (CREX_HANDLE_NUMERIC(key, hval)) {
						goto num_index_dim;
					}
				}
str_index_dim:
				CREX_ASSERT(ht != &EG(symbol_table));
				crex_hash_del(ht, key);
			} else if (EXPECTED(C_TYPE_P(offset) == IS_LONG)) {
				hval = C_LVAL_P(offset);
num_index_dim:
				crex_hash_index_del(ht, hval);
			} else if ((IS_CV & (IS_VAR|IS_CV)) && EXPECTED(C_TYPE_P(offset) == IS_REFERENCE)) {
				offset = C_REFVAL_P(offset);
				goto offset_again;
			} else if (C_TYPE_P(offset) == IS_DOUBLE) {
				hval = crex_dval_to_lval_safe(C_DVAL_P(offset));
				goto num_index_dim;
			} else if (C_TYPE_P(offset) == IS_NULL) {
				key = ZSTR_EMPTY_ALLOC();
				goto str_index_dim;
			} else if (C_TYPE_P(offset) == IS_FALSE) {
				hval = 0;
				goto num_index_dim;
			} else if (C_TYPE_P(offset) == IS_TRUE) {
				hval = 1;
				goto num_index_dim;
			} else if (C_TYPE_P(offset) == IS_RESOURCE) {
				crex_use_resource_as_offset(offset);
				hval = C_RES_HANDLE_P(offset);
				goto num_index_dim;
			} else if (IS_CV == IS_CV && C_TYPE_P(offset) == IS_UNDEF) {
				ZVAL_UNDEFINED_OP2();
				key = ZSTR_EMPTY_ALLOC();
				goto str_index_dim;
			} else {
				crex_illegal_array_offset_unset(offset);
			}
			break;
		} else if (C_ISREF_P(container)) {
			container = C_REFVAL_P(container);
			if (EXPECTED(C_TYPE_P(container) == IS_ARRAY)) {
				goto unset_dim_array;
			}
		}
		if (IS_VAR == IS_CV && UNEXPECTED(C_TYPE_P(container) == IS_UNDEF)) {
			container = ZVAL_UNDEFINED_OP1();
		}
		if (IS_CV == IS_CV && UNEXPECTED(C_TYPE_P(offset) == IS_UNDEF)) {
			offset = ZVAL_UNDEFINED_OP2();
		}
		if (EXPECTED(C_TYPE_P(container) == IS_OBJECT)) {
			if (IS_CV == IS_CONST && C_EXTRA_P(offset) == CREX_EXTRA_VALUE) {
				offset++;
			}
			C_OBJ_HT_P(container)->unset_dimension(C_OBJ_P(container), offset);
		} else if (UNEXPECTED(C_TYPE_P(container) == IS_STRING)) {
			crex_throw_error(NULL, "Cannot unset string offsets");
		} else if (UNEXPECTED(C_TYPE_P(container) > IS_FALSE)) {
			crex_throw_error(NULL, "Cannot unset offset in a non-array variable");
		} else if (UNEXPECTED(C_TYPE_P(container) == IS_FALSE)) {
			crex_false_to_array_deprecated();
		}
	} while (0);

	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_UNSET_OBJ_SPEC_VAR_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;
	zval *offset;
	crex_string *name, *tmp_name;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	offset = _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC);

	do {
		if (IS_VAR != IS_UNUSED && UNEXPECTED(C_TYPE_P(container) != IS_OBJECT)) {
			if (C_ISREF_P(container)) {
				container = C_REFVAL_P(container);
				if (C_TYPE_P(container) != IS_OBJECT) {
					if (IS_VAR == IS_CV
					 && UNEXPECTED(C_TYPE_P(container) == IS_UNDEF)) {
						ZVAL_UNDEFINED_OP1();
					}
					break;
				}
			} else {
				break;
			}
		}
		if (IS_CV == IS_CONST) {
			name = C_STR_P(offset);
		} else {
			name = zval_try_get_tmp_string(offset, &tmp_name);
			if (UNEXPECTED(!name)) {
				break;
			}
		}
		C_OBJ_HT_P(container)->unset_property(C_OBJ_P(container), name, ((IS_CV == IS_CONST) ? CACHE_ADDR(opline->extended_value) : NULL));
		if (IS_CV != IS_CONST) {
			crex_tmp_string_release(tmp_name);
		}
	} while (0);

	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_YIELD_SPEC_VAR_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	crex_generator *generator = crex_get_running_generator(EXECUTE_DATA_C);

	SAVE_OPLINE();
	if (UNEXPECTED(generator->flags & CREX_GENERATOR_FORCED_CLOSE)) {
		CREX_VM_TAIL_CALL(crex_yield_in_closed_generator_helper_SPEC(CREX_OPCODE_HANDLER_ARGS_PASSTHRU));
	}

	/* Destroy the previously yielded value */
	zval_ptr_dtor(&generator->value);

	/* Destroy the previously yielded key */
	zval_ptr_dtor(&generator->key);

	/* Set the new yielded value */
	if (IS_VAR != IS_UNUSED) {
		if (UNEXPECTED(EX(func)->op_array.fn_flags & CREX_ACC_RETURN_REFERENCE)) {
			/* Constants and temporary variables aren't yieldable by reference,
			 * but we still allow them with a notice. */
			if (IS_VAR & (IS_CONST|IS_TMP_VAR)) {
				zval *value;

				crex_error(E_NOTICE, "Only variable references should be yielded by reference");

				value = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);
				ZVAL_COPY_VALUE(&generator->value, value);
				if (IS_VAR == IS_CONST) {
					if (UNEXPECTED(C_OPT_REFCOUNTED(generator->value))) {
						C_ADDREF(generator->value);
					}
				}
			} else {
				zval *value_ptr = _get_zval_ptr_ptr_var(opline->op1.var EXECUTE_DATA_CC);

				/* If a function call result is yielded and the function did
				 * not return by reference we throw a notice. */
				do {
					if (IS_VAR == IS_VAR) {
						CREX_ASSERT(value_ptr != &EG(uninitialized_zval));
						if (opline->extended_value == CREX_RETURNS_FUNCTION
						 && !C_ISREF_P(value_ptr)) {
							crex_error(E_NOTICE, "Only variable references should be yielded by reference");
							ZVAL_COPY(&generator->value, value_ptr);
							break;
						}
					}
					if (C_ISREF_P(value_ptr)) {
						C_ADDREF_P(value_ptr);
					} else {
						ZVAL_MAKE_REF_EX(value_ptr, 2);
					}
					ZVAL_REF(&generator->value, C_REF_P(value_ptr));
				} while (0);

				zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
			}
		} else {
			zval *value = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);

			/* Consts, temporary variables and references need copying */
			if (IS_VAR == IS_CONST) {
				ZVAL_COPY_VALUE(&generator->value, value);
				if (UNEXPECTED(C_OPT_REFCOUNTED(generator->value))) {
					C_ADDREF(generator->value);
				}
			} else if (IS_VAR == IS_TMP_VAR) {
				ZVAL_COPY_VALUE(&generator->value, value);
			} else if ((IS_VAR & (IS_VAR|IS_CV)) && C_ISREF_P(value)) {
				ZVAL_COPY(&generator->value, C_REFVAL_P(value));
				zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
			} else {
				ZVAL_COPY_VALUE(&generator->value, value);
				if (IS_VAR == IS_CV) {
					if (C_OPT_REFCOUNTED_P(value)) C_ADDREF_P(value);
				}
			}
		}
	} else {
		/* If no value was specified yield null */
		ZVAL_NULL(&generator->value);
	}

	/* Set the new yielded key */
	if (IS_CV != IS_UNUSED) {
		zval *key = _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC);
		if ((IS_CV & (IS_CV|IS_VAR)) && UNEXPECTED(C_TYPE_P(key) == IS_REFERENCE)) {
			key = C_REFVAL_P(key);
		}
		ZVAL_COPY(&generator->key, key);

		if (C_TYPE(generator->key) == IS_LONG
		    && C_LVAL(generator->key) > generator->largest_used_integer_key
		) {
			generator->largest_used_integer_key = C_LVAL(generator->key);
		}
	} else {
		/* If no key was specified we use auto-increment keys */
		generator->largest_used_integer_key++;
		ZVAL_LONG(&generator->key, generator->largest_used_integer_key);
	}

	if (RETURN_VALUE_USED(opline)) {
		/* If the return value of yield is used set the send
		 * target and initialize it to NULL */
		generator->send_target = EX_VAR(opline->result.var);
		ZVAL_NULL(generator->send_target);
	} else {
		generator->send_target = NULL;
	}

	/* We increment to the next op, so we are at the correct position when the
	 * generator is resumed. */
	CREX_VM_INC_OPCODE();

	/* The GOTO VM uses a local opline variable. We need to set the opline
	 * variable in execute_data so we don't resume at an old position. */
	SAVE_OPLINE();

	CREX_VM_RETURN();
}

static CREX_VM_HOT CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FE_FETCH_R_SIMPLE_SPEC_VAR_CV_RETVAL_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *array;
	zval *value, *variable_ptr;
	uint32_t value_type;
	HashTable *fe_ht;
	HashPosition pos;

	array = EX_VAR(opline->op1.var);
	SAVE_OPLINE();
	fe_ht = C_ARRVAL_P(array);
	pos = C_FE_POS_P(array);
	if (HT_IS_PACKED(fe_ht)) {
		value = fe_ht->arPacked + pos;
		while (1) {
			if (UNEXPECTED(pos >= fe_ht->nNumUsed)) {
				/* reached end of iteration */
				CREX_VM_SET_RELATIVE_OPCODE(opline, opline->extended_value);
				CREX_VM_CONTINUE();
			}
			value_type = C_TYPE_INFO_P(value);
			CREX_ASSERT(value_type != IS_INDIRECT);
			if (EXPECTED(value_type != IS_UNDEF)) {
				break;
			}
			pos++;
			value++;
		}
		C_FE_POS_P(array) = pos + 1;
		if (0) {
			ZVAL_LONG(EX_VAR(opline->result.var), pos);
		}
	} else {
		Bucket *p;

		p = fe_ht->arData + pos;
		while (1) {
			if (UNEXPECTED(pos >= fe_ht->nNumUsed)) {
				/* reached end of iteration */
				CREX_VM_SET_RELATIVE_OPCODE(opline, opline->extended_value);
				CREX_VM_CONTINUE();
			}
			pos++;
			value = &p->val;
			value_type = C_TYPE_INFO_P(value);
			CREX_ASSERT(value_type != IS_INDIRECT);
			if (EXPECTED(value_type != IS_UNDEF)) {
				break;
			}
			p++;
		}
		C_FE_POS_P(array) = pos;
		if (0) {
			if (!p->key) {
				ZVAL_LONG(EX_VAR(opline->result.var), p->h);
			} else {
				ZVAL_STR_COPY(EX_VAR(opline->result.var), p->key);
			}
		}
	}

	variable_ptr = EX_VAR(opline->op2.var);
	crex_assign_to_variable(variable_ptr, value, IS_CV, EX_USES_STRICT_TYPES());
	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}


static CREX_VM_HOT CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FE_FETCH_R_SIMPLE_SPEC_VAR_CV_RETVAL_USED_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *array;
	zval *value, *variable_ptr;
	uint32_t value_type;
	HashTable *fe_ht;
	HashPosition pos;

	array = EX_VAR(opline->op1.var);
	SAVE_OPLINE();
	fe_ht = C_ARRVAL_P(array);
	pos = C_FE_POS_P(array);
	if (HT_IS_PACKED(fe_ht)) {
		value = fe_ht->arPacked + pos;
		while (1) {
			if (UNEXPECTED(pos >= fe_ht->nNumUsed)) {
				/* reached end of iteration */
				CREX_VM_SET_RELATIVE_OPCODE(opline, opline->extended_value);
				CREX_VM_CONTINUE();
			}
			value_type = C_TYPE_INFO_P(value);
			CREX_ASSERT(value_type != IS_INDIRECT);
			if (EXPECTED(value_type != IS_UNDEF)) {
				break;
			}
			pos++;
			value++;
		}
		C_FE_POS_P(array) = pos + 1;
		if (1) {
			ZVAL_LONG(EX_VAR(opline->result.var), pos);
		}
	} else {
		Bucket *p;

		p = fe_ht->arData + pos;
		while (1) {
			if (UNEXPECTED(pos >= fe_ht->nNumUsed)) {
				/* reached end of iteration */
				CREX_VM_SET_RELATIVE_OPCODE(opline, opline->extended_value);
				CREX_VM_CONTINUE();
			}
			pos++;
			value = &p->val;
			value_type = C_TYPE_INFO_P(value);
			CREX_ASSERT(value_type != IS_INDIRECT);
			if (EXPECTED(value_type != IS_UNDEF)) {
				break;
			}
			p++;
		}
		C_FE_POS_P(array) = pos;
		if (1) {
			if (!p->key) {
				ZVAL_LONG(EX_VAR(opline->result.var), p->h);
			} else {
				ZVAL_STR_COPY(EX_VAR(opline->result.var), p->key);
			}
		}
	}

	variable_ptr = EX_VAR(opline->op2.var);
	crex_assign_to_variable(variable_ptr, value, IS_CV, EX_USES_STRICT_TYPES());
	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}


static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_CLONE_SPEC_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *obj;
	crex_object *zobj;
	crex_class_entry *ce, *scope;
	crex_function *clone;
	crex_object_clone_obj_t clone_call;

	SAVE_OPLINE();
	obj = &EX(This);

	do {
		if (IS_UNUSED == IS_CONST ||
		    (IS_UNUSED != IS_UNUSED && UNEXPECTED(C_TYPE_P(obj) != IS_OBJECT))) {
			if ((IS_UNUSED & (IS_VAR|IS_CV)) && C_ISREF_P(obj)) {
				obj = C_REFVAL_P(obj);
				if (EXPECTED(C_TYPE_P(obj) == IS_OBJECT)) {
					break;
				}
			}
			ZVAL_UNDEF(EX_VAR(opline->result.var));
			if (IS_UNUSED == IS_CV && UNEXPECTED(C_TYPE_P(obj) == IS_UNDEF)) {
				ZVAL_UNDEFINED_OP1();
				if (UNEXPECTED(EG(exception) != NULL)) {
					HANDLE_EXCEPTION();
				}
			}
			crex_throw_error(NULL, "__clone method called on non-object");

			HANDLE_EXCEPTION();
		}
	} while (0);

	zobj = C_OBJ_P(obj);
	ce = zobj->ce;
	clone = ce->clone;
	clone_call = zobj->handlers->clone_obj;
	if (UNEXPECTED(clone_call == NULL)) {
		crex_throw_error(NULL, "Trying to clone an uncloneable object of class %s", ZSTR_VAL(ce->name));

		ZVAL_UNDEF(EX_VAR(opline->result.var));
		HANDLE_EXCEPTION();
	}

	if (clone && !(clone->common.fn_flags & CREX_ACC_PUBLIC)) {
		scope = EX(func)->op_array.scope;
		if (clone->common.scope != scope) {
			if (UNEXPECTED(clone->common.fn_flags & CREX_ACC_PRIVATE)
			 || UNEXPECTED(!crex_check_protected(crex_get_function_root_class(clone), scope))) {
				crex_wrong_clone_call(clone, scope);

				ZVAL_UNDEF(EX_VAR(opline->result.var));
				HANDLE_EXCEPTION();
			}
		}
	}

	ZVAL_OBJ(EX_VAR(opline->result.var), clone_call(zobj));

	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FETCH_CLASS_NAME_SPEC_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	uint32_t fetch_type;
	crex_class_entry *called_scope, *scope;
	USE_OPLINE

	if (IS_UNUSED != IS_UNUSED) {
		SAVE_OPLINE();
		zval *op = NULL;
		if (UNEXPECTED(C_TYPE_P(op) != IS_OBJECT)) {
			ZVAL_DEREF(op);
			if (C_TYPE_P(op) != IS_OBJECT) {
				crex_type_error("Cannot use \"::class\" on %s", crex_zval_value_name(op));
				ZVAL_UNDEF(EX_VAR(opline->result.var));

				HANDLE_EXCEPTION();
			}
		}

		ZVAL_STR_COPY(EX_VAR(opline->result.var), C_OBJCE_P(op)->name);

		CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
	}

	fetch_type = opline->op1.num;
	scope = EX(func)->op_array.scope;
	if (UNEXPECTED(scope == NULL)) {
		SAVE_OPLINE();
		crex_throw_error(NULL, "Cannot use \"%s\" in the global scope",
			fetch_type == CREX_FETCH_CLASS_SELF ? "self" :
			fetch_type == CREX_FETCH_CLASS_PARENT ? "parent" : "static");
		ZVAL_UNDEF(EX_VAR(opline->result.var));
		HANDLE_EXCEPTION();
	}

	switch (fetch_type) {
		case CREX_FETCH_CLASS_SELF:
			ZVAL_STR_COPY(EX_VAR(opline->result.var), scope->name);
			break;
		case CREX_FETCH_CLASS_PARENT:
			if (UNEXPECTED(scope->parent == NULL)) {
				SAVE_OPLINE();
				crex_throw_error(NULL,
					"Cannot use \"parent\" when current class scope has no parent");
				ZVAL_UNDEF(EX_VAR(opline->result.var));
				HANDLE_EXCEPTION();
			}
			ZVAL_STR_COPY(EX_VAR(opline->result.var), scope->parent->name);
			break;
		case CREX_FETCH_CLASS_STATIC:
			if (C_TYPE(EX(This)) == IS_OBJECT) {
				called_scope = C_OBJCE(EX(This));
			} else {
				called_scope = C_CE(EX(This));
			}
			ZVAL_STR_COPY(EX_VAR(opline->result.var), called_scope->name);
			break;
		EMPTY_SWITCH_DEFAULT_CASE()
	}
	CREX_VM_NEXT_OPCODE();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ASSIGN_OBJ_OP_SPEC_UNUSED_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *object;
	zval *property;
	zval *value;
	zval *zptr;
	void **cache_slot;
	crex_property_info *prop_info;
	crex_object *zobj;
	crex_string *name, *tmp_name;

	SAVE_OPLINE();
	object = &EX(This);
	property = RT_CONSTANT(opline, opline->op2);

	do {
		value = get_op_data_zval_ptr_r((opline+1)->op1_type, (opline+1)->op1);

		if (IS_UNUSED != IS_UNUSED && UNEXPECTED(C_TYPE_P(object) != IS_OBJECT)) {
			if (C_ISREF_P(object) && C_TYPE_P(C_REFVAL_P(object)) == IS_OBJECT) {
				object = C_REFVAL_P(object);
				goto assign_op_object;
			}
			if (IS_UNUSED == IS_CV
			 && UNEXPECTED(C_TYPE_P(object) == IS_UNDEF)) {
				ZVAL_UNDEFINED_OP1();
			}
			crex_throw_non_object_error(object, property OPLINE_CC EXECUTE_DATA_CC);
			break;
		}

assign_op_object:
		/* here we are sure we are dealing with an object */
		zobj = C_OBJ_P(object);
		if (IS_CONST == IS_CONST) {
			name = C_STR_P(property);
		} else {
			name = zval_try_get_tmp_string(property, &tmp_name);
			if (UNEXPECTED(!name)) {
				UNDEF_RESULT();
				break;
			}
		}
		cache_slot = (IS_CONST == IS_CONST) ? CACHE_ADDR((opline+1)->extended_value) : NULL;
		if (EXPECTED((zptr = zobj->handlers->get_property_ptr_ptr(zobj, name, BP_VAR_RW, cache_slot)) != NULL)) {
			if (UNEXPECTED(C_ISERROR_P(zptr))) {
				if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
					ZVAL_NULL(EX_VAR(opline->result.var));
				}
			} else {
				zval *orig_zptr = zptr;
				crex_reference *ref;

				do {
					if (UNEXPECTED(C_ISREF_P(zptr))) {
						ref = C_REF_P(zptr);
						zptr = C_REFVAL_P(zptr);
						if (UNEXPECTED(CREX_REF_HAS_TYPE_SOURCES(ref))) {
							crex_binary_assign_op_typed_ref(ref, value OPLINE_CC EXECUTE_DATA_CC);
							break;
						}
					}

					if (IS_CONST == IS_CONST) {
						prop_info = (crex_property_info*)CACHED_PTR_EX(cache_slot + 2);
					} else {
						prop_info = crex_object_fetch_property_type_info(C_OBJ_P(object), orig_zptr);
					}
					if (UNEXPECTED(prop_info)) {
						/* special case for typed properties */
						crex_binary_assign_op_typed_prop(prop_info, zptr, value OPLINE_CC EXECUTE_DATA_CC);
					} else {
						crex_binary_op(zptr, zptr, value OPLINE_CC);
					}
				} while (0);

				if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
					ZVAL_COPY(EX_VAR(opline->result.var), zptr);
				}
			}
		} else {
			crex_assign_op_overloaded_property(zobj, name, cache_slot, value OPLINE_CC EXECUTE_DATA_CC);
		}
		if (IS_CONST != IS_CONST) {
			crex_tmp_string_release(tmp_name);
		}
	} while (0);

	FREE_OP((opline+1)->op1_type, (opline+1)->op1.var);


	/* assign_obj has two opcodes! */
	CREX_VM_NEXT_OPCODE_EX(1, 2);
}

/* No specialization for op_types (CONST|TMP|VAR|CV, UNUSED|CONST|TMPVAR) */
static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_PRE_INC_OBJ_SPEC_UNUSED_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *object;
	zval *property;
	zval *zptr;
	void **cache_slot;
	crex_property_info *prop_info;
	crex_object *zobj;
	crex_string *name, *tmp_name;

	SAVE_OPLINE();
	object = &EX(This);
	property = RT_CONSTANT(opline, opline->op2);

	do {
		if (IS_UNUSED != IS_UNUSED && UNEXPECTED(C_TYPE_P(object) != IS_OBJECT)) {
			if (C_ISREF_P(object) && C_TYPE_P(C_REFVAL_P(object)) == IS_OBJECT) {
				object = C_REFVAL_P(object);
				goto pre_incdec_object;
			}
			if (IS_UNUSED == IS_CV
			 && UNEXPECTED(C_TYPE_P(object) == IS_UNDEF)) {
				ZVAL_UNDEFINED_OP1();
			}
			crex_throw_non_object_error(object, property OPLINE_CC EXECUTE_DATA_CC);
			break;
		}

pre_incdec_object:
		/* here we are sure we are dealing with an object */
		zobj = C_OBJ_P(object);
		if (IS_CONST == IS_CONST) {
			name = C_STR_P(property);
		} else {
			name = zval_try_get_tmp_string(property, &tmp_name);
			if (UNEXPECTED(!name)) {
				UNDEF_RESULT();
				break;
			}
		}
		cache_slot = (IS_CONST == IS_CONST) ? CACHE_ADDR(opline->extended_value) : NULL;
		if (EXPECTED((zptr = zobj->handlers->get_property_ptr_ptr(zobj, name, BP_VAR_RW, cache_slot)) != NULL)) {
			if (UNEXPECTED(C_ISERROR_P(zptr))) {
				if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
					ZVAL_NULL(EX_VAR(opline->result.var));
				}
			} else {
				if (IS_CONST == IS_CONST) {
					prop_info = (crex_property_info *) CACHED_PTR_EX(cache_slot + 2);
				} else {
					prop_info = crex_object_fetch_property_type_info(C_OBJ_P(object), zptr);
				}
				crex_pre_incdec_property_zval(zptr, prop_info OPLINE_CC EXECUTE_DATA_CC);
			}
		} else {
			crex_pre_incdec_overloaded_property(zobj, name, cache_slot OPLINE_CC EXECUTE_DATA_CC);
		}
		if (IS_CONST != IS_CONST) {
			crex_tmp_string_release(tmp_name);
		}
	} while (0);


	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_POST_INC_OBJ_SPEC_UNUSED_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *object;
	zval *property;
	zval *zptr;
	void **cache_slot;
	crex_property_info *prop_info;
	crex_object *zobj;
	crex_string *name, *tmp_name;

	SAVE_OPLINE();
	object = &EX(This);
	property = RT_CONSTANT(opline, opline->op2);

	do {
		if (IS_UNUSED != IS_UNUSED && UNEXPECTED(C_TYPE_P(object) != IS_OBJECT)) {
			if (C_ISREF_P(object) && C_TYPE_P(C_REFVAL_P(object)) == IS_OBJECT) {
				object = C_REFVAL_P(object);
				goto post_incdec_object;
			}
			if (IS_UNUSED == IS_CV
			 && UNEXPECTED(C_TYPE_P(object) == IS_UNDEF)) {
				ZVAL_UNDEFINED_OP1();
			}
			crex_throw_non_object_error(object, property OPLINE_CC EXECUTE_DATA_CC);
			break;
		}

post_incdec_object:
		/* here we are sure we are dealing with an object */
		zobj = C_OBJ_P(object);
		if (IS_CONST == IS_CONST) {
			name = C_STR_P(property);
		} else {
			name = zval_try_get_tmp_string(property, &tmp_name);
			if (UNEXPECTED(!name)) {
				ZVAL_UNDEF(EX_VAR(opline->result.var));
				break;
			}
		}
		cache_slot = (IS_CONST == IS_CONST) ? CACHE_ADDR(opline->extended_value) : NULL;
		if (EXPECTED((zptr = zobj->handlers->get_property_ptr_ptr(zobj, name, BP_VAR_RW, cache_slot)) != NULL)) {
			if (UNEXPECTED(C_ISERROR_P(zptr))) {
				ZVAL_NULL(EX_VAR(opline->result.var));
			} else {
				if (IS_CONST == IS_CONST) {
					prop_info = (crex_property_info*)CACHED_PTR_EX(cache_slot + 2);
				} else {
					prop_info = crex_object_fetch_property_type_info(C_OBJ_P(object), zptr);
				}

				crex_post_incdec_property_zval(zptr, prop_info OPLINE_CC EXECUTE_DATA_CC);
			}
		} else {
			crex_post_incdec_overloaded_property(zobj, name, cache_slot OPLINE_CC EXECUTE_DATA_CC);
		}
		if (IS_CONST != IS_CONST) {
			crex_tmp_string_release(tmp_name);
		}
	} while (0);


	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static crex_always_inline CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FETCH_OBJ_R_SPEC_UNUSED_CONST_INLINE_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;
	void **cache_slot = NULL;

	SAVE_OPLINE();
	container = &EX(This);

	if (IS_UNUSED == IS_CONST ||
	    (IS_UNUSED != IS_UNUSED && UNEXPECTED(C_TYPE_P(container) != IS_OBJECT))) {
		do {
			if ((IS_UNUSED & (IS_VAR|IS_CV)) && C_ISREF_P(container)) {
				container = C_REFVAL_P(container);
				if (EXPECTED(C_TYPE_P(container) == IS_OBJECT)) {
					break;
				}
			}
			if (IS_UNUSED == IS_CV && UNEXPECTED(C_TYPE_P(container) == IS_UNDEF)) {
				ZVAL_UNDEFINED_OP1();
			}
			crex_wrong_property_read(container, RT_CONSTANT(opline, opline->op2));
			ZVAL_NULL(EX_VAR(opline->result.var));
			goto fetch_obj_r_finish;
		} while (0);
	}

	/* here we are sure we are dealing with an object */
	do {
		crex_object *zobj = C_OBJ_P(container);
		crex_string *name, *tmp_name;
		zval *retval;

		if (IS_CONST == IS_CONST) {
			cache_slot = CACHE_ADDR(opline->extended_value & ~CREX_FETCH_REF /* FUNC_ARG fetch may contain it */);

			if (EXPECTED(zobj->ce == CACHED_PTR_EX(cache_slot))) {
				uintptr_t prop_offset = (uintptr_t)CACHED_PTR_EX(cache_slot + 1);

				if (EXPECTED(IS_VALID_PROPERTY_OFFSET(prop_offset))) {
					retval = OBJ_PROP(zobj, prop_offset);
					if (EXPECTED(C_TYPE_INFO_P(retval) != IS_UNDEF)) {
						if (0 || (IS_UNUSED & (IS_TMP_VAR|IS_VAR)) != 0) {
							goto fetch_obj_r_copy;
						} else {
fetch_obj_r_fast_copy:
							ZVAL_COPY_DEREF(EX_VAR(opline->result.var), retval);
							CREX_VM_NEXT_OPCODE();
						}
					}
				} else if (EXPECTED(zobj->properties != NULL)) {
					name = C_STR_P(RT_CONSTANT(opline, opline->op2));
					if (!IS_UNKNOWN_DYNAMIC_PROPERTY_OFFSET(prop_offset)) {
						uintptr_t idx = CREX_DECODE_DYN_PROP_OFFSET(prop_offset);

						if (EXPECTED(idx < zobj->properties->nNumUsed * sizeof(Bucket))) {
							Bucket *p = (Bucket*)((char*)zobj->properties->arData + idx);

							if (EXPECTED(p->key == name) ||
							    (EXPECTED(p->h == ZSTR_H(name)) &&
							     EXPECTED(p->key != NULL) &&
							     EXPECTED(crex_string_equal_content(p->key, name)))) {
								retval = &p->val;
								if (0 || (IS_UNUSED & (IS_TMP_VAR|IS_VAR)) != 0) {
									goto fetch_obj_r_copy;
								} else {
									goto fetch_obj_r_fast_copy;
								}
							}
						}
						CACHE_PTR_EX(cache_slot + 1, (void*)CREX_DYNAMIC_PROPERTY_OFFSET);
					}
					retval = crex_hash_find_known_hash(zobj->properties, name);
					if (EXPECTED(retval)) {
						uintptr_t idx = (char*)retval - (char*)zobj->properties->arData;
						CACHE_PTR_EX(cache_slot + 1, (void*)CREX_ENCODE_DYN_PROP_OFFSET(idx));
						if (0 || (IS_UNUSED & (IS_TMP_VAR|IS_VAR)) != 0) {
							goto fetch_obj_r_copy;
						} else {
							goto fetch_obj_r_fast_copy;
						}
					}
				}
			}
			name = C_STR_P(RT_CONSTANT(opline, opline->op2));
		} else {
			name = zval_try_get_tmp_string(RT_CONSTANT(opline, opline->op2), &tmp_name);
			if (UNEXPECTED(!name)) {
				ZVAL_UNDEF(EX_VAR(opline->result.var));
				break;
			}
		}

#if CREX_DEBUG
		/* For non-standard object handlers, verify a declared property type in debug builds.
		 * Fetch prop_info before calling read_property(), as it may deallocate the object. */
		crex_property_info *prop_info = NULL;
		if (zobj->handlers->read_property != crex_std_read_property) {
			prop_info = crex_get_property_info(zobj->ce, name, /* silent */ true);
		}
#endif
		retval = zobj->handlers->read_property(zobj, name, BP_VAR_R, cache_slot, EX_VAR(opline->result.var));
#if CREX_DEBUG
		if (!EG(exception) && prop_info && prop_info != CREX_WRONG_PROPERTY_INFO
				&& CREX_TYPE_IS_SET(prop_info->type)) {
			ZVAL_OPT_DEREF(retval);
			crex_verify_property_type(prop_info, retval, /* strict */ true);
		}
#endif

		if (IS_CONST != IS_CONST) {
			crex_tmp_string_release(tmp_name);
		}

		if (retval != EX_VAR(opline->result.var)) {
fetch_obj_r_copy:
			ZVAL_COPY_DEREF(EX_VAR(opline->result.var), retval);
		} else if (UNEXPECTED(C_ISREF_P(retval))) {
			crex_unwrap_reference(retval);
		}
	} while (0);

fetch_obj_r_finish:


	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FETCH_OBJ_R_SPEC_UNUSED_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	CREX_VM_TAIL_CALL(CREX_FETCH_OBJ_R_SPEC_UNUSED_CONST_INLINE_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU));
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FETCH_OBJ_W_SPEC_UNUSED_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *property, *container, *result;

	SAVE_OPLINE();

	container = &EX(This);
	property = RT_CONSTANT(opline, opline->op2);
	result = EX_VAR(opline->result.var);
	crex_fetch_property_address(
		result, container, IS_UNUSED, property, IS_CONST,
		((IS_CONST == IS_CONST) ? CACHE_ADDR(opline->extended_value & ~CREX_FETCH_OBJ_FLAGS) : NULL),
		BP_VAR_W, opline->extended_value OPLINE_CC EXECUTE_DATA_CC);

	if (IS_UNUSED == IS_VAR) {
		FREE_VAR_PTR_AND_EXTRACT_RESULT_IF_NECESSARY(opline->op1.var);
	}
	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FETCH_OBJ_RW_SPEC_UNUSED_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *property, *container, *result;

	SAVE_OPLINE();
	container = &EX(This);
	property = RT_CONSTANT(opline, opline->op2);
	result = EX_VAR(opline->result.var);
	crex_fetch_property_address(result, container, IS_UNUSED, property, IS_CONST, ((IS_CONST == IS_CONST) ? CACHE_ADDR(opline->extended_value) : NULL), BP_VAR_RW, 0 OPLINE_CC EXECUTE_DATA_CC);

	if (IS_UNUSED == IS_VAR) {
		FREE_VAR_PTR_AND_EXTRACT_RESULT_IF_NECESSARY(opline->op1.var);
	}
	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FETCH_OBJ_IS_SPEC_UNUSED_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;
	void **cache_slot = NULL;

	SAVE_OPLINE();
	container = &EX(This);

	if (IS_UNUSED == IS_CONST ||
	    (IS_UNUSED != IS_UNUSED && UNEXPECTED(C_TYPE_P(container) != IS_OBJECT))) {
		do {
			if ((IS_UNUSED & (IS_VAR|IS_CV)) && C_ISREF_P(container)) {
				container = C_REFVAL_P(container);
				if (EXPECTED(C_TYPE_P(container) == IS_OBJECT)) {
					break;
				}
			}
			if (IS_CONST == IS_CV && C_TYPE_P(EX_VAR(opline->op2.var)) == IS_UNDEF) {
				ZVAL_UNDEFINED_OP2();
			}
			ZVAL_NULL(EX_VAR(opline->result.var));
			goto fetch_obj_is_finish;
		} while (0);
	}

	/* here we are sure we are dealing with an object */
	do {
		crex_object *zobj = C_OBJ_P(container);
		crex_string *name, *tmp_name;
		zval *retval;

		if (IS_CONST == IS_CONST) {
			cache_slot = CACHE_ADDR(opline->extended_value);

			if (EXPECTED(zobj->ce == CACHED_PTR_EX(cache_slot))) {
				uintptr_t prop_offset = (uintptr_t)CACHED_PTR_EX(cache_slot + 1);

				if (EXPECTED(IS_VALID_PROPERTY_OFFSET(prop_offset))) {
					retval = OBJ_PROP(zobj, prop_offset);
					if (EXPECTED(C_TYPE_P(retval) != IS_UNDEF)) {
						if (0 || (IS_UNUSED & (IS_TMP_VAR|IS_VAR)) != 0) {
							goto fetch_obj_is_copy;
						} else {
fetch_obj_is_fast_copy:
							ZVAL_COPY_DEREF(EX_VAR(opline->result.var), retval);
							CREX_VM_NEXT_OPCODE();
						}
					}
				} else if (EXPECTED(zobj->properties != NULL)) {
					name = C_STR_P(RT_CONSTANT(opline, opline->op2));
					if (!IS_UNKNOWN_DYNAMIC_PROPERTY_OFFSET(prop_offset)) {
						uintptr_t idx = CREX_DECODE_DYN_PROP_OFFSET(prop_offset);

						if (EXPECTED(idx < zobj->properties->nNumUsed * sizeof(Bucket))) {
							Bucket *p = (Bucket*)((char*)zobj->properties->arData + idx);

							if (EXPECTED(p->key == name) ||
							    (EXPECTED(p->h == ZSTR_H(name)) &&
							     EXPECTED(p->key != NULL) &&
							     EXPECTED(crex_string_equal_content(p->key, name)))) {
								retval = &p->val;
								if (0 || (IS_UNUSED & (IS_TMP_VAR|IS_VAR)) != 0) {
									goto fetch_obj_is_copy;
								} else {
									goto fetch_obj_is_fast_copy;
								}
							}
						}
						CACHE_PTR_EX(cache_slot + 1, (void*)CREX_DYNAMIC_PROPERTY_OFFSET);
					}
					retval = crex_hash_find_known_hash(zobj->properties, name);
					if (EXPECTED(retval)) {
						uintptr_t idx = (char*)retval - (char*)zobj->properties->arData;
						CACHE_PTR_EX(cache_slot + 1, (void*)CREX_ENCODE_DYN_PROP_OFFSET(idx));
						if (0 || (IS_UNUSED & (IS_TMP_VAR|IS_VAR)) != 0) {
							goto fetch_obj_is_copy;
						} else {
							goto fetch_obj_is_fast_copy;
						}
					}
				}
			}
			name = C_STR_P(RT_CONSTANT(opline, opline->op2));
		} else {
			name = zval_try_get_tmp_string(RT_CONSTANT(opline, opline->op2), &tmp_name);
			if (UNEXPECTED(!name)) {
				ZVAL_UNDEF(EX_VAR(opline->result.var));
				break;
			}
		}

		retval = zobj->handlers->read_property(zobj, name, BP_VAR_IS, cache_slot, EX_VAR(opline->result.var));

		if (IS_CONST != IS_CONST) {
			crex_tmp_string_release(tmp_name);
		}

		if (retval != EX_VAR(opline->result.var)) {
fetch_obj_is_copy:
			ZVAL_COPY_DEREF(EX_VAR(opline->result.var), retval);
		} else if (UNEXPECTED(C_ISREF_P(retval))) {
			crex_unwrap_reference(retval);
		}
	} while (0);

fetch_obj_is_finish:


	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FETCH_OBJ_FUNC_ARG_SPEC_UNUSED_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
#if 0
	USE_OPLINE
#endif

	if (UNEXPECTED(CREX_CALL_INFO(EX(call)) & CREX_CALL_SEND_ARG_BY_REF)) {
		/* Behave like FETCH_OBJ_W */
		if ((IS_UNUSED & (IS_CONST|IS_TMP_VAR))) {
			CREX_VM_TAIL_CALL(crex_use_tmp_in_write_context_helper_SPEC(CREX_OPCODE_HANDLER_ARGS_PASSTHRU));
		}
		CREX_VM_TAIL_CALL(CREX_FETCH_OBJ_W_SPEC_UNUSED_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU));
	} else {
		CREX_VM_TAIL_CALL(CREX_FETCH_OBJ_R_SPEC_UNUSED_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU));
	}
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FETCH_OBJ_UNSET_SPEC_UNUSED_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container, *property, *result;

	SAVE_OPLINE();
	container = &EX(This);
	property = RT_CONSTANT(opline, opline->op2);
	result = EX_VAR(opline->result.var);
	crex_fetch_property_address(result, container, IS_UNUSED, property, IS_CONST, ((IS_CONST == IS_CONST) ? CACHE_ADDR(opline->extended_value) : NULL), BP_VAR_UNSET, 0 OPLINE_CC EXECUTE_DATA_CC);

	if (IS_UNUSED == IS_VAR) {
		FREE_VAR_PTR_AND_EXTRACT_RESULT_IF_NECESSARY(opline->op1.var);
	}
	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ASSIGN_OBJ_SPEC_UNUSED_CONST_OP_DATA_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *object, *value, tmp;
	crex_object *zobj;
	crex_string *name, *tmp_name;
	crex_refcounted *garbage = NULL;

	SAVE_OPLINE();
	object = &EX(This);
	value = RT_CONSTANT((opline+1), (opline+1)->op1);

	if (IS_UNUSED != IS_UNUSED && UNEXPECTED(C_TYPE_P(object) != IS_OBJECT)) {
		if (C_ISREF_P(object) && C_TYPE_P(C_REFVAL_P(object)) == IS_OBJECT) {
			object = C_REFVAL_P(object);
			goto assign_object;
		}
		crex_throw_non_object_error(object, RT_CONSTANT(opline, opline->op2) OPLINE_CC EXECUTE_DATA_CC);
		value = &EG(uninitialized_zval);
		goto free_and_exit_assign_obj;
	}

assign_object:
	zobj = C_OBJ_P(object);
	if (IS_CONST == IS_CONST) {
		if (EXPECTED(zobj->ce == CACHED_PTR(opline->extended_value))) {
			void **cache_slot = CACHE_ADDR(opline->extended_value);
			uintptr_t prop_offset = (uintptr_t)CACHED_PTR_EX(cache_slot + 1);
			zval *property_val;

			if (EXPECTED(IS_VALID_PROPERTY_OFFSET(prop_offset))) {
				property_val = OBJ_PROP(zobj, prop_offset);
				if (C_TYPE_P(property_val) != IS_UNDEF) {
					crex_property_info *prop_info = (crex_property_info*) CACHED_PTR_EX(cache_slot + 2);

					if (UNEXPECTED(prop_info != NULL)) {
						value = crex_assign_to_typed_prop(prop_info, property_val, value, &garbage EXECUTE_DATA_CC);
						goto free_and_exit_assign_obj;
					} else {
fast_assign_obj:
						value = crex_assign_to_variable_ex(property_val, value, IS_CONST, EX_USES_STRICT_TYPES(), &garbage);
						if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
							ZVAL_COPY(EX_VAR(opline->result.var), value);
						}
						goto exit_assign_obj;
					}
				}
			} else {
				name = C_STR_P(RT_CONSTANT(opline, opline->op2));
				if (EXPECTED(zobj->properties != NULL)) {
					if (UNEXPECTED(GC_REFCOUNT(zobj->properties) > 1)) {
						if (EXPECTED(!(GC_FLAGS(zobj->properties) & IS_ARRAY_IMMUTABLE))) {
							GC_DELREF(zobj->properties);
						}
						zobj->properties = crex_array_dup(zobj->properties);
					}
					property_val = crex_hash_find_known_hash(zobj->properties, name);
					if (property_val) {
						goto fast_assign_obj;
					}
				}

				if (!zobj->ce->__set && (zobj->ce->ce_flags & CREX_ACC_ALLOW_DYNAMIC_PROPERTIES)) {
					if (EXPECTED(zobj->properties == NULL)) {
						rebuild_object_properties(zobj);
					}
					if (IS_CONST == IS_CONST) {
						if (UNEXPECTED(C_OPT_REFCOUNTED_P(value))) {
							C_ADDREF_P(value);
						}
					} else if (IS_CONST != IS_TMP_VAR) {
						if (C_ISREF_P(value)) {
							if (IS_CONST == IS_VAR) {
								crex_reference *ref = C_REF_P(value);
								if (GC_DELREF(ref) == 0) {
									ZVAL_COPY_VALUE(&tmp, C_REFVAL_P(value));
									efree_size(ref, sizeof(crex_reference));
									value = &tmp;
								} else {
									value = C_REFVAL_P(value);
									C_TRY_ADDREF_P(value);
								}
							} else {
								value = C_REFVAL_P(value);
								C_TRY_ADDREF_P(value);
							}
						} else if (IS_CONST == IS_CV) {
							C_TRY_ADDREF_P(value);
						}
						}
					crex_hash_add_new(zobj->properties, name, value);
					if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
						ZVAL_COPY(EX_VAR(opline->result.var), value);
					}
					goto exit_assign_obj;
				}
			}
		}
		name = C_STR_P(RT_CONSTANT(opline, opline->op2));
	} else {
		name = zval_try_get_tmp_string(RT_CONSTANT(opline, opline->op2), &tmp_name);
		if (UNEXPECTED(!name)) {

			UNDEF_RESULT();
			goto exit_assign_obj;
		}
	}

	if (IS_CONST == IS_CV || IS_CONST == IS_VAR) {
		ZVAL_DEREF(value);
	}

	value = zobj->handlers->write_property(zobj, name, value, (IS_CONST == IS_CONST) ? CACHE_ADDR(opline->extended_value) : NULL);

	if (IS_CONST != IS_CONST) {
		crex_tmp_string_release(tmp_name);
	}

free_and_exit_assign_obj:
	if (UNEXPECTED(RETURN_VALUE_USED(opline)) && value) {
		ZVAL_COPY_DEREF(EX_VAR(opline->result.var), value);
	}

exit_assign_obj:
	if (garbage) {
		GC_DTOR_NO_REF(garbage);
	}


	/* assign_obj has two opcodes! */
	CREX_VM_NEXT_OPCODE_EX(1, 2);
}

/* No specialization for op_types (CONST|TMPVAR|CV, UNUSED|CONST|VAR) */
static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ASSIGN_OBJ_SPEC_UNUSED_CONST_OP_DATA_TMP_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *object, *value, tmp;
	crex_object *zobj;
	crex_string *name, *tmp_name;
	crex_refcounted *garbage = NULL;

	SAVE_OPLINE();
	object = &EX(This);
	value = _get_zval_ptr_tmp((opline+1)->op1.var EXECUTE_DATA_CC);

	if (IS_UNUSED != IS_UNUSED && UNEXPECTED(C_TYPE_P(object) != IS_OBJECT)) {
		if (C_ISREF_P(object) && C_TYPE_P(C_REFVAL_P(object)) == IS_OBJECT) {
			object = C_REFVAL_P(object);
			goto assign_object;
		}
		crex_throw_non_object_error(object, RT_CONSTANT(opline, opline->op2) OPLINE_CC EXECUTE_DATA_CC);
		value = &EG(uninitialized_zval);
		goto free_and_exit_assign_obj;
	}

assign_object:
	zobj = C_OBJ_P(object);
	if (IS_CONST == IS_CONST) {
		if (EXPECTED(zobj->ce == CACHED_PTR(opline->extended_value))) {
			void **cache_slot = CACHE_ADDR(opline->extended_value);
			uintptr_t prop_offset = (uintptr_t)CACHED_PTR_EX(cache_slot + 1);
			zval *property_val;

			if (EXPECTED(IS_VALID_PROPERTY_OFFSET(prop_offset))) {
				property_val = OBJ_PROP(zobj, prop_offset);
				if (C_TYPE_P(property_val) != IS_UNDEF) {
					crex_property_info *prop_info = (crex_property_info*) CACHED_PTR_EX(cache_slot + 2);

					if (UNEXPECTED(prop_info != NULL)) {
						value = crex_assign_to_typed_prop(prop_info, property_val, value, &garbage EXECUTE_DATA_CC);
						goto free_and_exit_assign_obj;
					} else {
fast_assign_obj:
						value = crex_assign_to_variable_ex(property_val, value, IS_TMP_VAR, EX_USES_STRICT_TYPES(), &garbage);
						if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
							ZVAL_COPY(EX_VAR(opline->result.var), value);
						}
						goto exit_assign_obj;
					}
				}
			} else {
				name = C_STR_P(RT_CONSTANT(opline, opline->op2));
				if (EXPECTED(zobj->properties != NULL)) {
					if (UNEXPECTED(GC_REFCOUNT(zobj->properties) > 1)) {
						if (EXPECTED(!(GC_FLAGS(zobj->properties) & IS_ARRAY_IMMUTABLE))) {
							GC_DELREF(zobj->properties);
						}
						zobj->properties = crex_array_dup(zobj->properties);
					}
					property_val = crex_hash_find_known_hash(zobj->properties, name);
					if (property_val) {
						goto fast_assign_obj;
					}
				}

				if (!zobj->ce->__set && (zobj->ce->ce_flags & CREX_ACC_ALLOW_DYNAMIC_PROPERTIES)) {
					if (EXPECTED(zobj->properties == NULL)) {
						rebuild_object_properties(zobj);
					}
					if (IS_TMP_VAR == IS_CONST) {
						if (UNEXPECTED(C_OPT_REFCOUNTED_P(value))) {
							C_ADDREF_P(value);
						}
					} else if (IS_TMP_VAR != IS_TMP_VAR) {
						if (C_ISREF_P(value)) {
							if (IS_TMP_VAR == IS_VAR) {
								crex_reference *ref = C_REF_P(value);
								if (GC_DELREF(ref) == 0) {
									ZVAL_COPY_VALUE(&tmp, C_REFVAL_P(value));
									efree_size(ref, sizeof(crex_reference));
									value = &tmp;
								} else {
									value = C_REFVAL_P(value);
									C_TRY_ADDREF_P(value);
								}
							} else {
								value = C_REFVAL_P(value);
								C_TRY_ADDREF_P(value);
							}
						} else if (IS_TMP_VAR == IS_CV) {
							C_TRY_ADDREF_P(value);
						}
						}
					crex_hash_add_new(zobj->properties, name, value);
					if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
						ZVAL_COPY(EX_VAR(opline->result.var), value);
					}
					goto exit_assign_obj;
				}
			}
		}
		name = C_STR_P(RT_CONSTANT(opline, opline->op2));
	} else {
		name = zval_try_get_tmp_string(RT_CONSTANT(opline, opline->op2), &tmp_name);
		if (UNEXPECTED(!name)) {
			zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
			UNDEF_RESULT();
			goto exit_assign_obj;
		}
	}

	if (IS_TMP_VAR == IS_CV || IS_TMP_VAR == IS_VAR) {
		ZVAL_DEREF(value);
	}

	value = zobj->handlers->write_property(zobj, name, value, (IS_CONST == IS_CONST) ? CACHE_ADDR(opline->extended_value) : NULL);

	if (IS_CONST != IS_CONST) {
		crex_tmp_string_release(tmp_name);
	}

free_and_exit_assign_obj:
	if (UNEXPECTED(RETURN_VALUE_USED(opline)) && value) {
		ZVAL_COPY_DEREF(EX_VAR(opline->result.var), value);
	}
	zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
exit_assign_obj:
	if (garbage) {
		GC_DTOR_NO_REF(garbage);
	}


	/* assign_obj has two opcodes! */
	CREX_VM_NEXT_OPCODE_EX(1, 2);
}

/* No specialization for op_types (CONST|TMPVAR|CV, UNUSED|CONST|VAR) */
static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ASSIGN_OBJ_SPEC_UNUSED_CONST_OP_DATA_VAR_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *object, *value, tmp;
	crex_object *zobj;
	crex_string *name, *tmp_name;
	crex_refcounted *garbage = NULL;

	SAVE_OPLINE();
	object = &EX(This);
	value = _get_zval_ptr_var((opline+1)->op1.var EXECUTE_DATA_CC);

	if (IS_UNUSED != IS_UNUSED && UNEXPECTED(C_TYPE_P(object) != IS_OBJECT)) {
		if (C_ISREF_P(object) && C_TYPE_P(C_REFVAL_P(object)) == IS_OBJECT) {
			object = C_REFVAL_P(object);
			goto assign_object;
		}
		crex_throw_non_object_error(object, RT_CONSTANT(opline, opline->op2) OPLINE_CC EXECUTE_DATA_CC);
		value = &EG(uninitialized_zval);
		goto free_and_exit_assign_obj;
	}

assign_object:
	zobj = C_OBJ_P(object);
	if (IS_CONST == IS_CONST) {
		if (EXPECTED(zobj->ce == CACHED_PTR(opline->extended_value))) {
			void **cache_slot = CACHE_ADDR(opline->extended_value);
			uintptr_t prop_offset = (uintptr_t)CACHED_PTR_EX(cache_slot + 1);
			zval *property_val;

			if (EXPECTED(IS_VALID_PROPERTY_OFFSET(prop_offset))) {
				property_val = OBJ_PROP(zobj, prop_offset);
				if (C_TYPE_P(property_val) != IS_UNDEF) {
					crex_property_info *prop_info = (crex_property_info*) CACHED_PTR_EX(cache_slot + 2);

					if (UNEXPECTED(prop_info != NULL)) {
						value = crex_assign_to_typed_prop(prop_info, property_val, value, &garbage EXECUTE_DATA_CC);
						goto free_and_exit_assign_obj;
					} else {
fast_assign_obj:
						value = crex_assign_to_variable_ex(property_val, value, IS_VAR, EX_USES_STRICT_TYPES(), &garbage);
						if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
							ZVAL_COPY(EX_VAR(opline->result.var), value);
						}
						goto exit_assign_obj;
					}
				}
			} else {
				name = C_STR_P(RT_CONSTANT(opline, opline->op2));
				if (EXPECTED(zobj->properties != NULL)) {
					if (UNEXPECTED(GC_REFCOUNT(zobj->properties) > 1)) {
						if (EXPECTED(!(GC_FLAGS(zobj->properties) & IS_ARRAY_IMMUTABLE))) {
							GC_DELREF(zobj->properties);
						}
						zobj->properties = crex_array_dup(zobj->properties);
					}
					property_val = crex_hash_find_known_hash(zobj->properties, name);
					if (property_val) {
						goto fast_assign_obj;
					}
				}

				if (!zobj->ce->__set && (zobj->ce->ce_flags & CREX_ACC_ALLOW_DYNAMIC_PROPERTIES)) {
					if (EXPECTED(zobj->properties == NULL)) {
						rebuild_object_properties(zobj);
					}
					if (IS_VAR == IS_CONST) {
						if (UNEXPECTED(C_OPT_REFCOUNTED_P(value))) {
							C_ADDREF_P(value);
						}
					} else if (IS_VAR != IS_TMP_VAR) {
						if (C_ISREF_P(value)) {
							if (IS_VAR == IS_VAR) {
								crex_reference *ref = C_REF_P(value);
								if (GC_DELREF(ref) == 0) {
									ZVAL_COPY_VALUE(&tmp, C_REFVAL_P(value));
									efree_size(ref, sizeof(crex_reference));
									value = &tmp;
								} else {
									value = C_REFVAL_P(value);
									C_TRY_ADDREF_P(value);
								}
							} else {
								value = C_REFVAL_P(value);
								C_TRY_ADDREF_P(value);
							}
						} else if (IS_VAR == IS_CV) {
							C_TRY_ADDREF_P(value);
						}
						}
					crex_hash_add_new(zobj->properties, name, value);
					if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
						ZVAL_COPY(EX_VAR(opline->result.var), value);
					}
					goto exit_assign_obj;
				}
			}
		}
		name = C_STR_P(RT_CONSTANT(opline, opline->op2));
	} else {
		name = zval_try_get_tmp_string(RT_CONSTANT(opline, opline->op2), &tmp_name);
		if (UNEXPECTED(!name)) {
			zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
			UNDEF_RESULT();
			goto exit_assign_obj;
		}
	}

	if (IS_VAR == IS_CV || IS_VAR == IS_VAR) {
		ZVAL_DEREF(value);
	}

	value = zobj->handlers->write_property(zobj, name, value, (IS_CONST == IS_CONST) ? CACHE_ADDR(opline->extended_value) : NULL);

	if (IS_CONST != IS_CONST) {
		crex_tmp_string_release(tmp_name);
	}

free_and_exit_assign_obj:
	if (UNEXPECTED(RETURN_VALUE_USED(opline)) && value) {
		ZVAL_COPY_DEREF(EX_VAR(opline->result.var), value);
	}
	zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
exit_assign_obj:
	if (garbage) {
		GC_DTOR_NO_REF(garbage);
	}


	/* assign_obj has two opcodes! */
	CREX_VM_NEXT_OPCODE_EX(1, 2);
}

/* No specialization for op_types (CONST|TMPVAR|CV, UNUSED|CONST|VAR) */
static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ASSIGN_OBJ_SPEC_UNUSED_CONST_OP_DATA_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *object, *value, tmp;
	crex_object *zobj;
	crex_string *name, *tmp_name;
	crex_refcounted *garbage = NULL;

	SAVE_OPLINE();
	object = &EX(This);
	value = _get_zval_ptr_cv_BP_VAR_R((opline+1)->op1.var EXECUTE_DATA_CC);

	if (IS_UNUSED != IS_UNUSED && UNEXPECTED(C_TYPE_P(object) != IS_OBJECT)) {
		if (C_ISREF_P(object) && C_TYPE_P(C_REFVAL_P(object)) == IS_OBJECT) {
			object = C_REFVAL_P(object);
			goto assign_object;
		}
		crex_throw_non_object_error(object, RT_CONSTANT(opline, opline->op2) OPLINE_CC EXECUTE_DATA_CC);
		value = &EG(uninitialized_zval);
		goto free_and_exit_assign_obj;
	}

assign_object:
	zobj = C_OBJ_P(object);
	if (IS_CONST == IS_CONST) {
		if (EXPECTED(zobj->ce == CACHED_PTR(opline->extended_value))) {
			void **cache_slot = CACHE_ADDR(opline->extended_value);
			uintptr_t prop_offset = (uintptr_t)CACHED_PTR_EX(cache_slot + 1);
			zval *property_val;

			if (EXPECTED(IS_VALID_PROPERTY_OFFSET(prop_offset))) {
				property_val = OBJ_PROP(zobj, prop_offset);
				if (C_TYPE_P(property_val) != IS_UNDEF) {
					crex_property_info *prop_info = (crex_property_info*) CACHED_PTR_EX(cache_slot + 2);

					if (UNEXPECTED(prop_info != NULL)) {
						value = crex_assign_to_typed_prop(prop_info, property_val, value, &garbage EXECUTE_DATA_CC);
						goto free_and_exit_assign_obj;
					} else {
fast_assign_obj:
						value = crex_assign_to_variable_ex(property_val, value, IS_CV, EX_USES_STRICT_TYPES(), &garbage);
						if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
							ZVAL_COPY(EX_VAR(opline->result.var), value);
						}
						goto exit_assign_obj;
					}
				}
			} else {
				name = C_STR_P(RT_CONSTANT(opline, opline->op2));
				if (EXPECTED(zobj->properties != NULL)) {
					if (UNEXPECTED(GC_REFCOUNT(zobj->properties) > 1)) {
						if (EXPECTED(!(GC_FLAGS(zobj->properties) & IS_ARRAY_IMMUTABLE))) {
							GC_DELREF(zobj->properties);
						}
						zobj->properties = crex_array_dup(zobj->properties);
					}
					property_val = crex_hash_find_known_hash(zobj->properties, name);
					if (property_val) {
						goto fast_assign_obj;
					}
				}

				if (!zobj->ce->__set && (zobj->ce->ce_flags & CREX_ACC_ALLOW_DYNAMIC_PROPERTIES)) {
					if (EXPECTED(zobj->properties == NULL)) {
						rebuild_object_properties(zobj);
					}
					if (IS_CV == IS_CONST) {
						if (UNEXPECTED(C_OPT_REFCOUNTED_P(value))) {
							C_ADDREF_P(value);
						}
					} else if (IS_CV != IS_TMP_VAR) {
						if (C_ISREF_P(value)) {
							if (IS_CV == IS_VAR) {
								crex_reference *ref = C_REF_P(value);
								if (GC_DELREF(ref) == 0) {
									ZVAL_COPY_VALUE(&tmp, C_REFVAL_P(value));
									efree_size(ref, sizeof(crex_reference));
									value = &tmp;
								} else {
									value = C_REFVAL_P(value);
									C_TRY_ADDREF_P(value);
								}
							} else {
								value = C_REFVAL_P(value);
								C_TRY_ADDREF_P(value);
							}
						} else if (IS_CV == IS_CV) {
							C_TRY_ADDREF_P(value);
						}
						}
					crex_hash_add_new(zobj->properties, name, value);
					if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
						ZVAL_COPY(EX_VAR(opline->result.var), value);
					}
					goto exit_assign_obj;
				}
			}
		}
		name = C_STR_P(RT_CONSTANT(opline, opline->op2));
	} else {
		name = zval_try_get_tmp_string(RT_CONSTANT(opline, opline->op2), &tmp_name);
		if (UNEXPECTED(!name)) {

			UNDEF_RESULT();
			goto exit_assign_obj;
		}
	}

	if (IS_CV == IS_CV || IS_CV == IS_VAR) {
		ZVAL_DEREF(value);
	}

	value = zobj->handlers->write_property(zobj, name, value, (IS_CONST == IS_CONST) ? CACHE_ADDR(opline->extended_value) : NULL);

	if (IS_CONST != IS_CONST) {
		crex_tmp_string_release(tmp_name);
	}

free_and_exit_assign_obj:
	if (UNEXPECTED(RETURN_VALUE_USED(opline)) && value) {
		ZVAL_COPY_DEREF(EX_VAR(opline->result.var), value);
	}

exit_assign_obj:
	if (garbage) {
		GC_DTOR_NO_REF(garbage);
	}


	/* assign_obj has two opcodes! */
	CREX_VM_NEXT_OPCODE_EX(1, 2);
}

/* No specialization for op_types (CONST|TMPVAR|CV, UNUSED|CONST|VAR) */
static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ASSIGN_OBJ_REF_SPEC_UNUSED_CONST_OP_DATA_VAR_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *property, *container, *value_ptr;

	SAVE_OPLINE();

	container = &EX(This);
	property = RT_CONSTANT(opline, opline->op2);

	value_ptr = _get_zval_ptr_ptr_var((opline+1)->op1.var EXECUTE_DATA_CC);

	if (1) {
		if (IS_UNUSED == IS_UNUSED) {
			if (IS_CONST == IS_CONST) {
				crex_assign_to_property_reference_this_const(container, property, value_ptr OPLINE_CC EXECUTE_DATA_CC);
			} else {
				crex_assign_to_property_reference_this_var(container, property, value_ptr OPLINE_CC EXECUTE_DATA_CC);
			}
		} else {
			if (IS_CONST == IS_CONST) {
				crex_assign_to_property_reference_var_const(container, property, value_ptr OPLINE_CC EXECUTE_DATA_CC);
			} else {
				crex_assign_to_property_reference_var_var(container, property, value_ptr OPLINE_CC EXECUTE_DATA_CC);
			}
		}
	} else {
		crex_assign_to_property_reference(container, IS_UNUSED, property, IS_CONST, value_ptr OPLINE_CC EXECUTE_DATA_CC);
	}


	zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
	CREX_VM_NEXT_OPCODE_EX(1, 2);
}

/* No specialization for op_types (CONST|TMPVAR|CV, UNUSED|CONST|VAR) */
static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ASSIGN_OBJ_REF_SPEC_UNUSED_CONST_OP_DATA_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *property, *container, *value_ptr;

	SAVE_OPLINE();

	container = &EX(This);
	property = RT_CONSTANT(opline, opline->op2);

	value_ptr = _get_zval_ptr_cv_BP_VAR_W((opline+1)->op1.var EXECUTE_DATA_CC);

	if (1) {
		if (IS_UNUSED == IS_UNUSED) {
			if (IS_CONST == IS_CONST) {
				crex_assign_to_property_reference_this_const(container, property, value_ptr OPLINE_CC EXECUTE_DATA_CC);
			} else {
				crex_assign_to_property_reference_this_var(container, property, value_ptr OPLINE_CC EXECUTE_DATA_CC);
			}
		} else {
			if (IS_CONST == IS_CONST) {
				crex_assign_to_property_reference_var_const(container, property, value_ptr OPLINE_CC EXECUTE_DATA_CC);
			} else {
				crex_assign_to_property_reference_var_var(container, property, value_ptr OPLINE_CC EXECUTE_DATA_CC);
			}
		}
	} else {
		crex_assign_to_property_reference(container, IS_UNUSED, property, IS_CONST, value_ptr OPLINE_CC EXECUTE_DATA_CC);
	}



	CREX_VM_NEXT_OPCODE_EX(1, 2);
}

/* No specialization for op_types (CONST|TMPVAR|CV, UNUSED|CONST|VAR) */
static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ROPE_INIT_SPEC_UNUSED_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	crex_string **rope;
	zval *var;

	/* Compiler allocates the necessary number of zval slots to keep the rope */
	rope = (crex_string**)EX_VAR(opline->result.var);
	if (IS_CONST == IS_CONST) {
		var = RT_CONSTANT(opline, opline->op2);
		rope[0] = C_STR_P(var);
		if (UNEXPECTED(C_REFCOUNTED_P(var))) {
			C_ADDREF_P(var);
		}
	} else {
		var = RT_CONSTANT(opline, opline->op2);
		if (EXPECTED(C_TYPE_P(var) == IS_STRING)) {
			if (IS_CONST == IS_CV) {
				rope[0] = crex_string_copy(C_STR_P(var));
			} else {
				rope[0] = C_STR_P(var);
			}
		} else {
			SAVE_OPLINE();
			if (IS_CONST == IS_CV && UNEXPECTED(C_TYPE_P(var) == IS_UNDEF)) {
				ZVAL_UNDEFINED_OP2();
			}
			rope[0] = zval_get_string_func(var);

			CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
		}
	}
	CREX_VM_NEXT_OPCODE();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FETCH_CLASS_SPEC_UNUSED_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	zval *class_name;
	USE_OPLINE

	SAVE_OPLINE();
	if (IS_CONST == IS_UNUSED) {
		C_CE_P(EX_VAR(opline->result.var)) = crex_fetch_class(NULL, opline->op1.num);
		CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
	} else if (IS_CONST == IS_CONST) {
		crex_class_entry *ce = CACHED_PTR(opline->extended_value);

		if (UNEXPECTED(ce == NULL)) {
			class_name = RT_CONSTANT(opline, opline->op2);
			ce = crex_fetch_class_by_name(C_STR_P(class_name), C_STR_P(class_name + 1), opline->op1.num);
			CACHE_PTR(opline->extended_value, ce);
		}
		C_CE_P(EX_VAR(opline->result.var)) = ce;
	} else {
		class_name = RT_CONSTANT(opline, opline->op2);
try_class_name:
		if (C_TYPE_P(class_name) == IS_OBJECT) {
			C_CE_P(EX_VAR(opline->result.var)) = C_OBJCE_P(class_name);
		} else if (C_TYPE_P(class_name) == IS_STRING) {
			C_CE_P(EX_VAR(opline->result.var)) = crex_fetch_class(C_STR_P(class_name), opline->op1.num);
		} else if ((IS_CONST & (IS_VAR|IS_CV)) && C_TYPE_P(class_name) == IS_REFERENCE) {
			class_name = C_REFVAL_P(class_name);
			goto try_class_name;
		} else {
			if (IS_CONST == IS_CV && UNEXPECTED(C_TYPE_P(class_name) == IS_UNDEF)) {
				ZVAL_UNDEFINED_OP2();
				if (UNEXPECTED(EG(exception) != NULL)) {
					HANDLE_EXCEPTION();
				}
			}
			crex_throw_error(NULL, "Class name must be a valid object or a string");
		}
	}

	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_VM_HOT CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_INIT_METHOD_CALL_SPEC_UNUSED_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *function_name;
	zval *object;
	crex_function *fbc;
	crex_class_entry *called_scope;
	crex_object *obj;
	crex_execute_data *call;
	uint32_t call_info;

	SAVE_OPLINE();

	object = &EX(This);

	if (IS_CONST != IS_CONST) {
		function_name = RT_CONSTANT(opline, opline->op2);
	}

	if (IS_CONST != IS_CONST &&
	    UNEXPECTED(C_TYPE_P(function_name) != IS_STRING)) {
		do {
			if ((IS_CONST & (IS_VAR|IS_CV)) && C_ISREF_P(function_name)) {
				function_name = C_REFVAL_P(function_name);
				if (EXPECTED(C_TYPE_P(function_name) == IS_STRING)) {
					break;
				}
			} else if (IS_CONST == IS_CV && UNEXPECTED(C_TYPE_P(function_name) == IS_UNDEF)) {
				ZVAL_UNDEFINED_OP2();
				if (UNEXPECTED(EG(exception) != NULL)) {

					HANDLE_EXCEPTION();
				}
			}
			crex_throw_error(NULL, "Method name must be a string");


			HANDLE_EXCEPTION();
		} while (0);
	}

	if (IS_UNUSED == IS_UNUSED) {
		obj = C_OBJ_P(object);
	} else {
		do {
			if (IS_UNUSED != IS_CONST && EXPECTED(C_TYPE_P(object) == IS_OBJECT)) {
				obj = C_OBJ_P(object);
			} else {
				if ((IS_UNUSED & (IS_VAR|IS_CV)) && EXPECTED(C_ISREF_P(object))) {
					crex_reference *ref = C_REF_P(object);

					object = &ref->val;
					if (EXPECTED(C_TYPE_P(object) == IS_OBJECT)) {
						obj = C_OBJ_P(object);
						if (IS_UNUSED & IS_VAR) {
							if (UNEXPECTED(GC_DELREF(ref) == 0)) {
								efree_size(ref, sizeof(crex_reference));
							} else {
								C_ADDREF_P(object);
							}
						}
						break;
					}
				}
				if (IS_UNUSED == IS_CV && UNEXPECTED(C_TYPE_P(object) == IS_UNDEF)) {
					object = ZVAL_UNDEFINED_OP1();
					if (UNEXPECTED(EG(exception) != NULL)) {
						if (IS_CONST != IS_CONST) {

						}
						HANDLE_EXCEPTION();
					}
				}
				if (IS_CONST == IS_CONST) {
					function_name = RT_CONSTANT(opline, opline->op2);
				}
				crex_invalid_method_call(object, function_name);


				HANDLE_EXCEPTION();
			}
		} while (0);
	}

	called_scope = obj->ce;

	if (IS_CONST == IS_CONST &&
	    EXPECTED(CACHED_PTR(opline->result.num) == called_scope)) {
		fbc = CACHED_PTR(opline->result.num + sizeof(void*));
	} else {
		crex_object *orig_obj = obj;

		if (IS_CONST == IS_CONST) {
			function_name = RT_CONSTANT(opline, opline->op2);
		}

		/* First, locate the function. */
		fbc = obj->handlers->get_method(&obj, C_STR_P(function_name), ((IS_CONST == IS_CONST) ? (RT_CONSTANT(opline, opline->op2) + 1) : NULL));
		if (UNEXPECTED(fbc == NULL)) {
			if (EXPECTED(!EG(exception))) {
				crex_undefined_method(obj->ce, C_STR_P(function_name));
			}

			if ((IS_UNUSED & (IS_VAR|IS_TMP_VAR)) && GC_DELREF(orig_obj) == 0) {
				crex_objects_store_del(orig_obj);
			}
			HANDLE_EXCEPTION();
		}
		if (IS_CONST == IS_CONST &&
		    EXPECTED(!(fbc->common.fn_flags & (CREX_ACC_CALL_VIA_TRAMPOLINE|CREX_ACC_NEVER_CACHE))) &&
		    EXPECTED(obj == orig_obj)) {
			CACHE_POLYMORPHIC_PTR(opline->result.num, called_scope, fbc);
		}
		if ((IS_UNUSED & (IS_VAR|IS_TMP_VAR)) && UNEXPECTED(obj != orig_obj)) {
			GC_ADDREF(obj); /* For $this pointer */
			if (GC_DELREF(orig_obj) == 0) {
				crex_objects_store_del(orig_obj);
			}
		}
		if (EXPECTED(fbc->type == CREX_USER_FUNCTION) && UNEXPECTED(!RUN_TIME_CACHE(&fbc->op_array))) {
			init_func_run_time_cache(&fbc->op_array);
		}
	}

	if (IS_CONST != IS_CONST) {

	}

	call_info = CREX_CALL_NESTED_FUNCTION | CREX_CALL_HAS_THIS;
	if (UNEXPECTED((fbc->common.fn_flags & CREX_ACC_STATIC) != 0)) {
		if ((IS_UNUSED & (IS_VAR|IS_TMP_VAR)) && GC_DELREF(obj) == 0) {
			crex_objects_store_del(obj);
			if (UNEXPECTED(EG(exception))) {
				HANDLE_EXCEPTION();
			}
		}
		/* call static method */
		obj = (crex_object*)called_scope;
		call_info = CREX_CALL_NESTED_FUNCTION;
	} else if (IS_UNUSED & (IS_VAR|IS_TMP_VAR|IS_CV)) {
		if (IS_UNUSED == IS_CV) {
			GC_ADDREF(obj); /* For $this pointer */
		}
		/* CV may be changed indirectly (e.g. when it's a reference) */
		call_info = CREX_CALL_NESTED_FUNCTION | CREX_CALL_HAS_THIS | CREX_CALL_RELEASE_THIS;
	}

	call = crex_vm_stack_push_call_frame(call_info,
		fbc, opline->extended_value, obj);
	call->prev_execute_data = EX(call);
	EX(call) = call;

	CREX_VM_NEXT_OPCODE();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_INIT_STATIC_METHOD_CALL_SPEC_UNUSED_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *function_name;
	crex_class_entry *ce;
	uint32_t call_info;
	crex_function *fbc;
	crex_execute_data *call;

	SAVE_OPLINE();

	if (IS_UNUSED == IS_CONST) {
		/* no function found. try a static method in class */
		ce = CACHED_PTR(opline->result.num);
		if (UNEXPECTED(ce == NULL)) {
			ce = crex_fetch_class_by_name(C_STR_P(RT_CONSTANT(opline, opline->op1)), C_STR_P(RT_CONSTANT(opline, opline->op1) + 1), CREX_FETCH_CLASS_DEFAULT | CREX_FETCH_CLASS_EXCEPTION);
			if (UNEXPECTED(ce == NULL)) {

				HANDLE_EXCEPTION();
			}
			if (IS_CONST != IS_CONST) {
				CACHE_PTR(opline->result.num, ce);
			}
		}
	} else if (IS_UNUSED == IS_UNUSED) {
		ce = crex_fetch_class(NULL, opline->op1.num);
		if (UNEXPECTED(ce == NULL)) {

			HANDLE_EXCEPTION();
		}
	} else {
		ce = C_CE_P(EX_VAR(opline->op1.var));
	}

	if (IS_UNUSED == IS_CONST &&
	    IS_CONST == IS_CONST &&
	    EXPECTED((fbc = CACHED_PTR(opline->result.num + sizeof(void*))) != NULL)) {
		/* nothing to do */
	} else if (IS_UNUSED != IS_CONST &&
	           IS_CONST == IS_CONST &&
	           EXPECTED(CACHED_PTR(opline->result.num) == ce)) {
		fbc = CACHED_PTR(opline->result.num + sizeof(void*));
	} else if (IS_CONST != IS_UNUSED) {
		function_name = RT_CONSTANT(opline, opline->op2);
		if (IS_CONST != IS_CONST) {
			if (UNEXPECTED(C_TYPE_P(function_name) != IS_STRING)) {
				do {
					if (IS_CONST & (IS_VAR|IS_CV) && C_ISREF_P(function_name)) {
						function_name = C_REFVAL_P(function_name);
						if (EXPECTED(C_TYPE_P(function_name) == IS_STRING)) {
							break;
						}
					} else if (IS_CONST == IS_CV && UNEXPECTED(C_TYPE_P(function_name) == IS_UNDEF)) {
						ZVAL_UNDEFINED_OP2();
						if (UNEXPECTED(EG(exception) != NULL)) {
							HANDLE_EXCEPTION();
						}
					}
					crex_throw_error(NULL, "Method name must be a string");

					HANDLE_EXCEPTION();
				} while (0);
			}
		}

		if (ce->get_static_method) {
			fbc = ce->get_static_method(ce, C_STR_P(function_name));
		} else {
			fbc = crex_std_get_static_method(ce, C_STR_P(function_name), ((IS_CONST == IS_CONST) ? (RT_CONSTANT(opline, opline->op2) + 1) : NULL));
		}
		if (UNEXPECTED(fbc == NULL)) {
			if (EXPECTED(!EG(exception))) {
				crex_undefined_method(ce, C_STR_P(function_name));
			}

			HANDLE_EXCEPTION();
		}
		if (IS_CONST == IS_CONST &&
		    EXPECTED(!(fbc->common.fn_flags & (CREX_ACC_CALL_VIA_TRAMPOLINE|CREX_ACC_NEVER_CACHE))) &&
			EXPECTED(!(fbc->common.scope->ce_flags & CREX_ACC_TRAIT))) {
			CACHE_POLYMORPHIC_PTR(opline->result.num, ce, fbc);
		}
		if (EXPECTED(fbc->type == CREX_USER_FUNCTION) && UNEXPECTED(!RUN_TIME_CACHE(&fbc->op_array))) {
			init_func_run_time_cache(&fbc->op_array);
		}
		if (IS_CONST != IS_CONST) {

		}
	} else {
		if (UNEXPECTED(ce->constructor == NULL)) {
			crex_throw_error(NULL, "Cannot call constructor");
			HANDLE_EXCEPTION();
		}
		if (C_TYPE(EX(This)) == IS_OBJECT && C_OBJ(EX(This))->ce != ce->constructor->common.scope && (ce->constructor->common.fn_flags & CREX_ACC_PRIVATE)) {
			crex_throw_error(NULL, "Cannot call private %s::__main()", ZSTR_VAL(ce->name));
			HANDLE_EXCEPTION();
		}
		fbc = ce->constructor;
		if (EXPECTED(fbc->type == CREX_USER_FUNCTION) && UNEXPECTED(!RUN_TIME_CACHE(&fbc->op_array))) {
			init_func_run_time_cache(&fbc->op_array);
		}
	}

	if (!(fbc->common.fn_flags & CREX_ACC_STATIC)) {
		if (C_TYPE(EX(This)) == IS_OBJECT && instanceof_function(C_OBJCE(EX(This)), ce)) {
			ce = (crex_class_entry*)C_OBJ(EX(This));
			call_info = CREX_CALL_NESTED_FUNCTION | CREX_CALL_HAS_THIS;
		} else {
			crex_non_static_method_call(fbc);
			HANDLE_EXCEPTION();
		}
	} else {
		/* previous opcode is CREX_FETCH_CLASS */
		if (IS_UNUSED == IS_UNUSED
		 && ((opline->op1.num & CREX_FETCH_CLASS_MASK) == CREX_FETCH_CLASS_PARENT ||
		     (opline->op1.num & CREX_FETCH_CLASS_MASK) == CREX_FETCH_CLASS_SELF)) {
			if (C_TYPE(EX(This)) == IS_OBJECT) {
				ce = C_OBJCE(EX(This));
			} else {
				ce = C_CE(EX(This));
			}
		}
		call_info = CREX_CALL_NESTED_FUNCTION;
	}

	call = crex_vm_stack_push_call_frame(call_info,
		fbc, opline->extended_value, ce);
	call->prev_execute_data = EX(call);
	EX(call) = call;

	CREX_VM_NEXT_OPCODE();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_CHECK_FUNC_ARG_SPEC_UNUSED_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	uint32_t arg_num;

	if (IS_CONST == IS_CONST) {
		crex_string *arg_name = C_STR_P(RT_CONSTANT(opline, opline->op2));
		arg_num = crex_get_arg_offset_by_name(
			EX(call)->func, arg_name, CACHE_ADDR(opline->result.num)) + 1;
		if (UNEXPECTED(arg_num == 0)) {
			/* Treat this as a by-value argument, and throw an error during SEND. */
			CREX_DEL_CALL_FLAG(EX(call), CREX_CALL_SEND_ARG_BY_REF);
			CREX_VM_NEXT_OPCODE();
		}
	} else {
		arg_num = opline->op2.num;
	}

	if (EXPECTED(arg_num <= MAX_ARG_FLAG_NUM)) {
		if (QUICK_ARG_SHOULD_BE_SENT_BY_REF(EX(call)->func, arg_num)) {
			CREX_ADD_CALL_FLAG(EX(call), CREX_CALL_SEND_ARG_BY_REF);
		} else {
			CREX_DEL_CALL_FLAG(EX(call), CREX_CALL_SEND_ARG_BY_REF);
		}
	} else if (ARG_SHOULD_BE_SENT_BY_REF(EX(call)->func, arg_num)) {
		CREX_ADD_CALL_FLAG(EX(call), CREX_CALL_SEND_ARG_BY_REF);
	} else {
		CREX_DEL_CALL_FLAG(EX(call), CREX_CALL_SEND_ARG_BY_REF);
	}
	CREX_VM_NEXT_OPCODE();
}

static CREX_VM_HOT CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FETCH_CONSTANT_SPEC_UNUSED_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	crex_constant *c;

	c = CACHED_PTR(opline->extended_value);
	if (EXPECTED(c != NULL) && EXPECTED(!IS_SPECIAL_CACHE_VAL(c))) {
		ZVAL_COPY_OR_DUP(EX_VAR(opline->result.var), &c->value);
		CREX_VM_NEXT_OPCODE();
	}

	SAVE_OPLINE();
	crex_quick_get_constant(RT_CONSTANT(opline, opline->op2) + 1, opline->op1.num OPLINE_CC EXECUTE_DATA_CC);
	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FETCH_CLASS_CONSTANT_SPEC_UNUSED_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	crex_class_entry *ce, *scope;
	crex_class_constant *c;
	zval *value, *zv, *constant_zv;
	crex_string *constant_name;
	USE_OPLINE

	SAVE_OPLINE();

	do {
		if (IS_UNUSED == IS_CONST && IS_CONST == IS_CONST) {
			if (EXPECTED(CACHED_PTR(opline->extended_value + sizeof(void*)))) {
				value = CACHED_PTR(opline->extended_value + sizeof(void*));
				break;
			}
		}
		if (IS_UNUSED == IS_CONST) {
			if (EXPECTED(CACHED_PTR(opline->extended_value))) {
				ce = CACHED_PTR(opline->extended_value);
			} else {
				ce = crex_fetch_class_by_name(C_STR_P(RT_CONSTANT(opline, opline->op1)), C_STR_P(RT_CONSTANT(opline, opline->op1) + 1), CREX_FETCH_CLASS_DEFAULT | CREX_FETCH_CLASS_EXCEPTION);
				if (UNEXPECTED(ce == NULL)) {
					ZVAL_UNDEF(EX_VAR(opline->result.var));

					HANDLE_EXCEPTION();
				}
				CACHE_PTR(opline->extended_value, ce);
			}
		} else if (IS_UNUSED == IS_UNUSED) {
			ce = crex_fetch_class(NULL, opline->op1.num);
			if (UNEXPECTED(ce == NULL)) {
				ZVAL_UNDEF(EX_VAR(opline->result.var));

				HANDLE_EXCEPTION();
			}
		} else {
			ce = C_CE_P(EX_VAR(opline->op1.var));
		}
		if (IS_UNUSED != IS_CONST
			&& IS_CONST == IS_CONST
			&& EXPECTED(CACHED_PTR(opline->extended_value) == ce)) {
			value = CACHED_PTR(opline->extended_value + sizeof(void*));
			break;
		}

		constant_zv = RT_CONSTANT(opline, opline->op2);
		if (UNEXPECTED(C_TYPE_P(constant_zv) != IS_STRING)) {
			crex_invalid_class_constant_type_error(C_TYPE_P(constant_zv));
			ZVAL_UNDEF(EX_VAR(opline->result.var));

			HANDLE_EXCEPTION();
		}
		constant_name = C_STR_P(constant_zv);
		/* Magic 'class' for constant OP2 is caught at compile-time */
		if (IS_CONST != IS_CONST && UNEXPECTED(crex_string_equals_literal_ci(constant_name, "class"))) {
			ZVAL_STR_COPY(EX_VAR(opline->result.var), ce->name);

			CREX_VM_NEXT_OPCODE();
		}
		zv = IS_CONST == IS_CONST
			? crex_hash_find_known_hash(CE_CONSTANTS_TABLE(ce), constant_name)
			: crex_hash_find(CE_CONSTANTS_TABLE(ce), constant_name);

		if (EXPECTED(zv != NULL)) {
			c = C_PTR_P(zv);
			scope = EX(func)->op_array.scope;
			if (!crex_verify_const_access(c, scope)) {
				crex_throw_error(NULL, "Cannot access %s constant %s::%s", crex_visibility_string(CREX_CLASS_CONST_FLAGS(c)), ZSTR_VAL(ce->name), ZSTR_VAL(constant_name));
				ZVAL_UNDEF(EX_VAR(opline->result.var));

				HANDLE_EXCEPTION();
			}

			if (ce->ce_flags & CREX_ACC_TRAIT) {
				crex_throw_error(NULL, "Cannot access trait constant %s::%s directly", ZSTR_VAL(ce->name), ZSTR_VAL(constant_name));
				ZVAL_UNDEF(EX_VAR(opline->result.var));

				HANDLE_EXCEPTION();
			}

			bool is_constant_deprecated = CREX_CLASS_CONST_FLAGS(c) & CREX_ACC_DEPRECATED;
			if (UNEXPECTED(is_constant_deprecated)) {
				crex_error(E_DEPRECATED, "Constant %s::%s is deprecated", ZSTR_VAL(ce->name), ZSTR_VAL(constant_name));

				if (EG(exception)) {
					ZVAL_UNDEF(EX_VAR(opline->result.var));

					HANDLE_EXCEPTION();
				}
			}

			value = &c->value;
			// Enums require loading of all class constants to build the backed enum table
			if (ce->ce_flags & CREX_ACC_ENUM && ce->enum_backing_type != IS_UNDEF && ce->type == CREX_USER_CLASS && !(ce->ce_flags & CREX_ACC_CONSTANTS_UPDATED)) {
				if (UNEXPECTED(crex_update_class_constants(ce) == FAILURE)) {
					ZVAL_UNDEF(EX_VAR(opline->result.var));

					HANDLE_EXCEPTION();
				}
			}
			if (C_TYPE_P(value) == IS_CONSTANT_AST) {
				if (UNEXPECTED(crex_update_class_constant(c, constant_name, c->ce) != SUCCESS)) {
					ZVAL_UNDEF(EX_VAR(opline->result.var));

					HANDLE_EXCEPTION();
				}
			}
			if (IS_CONST == IS_CONST && !is_constant_deprecated) {
				CACHE_POLYMORPHIC_PTR(opline->extended_value, ce, value);
			}
		} else {
			crex_throw_error(NULL, "Undefined constant %s::%s",
				ZSTR_VAL(ce->name), ZSTR_VAL(constant_name));
			ZVAL_UNDEF(EX_VAR(opline->result.var));

			HANDLE_EXCEPTION();
		}
	} while (0);

	ZVAL_COPY_OR_DUP(EX_VAR(opline->result.var), value);

	CREX_VM_NEXT_OPCODE();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_INIT_ARRAY_SPEC_UNUSED_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	zval *array;
	uint32_t size;
	USE_OPLINE

	array = EX_VAR(opline->result.var);
	if (IS_UNUSED != IS_UNUSED) {
		size = opline->extended_value >> CREX_ARRAY_SIZE_SHIFT;
		ZVAL_ARR(array, crex_new_array(size));
		/* Explicitly initialize array as not-packed if flag is set */
		if (opline->extended_value & CREX_ARRAY_NOT_PACKED) {
			crex_hash_real_init_mixed(C_ARRVAL_P(array));
		}
		CREX_VM_TAIL_CALL(CREX_NULL_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU));
	} else {
		ZVAL_ARR(array, crex_new_array(0));
		CREX_VM_NEXT_OPCODE();
	}
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_UNSET_OBJ_SPEC_UNUSED_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;
	zval *offset;
	crex_string *name, *tmp_name;

	SAVE_OPLINE();
	container = &EX(This);
	offset = RT_CONSTANT(opline, opline->op2);

	do {
		if (IS_UNUSED != IS_UNUSED && UNEXPECTED(C_TYPE_P(container) != IS_OBJECT)) {
			if (C_ISREF_P(container)) {
				container = C_REFVAL_P(container);
				if (C_TYPE_P(container) != IS_OBJECT) {
					if (IS_UNUSED == IS_CV
					 && UNEXPECTED(C_TYPE_P(container) == IS_UNDEF)) {
						ZVAL_UNDEFINED_OP1();
					}
					break;
				}
			} else {
				break;
			}
		}
		if (IS_CONST == IS_CONST) {
			name = C_STR_P(offset);
		} else {
			name = zval_try_get_tmp_string(offset, &tmp_name);
			if (UNEXPECTED(!name)) {
				break;
			}
		}
		C_OBJ_HT_P(container)->unset_property(C_OBJ_P(container), name, ((IS_CONST == IS_CONST) ? CACHE_ADDR(opline->extended_value) : NULL));
		if (IS_CONST != IS_CONST) {
			crex_tmp_string_release(tmp_name);
		}
	} while (0);


	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ISSET_ISEMPTY_PROP_OBJ_SPEC_UNUSED_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;
	int result;
	zval *offset;
	crex_string *name, *tmp_name;

	SAVE_OPLINE();
	container = &EX(This);
	offset = RT_CONSTANT(opline, opline->op2);

	if (IS_UNUSED == IS_CONST ||
	    (IS_UNUSED != IS_UNUSED && UNEXPECTED(C_TYPE_P(container) != IS_OBJECT))) {
		if ((IS_UNUSED & (IS_VAR|IS_CV)) && C_ISREF_P(container)) {
			container = C_REFVAL_P(container);
			if (UNEXPECTED(C_TYPE_P(container) != IS_OBJECT)) {
				result = (opline->extended_value & CREX_ISEMPTY);
				goto isset_object_finish;
			}
		} else {
			result = (opline->extended_value & CREX_ISEMPTY);
			goto isset_object_finish;
		}
	}

	if (IS_CONST == IS_CONST) {
		name = C_STR_P(offset);
	} else {
		name = zval_try_get_tmp_string(offset, &tmp_name);
		if (UNEXPECTED(!name)) {
			result = 0;
			goto isset_object_finish;
		}
	}

	result =
		(opline->extended_value & CREX_ISEMPTY) ^
		C_OBJ_HT_P(container)->has_property(C_OBJ_P(container), name, (opline->extended_value & CREX_ISEMPTY), ((IS_CONST == IS_CONST) ? CACHE_ADDR(opline->extended_value & ~CREX_ISEMPTY) : NULL));

	if (IS_CONST != IS_CONST) {
		crex_tmp_string_release(tmp_name);
	}

isset_object_finish:


	CREX_VM_SMART_BRANCH(result, 1);
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_YIELD_SPEC_UNUSED_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	crex_generator *generator = crex_get_running_generator(EXECUTE_DATA_C);

	SAVE_OPLINE();
	if (UNEXPECTED(generator->flags & CREX_GENERATOR_FORCED_CLOSE)) {
		CREX_VM_TAIL_CALL(crex_yield_in_closed_generator_helper_SPEC(CREX_OPCODE_HANDLER_ARGS_PASSTHRU));
	}

	/* Destroy the previously yielded value */
	zval_ptr_dtor(&generator->value);

	/* Destroy the previously yielded key */
	zval_ptr_dtor(&generator->key);

	/* Set the new yielded value */
	if (IS_UNUSED != IS_UNUSED) {
		if (UNEXPECTED(EX(func)->op_array.fn_flags & CREX_ACC_RETURN_REFERENCE)) {
			/* Constants and temporary variables aren't yieldable by reference,
			 * but we still allow them with a notice. */
			if (IS_UNUSED & (IS_CONST|IS_TMP_VAR)) {
				zval *value;

				crex_error(E_NOTICE, "Only variable references should be yielded by reference");

				value = NULL;
				ZVAL_COPY_VALUE(&generator->value, value);
				if (IS_UNUSED == IS_CONST) {
					if (UNEXPECTED(C_OPT_REFCOUNTED(generator->value))) {
						C_ADDREF(generator->value);
					}
				}
			} else {
				zval *value_ptr = NULL;

				/* If a function call result is yielded and the function did
				 * not return by reference we throw a notice. */
				do {
					if (IS_UNUSED == IS_VAR) {
						CREX_ASSERT(value_ptr != &EG(uninitialized_zval));
						if (opline->extended_value == CREX_RETURNS_FUNCTION
						 && !C_ISREF_P(value_ptr)) {
							crex_error(E_NOTICE, "Only variable references should be yielded by reference");
							ZVAL_COPY(&generator->value, value_ptr);
							break;
						}
					}
					if (C_ISREF_P(value_ptr)) {
						C_ADDREF_P(value_ptr);
					} else {
						ZVAL_MAKE_REF_EX(value_ptr, 2);
					}
					ZVAL_REF(&generator->value, C_REF_P(value_ptr));
				} while (0);

			}
		} else {
			zval *value = NULL;

			/* Consts, temporary variables and references need copying */
			if (IS_UNUSED == IS_CONST) {
				ZVAL_COPY_VALUE(&generator->value, value);
				if (UNEXPECTED(C_OPT_REFCOUNTED(generator->value))) {
					C_ADDREF(generator->value);
				}
			} else if (IS_UNUSED == IS_TMP_VAR) {
				ZVAL_COPY_VALUE(&generator->value, value);
			} else if ((IS_UNUSED & (IS_VAR|IS_CV)) && C_ISREF_P(value)) {
				ZVAL_COPY(&generator->value, C_REFVAL_P(value));

			} else {
				ZVAL_COPY_VALUE(&generator->value, value);
				if (IS_UNUSED == IS_CV) {
					if (C_OPT_REFCOUNTED_P(value)) C_ADDREF_P(value);
				}
			}
		}
	} else {
		/* If no value was specified yield null */
		ZVAL_NULL(&generator->value);
	}

	/* Set the new yielded key */
	if (IS_CONST != IS_UNUSED) {
		zval *key = RT_CONSTANT(opline, opline->op2);
		if ((IS_CONST & (IS_CV|IS_VAR)) && UNEXPECTED(C_TYPE_P(key) == IS_REFERENCE)) {
			key = C_REFVAL_P(key);
		}
		ZVAL_COPY(&generator->key, key);

		if (C_TYPE(generator->key) == IS_LONG
		    && C_LVAL(generator->key) > generator->largest_used_integer_key
		) {
			generator->largest_used_integer_key = C_LVAL(generator->key);
		}
	} else {
		/* If no key was specified we use auto-increment keys */
		generator->largest_used_integer_key++;
		ZVAL_LONG(&generator->key, generator->largest_used_integer_key);
	}

	if (RETURN_VALUE_USED(opline)) {
		/* If the return value of yield is used set the send
		 * target and initialize it to NULL */
		generator->send_target = EX_VAR(opline->result.var);
		ZVAL_NULL(generator->send_target);
	} else {
		generator->send_target = NULL;
	}

	/* We increment to the next op, so we are at the correct position when the
	 * generator is resumed. */
	CREX_VM_INC_OPCODE();

	/* The GOTO VM uses a local opline variable. We need to set the opline
	 * variable in execute_data so we don't resume at an old position. */
	SAVE_OPLINE();

	CREX_VM_RETURN();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FETCH_CLASS_CONSTANT_SPEC_UNUSED_TMPVARCV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	crex_class_entry *ce, *scope;
	crex_class_constant *c;
	zval *value, *zv, *constant_zv;
	crex_string *constant_name;
	USE_OPLINE

	SAVE_OPLINE();

	do {
		if (IS_UNUSED == IS_CONST && (IS_TMP_VAR|IS_VAR|IS_CV) == IS_CONST) {
			if (EXPECTED(CACHED_PTR(opline->extended_value + sizeof(void*)))) {
				value = CACHED_PTR(opline->extended_value + sizeof(void*));
				break;
			}
		}
		if (IS_UNUSED == IS_CONST) {
			if (EXPECTED(CACHED_PTR(opline->extended_value))) {
				ce = CACHED_PTR(opline->extended_value);
			} else {
				ce = crex_fetch_class_by_name(C_STR_P(RT_CONSTANT(opline, opline->op1)), C_STR_P(RT_CONSTANT(opline, opline->op1) + 1), CREX_FETCH_CLASS_DEFAULT | CREX_FETCH_CLASS_EXCEPTION);
				if (UNEXPECTED(ce == NULL)) {
					ZVAL_UNDEF(EX_VAR(opline->result.var));
					FREE_OP(opline->op2_type, opline->op2.var);
					HANDLE_EXCEPTION();
				}
				CACHE_PTR(opline->extended_value, ce);
			}
		} else if (IS_UNUSED == IS_UNUSED) {
			ce = crex_fetch_class(NULL, opline->op1.num);
			if (UNEXPECTED(ce == NULL)) {
				ZVAL_UNDEF(EX_VAR(opline->result.var));
				FREE_OP(opline->op2_type, opline->op2.var);
				HANDLE_EXCEPTION();
			}
		} else {
			ce = C_CE_P(EX_VAR(opline->op1.var));
		}
		if (IS_UNUSED != IS_CONST
			&& (IS_TMP_VAR|IS_VAR|IS_CV) == IS_CONST
			&& EXPECTED(CACHED_PTR(opline->extended_value) == ce)) {
			value = CACHED_PTR(opline->extended_value + sizeof(void*));
			break;
		}

		constant_zv = _get_zval_ptr_tmpvarcv(opline->op2_type, opline->op2, BP_VAR_R EXECUTE_DATA_CC);
		if (UNEXPECTED(C_TYPE_P(constant_zv) != IS_STRING)) {
			crex_invalid_class_constant_type_error(C_TYPE_P(constant_zv));
			ZVAL_UNDEF(EX_VAR(opline->result.var));
			FREE_OP(opline->op2_type, opline->op2.var);
			HANDLE_EXCEPTION();
		}
		constant_name = C_STR_P(constant_zv);
		/* Magic 'class' for constant OP2 is caught at compile-time */
		if ((IS_TMP_VAR|IS_VAR|IS_CV) != IS_CONST && UNEXPECTED(crex_string_equals_literal_ci(constant_name, "class"))) {
			ZVAL_STR_COPY(EX_VAR(opline->result.var), ce->name);
			FREE_OP(opline->op2_type, opline->op2.var);
			CREX_VM_NEXT_OPCODE();
		}
		zv = (IS_TMP_VAR|IS_VAR|IS_CV) == IS_CONST
			? crex_hash_find_known_hash(CE_CONSTANTS_TABLE(ce), constant_name)
			: crex_hash_find(CE_CONSTANTS_TABLE(ce), constant_name);

		if (EXPECTED(zv != NULL)) {
			c = C_PTR_P(zv);
			scope = EX(func)->op_array.scope;
			if (!crex_verify_const_access(c, scope)) {
				crex_throw_error(NULL, "Cannot access %s constant %s::%s", crex_visibility_string(CREX_CLASS_CONST_FLAGS(c)), ZSTR_VAL(ce->name), ZSTR_VAL(constant_name));
				ZVAL_UNDEF(EX_VAR(opline->result.var));
				FREE_OP(opline->op2_type, opline->op2.var);
				HANDLE_EXCEPTION();
			}

			if (ce->ce_flags & CREX_ACC_TRAIT) {
				crex_throw_error(NULL, "Cannot access trait constant %s::%s directly", ZSTR_VAL(ce->name), ZSTR_VAL(constant_name));
				ZVAL_UNDEF(EX_VAR(opline->result.var));
				FREE_OP(opline->op2_type, opline->op2.var);
				HANDLE_EXCEPTION();
			}

			bool is_constant_deprecated = CREX_CLASS_CONST_FLAGS(c) & CREX_ACC_DEPRECATED;
			if (UNEXPECTED(is_constant_deprecated)) {
				crex_error(E_DEPRECATED, "Constant %s::%s is deprecated", ZSTR_VAL(ce->name), ZSTR_VAL(constant_name));

				if (EG(exception)) {
					ZVAL_UNDEF(EX_VAR(opline->result.var));
					FREE_OP(opline->op2_type, opline->op2.var);
					HANDLE_EXCEPTION();
				}
			}

			value = &c->value;
			// Enums require loading of all class constants to build the backed enum table
			if (ce->ce_flags & CREX_ACC_ENUM && ce->enum_backing_type != IS_UNDEF && ce->type == CREX_USER_CLASS && !(ce->ce_flags & CREX_ACC_CONSTANTS_UPDATED)) {
				if (UNEXPECTED(crex_update_class_constants(ce) == FAILURE)) {
					ZVAL_UNDEF(EX_VAR(opline->result.var));
					FREE_OP(opline->op2_type, opline->op2.var);
					HANDLE_EXCEPTION();
				}
			}
			if (C_TYPE_P(value) == IS_CONSTANT_AST) {
				if (UNEXPECTED(crex_update_class_constant(c, constant_name, c->ce) != SUCCESS)) {
					ZVAL_UNDEF(EX_VAR(opline->result.var));
					FREE_OP(opline->op2_type, opline->op2.var);
					HANDLE_EXCEPTION();
				}
			}
			if ((IS_TMP_VAR|IS_VAR|IS_CV) == IS_CONST && !is_constant_deprecated) {
				CACHE_POLYMORPHIC_PTR(opline->extended_value, ce, value);
			}
		} else {
			crex_throw_error(NULL, "Undefined constant %s::%s",
				ZSTR_VAL(ce->name), ZSTR_VAL(constant_name));
			ZVAL_UNDEF(EX_VAR(opline->result.var));
			FREE_OP(opline->op2_type, opline->op2.var);
			HANDLE_EXCEPTION();
		}
	} while (0);

	ZVAL_COPY_OR_DUP(EX_VAR(opline->result.var), value);

	FREE_OP(opline->op2_type, opline->op2.var);
	CREX_VM_NEXT_OPCODE();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ASSIGN_OBJ_OP_SPEC_UNUSED_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *object;
	zval *property;
	zval *value;
	zval *zptr;
	void **cache_slot;
	crex_property_info *prop_info;
	crex_object *zobj;
	crex_string *name, *tmp_name;

	SAVE_OPLINE();
	object = &EX(This);
	property = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);

	do {
		value = get_op_data_zval_ptr_r((opline+1)->op1_type, (opline+1)->op1);

		if (IS_UNUSED != IS_UNUSED && UNEXPECTED(C_TYPE_P(object) != IS_OBJECT)) {
			if (C_ISREF_P(object) && C_TYPE_P(C_REFVAL_P(object)) == IS_OBJECT) {
				object = C_REFVAL_P(object);
				goto assign_op_object;
			}
			if (IS_UNUSED == IS_CV
			 && UNEXPECTED(C_TYPE_P(object) == IS_UNDEF)) {
				ZVAL_UNDEFINED_OP1();
			}
			crex_throw_non_object_error(object, property OPLINE_CC EXECUTE_DATA_CC);
			break;
		}

assign_op_object:
		/* here we are sure we are dealing with an object */
		zobj = C_OBJ_P(object);
		if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
			name = C_STR_P(property);
		} else {
			name = zval_try_get_tmp_string(property, &tmp_name);
			if (UNEXPECTED(!name)) {
				UNDEF_RESULT();
				break;
			}
		}
		cache_slot = ((IS_TMP_VAR|IS_VAR) == IS_CONST) ? CACHE_ADDR((opline+1)->extended_value) : NULL;
		if (EXPECTED((zptr = zobj->handlers->get_property_ptr_ptr(zobj, name, BP_VAR_RW, cache_slot)) != NULL)) {
			if (UNEXPECTED(C_ISERROR_P(zptr))) {
				if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
					ZVAL_NULL(EX_VAR(opline->result.var));
				}
			} else {
				zval *orig_zptr = zptr;
				crex_reference *ref;

				do {
					if (UNEXPECTED(C_ISREF_P(zptr))) {
						ref = C_REF_P(zptr);
						zptr = C_REFVAL_P(zptr);
						if (UNEXPECTED(CREX_REF_HAS_TYPE_SOURCES(ref))) {
							crex_binary_assign_op_typed_ref(ref, value OPLINE_CC EXECUTE_DATA_CC);
							break;
						}
					}

					if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
						prop_info = (crex_property_info*)CACHED_PTR_EX(cache_slot + 2);
					} else {
						prop_info = crex_object_fetch_property_type_info(C_OBJ_P(object), orig_zptr);
					}
					if (UNEXPECTED(prop_info)) {
						/* special case for typed properties */
						crex_binary_assign_op_typed_prop(prop_info, zptr, value OPLINE_CC EXECUTE_DATA_CC);
					} else {
						crex_binary_op(zptr, zptr, value OPLINE_CC);
					}
				} while (0);

				if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
					ZVAL_COPY(EX_VAR(opline->result.var), zptr);
				}
			}
		} else {
			crex_assign_op_overloaded_property(zobj, name, cache_slot, value OPLINE_CC EXECUTE_DATA_CC);
		}
		if ((IS_TMP_VAR|IS_VAR) != IS_CONST) {
			crex_tmp_string_release(tmp_name);
		}
	} while (0);

	FREE_OP((opline+1)->op1_type, (opline+1)->op1.var);
	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));

	/* assign_obj has two opcodes! */
	CREX_VM_NEXT_OPCODE_EX(1, 2);
}

/* No specialization for op_types (CONST|TMP|VAR|CV, UNUSED|CONST|TMPVAR) */
static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_PRE_INC_OBJ_SPEC_UNUSED_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *object;
	zval *property;
	zval *zptr;
	void **cache_slot;
	crex_property_info *prop_info;
	crex_object *zobj;
	crex_string *name, *tmp_name;

	SAVE_OPLINE();
	object = &EX(This);
	property = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);

	do {
		if (IS_UNUSED != IS_UNUSED && UNEXPECTED(C_TYPE_P(object) != IS_OBJECT)) {
			if (C_ISREF_P(object) && C_TYPE_P(C_REFVAL_P(object)) == IS_OBJECT) {
				object = C_REFVAL_P(object);
				goto pre_incdec_object;
			}
			if (IS_UNUSED == IS_CV
			 && UNEXPECTED(C_TYPE_P(object) == IS_UNDEF)) {
				ZVAL_UNDEFINED_OP1();
			}
			crex_throw_non_object_error(object, property OPLINE_CC EXECUTE_DATA_CC);
			break;
		}

pre_incdec_object:
		/* here we are sure we are dealing with an object */
		zobj = C_OBJ_P(object);
		if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
			name = C_STR_P(property);
		} else {
			name = zval_try_get_tmp_string(property, &tmp_name);
			if (UNEXPECTED(!name)) {
				UNDEF_RESULT();
				break;
			}
		}
		cache_slot = ((IS_TMP_VAR|IS_VAR) == IS_CONST) ? CACHE_ADDR(opline->extended_value) : NULL;
		if (EXPECTED((zptr = zobj->handlers->get_property_ptr_ptr(zobj, name, BP_VAR_RW, cache_slot)) != NULL)) {
			if (UNEXPECTED(C_ISERROR_P(zptr))) {
				if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
					ZVAL_NULL(EX_VAR(opline->result.var));
				}
			} else {
				if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
					prop_info = (crex_property_info *) CACHED_PTR_EX(cache_slot + 2);
				} else {
					prop_info = crex_object_fetch_property_type_info(C_OBJ_P(object), zptr);
				}
				crex_pre_incdec_property_zval(zptr, prop_info OPLINE_CC EXECUTE_DATA_CC);
			}
		} else {
			crex_pre_incdec_overloaded_property(zobj, name, cache_slot OPLINE_CC EXECUTE_DATA_CC);
		}
		if ((IS_TMP_VAR|IS_VAR) != IS_CONST) {
			crex_tmp_string_release(tmp_name);
		}
	} while (0);

	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));

	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_POST_INC_OBJ_SPEC_UNUSED_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *object;
	zval *property;
	zval *zptr;
	void **cache_slot;
	crex_property_info *prop_info;
	crex_object *zobj;
	crex_string *name, *tmp_name;

	SAVE_OPLINE();
	object = &EX(This);
	property = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);

	do {
		if (IS_UNUSED != IS_UNUSED && UNEXPECTED(C_TYPE_P(object) != IS_OBJECT)) {
			if (C_ISREF_P(object) && C_TYPE_P(C_REFVAL_P(object)) == IS_OBJECT) {
				object = C_REFVAL_P(object);
				goto post_incdec_object;
			}
			if (IS_UNUSED == IS_CV
			 && UNEXPECTED(C_TYPE_P(object) == IS_UNDEF)) {
				ZVAL_UNDEFINED_OP1();
			}
			crex_throw_non_object_error(object, property OPLINE_CC EXECUTE_DATA_CC);
			break;
		}

post_incdec_object:
		/* here we are sure we are dealing with an object */
		zobj = C_OBJ_P(object);
		if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
			name = C_STR_P(property);
		} else {
			name = zval_try_get_tmp_string(property, &tmp_name);
			if (UNEXPECTED(!name)) {
				ZVAL_UNDEF(EX_VAR(opline->result.var));
				break;
			}
		}
		cache_slot = ((IS_TMP_VAR|IS_VAR) == IS_CONST) ? CACHE_ADDR(opline->extended_value) : NULL;
		if (EXPECTED((zptr = zobj->handlers->get_property_ptr_ptr(zobj, name, BP_VAR_RW, cache_slot)) != NULL)) {
			if (UNEXPECTED(C_ISERROR_P(zptr))) {
				ZVAL_NULL(EX_VAR(opline->result.var));
			} else {
				if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
					prop_info = (crex_property_info*)CACHED_PTR_EX(cache_slot + 2);
				} else {
					prop_info = crex_object_fetch_property_type_info(C_OBJ_P(object), zptr);
				}

				crex_post_incdec_property_zval(zptr, prop_info OPLINE_CC EXECUTE_DATA_CC);
			}
		} else {
			crex_post_incdec_overloaded_property(zobj, name, cache_slot OPLINE_CC EXECUTE_DATA_CC);
		}
		if ((IS_TMP_VAR|IS_VAR) != IS_CONST) {
			crex_tmp_string_release(tmp_name);
		}
	} while (0);

	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));

	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FETCH_OBJ_R_SPEC_UNUSED_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;
	void **cache_slot = NULL;

	SAVE_OPLINE();
	container = &EX(This);

	if (IS_UNUSED == IS_CONST ||
	    (IS_UNUSED != IS_UNUSED && UNEXPECTED(C_TYPE_P(container) != IS_OBJECT))) {
		do {
			if ((IS_UNUSED & (IS_VAR|IS_CV)) && C_ISREF_P(container)) {
				container = C_REFVAL_P(container);
				if (EXPECTED(C_TYPE_P(container) == IS_OBJECT)) {
					break;
				}
			}
			if (IS_UNUSED == IS_CV && UNEXPECTED(C_TYPE_P(container) == IS_UNDEF)) {
				ZVAL_UNDEFINED_OP1();
			}
			crex_wrong_property_read(container, _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC));
			ZVAL_NULL(EX_VAR(opline->result.var));
			goto fetch_obj_r_finish;
		} while (0);
	}

	/* here we are sure we are dealing with an object */
	do {
		crex_object *zobj = C_OBJ_P(container);
		crex_string *name, *tmp_name;
		zval *retval;

		if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
			cache_slot = CACHE_ADDR(opline->extended_value & ~CREX_FETCH_REF /* FUNC_ARG fetch may contain it */);

			if (EXPECTED(zobj->ce == CACHED_PTR_EX(cache_slot))) {
				uintptr_t prop_offset = (uintptr_t)CACHED_PTR_EX(cache_slot + 1);

				if (EXPECTED(IS_VALID_PROPERTY_OFFSET(prop_offset))) {
					retval = OBJ_PROP(zobj, prop_offset);
					if (EXPECTED(C_TYPE_INFO_P(retval) != IS_UNDEF)) {
						if (0 || (IS_UNUSED & (IS_TMP_VAR|IS_VAR)) != 0) {
							goto fetch_obj_r_copy;
						} else {
fetch_obj_r_fast_copy:
							ZVAL_COPY_DEREF(EX_VAR(opline->result.var), retval);
							CREX_VM_NEXT_OPCODE();
						}
					}
				} else if (EXPECTED(zobj->properties != NULL)) {
					name = C_STR_P(_get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC));
					if (!IS_UNKNOWN_DYNAMIC_PROPERTY_OFFSET(prop_offset)) {
						uintptr_t idx = CREX_DECODE_DYN_PROP_OFFSET(prop_offset);

						if (EXPECTED(idx < zobj->properties->nNumUsed * sizeof(Bucket))) {
							Bucket *p = (Bucket*)((char*)zobj->properties->arData + idx);

							if (EXPECTED(p->key == name) ||
							    (EXPECTED(p->h == ZSTR_H(name)) &&
							     EXPECTED(p->key != NULL) &&
							     EXPECTED(crex_string_equal_content(p->key, name)))) {
								retval = &p->val;
								if (0 || (IS_UNUSED & (IS_TMP_VAR|IS_VAR)) != 0) {
									goto fetch_obj_r_copy;
								} else {
									goto fetch_obj_r_fast_copy;
								}
							}
						}
						CACHE_PTR_EX(cache_slot + 1, (void*)CREX_DYNAMIC_PROPERTY_OFFSET);
					}
					retval = crex_hash_find_known_hash(zobj->properties, name);
					if (EXPECTED(retval)) {
						uintptr_t idx = (char*)retval - (char*)zobj->properties->arData;
						CACHE_PTR_EX(cache_slot + 1, (void*)CREX_ENCODE_DYN_PROP_OFFSET(idx));
						if (0 || (IS_UNUSED & (IS_TMP_VAR|IS_VAR)) != 0) {
							goto fetch_obj_r_copy;
						} else {
							goto fetch_obj_r_fast_copy;
						}
					}
				}
			}
			name = C_STR_P(_get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC));
		} else {
			name = zval_try_get_tmp_string(_get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC), &tmp_name);
			if (UNEXPECTED(!name)) {
				ZVAL_UNDEF(EX_VAR(opline->result.var));
				break;
			}
		}

#if CREX_DEBUG
		/* For non-standard object handlers, verify a declared property type in debug builds.
		 * Fetch prop_info before calling read_property(), as it may deallocate the object. */
		crex_property_info *prop_info = NULL;
		if (zobj->handlers->read_property != crex_std_read_property) {
			prop_info = crex_get_property_info(zobj->ce, name, /* silent */ true);
		}
#endif
		retval = zobj->handlers->read_property(zobj, name, BP_VAR_R, cache_slot, EX_VAR(opline->result.var));
#if CREX_DEBUG
		if (!EG(exception) && prop_info && prop_info != CREX_WRONG_PROPERTY_INFO
				&& CREX_TYPE_IS_SET(prop_info->type)) {
			ZVAL_OPT_DEREF(retval);
			crex_verify_property_type(prop_info, retval, /* strict */ true);
		}
#endif

		if ((IS_TMP_VAR|IS_VAR) != IS_CONST) {
			crex_tmp_string_release(tmp_name);
		}

		if (retval != EX_VAR(opline->result.var)) {
fetch_obj_r_copy:
			ZVAL_COPY_DEREF(EX_VAR(opline->result.var), retval);
		} else if (UNEXPECTED(C_ISREF_P(retval))) {
			crex_unwrap_reference(retval);
		}
	} while (0);

fetch_obj_r_finish:
	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));

	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FETCH_OBJ_W_SPEC_UNUSED_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *property, *container, *result;

	SAVE_OPLINE();

	container = &EX(This);
	property = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
	result = EX_VAR(opline->result.var);
	crex_fetch_property_address(
		result, container, IS_UNUSED, property, (IS_TMP_VAR|IS_VAR),
		(((IS_TMP_VAR|IS_VAR) == IS_CONST) ? CACHE_ADDR(opline->extended_value & ~CREX_FETCH_OBJ_FLAGS) : NULL),
		BP_VAR_W, opline->extended_value OPLINE_CC EXECUTE_DATA_CC);
	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
	if (IS_UNUSED == IS_VAR) {
		FREE_VAR_PTR_AND_EXTRACT_RESULT_IF_NECESSARY(opline->op1.var);
	}
	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FETCH_OBJ_RW_SPEC_UNUSED_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *property, *container, *result;

	SAVE_OPLINE();
	container = &EX(This);
	property = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
	result = EX_VAR(opline->result.var);
	crex_fetch_property_address(result, container, IS_UNUSED, property, (IS_TMP_VAR|IS_VAR), (((IS_TMP_VAR|IS_VAR) == IS_CONST) ? CACHE_ADDR(opline->extended_value) : NULL), BP_VAR_RW, 0 OPLINE_CC EXECUTE_DATA_CC);
	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
	if (IS_UNUSED == IS_VAR) {
		FREE_VAR_PTR_AND_EXTRACT_RESULT_IF_NECESSARY(opline->op1.var);
	}
	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FETCH_OBJ_IS_SPEC_UNUSED_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;
	void **cache_slot = NULL;

	SAVE_OPLINE();
	container = &EX(This);

	if (IS_UNUSED == IS_CONST ||
	    (IS_UNUSED != IS_UNUSED && UNEXPECTED(C_TYPE_P(container) != IS_OBJECT))) {
		do {
			if ((IS_UNUSED & (IS_VAR|IS_CV)) && C_ISREF_P(container)) {
				container = C_REFVAL_P(container);
				if (EXPECTED(C_TYPE_P(container) == IS_OBJECT)) {
					break;
				}
			}
			if ((IS_TMP_VAR|IS_VAR) == IS_CV && C_TYPE_P(EX_VAR(opline->op2.var)) == IS_UNDEF) {
				ZVAL_UNDEFINED_OP2();
			}
			ZVAL_NULL(EX_VAR(opline->result.var));
			goto fetch_obj_is_finish;
		} while (0);
	}

	/* here we are sure we are dealing with an object */
	do {
		crex_object *zobj = C_OBJ_P(container);
		crex_string *name, *tmp_name;
		zval *retval;

		if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
			cache_slot = CACHE_ADDR(opline->extended_value);

			if (EXPECTED(zobj->ce == CACHED_PTR_EX(cache_slot))) {
				uintptr_t prop_offset = (uintptr_t)CACHED_PTR_EX(cache_slot + 1);

				if (EXPECTED(IS_VALID_PROPERTY_OFFSET(prop_offset))) {
					retval = OBJ_PROP(zobj, prop_offset);
					if (EXPECTED(C_TYPE_P(retval) != IS_UNDEF)) {
						if (0 || (IS_UNUSED & (IS_TMP_VAR|IS_VAR)) != 0) {
							goto fetch_obj_is_copy;
						} else {
fetch_obj_is_fast_copy:
							ZVAL_COPY_DEREF(EX_VAR(opline->result.var), retval);
							CREX_VM_NEXT_OPCODE();
						}
					}
				} else if (EXPECTED(zobj->properties != NULL)) {
					name = C_STR_P(_get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC));
					if (!IS_UNKNOWN_DYNAMIC_PROPERTY_OFFSET(prop_offset)) {
						uintptr_t idx = CREX_DECODE_DYN_PROP_OFFSET(prop_offset);

						if (EXPECTED(idx < zobj->properties->nNumUsed * sizeof(Bucket))) {
							Bucket *p = (Bucket*)((char*)zobj->properties->arData + idx);

							if (EXPECTED(p->key == name) ||
							    (EXPECTED(p->h == ZSTR_H(name)) &&
							     EXPECTED(p->key != NULL) &&
							     EXPECTED(crex_string_equal_content(p->key, name)))) {
								retval = &p->val;
								if (0 || (IS_UNUSED & (IS_TMP_VAR|IS_VAR)) != 0) {
									goto fetch_obj_is_copy;
								} else {
									goto fetch_obj_is_fast_copy;
								}
							}
						}
						CACHE_PTR_EX(cache_slot + 1, (void*)CREX_DYNAMIC_PROPERTY_OFFSET);
					}
					retval = crex_hash_find_known_hash(zobj->properties, name);
					if (EXPECTED(retval)) {
						uintptr_t idx = (char*)retval - (char*)zobj->properties->arData;
						CACHE_PTR_EX(cache_slot + 1, (void*)CREX_ENCODE_DYN_PROP_OFFSET(idx));
						if (0 || (IS_UNUSED & (IS_TMP_VAR|IS_VAR)) != 0) {
							goto fetch_obj_is_copy;
						} else {
							goto fetch_obj_is_fast_copy;
						}
					}
				}
			}
			name = C_STR_P(_get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC));
		} else {
			name = zval_try_get_tmp_string(_get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC), &tmp_name);
			if (UNEXPECTED(!name)) {
				ZVAL_UNDEF(EX_VAR(opline->result.var));
				break;
			}
		}

		retval = zobj->handlers->read_property(zobj, name, BP_VAR_IS, cache_slot, EX_VAR(opline->result.var));

		if ((IS_TMP_VAR|IS_VAR) != IS_CONST) {
			crex_tmp_string_release(tmp_name);
		}

		if (retval != EX_VAR(opline->result.var)) {
fetch_obj_is_copy:
			ZVAL_COPY_DEREF(EX_VAR(opline->result.var), retval);
		} else if (UNEXPECTED(C_ISREF_P(retval))) {
			crex_unwrap_reference(retval);
		}
	} while (0);

fetch_obj_is_finish:
	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));

	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FETCH_OBJ_FUNC_ARG_SPEC_UNUSED_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
#if 0
	USE_OPLINE
#endif

	if (UNEXPECTED(CREX_CALL_INFO(EX(call)) & CREX_CALL_SEND_ARG_BY_REF)) {
		/* Behave like FETCH_OBJ_W */
		if ((IS_UNUSED & (IS_CONST|IS_TMP_VAR))) {
			CREX_VM_TAIL_CALL(crex_use_tmp_in_write_context_helper_SPEC(CREX_OPCODE_HANDLER_ARGS_PASSTHRU));
		}
		CREX_VM_TAIL_CALL(CREX_FETCH_OBJ_W_SPEC_UNUSED_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU));
	} else {
		CREX_VM_TAIL_CALL(CREX_FETCH_OBJ_R_SPEC_UNUSED_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU));
	}
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FETCH_OBJ_UNSET_SPEC_UNUSED_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container, *property, *result;

	SAVE_OPLINE();
	container = &EX(This);
	property = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
	result = EX_VAR(opline->result.var);
	crex_fetch_property_address(result, container, IS_UNUSED, property, (IS_TMP_VAR|IS_VAR), (((IS_TMP_VAR|IS_VAR) == IS_CONST) ? CACHE_ADDR(opline->extended_value) : NULL), BP_VAR_UNSET, 0 OPLINE_CC EXECUTE_DATA_CC);
	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
	if (IS_UNUSED == IS_VAR) {
		FREE_VAR_PTR_AND_EXTRACT_RESULT_IF_NECESSARY(opline->op1.var);
	}
	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ASSIGN_OBJ_SPEC_UNUSED_TMPVAR_OP_DATA_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *object, *value, tmp;
	crex_object *zobj;
	crex_string *name, *tmp_name;
	crex_refcounted *garbage = NULL;

	SAVE_OPLINE();
	object = &EX(This);
	value = RT_CONSTANT((opline+1), (opline+1)->op1);

	if (IS_UNUSED != IS_UNUSED && UNEXPECTED(C_TYPE_P(object) != IS_OBJECT)) {
		if (C_ISREF_P(object) && C_TYPE_P(C_REFVAL_P(object)) == IS_OBJECT) {
			object = C_REFVAL_P(object);
			goto assign_object;
		}
		crex_throw_non_object_error(object, _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC) OPLINE_CC EXECUTE_DATA_CC);
		value = &EG(uninitialized_zval);
		goto free_and_exit_assign_obj;
	}

assign_object:
	zobj = C_OBJ_P(object);
	if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
		if (EXPECTED(zobj->ce == CACHED_PTR(opline->extended_value))) {
			void **cache_slot = CACHE_ADDR(opline->extended_value);
			uintptr_t prop_offset = (uintptr_t)CACHED_PTR_EX(cache_slot + 1);
			zval *property_val;

			if (EXPECTED(IS_VALID_PROPERTY_OFFSET(prop_offset))) {
				property_val = OBJ_PROP(zobj, prop_offset);
				if (C_TYPE_P(property_val) != IS_UNDEF) {
					crex_property_info *prop_info = (crex_property_info*) CACHED_PTR_EX(cache_slot + 2);

					if (UNEXPECTED(prop_info != NULL)) {
						value = crex_assign_to_typed_prop(prop_info, property_val, value, &garbage EXECUTE_DATA_CC);
						goto free_and_exit_assign_obj;
					} else {
fast_assign_obj:
						value = crex_assign_to_variable_ex(property_val, value, IS_CONST, EX_USES_STRICT_TYPES(), &garbage);
						if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
							ZVAL_COPY(EX_VAR(opline->result.var), value);
						}
						goto exit_assign_obj;
					}
				}
			} else {
				name = C_STR_P(_get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC));
				if (EXPECTED(zobj->properties != NULL)) {
					if (UNEXPECTED(GC_REFCOUNT(zobj->properties) > 1)) {
						if (EXPECTED(!(GC_FLAGS(zobj->properties) & IS_ARRAY_IMMUTABLE))) {
							GC_DELREF(zobj->properties);
						}
						zobj->properties = crex_array_dup(zobj->properties);
					}
					property_val = crex_hash_find_known_hash(zobj->properties, name);
					if (property_val) {
						goto fast_assign_obj;
					}
				}

				if (!zobj->ce->__set && (zobj->ce->ce_flags & CREX_ACC_ALLOW_DYNAMIC_PROPERTIES)) {
					if (EXPECTED(zobj->properties == NULL)) {
						rebuild_object_properties(zobj);
					}
					if (IS_CONST == IS_CONST) {
						if (UNEXPECTED(C_OPT_REFCOUNTED_P(value))) {
							C_ADDREF_P(value);
						}
					} else if (IS_CONST != IS_TMP_VAR) {
						if (C_ISREF_P(value)) {
							if (IS_CONST == IS_VAR) {
								crex_reference *ref = C_REF_P(value);
								if (GC_DELREF(ref) == 0) {
									ZVAL_COPY_VALUE(&tmp, C_REFVAL_P(value));
									efree_size(ref, sizeof(crex_reference));
									value = &tmp;
								} else {
									value = C_REFVAL_P(value);
									C_TRY_ADDREF_P(value);
								}
							} else {
								value = C_REFVAL_P(value);
								C_TRY_ADDREF_P(value);
							}
						} else if (IS_CONST == IS_CV) {
							C_TRY_ADDREF_P(value);
						}
						}
					crex_hash_add_new(zobj->properties, name, value);
					if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
						ZVAL_COPY(EX_VAR(opline->result.var), value);
					}
					goto exit_assign_obj;
				}
			}
		}
		name = C_STR_P(_get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC));
	} else {
		name = zval_try_get_tmp_string(_get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC), &tmp_name);
		if (UNEXPECTED(!name)) {

			UNDEF_RESULT();
			goto exit_assign_obj;
		}
	}

	if (IS_CONST == IS_CV || IS_CONST == IS_VAR) {
		ZVAL_DEREF(value);
	}

	value = zobj->handlers->write_property(zobj, name, value, ((IS_TMP_VAR|IS_VAR) == IS_CONST) ? CACHE_ADDR(opline->extended_value) : NULL);

	if ((IS_TMP_VAR|IS_VAR) != IS_CONST) {
		crex_tmp_string_release(tmp_name);
	}

free_and_exit_assign_obj:
	if (UNEXPECTED(RETURN_VALUE_USED(opline)) && value) {
		ZVAL_COPY_DEREF(EX_VAR(opline->result.var), value);
	}

exit_assign_obj:
	if (garbage) {
		GC_DTOR_NO_REF(garbage);
	}
	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));

	/* assign_obj has two opcodes! */
	CREX_VM_NEXT_OPCODE_EX(1, 2);
}

/* No specialization for op_types (CONST|TMPVAR|CV, UNUSED|CONST|VAR) */
static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ASSIGN_OBJ_SPEC_UNUSED_TMPVAR_OP_DATA_TMP_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *object, *value, tmp;
	crex_object *zobj;
	crex_string *name, *tmp_name;
	crex_refcounted *garbage = NULL;

	SAVE_OPLINE();
	object = &EX(This);
	value = _get_zval_ptr_tmp((opline+1)->op1.var EXECUTE_DATA_CC);

	if (IS_UNUSED != IS_UNUSED && UNEXPECTED(C_TYPE_P(object) != IS_OBJECT)) {
		if (C_ISREF_P(object) && C_TYPE_P(C_REFVAL_P(object)) == IS_OBJECT) {
			object = C_REFVAL_P(object);
			goto assign_object;
		}
		crex_throw_non_object_error(object, _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC) OPLINE_CC EXECUTE_DATA_CC);
		value = &EG(uninitialized_zval);
		goto free_and_exit_assign_obj;
	}

assign_object:
	zobj = C_OBJ_P(object);
	if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
		if (EXPECTED(zobj->ce == CACHED_PTR(opline->extended_value))) {
			void **cache_slot = CACHE_ADDR(opline->extended_value);
			uintptr_t prop_offset = (uintptr_t)CACHED_PTR_EX(cache_slot + 1);
			zval *property_val;

			if (EXPECTED(IS_VALID_PROPERTY_OFFSET(prop_offset))) {
				property_val = OBJ_PROP(zobj, prop_offset);
				if (C_TYPE_P(property_val) != IS_UNDEF) {
					crex_property_info *prop_info = (crex_property_info*) CACHED_PTR_EX(cache_slot + 2);

					if (UNEXPECTED(prop_info != NULL)) {
						value = crex_assign_to_typed_prop(prop_info, property_val, value, &garbage EXECUTE_DATA_CC);
						goto free_and_exit_assign_obj;
					} else {
fast_assign_obj:
						value = crex_assign_to_variable_ex(property_val, value, IS_TMP_VAR, EX_USES_STRICT_TYPES(), &garbage);
						if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
							ZVAL_COPY(EX_VAR(opline->result.var), value);
						}
						goto exit_assign_obj;
					}
				}
			} else {
				name = C_STR_P(_get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC));
				if (EXPECTED(zobj->properties != NULL)) {
					if (UNEXPECTED(GC_REFCOUNT(zobj->properties) > 1)) {
						if (EXPECTED(!(GC_FLAGS(zobj->properties) & IS_ARRAY_IMMUTABLE))) {
							GC_DELREF(zobj->properties);
						}
						zobj->properties = crex_array_dup(zobj->properties);
					}
					property_val = crex_hash_find_known_hash(zobj->properties, name);
					if (property_val) {
						goto fast_assign_obj;
					}
				}

				if (!zobj->ce->__set && (zobj->ce->ce_flags & CREX_ACC_ALLOW_DYNAMIC_PROPERTIES)) {
					if (EXPECTED(zobj->properties == NULL)) {
						rebuild_object_properties(zobj);
					}
					if (IS_TMP_VAR == IS_CONST) {
						if (UNEXPECTED(C_OPT_REFCOUNTED_P(value))) {
							C_ADDREF_P(value);
						}
					} else if (IS_TMP_VAR != IS_TMP_VAR) {
						if (C_ISREF_P(value)) {
							if (IS_TMP_VAR == IS_VAR) {
								crex_reference *ref = C_REF_P(value);
								if (GC_DELREF(ref) == 0) {
									ZVAL_COPY_VALUE(&tmp, C_REFVAL_P(value));
									efree_size(ref, sizeof(crex_reference));
									value = &tmp;
								} else {
									value = C_REFVAL_P(value);
									C_TRY_ADDREF_P(value);
								}
							} else {
								value = C_REFVAL_P(value);
								C_TRY_ADDREF_P(value);
							}
						} else if (IS_TMP_VAR == IS_CV) {
							C_TRY_ADDREF_P(value);
						}
						}
					crex_hash_add_new(zobj->properties, name, value);
					if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
						ZVAL_COPY(EX_VAR(opline->result.var), value);
					}
					goto exit_assign_obj;
				}
			}
		}
		name = C_STR_P(_get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC));
	} else {
		name = zval_try_get_tmp_string(_get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC), &tmp_name);
		if (UNEXPECTED(!name)) {
			zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
			UNDEF_RESULT();
			goto exit_assign_obj;
		}
	}

	if (IS_TMP_VAR == IS_CV || IS_TMP_VAR == IS_VAR) {
		ZVAL_DEREF(value);
	}

	value = zobj->handlers->write_property(zobj, name, value, ((IS_TMP_VAR|IS_VAR) == IS_CONST) ? CACHE_ADDR(opline->extended_value) : NULL);

	if ((IS_TMP_VAR|IS_VAR) != IS_CONST) {
		crex_tmp_string_release(tmp_name);
	}

free_and_exit_assign_obj:
	if (UNEXPECTED(RETURN_VALUE_USED(opline)) && value) {
		ZVAL_COPY_DEREF(EX_VAR(opline->result.var), value);
	}
	zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
exit_assign_obj:
	if (garbage) {
		GC_DTOR_NO_REF(garbage);
	}
	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));

	/* assign_obj has two opcodes! */
	CREX_VM_NEXT_OPCODE_EX(1, 2);
}

/* No specialization for op_types (CONST|TMPVAR|CV, UNUSED|CONST|VAR) */
static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ASSIGN_OBJ_SPEC_UNUSED_TMPVAR_OP_DATA_VAR_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *object, *value, tmp;
	crex_object *zobj;
	crex_string *name, *tmp_name;
	crex_refcounted *garbage = NULL;

	SAVE_OPLINE();
	object = &EX(This);
	value = _get_zval_ptr_var((opline+1)->op1.var EXECUTE_DATA_CC);

	if (IS_UNUSED != IS_UNUSED && UNEXPECTED(C_TYPE_P(object) != IS_OBJECT)) {
		if (C_ISREF_P(object) && C_TYPE_P(C_REFVAL_P(object)) == IS_OBJECT) {
			object = C_REFVAL_P(object);
			goto assign_object;
		}
		crex_throw_non_object_error(object, _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC) OPLINE_CC EXECUTE_DATA_CC);
		value = &EG(uninitialized_zval);
		goto free_and_exit_assign_obj;
	}

assign_object:
	zobj = C_OBJ_P(object);
	if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
		if (EXPECTED(zobj->ce == CACHED_PTR(opline->extended_value))) {
			void **cache_slot = CACHE_ADDR(opline->extended_value);
			uintptr_t prop_offset = (uintptr_t)CACHED_PTR_EX(cache_slot + 1);
			zval *property_val;

			if (EXPECTED(IS_VALID_PROPERTY_OFFSET(prop_offset))) {
				property_val = OBJ_PROP(zobj, prop_offset);
				if (C_TYPE_P(property_val) != IS_UNDEF) {
					crex_property_info *prop_info = (crex_property_info*) CACHED_PTR_EX(cache_slot + 2);

					if (UNEXPECTED(prop_info != NULL)) {
						value = crex_assign_to_typed_prop(prop_info, property_val, value, &garbage EXECUTE_DATA_CC);
						goto free_and_exit_assign_obj;
					} else {
fast_assign_obj:
						value = crex_assign_to_variable_ex(property_val, value, IS_VAR, EX_USES_STRICT_TYPES(), &garbage);
						if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
							ZVAL_COPY(EX_VAR(opline->result.var), value);
						}
						goto exit_assign_obj;
					}
				}
			} else {
				name = C_STR_P(_get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC));
				if (EXPECTED(zobj->properties != NULL)) {
					if (UNEXPECTED(GC_REFCOUNT(zobj->properties) > 1)) {
						if (EXPECTED(!(GC_FLAGS(zobj->properties) & IS_ARRAY_IMMUTABLE))) {
							GC_DELREF(zobj->properties);
						}
						zobj->properties = crex_array_dup(zobj->properties);
					}
					property_val = crex_hash_find_known_hash(zobj->properties, name);
					if (property_val) {
						goto fast_assign_obj;
					}
				}

				if (!zobj->ce->__set && (zobj->ce->ce_flags & CREX_ACC_ALLOW_DYNAMIC_PROPERTIES)) {
					if (EXPECTED(zobj->properties == NULL)) {
						rebuild_object_properties(zobj);
					}
					if (IS_VAR == IS_CONST) {
						if (UNEXPECTED(C_OPT_REFCOUNTED_P(value))) {
							C_ADDREF_P(value);
						}
					} else if (IS_VAR != IS_TMP_VAR) {
						if (C_ISREF_P(value)) {
							if (IS_VAR == IS_VAR) {
								crex_reference *ref = C_REF_P(value);
								if (GC_DELREF(ref) == 0) {
									ZVAL_COPY_VALUE(&tmp, C_REFVAL_P(value));
									efree_size(ref, sizeof(crex_reference));
									value = &tmp;
								} else {
									value = C_REFVAL_P(value);
									C_TRY_ADDREF_P(value);
								}
							} else {
								value = C_REFVAL_P(value);
								C_TRY_ADDREF_P(value);
							}
						} else if (IS_VAR == IS_CV) {
							C_TRY_ADDREF_P(value);
						}
						}
					crex_hash_add_new(zobj->properties, name, value);
					if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
						ZVAL_COPY(EX_VAR(opline->result.var), value);
					}
					goto exit_assign_obj;
				}
			}
		}
		name = C_STR_P(_get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC));
	} else {
		name = zval_try_get_tmp_string(_get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC), &tmp_name);
		if (UNEXPECTED(!name)) {
			zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
			UNDEF_RESULT();
			goto exit_assign_obj;
		}
	}

	if (IS_VAR == IS_CV || IS_VAR == IS_VAR) {
		ZVAL_DEREF(value);
	}

	value = zobj->handlers->write_property(zobj, name, value, ((IS_TMP_VAR|IS_VAR) == IS_CONST) ? CACHE_ADDR(opline->extended_value) : NULL);

	if ((IS_TMP_VAR|IS_VAR) != IS_CONST) {
		crex_tmp_string_release(tmp_name);
	}

free_and_exit_assign_obj:
	if (UNEXPECTED(RETURN_VALUE_USED(opline)) && value) {
		ZVAL_COPY_DEREF(EX_VAR(opline->result.var), value);
	}
	zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
exit_assign_obj:
	if (garbage) {
		GC_DTOR_NO_REF(garbage);
	}
	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));

	/* assign_obj has two opcodes! */
	CREX_VM_NEXT_OPCODE_EX(1, 2);
}

/* No specialization for op_types (CONST|TMPVAR|CV, UNUSED|CONST|VAR) */
static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ASSIGN_OBJ_SPEC_UNUSED_TMPVAR_OP_DATA_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *object, *value, tmp;
	crex_object *zobj;
	crex_string *name, *tmp_name;
	crex_refcounted *garbage = NULL;

	SAVE_OPLINE();
	object = &EX(This);
	value = _get_zval_ptr_cv_BP_VAR_R((opline+1)->op1.var EXECUTE_DATA_CC);

	if (IS_UNUSED != IS_UNUSED && UNEXPECTED(C_TYPE_P(object) != IS_OBJECT)) {
		if (C_ISREF_P(object) && C_TYPE_P(C_REFVAL_P(object)) == IS_OBJECT) {
			object = C_REFVAL_P(object);
			goto assign_object;
		}
		crex_throw_non_object_error(object, _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC) OPLINE_CC EXECUTE_DATA_CC);
		value = &EG(uninitialized_zval);
		goto free_and_exit_assign_obj;
	}

assign_object:
	zobj = C_OBJ_P(object);
	if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
		if (EXPECTED(zobj->ce == CACHED_PTR(opline->extended_value))) {
			void **cache_slot = CACHE_ADDR(opline->extended_value);
			uintptr_t prop_offset = (uintptr_t)CACHED_PTR_EX(cache_slot + 1);
			zval *property_val;

			if (EXPECTED(IS_VALID_PROPERTY_OFFSET(prop_offset))) {
				property_val = OBJ_PROP(zobj, prop_offset);
				if (C_TYPE_P(property_val) != IS_UNDEF) {
					crex_property_info *prop_info = (crex_property_info*) CACHED_PTR_EX(cache_slot + 2);

					if (UNEXPECTED(prop_info != NULL)) {
						value = crex_assign_to_typed_prop(prop_info, property_val, value, &garbage EXECUTE_DATA_CC);
						goto free_and_exit_assign_obj;
					} else {
fast_assign_obj:
						value = crex_assign_to_variable_ex(property_val, value, IS_CV, EX_USES_STRICT_TYPES(), &garbage);
						if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
							ZVAL_COPY(EX_VAR(opline->result.var), value);
						}
						goto exit_assign_obj;
					}
				}
			} else {
				name = C_STR_P(_get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC));
				if (EXPECTED(zobj->properties != NULL)) {
					if (UNEXPECTED(GC_REFCOUNT(zobj->properties) > 1)) {
						if (EXPECTED(!(GC_FLAGS(zobj->properties) & IS_ARRAY_IMMUTABLE))) {
							GC_DELREF(zobj->properties);
						}
						zobj->properties = crex_array_dup(zobj->properties);
					}
					property_val = crex_hash_find_known_hash(zobj->properties, name);
					if (property_val) {
						goto fast_assign_obj;
					}
				}

				if (!zobj->ce->__set && (zobj->ce->ce_flags & CREX_ACC_ALLOW_DYNAMIC_PROPERTIES)) {
					if (EXPECTED(zobj->properties == NULL)) {
						rebuild_object_properties(zobj);
					}
					if (IS_CV == IS_CONST) {
						if (UNEXPECTED(C_OPT_REFCOUNTED_P(value))) {
							C_ADDREF_P(value);
						}
					} else if (IS_CV != IS_TMP_VAR) {
						if (C_ISREF_P(value)) {
							if (IS_CV == IS_VAR) {
								crex_reference *ref = C_REF_P(value);
								if (GC_DELREF(ref) == 0) {
									ZVAL_COPY_VALUE(&tmp, C_REFVAL_P(value));
									efree_size(ref, sizeof(crex_reference));
									value = &tmp;
								} else {
									value = C_REFVAL_P(value);
									C_TRY_ADDREF_P(value);
								}
							} else {
								value = C_REFVAL_P(value);
								C_TRY_ADDREF_P(value);
							}
						} else if (IS_CV == IS_CV) {
							C_TRY_ADDREF_P(value);
						}
						}
					crex_hash_add_new(zobj->properties, name, value);
					if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
						ZVAL_COPY(EX_VAR(opline->result.var), value);
					}
					goto exit_assign_obj;
				}
			}
		}
		name = C_STR_P(_get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC));
	} else {
		name = zval_try_get_tmp_string(_get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC), &tmp_name);
		if (UNEXPECTED(!name)) {

			UNDEF_RESULT();
			goto exit_assign_obj;
		}
	}

	if (IS_CV == IS_CV || IS_CV == IS_VAR) {
		ZVAL_DEREF(value);
	}

	value = zobj->handlers->write_property(zobj, name, value, ((IS_TMP_VAR|IS_VAR) == IS_CONST) ? CACHE_ADDR(opline->extended_value) : NULL);

	if ((IS_TMP_VAR|IS_VAR) != IS_CONST) {
		crex_tmp_string_release(tmp_name);
	}

free_and_exit_assign_obj:
	if (UNEXPECTED(RETURN_VALUE_USED(opline)) && value) {
		ZVAL_COPY_DEREF(EX_VAR(opline->result.var), value);
	}

exit_assign_obj:
	if (garbage) {
		GC_DTOR_NO_REF(garbage);
	}
	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));

	/* assign_obj has two opcodes! */
	CREX_VM_NEXT_OPCODE_EX(1, 2);
}

/* No specialization for op_types (CONST|TMPVAR|CV, UNUSED|CONST|VAR) */
static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ASSIGN_OBJ_REF_SPEC_UNUSED_TMPVAR_OP_DATA_VAR_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *property, *container, *value_ptr;

	SAVE_OPLINE();

	container = &EX(This);
	property = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);

	value_ptr = _get_zval_ptr_ptr_var((opline+1)->op1.var EXECUTE_DATA_CC);

	if (1) {
		if (IS_UNUSED == IS_UNUSED) {
			if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
				crex_assign_to_property_reference_this_const(container, property, value_ptr OPLINE_CC EXECUTE_DATA_CC);
			} else {
				crex_assign_to_property_reference_this_var(container, property, value_ptr OPLINE_CC EXECUTE_DATA_CC);
			}
		} else {
			if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
				crex_assign_to_property_reference_var_const(container, property, value_ptr OPLINE_CC EXECUTE_DATA_CC);
			} else {
				crex_assign_to_property_reference_var_var(container, property, value_ptr OPLINE_CC EXECUTE_DATA_CC);
			}
		}
	} else {
		crex_assign_to_property_reference(container, IS_UNUSED, property, (IS_TMP_VAR|IS_VAR), value_ptr OPLINE_CC EXECUTE_DATA_CC);
	}

	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
	zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
	CREX_VM_NEXT_OPCODE_EX(1, 2);
}

/* No specialization for op_types (CONST|TMPVAR|CV, UNUSED|CONST|VAR) */
static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ASSIGN_OBJ_REF_SPEC_UNUSED_TMPVAR_OP_DATA_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *property, *container, *value_ptr;

	SAVE_OPLINE();

	container = &EX(This);
	property = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);

	value_ptr = _get_zval_ptr_cv_BP_VAR_W((opline+1)->op1.var EXECUTE_DATA_CC);

	if (1) {
		if (IS_UNUSED == IS_UNUSED) {
			if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
				crex_assign_to_property_reference_this_const(container, property, value_ptr OPLINE_CC EXECUTE_DATA_CC);
			} else {
				crex_assign_to_property_reference_this_var(container, property, value_ptr OPLINE_CC EXECUTE_DATA_CC);
			}
		} else {
			if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
				crex_assign_to_property_reference_var_const(container, property, value_ptr OPLINE_CC EXECUTE_DATA_CC);
			} else {
				crex_assign_to_property_reference_var_var(container, property, value_ptr OPLINE_CC EXECUTE_DATA_CC);
			}
		}
	} else {
		crex_assign_to_property_reference(container, IS_UNUSED, property, (IS_TMP_VAR|IS_VAR), value_ptr OPLINE_CC EXECUTE_DATA_CC);
	}

	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));

	CREX_VM_NEXT_OPCODE_EX(1, 2);
}

/* No specialization for op_types (CONST|TMPVAR|CV, UNUSED|CONST|VAR) */
static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ROPE_INIT_SPEC_UNUSED_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	crex_string **rope;
	zval *var;

	/* Compiler allocates the necessary number of zval slots to keep the rope */
	rope = (crex_string**)EX_VAR(opline->result.var);
	if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
		var = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
		rope[0] = C_STR_P(var);
		if (UNEXPECTED(C_REFCOUNTED_P(var))) {
			C_ADDREF_P(var);
		}
	} else {
		var = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
		if (EXPECTED(C_TYPE_P(var) == IS_STRING)) {
			if ((IS_TMP_VAR|IS_VAR) == IS_CV) {
				rope[0] = crex_string_copy(C_STR_P(var));
			} else {
				rope[0] = C_STR_P(var);
			}
		} else {
			SAVE_OPLINE();
			if ((IS_TMP_VAR|IS_VAR) == IS_CV && UNEXPECTED(C_TYPE_P(var) == IS_UNDEF)) {
				ZVAL_UNDEFINED_OP2();
			}
			rope[0] = zval_get_string_func(var);
			zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
			CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
		}
	}
	CREX_VM_NEXT_OPCODE();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FETCH_CLASS_SPEC_UNUSED_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	zval *class_name;
	USE_OPLINE

	SAVE_OPLINE();
	if ((IS_TMP_VAR|IS_VAR) == IS_UNUSED) {
		C_CE_P(EX_VAR(opline->result.var)) = crex_fetch_class(NULL, opline->op1.num);
		CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
	} else if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
		crex_class_entry *ce = CACHED_PTR(opline->extended_value);

		if (UNEXPECTED(ce == NULL)) {
			class_name = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
			ce = crex_fetch_class_by_name(C_STR_P(class_name), C_STR_P(class_name + 1), opline->op1.num);
			CACHE_PTR(opline->extended_value, ce);
		}
		C_CE_P(EX_VAR(opline->result.var)) = ce;
	} else {
		class_name = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
try_class_name:
		if (C_TYPE_P(class_name) == IS_OBJECT) {
			C_CE_P(EX_VAR(opline->result.var)) = C_OBJCE_P(class_name);
		} else if (C_TYPE_P(class_name) == IS_STRING) {
			C_CE_P(EX_VAR(opline->result.var)) = crex_fetch_class(C_STR_P(class_name), opline->op1.num);
		} else if (((IS_TMP_VAR|IS_VAR) & (IS_VAR|IS_CV)) && C_TYPE_P(class_name) == IS_REFERENCE) {
			class_name = C_REFVAL_P(class_name);
			goto try_class_name;
		} else {
			if ((IS_TMP_VAR|IS_VAR) == IS_CV && UNEXPECTED(C_TYPE_P(class_name) == IS_UNDEF)) {
				ZVAL_UNDEFINED_OP2();
				if (UNEXPECTED(EG(exception) != NULL)) {
					HANDLE_EXCEPTION();
				}
			}
			crex_throw_error(NULL, "Class name must be a valid object or a string");
		}
	}

	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_INIT_METHOD_CALL_SPEC_UNUSED_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *function_name;
	zval *object;
	crex_function *fbc;
	crex_class_entry *called_scope;
	crex_object *obj;
	crex_execute_data *call;
	uint32_t call_info;

	SAVE_OPLINE();

	object = &EX(This);

	if ((IS_TMP_VAR|IS_VAR) != IS_CONST) {
		function_name = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
	}

	if ((IS_TMP_VAR|IS_VAR) != IS_CONST &&
	    UNEXPECTED(C_TYPE_P(function_name) != IS_STRING)) {
		do {
			if (((IS_TMP_VAR|IS_VAR) & (IS_VAR|IS_CV)) && C_ISREF_P(function_name)) {
				function_name = C_REFVAL_P(function_name);
				if (EXPECTED(C_TYPE_P(function_name) == IS_STRING)) {
					break;
				}
			} else if ((IS_TMP_VAR|IS_VAR) == IS_CV && UNEXPECTED(C_TYPE_P(function_name) == IS_UNDEF)) {
				ZVAL_UNDEFINED_OP2();
				if (UNEXPECTED(EG(exception) != NULL)) {

					HANDLE_EXCEPTION();
				}
			}
			crex_throw_error(NULL, "Method name must be a string");
			zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));

			HANDLE_EXCEPTION();
		} while (0);
	}

	if (IS_UNUSED == IS_UNUSED) {
		obj = C_OBJ_P(object);
	} else {
		do {
			if (IS_UNUSED != IS_CONST && EXPECTED(C_TYPE_P(object) == IS_OBJECT)) {
				obj = C_OBJ_P(object);
			} else {
				if ((IS_UNUSED & (IS_VAR|IS_CV)) && EXPECTED(C_ISREF_P(object))) {
					crex_reference *ref = C_REF_P(object);

					object = &ref->val;
					if (EXPECTED(C_TYPE_P(object) == IS_OBJECT)) {
						obj = C_OBJ_P(object);
						if (IS_UNUSED & IS_VAR) {
							if (UNEXPECTED(GC_DELREF(ref) == 0)) {
								efree_size(ref, sizeof(crex_reference));
							} else {
								C_ADDREF_P(object);
							}
						}
						break;
					}
				}
				if (IS_UNUSED == IS_CV && UNEXPECTED(C_TYPE_P(object) == IS_UNDEF)) {
					object = ZVAL_UNDEFINED_OP1();
					if (UNEXPECTED(EG(exception) != NULL)) {
						if ((IS_TMP_VAR|IS_VAR) != IS_CONST) {
							zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
						}
						HANDLE_EXCEPTION();
					}
				}
				if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
					function_name = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
				}
				crex_invalid_method_call(object, function_name);
				zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));

				HANDLE_EXCEPTION();
			}
		} while (0);
	}

	called_scope = obj->ce;

	if ((IS_TMP_VAR|IS_VAR) == IS_CONST &&
	    EXPECTED(CACHED_PTR(opline->result.num) == called_scope)) {
		fbc = CACHED_PTR(opline->result.num + sizeof(void*));
	} else {
		crex_object *orig_obj = obj;

		if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
			function_name = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
		}

		/* First, locate the function. */
		fbc = obj->handlers->get_method(&obj, C_STR_P(function_name), (((IS_TMP_VAR|IS_VAR) == IS_CONST) ? (RT_CONSTANT(opline, opline->op2) + 1) : NULL));
		if (UNEXPECTED(fbc == NULL)) {
			if (EXPECTED(!EG(exception))) {
				crex_undefined_method(obj->ce, C_STR_P(function_name));
			}
			zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
			if ((IS_UNUSED & (IS_VAR|IS_TMP_VAR)) && GC_DELREF(orig_obj) == 0) {
				crex_objects_store_del(orig_obj);
			}
			HANDLE_EXCEPTION();
		}
		if ((IS_TMP_VAR|IS_VAR) == IS_CONST &&
		    EXPECTED(!(fbc->common.fn_flags & (CREX_ACC_CALL_VIA_TRAMPOLINE|CREX_ACC_NEVER_CACHE))) &&
		    EXPECTED(obj == orig_obj)) {
			CACHE_POLYMORPHIC_PTR(opline->result.num, called_scope, fbc);
		}
		if ((IS_UNUSED & (IS_VAR|IS_TMP_VAR)) && UNEXPECTED(obj != orig_obj)) {
			GC_ADDREF(obj); /* For $this pointer */
			if (GC_DELREF(orig_obj) == 0) {
				crex_objects_store_del(orig_obj);
			}
		}
		if (EXPECTED(fbc->type == CREX_USER_FUNCTION) && UNEXPECTED(!RUN_TIME_CACHE(&fbc->op_array))) {
			init_func_run_time_cache(&fbc->op_array);
		}
	}

	if ((IS_TMP_VAR|IS_VAR) != IS_CONST) {
		zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
	}

	call_info = CREX_CALL_NESTED_FUNCTION | CREX_CALL_HAS_THIS;
	if (UNEXPECTED((fbc->common.fn_flags & CREX_ACC_STATIC) != 0)) {
		if ((IS_UNUSED & (IS_VAR|IS_TMP_VAR)) && GC_DELREF(obj) == 0) {
			crex_objects_store_del(obj);
			if (UNEXPECTED(EG(exception))) {
				HANDLE_EXCEPTION();
			}
		}
		/* call static method */
		obj = (crex_object*)called_scope;
		call_info = CREX_CALL_NESTED_FUNCTION;
	} else if (IS_UNUSED & (IS_VAR|IS_TMP_VAR|IS_CV)) {
		if (IS_UNUSED == IS_CV) {
			GC_ADDREF(obj); /* For $this pointer */
		}
		/* CV may be changed indirectly (e.g. when it's a reference) */
		call_info = CREX_CALL_NESTED_FUNCTION | CREX_CALL_HAS_THIS | CREX_CALL_RELEASE_THIS;
	}

	call = crex_vm_stack_push_call_frame(call_info,
		fbc, opline->extended_value, obj);
	call->prev_execute_data = EX(call);
	EX(call) = call;

	CREX_VM_NEXT_OPCODE();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_INIT_STATIC_METHOD_CALL_SPEC_UNUSED_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *function_name;
	crex_class_entry *ce;
	uint32_t call_info;
	crex_function *fbc;
	crex_execute_data *call;

	SAVE_OPLINE();

	if (IS_UNUSED == IS_CONST) {
		/* no function found. try a static method in class */
		ce = CACHED_PTR(opline->result.num);
		if (UNEXPECTED(ce == NULL)) {
			ce = crex_fetch_class_by_name(C_STR_P(RT_CONSTANT(opline, opline->op1)), C_STR_P(RT_CONSTANT(opline, opline->op1) + 1), CREX_FETCH_CLASS_DEFAULT | CREX_FETCH_CLASS_EXCEPTION);
			if (UNEXPECTED(ce == NULL)) {
				zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
				HANDLE_EXCEPTION();
			}
			if ((IS_TMP_VAR|IS_VAR) != IS_CONST) {
				CACHE_PTR(opline->result.num, ce);
			}
		}
	} else if (IS_UNUSED == IS_UNUSED) {
		ce = crex_fetch_class(NULL, opline->op1.num);
		if (UNEXPECTED(ce == NULL)) {
			zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
			HANDLE_EXCEPTION();
		}
	} else {
		ce = C_CE_P(EX_VAR(opline->op1.var));
	}

	if (IS_UNUSED == IS_CONST &&
	    (IS_TMP_VAR|IS_VAR) == IS_CONST &&
	    EXPECTED((fbc = CACHED_PTR(opline->result.num + sizeof(void*))) != NULL)) {
		/* nothing to do */
	} else if (IS_UNUSED != IS_CONST &&
	           (IS_TMP_VAR|IS_VAR) == IS_CONST &&
	           EXPECTED(CACHED_PTR(opline->result.num) == ce)) {
		fbc = CACHED_PTR(opline->result.num + sizeof(void*));
	} else if ((IS_TMP_VAR|IS_VAR) != IS_UNUSED) {
		function_name = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
		if ((IS_TMP_VAR|IS_VAR) != IS_CONST) {
			if (UNEXPECTED(C_TYPE_P(function_name) != IS_STRING)) {
				do {
					if ((IS_TMP_VAR|IS_VAR) & (IS_VAR|IS_CV) && C_ISREF_P(function_name)) {
						function_name = C_REFVAL_P(function_name);
						if (EXPECTED(C_TYPE_P(function_name) == IS_STRING)) {
							break;
						}
					} else if ((IS_TMP_VAR|IS_VAR) == IS_CV && UNEXPECTED(C_TYPE_P(function_name) == IS_UNDEF)) {
						ZVAL_UNDEFINED_OP2();
						if (UNEXPECTED(EG(exception) != NULL)) {
							HANDLE_EXCEPTION();
						}
					}
					crex_throw_error(NULL, "Method name must be a string");
					zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
					HANDLE_EXCEPTION();
				} while (0);
			}
		}

		if (ce->get_static_method) {
			fbc = ce->get_static_method(ce, C_STR_P(function_name));
		} else {
			fbc = crex_std_get_static_method(ce, C_STR_P(function_name), (((IS_TMP_VAR|IS_VAR) == IS_CONST) ? (RT_CONSTANT(opline, opline->op2) + 1) : NULL));
		}
		if (UNEXPECTED(fbc == NULL)) {
			if (EXPECTED(!EG(exception))) {
				crex_undefined_method(ce, C_STR_P(function_name));
			}
			zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
			HANDLE_EXCEPTION();
		}
		if ((IS_TMP_VAR|IS_VAR) == IS_CONST &&
		    EXPECTED(!(fbc->common.fn_flags & (CREX_ACC_CALL_VIA_TRAMPOLINE|CREX_ACC_NEVER_CACHE))) &&
			EXPECTED(!(fbc->common.scope->ce_flags & CREX_ACC_TRAIT))) {
			CACHE_POLYMORPHIC_PTR(opline->result.num, ce, fbc);
		}
		if (EXPECTED(fbc->type == CREX_USER_FUNCTION) && UNEXPECTED(!RUN_TIME_CACHE(&fbc->op_array))) {
			init_func_run_time_cache(&fbc->op_array);
		}
		if ((IS_TMP_VAR|IS_VAR) != IS_CONST) {
			zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
		}
	} else {
		if (UNEXPECTED(ce->constructor == NULL)) {
			crex_throw_error(NULL, "Cannot call constructor");
			HANDLE_EXCEPTION();
		}
		if (C_TYPE(EX(This)) == IS_OBJECT && C_OBJ(EX(This))->ce != ce->constructor->common.scope && (ce->constructor->common.fn_flags & CREX_ACC_PRIVATE)) {
			crex_throw_error(NULL, "Cannot call private %s::__main()", ZSTR_VAL(ce->name));
			HANDLE_EXCEPTION();
		}
		fbc = ce->constructor;
		if (EXPECTED(fbc->type == CREX_USER_FUNCTION) && UNEXPECTED(!RUN_TIME_CACHE(&fbc->op_array))) {
			init_func_run_time_cache(&fbc->op_array);
		}
	}

	if (!(fbc->common.fn_flags & CREX_ACC_STATIC)) {
		if (C_TYPE(EX(This)) == IS_OBJECT && instanceof_function(C_OBJCE(EX(This)), ce)) {
			ce = (crex_class_entry*)C_OBJ(EX(This));
			call_info = CREX_CALL_NESTED_FUNCTION | CREX_CALL_HAS_THIS;
		} else {
			crex_non_static_method_call(fbc);
			HANDLE_EXCEPTION();
		}
	} else {
		/* previous opcode is CREX_FETCH_CLASS */
		if (IS_UNUSED == IS_UNUSED
		 && ((opline->op1.num & CREX_FETCH_CLASS_MASK) == CREX_FETCH_CLASS_PARENT ||
		     (opline->op1.num & CREX_FETCH_CLASS_MASK) == CREX_FETCH_CLASS_SELF)) {
			if (C_TYPE(EX(This)) == IS_OBJECT) {
				ce = C_OBJCE(EX(This));
			} else {
				ce = C_CE(EX(This));
			}
		}
		call_info = CREX_CALL_NESTED_FUNCTION;
	}

	call = crex_vm_stack_push_call_frame(call_info,
		fbc, opline->extended_value, ce);
	call->prev_execute_data = EX(call);
	EX(call) = call;

	CREX_VM_NEXT_OPCODE();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_INIT_ARRAY_SPEC_UNUSED_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	zval *array;
	uint32_t size;
	USE_OPLINE

	array = EX_VAR(opline->result.var);
	if (IS_UNUSED != IS_UNUSED) {
		size = opline->extended_value >> CREX_ARRAY_SIZE_SHIFT;
		ZVAL_ARR(array, crex_new_array(size));
		/* Explicitly initialize array as not-packed if flag is set */
		if (opline->extended_value & CREX_ARRAY_NOT_PACKED) {
			crex_hash_real_init_mixed(C_ARRVAL_P(array));
		}
		CREX_VM_TAIL_CALL(CREX_NULL_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU));
	} else {
		ZVAL_ARR(array, crex_new_array(0));
		CREX_VM_NEXT_OPCODE();
	}
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_UNSET_OBJ_SPEC_UNUSED_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;
	zval *offset;
	crex_string *name, *tmp_name;

	SAVE_OPLINE();
	container = &EX(This);
	offset = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);

	do {
		if (IS_UNUSED != IS_UNUSED && UNEXPECTED(C_TYPE_P(container) != IS_OBJECT)) {
			if (C_ISREF_P(container)) {
				container = C_REFVAL_P(container);
				if (C_TYPE_P(container) != IS_OBJECT) {
					if (IS_UNUSED == IS_CV
					 && UNEXPECTED(C_TYPE_P(container) == IS_UNDEF)) {
						ZVAL_UNDEFINED_OP1();
					}
					break;
				}
			} else {
				break;
			}
		}
		if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
			name = C_STR_P(offset);
		} else {
			name = zval_try_get_tmp_string(offset, &tmp_name);
			if (UNEXPECTED(!name)) {
				break;
			}
		}
		C_OBJ_HT_P(container)->unset_property(C_OBJ_P(container), name, (((IS_TMP_VAR|IS_VAR) == IS_CONST) ? CACHE_ADDR(opline->extended_value) : NULL));
		if ((IS_TMP_VAR|IS_VAR) != IS_CONST) {
			crex_tmp_string_release(tmp_name);
		}
	} while (0);

	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));

	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ISSET_ISEMPTY_PROP_OBJ_SPEC_UNUSED_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;
	int result;
	zval *offset;
	crex_string *name, *tmp_name;

	SAVE_OPLINE();
	container = &EX(This);
	offset = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);

	if (IS_UNUSED == IS_CONST ||
	    (IS_UNUSED != IS_UNUSED && UNEXPECTED(C_TYPE_P(container) != IS_OBJECT))) {
		if ((IS_UNUSED & (IS_VAR|IS_CV)) && C_ISREF_P(container)) {
			container = C_REFVAL_P(container);
			if (UNEXPECTED(C_TYPE_P(container) != IS_OBJECT)) {
				result = (opline->extended_value & CREX_ISEMPTY);
				goto isset_object_finish;
			}
		} else {
			result = (opline->extended_value & CREX_ISEMPTY);
			goto isset_object_finish;
		}
	}

	if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
		name = C_STR_P(offset);
	} else {
		name = zval_try_get_tmp_string(offset, &tmp_name);
		if (UNEXPECTED(!name)) {
			result = 0;
			goto isset_object_finish;
		}
	}

	result =
		(opline->extended_value & CREX_ISEMPTY) ^
		C_OBJ_HT_P(container)->has_property(C_OBJ_P(container), name, (opline->extended_value & CREX_ISEMPTY), (((IS_TMP_VAR|IS_VAR) == IS_CONST) ? CACHE_ADDR(opline->extended_value & ~CREX_ISEMPTY) : NULL));

	if ((IS_TMP_VAR|IS_VAR) != IS_CONST) {
		crex_tmp_string_release(tmp_name);
	}

isset_object_finish:
	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));

	CREX_VM_SMART_BRANCH(result, 1);
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_YIELD_SPEC_UNUSED_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	crex_generator *generator = crex_get_running_generator(EXECUTE_DATA_C);

	SAVE_OPLINE();
	if (UNEXPECTED(generator->flags & CREX_GENERATOR_FORCED_CLOSE)) {
		CREX_VM_TAIL_CALL(crex_yield_in_closed_generator_helper_SPEC(CREX_OPCODE_HANDLER_ARGS_PASSTHRU));
	}

	/* Destroy the previously yielded value */
	zval_ptr_dtor(&generator->value);

	/* Destroy the previously yielded key */
	zval_ptr_dtor(&generator->key);

	/* Set the new yielded value */
	if (IS_UNUSED != IS_UNUSED) {
		if (UNEXPECTED(EX(func)->op_array.fn_flags & CREX_ACC_RETURN_REFERENCE)) {
			/* Constants and temporary variables aren't yieldable by reference,
			 * but we still allow them with a notice. */
			if (IS_UNUSED & (IS_CONST|IS_TMP_VAR)) {
				zval *value;

				crex_error(E_NOTICE, "Only variable references should be yielded by reference");

				value = NULL;
				ZVAL_COPY_VALUE(&generator->value, value);
				if (IS_UNUSED == IS_CONST) {
					if (UNEXPECTED(C_OPT_REFCOUNTED(generator->value))) {
						C_ADDREF(generator->value);
					}
				}
			} else {
				zval *value_ptr = NULL;

				/* If a function call result is yielded and the function did
				 * not return by reference we throw a notice. */
				do {
					if (IS_UNUSED == IS_VAR) {
						CREX_ASSERT(value_ptr != &EG(uninitialized_zval));
						if (opline->extended_value == CREX_RETURNS_FUNCTION
						 && !C_ISREF_P(value_ptr)) {
							crex_error(E_NOTICE, "Only variable references should be yielded by reference");
							ZVAL_COPY(&generator->value, value_ptr);
							break;
						}
					}
					if (C_ISREF_P(value_ptr)) {
						C_ADDREF_P(value_ptr);
					} else {
						ZVAL_MAKE_REF_EX(value_ptr, 2);
					}
					ZVAL_REF(&generator->value, C_REF_P(value_ptr));
				} while (0);

			}
		} else {
			zval *value = NULL;

			/* Consts, temporary variables and references need copying */
			if (IS_UNUSED == IS_CONST) {
				ZVAL_COPY_VALUE(&generator->value, value);
				if (UNEXPECTED(C_OPT_REFCOUNTED(generator->value))) {
					C_ADDREF(generator->value);
				}
			} else if (IS_UNUSED == IS_TMP_VAR) {
				ZVAL_COPY_VALUE(&generator->value, value);
			} else if ((IS_UNUSED & (IS_VAR|IS_CV)) && C_ISREF_P(value)) {
				ZVAL_COPY(&generator->value, C_REFVAL_P(value));

			} else {
				ZVAL_COPY_VALUE(&generator->value, value);
				if (IS_UNUSED == IS_CV) {
					if (C_OPT_REFCOUNTED_P(value)) C_ADDREF_P(value);
				}
			}
		}
	} else {
		/* If no value was specified yield null */
		ZVAL_NULL(&generator->value);
	}

	/* Set the new yielded key */
	if ((IS_TMP_VAR|IS_VAR) != IS_UNUSED) {
		zval *key = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
		if (((IS_TMP_VAR|IS_VAR) & (IS_CV|IS_VAR)) && UNEXPECTED(C_TYPE_P(key) == IS_REFERENCE)) {
			key = C_REFVAL_P(key);
		}
		ZVAL_COPY(&generator->key, key);
		zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));

		if (C_TYPE(generator->key) == IS_LONG
		    && C_LVAL(generator->key) > generator->largest_used_integer_key
		) {
			generator->largest_used_integer_key = C_LVAL(generator->key);
		}
	} else {
		/* If no key was specified we use auto-increment keys */
		generator->largest_used_integer_key++;
		ZVAL_LONG(&generator->key, generator->largest_used_integer_key);
	}

	if (RETURN_VALUE_USED(opline)) {
		/* If the return value of yield is used set the send
		 * target and initialize it to NULL */
		generator->send_target = EX_VAR(opline->result.var);
		ZVAL_NULL(generator->send_target);
	} else {
		generator->send_target = NULL;
	}

	/* We increment to the next op, so we are at the correct position when the
	 * generator is resumed. */
	CREX_VM_INC_OPCODE();

	/* The GOTO VM uses a local opline variable. We need to set the opline
	 * variable in execute_data so we don't resume at an old position. */
	SAVE_OPLINE();

	CREX_VM_RETURN();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FETCH_CLASS_SPEC_UNUSED_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	zval *class_name;
	USE_OPLINE

	SAVE_OPLINE();
	if (IS_UNUSED == IS_UNUSED) {
		C_CE_P(EX_VAR(opline->result.var)) = crex_fetch_class(NULL, opline->op1.num);
		CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
	} else if (IS_UNUSED == IS_CONST) {
		crex_class_entry *ce = CACHED_PTR(opline->extended_value);

		if (UNEXPECTED(ce == NULL)) {
			class_name = NULL;
			ce = crex_fetch_class_by_name(C_STR_P(class_name), C_STR_P(class_name + 1), opline->op1.num);
			CACHE_PTR(opline->extended_value, ce);
		}
		C_CE_P(EX_VAR(opline->result.var)) = ce;
	} else {
		class_name = NULL;
try_class_name:
		if (C_TYPE_P(class_name) == IS_OBJECT) {
			C_CE_P(EX_VAR(opline->result.var)) = C_OBJCE_P(class_name);
		} else if (C_TYPE_P(class_name) == IS_STRING) {
			C_CE_P(EX_VAR(opline->result.var)) = crex_fetch_class(C_STR_P(class_name), opline->op1.num);
		} else if ((IS_UNUSED & (IS_VAR|IS_CV)) && C_TYPE_P(class_name) == IS_REFERENCE) {
			class_name = C_REFVAL_P(class_name);
			goto try_class_name;
		} else {
			if (IS_UNUSED == IS_CV && UNEXPECTED(C_TYPE_P(class_name) == IS_UNDEF)) {
				ZVAL_UNDEFINED_OP2();
				if (UNEXPECTED(EG(exception) != NULL)) {
					HANDLE_EXCEPTION();
				}
			}
			crex_throw_error(NULL, "Class name must be a valid object or a string");
		}
	}

	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_INIT_STATIC_METHOD_CALL_SPEC_UNUSED_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *function_name;
	crex_class_entry *ce;
	uint32_t call_info;
	crex_function *fbc;
	crex_execute_data *call;

	SAVE_OPLINE();

	if (IS_UNUSED == IS_CONST) {
		/* no function found. try a static method in class */
		ce = CACHED_PTR(opline->result.num);
		if (UNEXPECTED(ce == NULL)) {
			ce = crex_fetch_class_by_name(C_STR_P(RT_CONSTANT(opline, opline->op1)), C_STR_P(RT_CONSTANT(opline, opline->op1) + 1), CREX_FETCH_CLASS_DEFAULT | CREX_FETCH_CLASS_EXCEPTION);
			if (UNEXPECTED(ce == NULL)) {

				HANDLE_EXCEPTION();
			}
			if (IS_UNUSED != IS_CONST) {
				CACHE_PTR(opline->result.num, ce);
			}
		}
	} else if (IS_UNUSED == IS_UNUSED) {
		ce = crex_fetch_class(NULL, opline->op1.num);
		if (UNEXPECTED(ce == NULL)) {

			HANDLE_EXCEPTION();
		}
	} else {
		ce = C_CE_P(EX_VAR(opline->op1.var));
	}

	if (IS_UNUSED == IS_CONST &&
	    IS_UNUSED == IS_CONST &&
	    EXPECTED((fbc = CACHED_PTR(opline->result.num + sizeof(void*))) != NULL)) {
		/* nothing to do */
	} else if (IS_UNUSED != IS_CONST &&
	           IS_UNUSED == IS_CONST &&
	           EXPECTED(CACHED_PTR(opline->result.num) == ce)) {
		fbc = CACHED_PTR(opline->result.num + sizeof(void*));
	} else if (IS_UNUSED != IS_UNUSED) {
		function_name = NULL;
		if (IS_UNUSED != IS_CONST) {
			if (UNEXPECTED(C_TYPE_P(function_name) != IS_STRING)) {
				do {
					if (IS_UNUSED & (IS_VAR|IS_CV) && C_ISREF_P(function_name)) {
						function_name = C_REFVAL_P(function_name);
						if (EXPECTED(C_TYPE_P(function_name) == IS_STRING)) {
							break;
						}
					} else if (IS_UNUSED == IS_CV && UNEXPECTED(C_TYPE_P(function_name) == IS_UNDEF)) {
						ZVAL_UNDEFINED_OP2();
						if (UNEXPECTED(EG(exception) != NULL)) {
							HANDLE_EXCEPTION();
						}
					}
					crex_throw_error(NULL, "Method name must be a string");

					HANDLE_EXCEPTION();
				} while (0);
			}
		}

		if (ce->get_static_method) {
			fbc = ce->get_static_method(ce, C_STR_P(function_name));
		} else {
			fbc = crex_std_get_static_method(ce, C_STR_P(function_name), ((IS_UNUSED == IS_CONST) ? (RT_CONSTANT(opline, opline->op2) + 1) : NULL));
		}
		if (UNEXPECTED(fbc == NULL)) {
			if (EXPECTED(!EG(exception))) {
				crex_undefined_method(ce, C_STR_P(function_name));
			}

			HANDLE_EXCEPTION();
		}
		if (IS_UNUSED == IS_CONST &&
		    EXPECTED(!(fbc->common.fn_flags & (CREX_ACC_CALL_VIA_TRAMPOLINE|CREX_ACC_NEVER_CACHE))) &&
			EXPECTED(!(fbc->common.scope->ce_flags & CREX_ACC_TRAIT))) {
			CACHE_POLYMORPHIC_PTR(opline->result.num, ce, fbc);
		}
		if (EXPECTED(fbc->type == CREX_USER_FUNCTION) && UNEXPECTED(!RUN_TIME_CACHE(&fbc->op_array))) {
			init_func_run_time_cache(&fbc->op_array);
		}
		if (IS_UNUSED != IS_CONST) {

		}
	} else {
		if (UNEXPECTED(ce->constructor == NULL)) {
			crex_throw_error(NULL, "Cannot call constructor");
			HANDLE_EXCEPTION();
		}
		if (C_TYPE(EX(This)) == IS_OBJECT && C_OBJ(EX(This))->ce != ce->constructor->common.scope && (ce->constructor->common.fn_flags & CREX_ACC_PRIVATE)) {
			crex_throw_error(NULL, "Cannot call private %s::__main()", ZSTR_VAL(ce->name));
			HANDLE_EXCEPTION();
		}
		fbc = ce->constructor;
		if (EXPECTED(fbc->type == CREX_USER_FUNCTION) && UNEXPECTED(!RUN_TIME_CACHE(&fbc->op_array))) {
			init_func_run_time_cache(&fbc->op_array);
		}
	}

	if (!(fbc->common.fn_flags & CREX_ACC_STATIC)) {
		if (C_TYPE(EX(This)) == IS_OBJECT && instanceof_function(C_OBJCE(EX(This)), ce)) {
			ce = (crex_class_entry*)C_OBJ(EX(This));
			call_info = CREX_CALL_NESTED_FUNCTION | CREX_CALL_HAS_THIS;
		} else {
			crex_non_static_method_call(fbc);
			HANDLE_EXCEPTION();
		}
	} else {
		/* previous opcode is CREX_FETCH_CLASS */
		if (IS_UNUSED == IS_UNUSED
		 && ((opline->op1.num & CREX_FETCH_CLASS_MASK) == CREX_FETCH_CLASS_PARENT ||
		     (opline->op1.num & CREX_FETCH_CLASS_MASK) == CREX_FETCH_CLASS_SELF)) {
			if (C_TYPE(EX(This)) == IS_OBJECT) {
				ce = C_OBJCE(EX(This));
			} else {
				ce = C_CE(EX(This));
			}
		}
		call_info = CREX_CALL_NESTED_FUNCTION;
	}

	call = crex_vm_stack_push_call_frame(call_info,
		fbc, opline->extended_value, ce);
	call->prev_execute_data = EX(call);
	EX(call) = call;

	CREX_VM_NEXT_OPCODE();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_VERIFY_RETURN_TYPE_SPEC_UNUSED_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	if (IS_UNUSED == IS_UNUSED) {
		SAVE_OPLINE();
		crex_verify_missing_return_type(EX(func));
		HANDLE_EXCEPTION();
	} else {
/* prevents "undefined variable opline" errors */
#if 0 || (IS_UNUSED != IS_UNUSED)
		USE_OPLINE
		zval *retval_ref, *retval_ptr;
		crex_arg_info *ret_info = EX(func)->common.arg_info - 1;
		retval_ref = retval_ptr = NULL;

		if (IS_UNUSED == IS_CONST) {
			ZVAL_COPY(EX_VAR(opline->result.var), retval_ptr);
			retval_ref = retval_ptr = EX_VAR(opline->result.var);
		} else if (IS_UNUSED == IS_VAR) {
			if (UNEXPECTED(C_TYPE_P(retval_ptr) == IS_INDIRECT)) {
				retval_ref = retval_ptr = C_INDIRECT_P(retval_ptr);
			}
			ZVAL_DEREF(retval_ptr);
		} else if (IS_UNUSED == IS_CV) {
			ZVAL_DEREF(retval_ptr);
		}

		if (EXPECTED(CREX_TYPE_CONTAINS_CODE(ret_info->type, C_TYPE_P(retval_ptr)))) {
			CREX_VM_NEXT_OPCODE();
		}

		if (IS_UNUSED == IS_CV && UNEXPECTED(C_ISUNDEF_P(retval_ptr))) {
			SAVE_OPLINE();
			retval_ref = retval_ptr = ZVAL_UNDEFINED_OP1();
			if (UNEXPECTED(EG(exception))) {
				HANDLE_EXCEPTION();
			}
			if (CREX_TYPE_FULL_MASK(ret_info->type) & MAY_BE_NULL) {
				CREX_VM_NEXT_OPCODE();
			}
		}

		crex_reference *ref = NULL;
		void *cache_slot = CACHE_ADDR(opline->op2.num);
		if (UNEXPECTED(retval_ref != retval_ptr)) {
			if (UNEXPECTED(EX(func)->op_array.fn_flags & CREX_ACC_RETURN_REFERENCE)) {
				ref = C_REF_P(retval_ref);
			} else {
				/* A cast might happen - unwrap the reference if this is a by-value return */
				if (C_REFCOUNT_P(retval_ref) == 1) {
					ZVAL_UNREF(retval_ref);
				} else {
					C_DELREF_P(retval_ref);
					ZVAL_COPY(retval_ref, retval_ptr);
				}
				retval_ptr = retval_ref;
			}
		}

		SAVE_OPLINE();
		if (UNEXPECTED(!crex_check_type_slow(&ret_info->type, retval_ptr, ref, cache_slot, 1, 0))) {
			crex_verify_return_error(EX(func), retval_ptr);
			HANDLE_EXCEPTION();
		}
		CREX_VM_NEXT_OPCODE();
#endif
	}
}

static CREX_VM_COLD CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_VERIFY_NEVER_TYPE_SPEC_UNUSED_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	SAVE_OPLINE();
	crex_verify_never_error(EX(func));
	HANDLE_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_CHECK_FUNC_ARG_SPEC_UNUSED_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	uint32_t arg_num;

	if (IS_UNUSED == IS_CONST) {
		crex_string *arg_name = C_STR_P(RT_CONSTANT(opline, opline->op2));
		arg_num = crex_get_arg_offset_by_name(
			EX(call)->func, arg_name, CACHE_ADDR(opline->result.num)) + 1;
		if (UNEXPECTED(arg_num == 0)) {
			/* Treat this as a by-value argument, and throw an error during SEND. */
			CREX_DEL_CALL_FLAG(EX(call), CREX_CALL_SEND_ARG_BY_REF);
			CREX_VM_NEXT_OPCODE();
		}
	} else {
		arg_num = opline->op2.num;
	}

	if (EXPECTED(0)) {
		if (QUICK_ARG_SHOULD_BE_SENT_BY_REF(EX(call)->func, arg_num)) {
			CREX_ADD_CALL_FLAG(EX(call), CREX_CALL_SEND_ARG_BY_REF);
		} else {
			CREX_DEL_CALL_FLAG(EX(call), CREX_CALL_SEND_ARG_BY_REF);
		}
	} else if (ARG_SHOULD_BE_SENT_BY_REF(EX(call)->func, arg_num)) {
		CREX_ADD_CALL_FLAG(EX(call), CREX_CALL_SEND_ARG_BY_REF);
	} else {
		CREX_DEL_CALL_FLAG(EX(call), CREX_CALL_SEND_ARG_BY_REF);
	}
	CREX_VM_NEXT_OPCODE();
}

static CREX_VM_HOT CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_CHECK_FUNC_ARG_SPEC_UNUSED_UNUSED_QUICK_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	uint32_t arg_num;

	if (IS_UNUSED == IS_CONST) {
		crex_string *arg_name = C_STR_P(RT_CONSTANT(opline, opline->op2));
		arg_num = crex_get_arg_offset_by_name(
			EX(call)->func, arg_name, CACHE_ADDR(opline->result.num)) + 1;
		if (UNEXPECTED(arg_num == 0)) {
			/* Treat this as a by-value argument, and throw an error during SEND. */
			CREX_DEL_CALL_FLAG(EX(call), CREX_CALL_SEND_ARG_BY_REF);
			CREX_VM_NEXT_OPCODE();
		}
	} else {
		arg_num = opline->op2.num;
	}

	if (EXPECTED(1)) {
		if (QUICK_ARG_SHOULD_BE_SENT_BY_REF(EX(call)->func, arg_num)) {
			CREX_ADD_CALL_FLAG(EX(call), CREX_CALL_SEND_ARG_BY_REF);
		} else {
			CREX_DEL_CALL_FLAG(EX(call), CREX_CALL_SEND_ARG_BY_REF);
		}
	} else if (ARG_SHOULD_BE_SENT_BY_REF(EX(call)->func, arg_num)) {
		CREX_ADD_CALL_FLAG(EX(call), CREX_CALL_SEND_ARG_BY_REF);
	} else {
		CREX_DEL_CALL_FLAG(EX(call), CREX_CALL_SEND_ARG_BY_REF);
	}
	CREX_VM_NEXT_OPCODE();
}

static CREX_VM_HOT CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_CHECK_UNDEF_ARGS_SPEC_UNUSED_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	crex_execute_data *call = execute_data->call;
	if (EXPECTED(!(CREX_CALL_INFO(call) & CREX_CALL_MAY_HAVE_UNDEF))) {
		CREX_VM_NEXT_OPCODE();
	}

	SAVE_OPLINE();
	crex_handle_undef_args(call);
	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_NEW_SPEC_UNUSED_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *result;
	crex_function *constructor;
	crex_class_entry *ce;
	crex_execute_data *call;

	SAVE_OPLINE();
	if (IS_UNUSED == IS_CONST) {
		ce = CACHED_PTR(opline->op2.num);
		if (UNEXPECTED(ce == NULL)) {
			ce = crex_fetch_class_by_name(C_STR_P(RT_CONSTANT(opline, opline->op1)), C_STR_P(RT_CONSTANT(opline, opline->op1) + 1), CREX_FETCH_CLASS_DEFAULT | CREX_FETCH_CLASS_EXCEPTION);
			if (UNEXPECTED(ce == NULL)) {
				ZVAL_UNDEF(EX_VAR(opline->result.var));
				HANDLE_EXCEPTION();
			}
			CACHE_PTR(opline->op2.num, ce);
		}
	} else if (IS_UNUSED == IS_UNUSED) {
		ce = crex_fetch_class(NULL, opline->op1.num);
		if (UNEXPECTED(ce == NULL)) {
			ZVAL_UNDEF(EX_VAR(opline->result.var));
			HANDLE_EXCEPTION();
		}
	} else {
		ce = C_CE_P(EX_VAR(opline->op1.var));
	}

	result = EX_VAR(opline->result.var);
	if (UNEXPECTED(object_init_ex(result, ce) != SUCCESS)) {
		ZVAL_UNDEF(result);
		HANDLE_EXCEPTION();
	}

	constructor = C_OBJ_HT_P(result)->get_constructor(C_OBJ_P(result));
	if (constructor == NULL) {
		if (UNEXPECTED(EG(exception))) {
			HANDLE_EXCEPTION();
		}

		/* If there are no arguments, skip over the DO_FCALL opcode. We check if the next
		 * opcode is DO_FCALL in case EXT instructions are used. */
		if (EXPECTED(opline->extended_value == 0 && (opline+1)->opcode == CREX_DO_FCALL)) {
			CREX_VM_NEXT_OPCODE_EX(1, 2);
		}

		/* Perform a dummy function call */
		call = crex_vm_stack_push_call_frame(
			CREX_CALL_FUNCTION, (crex_function *) &crex_pass_function,
			opline->extended_value, NULL);
	} else {
		if (EXPECTED(constructor->type == CREX_USER_FUNCTION) && UNEXPECTED(!RUN_TIME_CACHE(&constructor->op_array))) {
			init_func_run_time_cache(&constructor->op_array);
		}
		/* We are not handling overloaded classes right now */
		call = crex_vm_stack_push_call_frame(
			CREX_CALL_FUNCTION | CREX_CALL_RELEASE_THIS | CREX_CALL_HAS_THIS,
			constructor,
			opline->extended_value,
			C_OBJ_P(result));
		C_ADDREF_P(result);
	}

	call->prev_execute_data = EX(call);
	EX(call) = call;
	CREX_VM_NEXT_OPCODE();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_INIT_ARRAY_SPEC_UNUSED_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	zval *array;
	uint32_t size;
	USE_OPLINE

	array = EX_VAR(opline->result.var);
	if (IS_UNUSED != IS_UNUSED) {
		size = opline->extended_value >> CREX_ARRAY_SIZE_SHIFT;
		ZVAL_ARR(array, crex_new_array(size));
		/* Explicitly initialize array as not-packed if flag is set */
		if (opline->extended_value & CREX_ARRAY_NOT_PACKED) {
			crex_hash_real_init_mixed(C_ARRVAL_P(array));
		}
		CREX_VM_TAIL_CALL(CREX_NULL_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU));
	} else {
		ZVAL_ARR(array, crex_new_array(0));
		CREX_VM_NEXT_OPCODE();
	}
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_YIELD_SPEC_UNUSED_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	crex_generator *generator = crex_get_running_generator(EXECUTE_DATA_C);

	SAVE_OPLINE();
	if (UNEXPECTED(generator->flags & CREX_GENERATOR_FORCED_CLOSE)) {
		CREX_VM_TAIL_CALL(crex_yield_in_closed_generator_helper_SPEC(CREX_OPCODE_HANDLER_ARGS_PASSTHRU));
	}

	/* Destroy the previously yielded value */
	zval_ptr_dtor(&generator->value);

	/* Destroy the previously yielded key */
	zval_ptr_dtor(&generator->key);

	/* Set the new yielded value */
	if (IS_UNUSED != IS_UNUSED) {
		if (UNEXPECTED(EX(func)->op_array.fn_flags & CREX_ACC_RETURN_REFERENCE)) {
			/* Constants and temporary variables aren't yieldable by reference,
			 * but we still allow them with a notice. */
			if (IS_UNUSED & (IS_CONST|IS_TMP_VAR)) {
				zval *value;

				crex_error(E_NOTICE, "Only variable references should be yielded by reference");

				value = NULL;
				ZVAL_COPY_VALUE(&generator->value, value);
				if (IS_UNUSED == IS_CONST) {
					if (UNEXPECTED(C_OPT_REFCOUNTED(generator->value))) {
						C_ADDREF(generator->value);
					}
				}
			} else {
				zval *value_ptr = NULL;

				/* If a function call result is yielded and the function did
				 * not return by reference we throw a notice. */
				do {
					if (IS_UNUSED == IS_VAR) {
						CREX_ASSERT(value_ptr != &EG(uninitialized_zval));
						if (opline->extended_value == CREX_RETURNS_FUNCTION
						 && !C_ISREF_P(value_ptr)) {
							crex_error(E_NOTICE, "Only variable references should be yielded by reference");
							ZVAL_COPY(&generator->value, value_ptr);
							break;
						}
					}
					if (C_ISREF_P(value_ptr)) {
						C_ADDREF_P(value_ptr);
					} else {
						ZVAL_MAKE_REF_EX(value_ptr, 2);
					}
					ZVAL_REF(&generator->value, C_REF_P(value_ptr));
				} while (0);

			}
		} else {
			zval *value = NULL;

			/* Consts, temporary variables and references need copying */
			if (IS_UNUSED == IS_CONST) {
				ZVAL_COPY_VALUE(&generator->value, value);
				if (UNEXPECTED(C_OPT_REFCOUNTED(generator->value))) {
					C_ADDREF(generator->value);
				}
			} else if (IS_UNUSED == IS_TMP_VAR) {
				ZVAL_COPY_VALUE(&generator->value, value);
			} else if ((IS_UNUSED & (IS_VAR|IS_CV)) && C_ISREF_P(value)) {
				ZVAL_COPY(&generator->value, C_REFVAL_P(value));

			} else {
				ZVAL_COPY_VALUE(&generator->value, value);
				if (IS_UNUSED == IS_CV) {
					if (C_OPT_REFCOUNTED_P(value)) C_ADDREF_P(value);
				}
			}
		}
	} else {
		/* If no value was specified yield null */
		ZVAL_NULL(&generator->value);
	}

	/* Set the new yielded key */
	if (IS_UNUSED != IS_UNUSED) {
		zval *key = NULL;
		if ((IS_UNUSED & (IS_CV|IS_VAR)) && UNEXPECTED(C_TYPE_P(key) == IS_REFERENCE)) {
			key = C_REFVAL_P(key);
		}
		ZVAL_COPY(&generator->key, key);

		if (C_TYPE(generator->key) == IS_LONG
		    && C_LVAL(generator->key) > generator->largest_used_integer_key
		) {
			generator->largest_used_integer_key = C_LVAL(generator->key);
		}
	} else {
		/* If no key was specified we use auto-increment keys */
		generator->largest_used_integer_key++;
		ZVAL_LONG(&generator->key, generator->largest_used_integer_key);
	}

	if (RETURN_VALUE_USED(opline)) {
		/* If the return value of yield is used set the send
		 * target and initialize it to NULL */
		generator->send_target = EX_VAR(opline->result.var);
		ZVAL_NULL(generator->send_target);
	} else {
		generator->send_target = NULL;
	}

	/* We increment to the next op, so we are at the correct position when the
	 * generator is resumed. */
	CREX_VM_INC_OPCODE();

	/* The GOTO VM uses a local opline variable. We need to set the opline
	 * variable in execute_data so we don't resume at an old position. */
	SAVE_OPLINE();

	CREX_VM_RETURN();
}

static CREX_VM_HOT CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FETCH_THIS_SPEC_UNUSED_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (EXPECTED(C_TYPE(EX(This)) == IS_OBJECT)) {
		zval *result = EX_VAR(opline->result.var);

		ZVAL_OBJ(result, C_OBJ(EX(This)));
		C_ADDREF_P(result);
		CREX_VM_NEXT_OPCODE();
	} else {
		CREX_VM_TAIL_CALL(crex_this_not_in_object_context_helper_SPEC(CREX_OPCODE_HANDLER_ARGS_PASSTHRU));
	}
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FETCH_GLOBALS_SPEC_UNUSED_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	/* For symbol tables we need to deal with exactly the same problems as for property tables. */
	ZVAL_ARR(EX_VAR(opline->result.var),
		crex_proptable_to_symtable(&EG(symbol_table), /* always_duplicate */ 1));
	CREX_VM_NEXT_OPCODE();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ISSET_ISEMPTY_THIS_SPEC_UNUSED_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	ZVAL_BOOL(EX_VAR(opline->result.var),
		(opline->extended_value & CREX_ISEMPTY) ^
		 (C_TYPE(EX(This)) == IS_OBJECT));
	CREX_VM_NEXT_OPCODE();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_GET_CLASS_SPEC_UNUSED_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (IS_UNUSED == IS_UNUSED) {
		SAVE_OPLINE();
		if (UNEXPECTED(!EX(func)->common.scope)) {
			crex_throw_error(NULL, "get_class() without arguments must be called from within a class");
			ZVAL_UNDEF(EX_VAR(opline->result.var));
			HANDLE_EXCEPTION();
		} else {
			crex_error(E_DEPRECATED, "Calling get_class() without arguments is deprecated");
			ZVAL_STR_COPY(EX_VAR(opline->result.var), EX(func)->common.scope->name);
			if (UNEXPECTED(EG(exception))) {
				HANDLE_EXCEPTION();
			}
			CREX_VM_NEXT_OPCODE();
		}
	} else {
		zval *op1;

		SAVE_OPLINE();
		op1 = NULL;
		while (1) {
			if (C_TYPE_P(op1) == IS_OBJECT) {
				ZVAL_STR_COPY(EX_VAR(opline->result.var), C_OBJCE_P(op1)->name);
			} else if ((IS_UNUSED & (IS_VAR|IS_CV)) != 0 && C_TYPE_P(op1) == IS_REFERENCE) {
				op1 = C_REFVAL_P(op1);
				continue;
			} else {
				if (IS_UNUSED == IS_CV && UNEXPECTED(C_TYPE_P(op1) == IS_UNDEF)) {
					ZVAL_UNDEFINED_OP1();
				}
				crex_type_error("get_class(): Argument #1 ($object) must be of type object, %s given", crex_zval_value_name(op1));
				ZVAL_UNDEF(EX_VAR(opline->result.var));
			}
			break;
		}

		CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
	}
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_GET_CALLED_CLASS_SPEC_UNUSED_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (C_TYPE(EX(This)) == IS_OBJECT) {
		ZVAL_STR_COPY(EX_VAR(opline->result.var), C_OBJCE(EX(This))->name);
	} else if (C_CE(EX(This))) {
		ZVAL_STR_COPY(EX_VAR(opline->result.var), C_CE(EX(This))->name);
	} else {
		CREX_ASSERT(!EX(func)->common.scope);
		SAVE_OPLINE();
		crex_throw_error(NULL, "get_called_class() must be called from within a class");
		ZVAL_UNDEF(EX_VAR(opline->result.var));
		HANDLE_EXCEPTION();
	}
	CREX_VM_NEXT_OPCODE();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FUNC_NUM_ARGS_SPEC_UNUSED_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	ZVAL_LONG(EX_VAR(opline->result.var), EX_NUM_ARGS());
	CREX_VM_NEXT_OPCODE();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FUNC_GET_ARGS_SPEC_UNUSED_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	crex_array *ht;
	uint32_t arg_count, result_size, skip;

	arg_count = EX_NUM_ARGS();
	if (IS_UNUSED == IS_CONST) {
		skip = C_LVAL_P(RT_CONSTANT(opline, opline->op1));
		if (arg_count < skip) {
			result_size = 0;
		} else {
			result_size = arg_count - skip;
		}
	} else {
		skip = 0;
		result_size = arg_count;
	}

	if (result_size) {
		uint32_t first_extra_arg = EX(func)->op_array.num_args;

		ht = crex_new_array(result_size);
		ZVAL_ARR(EX_VAR(opline->result.var), ht);
		crex_hash_real_init_packed(ht);
		CREX_HASH_FILL_PACKED(ht) {
			zval *p, *q;
			uint32_t i = skip;
			p = EX_VAR_NUM(i);
			if (arg_count > first_extra_arg) {
				while (i < first_extra_arg) {
					q = p;
					if (EXPECTED(C_TYPE_INFO_P(q) != IS_UNDEF)) {
						ZVAL_DEREF(q);
						if (C_OPT_REFCOUNTED_P(q)) {
							C_ADDREF_P(q);
						}
						CREX_HASH_FILL_SET(q);
					} else {
						CREX_HASH_FILL_SET_NULL();
					}
					CREX_HASH_FILL_NEXT();
					p++;
					i++;
				}
				if (skip < first_extra_arg) {
					skip = 0;
				} else {
					skip -= first_extra_arg;
				}
				p = EX_VAR_NUM(EX(func)->op_array.last_var + EX(func)->op_array.T + skip);
			}
			while (i < arg_count) {
				q = p;
				if (EXPECTED(C_TYPE_INFO_P(q) != IS_UNDEF)) {
					ZVAL_DEREF(q);
					if (C_OPT_REFCOUNTED_P(q)) {
						C_ADDREF_P(q);
					}
					CREX_HASH_FILL_SET(q);
				} else {
					CREX_HASH_FILL_SET_NULL();
				}
				CREX_HASH_FILL_NEXT();
				p++;
				i++;
			}
		} CREX_HASH_FILL_END();
		ht->nNumOfElements = result_size;
	} else {
		ZVAL_EMPTY_ARRAY(EX_VAR(opline->result.var));
	}
	CREX_VM_NEXT_OPCODE();
}

/* Contrary to what its name indicates, CREX_COPY_TMP may receive and define references. */
static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_CALLABLE_CONVERT_SPEC_UNUSED_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	crex_execute_data *call = EX(call);

	crex_closure_from_frame(EX_VAR(opline->result.var), call);

	if (CREX_CALL_INFO(call) & CREX_CALL_RELEASE_THIS) {
		OBJ_RELEASE(C_OBJ(call->This));
	}

	EX(call) = call->prev_execute_data;

	crex_vm_stack_free_call_frame(call);

	CREX_VM_NEXT_OPCODE();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ASSIGN_OBJ_OP_SPEC_UNUSED_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *object;
	zval *property;
	zval *value;
	zval *zptr;
	void **cache_slot;
	crex_property_info *prop_info;
	crex_object *zobj;
	crex_string *name, *tmp_name;

	SAVE_OPLINE();
	object = &EX(This);
	property = _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC);

	do {
		value = get_op_data_zval_ptr_r((opline+1)->op1_type, (opline+1)->op1);

		if (IS_UNUSED != IS_UNUSED && UNEXPECTED(C_TYPE_P(object) != IS_OBJECT)) {
			if (C_ISREF_P(object) && C_TYPE_P(C_REFVAL_P(object)) == IS_OBJECT) {
				object = C_REFVAL_P(object);
				goto assign_op_object;
			}
			if (IS_UNUSED == IS_CV
			 && UNEXPECTED(C_TYPE_P(object) == IS_UNDEF)) {
				ZVAL_UNDEFINED_OP1();
			}
			crex_throw_non_object_error(object, property OPLINE_CC EXECUTE_DATA_CC);
			break;
		}

assign_op_object:
		/* here we are sure we are dealing with an object */
		zobj = C_OBJ_P(object);
		if (IS_CV == IS_CONST) {
			name = C_STR_P(property);
		} else {
			name = zval_try_get_tmp_string(property, &tmp_name);
			if (UNEXPECTED(!name)) {
				UNDEF_RESULT();
				break;
			}
		}
		cache_slot = (IS_CV == IS_CONST) ? CACHE_ADDR((opline+1)->extended_value) : NULL;
		if (EXPECTED((zptr = zobj->handlers->get_property_ptr_ptr(zobj, name, BP_VAR_RW, cache_slot)) != NULL)) {
			if (UNEXPECTED(C_ISERROR_P(zptr))) {
				if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
					ZVAL_NULL(EX_VAR(opline->result.var));
				}
			} else {
				zval *orig_zptr = zptr;
				crex_reference *ref;

				do {
					if (UNEXPECTED(C_ISREF_P(zptr))) {
						ref = C_REF_P(zptr);
						zptr = C_REFVAL_P(zptr);
						if (UNEXPECTED(CREX_REF_HAS_TYPE_SOURCES(ref))) {
							crex_binary_assign_op_typed_ref(ref, value OPLINE_CC EXECUTE_DATA_CC);
							break;
						}
					}

					if (IS_CV == IS_CONST) {
						prop_info = (crex_property_info*)CACHED_PTR_EX(cache_slot + 2);
					} else {
						prop_info = crex_object_fetch_property_type_info(C_OBJ_P(object), orig_zptr);
					}
					if (UNEXPECTED(prop_info)) {
						/* special case for typed properties */
						crex_binary_assign_op_typed_prop(prop_info, zptr, value OPLINE_CC EXECUTE_DATA_CC);
					} else {
						crex_binary_op(zptr, zptr, value OPLINE_CC);
					}
				} while (0);

				if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
					ZVAL_COPY(EX_VAR(opline->result.var), zptr);
				}
			}
		} else {
			crex_assign_op_overloaded_property(zobj, name, cache_slot, value OPLINE_CC EXECUTE_DATA_CC);
		}
		if (IS_CV != IS_CONST) {
			crex_tmp_string_release(tmp_name);
		}
	} while (0);

	FREE_OP((opline+1)->op1_type, (opline+1)->op1.var);


	/* assign_obj has two opcodes! */
	CREX_VM_NEXT_OPCODE_EX(1, 2);
}

/* No specialization for op_types (CONST|TMP|VAR|CV, UNUSED|CONST|TMPVAR) */
static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_PRE_INC_OBJ_SPEC_UNUSED_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *object;
	zval *property;
	zval *zptr;
	void **cache_slot;
	crex_property_info *prop_info;
	crex_object *zobj;
	crex_string *name, *tmp_name;

	SAVE_OPLINE();
	object = &EX(This);
	property = _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC);

	do {
		if (IS_UNUSED != IS_UNUSED && UNEXPECTED(C_TYPE_P(object) != IS_OBJECT)) {
			if (C_ISREF_P(object) && C_TYPE_P(C_REFVAL_P(object)) == IS_OBJECT) {
				object = C_REFVAL_P(object);
				goto pre_incdec_object;
			}
			if (IS_UNUSED == IS_CV
			 && UNEXPECTED(C_TYPE_P(object) == IS_UNDEF)) {
				ZVAL_UNDEFINED_OP1();
			}
			crex_throw_non_object_error(object, property OPLINE_CC EXECUTE_DATA_CC);
			break;
		}

pre_incdec_object:
		/* here we are sure we are dealing with an object */
		zobj = C_OBJ_P(object);
		if (IS_CV == IS_CONST) {
			name = C_STR_P(property);
		} else {
			name = zval_try_get_tmp_string(property, &tmp_name);
			if (UNEXPECTED(!name)) {
				UNDEF_RESULT();
				break;
			}
		}
		cache_slot = (IS_CV == IS_CONST) ? CACHE_ADDR(opline->extended_value) : NULL;
		if (EXPECTED((zptr = zobj->handlers->get_property_ptr_ptr(zobj, name, BP_VAR_RW, cache_slot)) != NULL)) {
			if (UNEXPECTED(C_ISERROR_P(zptr))) {
				if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
					ZVAL_NULL(EX_VAR(opline->result.var));
				}
			} else {
				if (IS_CV == IS_CONST) {
					prop_info = (crex_property_info *) CACHED_PTR_EX(cache_slot + 2);
				} else {
					prop_info = crex_object_fetch_property_type_info(C_OBJ_P(object), zptr);
				}
				crex_pre_incdec_property_zval(zptr, prop_info OPLINE_CC EXECUTE_DATA_CC);
			}
		} else {
			crex_pre_incdec_overloaded_property(zobj, name, cache_slot OPLINE_CC EXECUTE_DATA_CC);
		}
		if (IS_CV != IS_CONST) {
			crex_tmp_string_release(tmp_name);
		}
	} while (0);


	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_POST_INC_OBJ_SPEC_UNUSED_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *object;
	zval *property;
	zval *zptr;
	void **cache_slot;
	crex_property_info *prop_info;
	crex_object *zobj;
	crex_string *name, *tmp_name;

	SAVE_OPLINE();
	object = &EX(This);
	property = _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC);

	do {
		if (IS_UNUSED != IS_UNUSED && UNEXPECTED(C_TYPE_P(object) != IS_OBJECT)) {
			if (C_ISREF_P(object) && C_TYPE_P(C_REFVAL_P(object)) == IS_OBJECT) {
				object = C_REFVAL_P(object);
				goto post_incdec_object;
			}
			if (IS_UNUSED == IS_CV
			 && UNEXPECTED(C_TYPE_P(object) == IS_UNDEF)) {
				ZVAL_UNDEFINED_OP1();
			}
			crex_throw_non_object_error(object, property OPLINE_CC EXECUTE_DATA_CC);
			break;
		}

post_incdec_object:
		/* here we are sure we are dealing with an object */
		zobj = C_OBJ_P(object);
		if (IS_CV == IS_CONST) {
			name = C_STR_P(property);
		} else {
			name = zval_try_get_tmp_string(property, &tmp_name);
			if (UNEXPECTED(!name)) {
				ZVAL_UNDEF(EX_VAR(opline->result.var));
				break;
			}
		}
		cache_slot = (IS_CV == IS_CONST) ? CACHE_ADDR(opline->extended_value) : NULL;
		if (EXPECTED((zptr = zobj->handlers->get_property_ptr_ptr(zobj, name, BP_VAR_RW, cache_slot)) != NULL)) {
			if (UNEXPECTED(C_ISERROR_P(zptr))) {
				ZVAL_NULL(EX_VAR(opline->result.var));
			} else {
				if (IS_CV == IS_CONST) {
					prop_info = (crex_property_info*)CACHED_PTR_EX(cache_slot + 2);
				} else {
					prop_info = crex_object_fetch_property_type_info(C_OBJ_P(object), zptr);
				}

				crex_post_incdec_property_zval(zptr, prop_info OPLINE_CC EXECUTE_DATA_CC);
			}
		} else {
			crex_post_incdec_overloaded_property(zobj, name, cache_slot OPLINE_CC EXECUTE_DATA_CC);
		}
		if (IS_CV != IS_CONST) {
			crex_tmp_string_release(tmp_name);
		}
	} while (0);


	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FETCH_OBJ_R_SPEC_UNUSED_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;
	void **cache_slot = NULL;

	SAVE_OPLINE();
	container = &EX(This);

	if (IS_UNUSED == IS_CONST ||
	    (IS_UNUSED != IS_UNUSED && UNEXPECTED(C_TYPE_P(container) != IS_OBJECT))) {
		do {
			if ((IS_UNUSED & (IS_VAR|IS_CV)) && C_ISREF_P(container)) {
				container = C_REFVAL_P(container);
				if (EXPECTED(C_TYPE_P(container) == IS_OBJECT)) {
					break;
				}
			}
			if (IS_UNUSED == IS_CV && UNEXPECTED(C_TYPE_P(container) == IS_UNDEF)) {
				ZVAL_UNDEFINED_OP1();
			}
			crex_wrong_property_read(container, _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC));
			ZVAL_NULL(EX_VAR(opline->result.var));
			goto fetch_obj_r_finish;
		} while (0);
	}

	/* here we are sure we are dealing with an object */
	do {
		crex_object *zobj = C_OBJ_P(container);
		crex_string *name, *tmp_name;
		zval *retval;

		if (IS_CV == IS_CONST) {
			cache_slot = CACHE_ADDR(opline->extended_value & ~CREX_FETCH_REF /* FUNC_ARG fetch may contain it */);

			if (EXPECTED(zobj->ce == CACHED_PTR_EX(cache_slot))) {
				uintptr_t prop_offset = (uintptr_t)CACHED_PTR_EX(cache_slot + 1);

				if (EXPECTED(IS_VALID_PROPERTY_OFFSET(prop_offset))) {
					retval = OBJ_PROP(zobj, prop_offset);
					if (EXPECTED(C_TYPE_INFO_P(retval) != IS_UNDEF)) {
						if (0 || (IS_UNUSED & (IS_TMP_VAR|IS_VAR)) != 0) {
							goto fetch_obj_r_copy;
						} else {
fetch_obj_r_fast_copy:
							ZVAL_COPY_DEREF(EX_VAR(opline->result.var), retval);
							CREX_VM_NEXT_OPCODE();
						}
					}
				} else if (EXPECTED(zobj->properties != NULL)) {
					name = C_STR_P(_get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC));
					if (!IS_UNKNOWN_DYNAMIC_PROPERTY_OFFSET(prop_offset)) {
						uintptr_t idx = CREX_DECODE_DYN_PROP_OFFSET(prop_offset);

						if (EXPECTED(idx < zobj->properties->nNumUsed * sizeof(Bucket))) {
							Bucket *p = (Bucket*)((char*)zobj->properties->arData + idx);

							if (EXPECTED(p->key == name) ||
							    (EXPECTED(p->h == ZSTR_H(name)) &&
							     EXPECTED(p->key != NULL) &&
							     EXPECTED(crex_string_equal_content(p->key, name)))) {
								retval = &p->val;
								if (0 || (IS_UNUSED & (IS_TMP_VAR|IS_VAR)) != 0) {
									goto fetch_obj_r_copy;
								} else {
									goto fetch_obj_r_fast_copy;
								}
							}
						}
						CACHE_PTR_EX(cache_slot + 1, (void*)CREX_DYNAMIC_PROPERTY_OFFSET);
					}
					retval = crex_hash_find_known_hash(zobj->properties, name);
					if (EXPECTED(retval)) {
						uintptr_t idx = (char*)retval - (char*)zobj->properties->arData;
						CACHE_PTR_EX(cache_slot + 1, (void*)CREX_ENCODE_DYN_PROP_OFFSET(idx));
						if (0 || (IS_UNUSED & (IS_TMP_VAR|IS_VAR)) != 0) {
							goto fetch_obj_r_copy;
						} else {
							goto fetch_obj_r_fast_copy;
						}
					}
				}
			}
			name = C_STR_P(_get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC));
		} else {
			name = zval_try_get_tmp_string(_get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC), &tmp_name);
			if (UNEXPECTED(!name)) {
				ZVAL_UNDEF(EX_VAR(opline->result.var));
				break;
			}
		}

#if CREX_DEBUG
		/* For non-standard object handlers, verify a declared property type in debug builds.
		 * Fetch prop_info before calling read_property(), as it may deallocate the object. */
		crex_property_info *prop_info = NULL;
		if (zobj->handlers->read_property != crex_std_read_property) {
			prop_info = crex_get_property_info(zobj->ce, name, /* silent */ true);
		}
#endif
		retval = zobj->handlers->read_property(zobj, name, BP_VAR_R, cache_slot, EX_VAR(opline->result.var));
#if CREX_DEBUG
		if (!EG(exception) && prop_info && prop_info != CREX_WRONG_PROPERTY_INFO
				&& CREX_TYPE_IS_SET(prop_info->type)) {
			ZVAL_OPT_DEREF(retval);
			crex_verify_property_type(prop_info, retval, /* strict */ true);
		}
#endif

		if (IS_CV != IS_CONST) {
			crex_tmp_string_release(tmp_name);
		}

		if (retval != EX_VAR(opline->result.var)) {
fetch_obj_r_copy:
			ZVAL_COPY_DEREF(EX_VAR(opline->result.var), retval);
		} else if (UNEXPECTED(C_ISREF_P(retval))) {
			crex_unwrap_reference(retval);
		}
	} while (0);

fetch_obj_r_finish:


	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FETCH_OBJ_W_SPEC_UNUSED_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *property, *container, *result;

	SAVE_OPLINE();

	container = &EX(This);
	property = _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC);
	result = EX_VAR(opline->result.var);
	crex_fetch_property_address(
		result, container, IS_UNUSED, property, IS_CV,
		((IS_CV == IS_CONST) ? CACHE_ADDR(opline->extended_value & ~CREX_FETCH_OBJ_FLAGS) : NULL),
		BP_VAR_W, opline->extended_value OPLINE_CC EXECUTE_DATA_CC);

	if (IS_UNUSED == IS_VAR) {
		FREE_VAR_PTR_AND_EXTRACT_RESULT_IF_NECESSARY(opline->op1.var);
	}
	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FETCH_OBJ_RW_SPEC_UNUSED_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *property, *container, *result;

	SAVE_OPLINE();
	container = &EX(This);
	property = _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC);
	result = EX_VAR(opline->result.var);
	crex_fetch_property_address(result, container, IS_UNUSED, property, IS_CV, ((IS_CV == IS_CONST) ? CACHE_ADDR(opline->extended_value) : NULL), BP_VAR_RW, 0 OPLINE_CC EXECUTE_DATA_CC);

	if (IS_UNUSED == IS_VAR) {
		FREE_VAR_PTR_AND_EXTRACT_RESULT_IF_NECESSARY(opline->op1.var);
	}
	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FETCH_OBJ_IS_SPEC_UNUSED_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;
	void **cache_slot = NULL;

	SAVE_OPLINE();
	container = &EX(This);

	if (IS_UNUSED == IS_CONST ||
	    (IS_UNUSED != IS_UNUSED && UNEXPECTED(C_TYPE_P(container) != IS_OBJECT))) {
		do {
			if ((IS_UNUSED & (IS_VAR|IS_CV)) && C_ISREF_P(container)) {
				container = C_REFVAL_P(container);
				if (EXPECTED(C_TYPE_P(container) == IS_OBJECT)) {
					break;
				}
			}
			if (IS_CV == IS_CV && C_TYPE_P(EX_VAR(opline->op2.var)) == IS_UNDEF) {
				ZVAL_UNDEFINED_OP2();
			}
			ZVAL_NULL(EX_VAR(opline->result.var));
			goto fetch_obj_is_finish;
		} while (0);
	}

	/* here we are sure we are dealing with an object */
	do {
		crex_object *zobj = C_OBJ_P(container);
		crex_string *name, *tmp_name;
		zval *retval;

		if (IS_CV == IS_CONST) {
			cache_slot = CACHE_ADDR(opline->extended_value);

			if (EXPECTED(zobj->ce == CACHED_PTR_EX(cache_slot))) {
				uintptr_t prop_offset = (uintptr_t)CACHED_PTR_EX(cache_slot + 1);

				if (EXPECTED(IS_VALID_PROPERTY_OFFSET(prop_offset))) {
					retval = OBJ_PROP(zobj, prop_offset);
					if (EXPECTED(C_TYPE_P(retval) != IS_UNDEF)) {
						if (0 || (IS_UNUSED & (IS_TMP_VAR|IS_VAR)) != 0) {
							goto fetch_obj_is_copy;
						} else {
fetch_obj_is_fast_copy:
							ZVAL_COPY_DEREF(EX_VAR(opline->result.var), retval);
							CREX_VM_NEXT_OPCODE();
						}
					}
				} else if (EXPECTED(zobj->properties != NULL)) {
					name = C_STR_P(_get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC));
					if (!IS_UNKNOWN_DYNAMIC_PROPERTY_OFFSET(prop_offset)) {
						uintptr_t idx = CREX_DECODE_DYN_PROP_OFFSET(prop_offset);

						if (EXPECTED(idx < zobj->properties->nNumUsed * sizeof(Bucket))) {
							Bucket *p = (Bucket*)((char*)zobj->properties->arData + idx);

							if (EXPECTED(p->key == name) ||
							    (EXPECTED(p->h == ZSTR_H(name)) &&
							     EXPECTED(p->key != NULL) &&
							     EXPECTED(crex_string_equal_content(p->key, name)))) {
								retval = &p->val;
								if (0 || (IS_UNUSED & (IS_TMP_VAR|IS_VAR)) != 0) {
									goto fetch_obj_is_copy;
								} else {
									goto fetch_obj_is_fast_copy;
								}
							}
						}
						CACHE_PTR_EX(cache_slot + 1, (void*)CREX_DYNAMIC_PROPERTY_OFFSET);
					}
					retval = crex_hash_find_known_hash(zobj->properties, name);
					if (EXPECTED(retval)) {
						uintptr_t idx = (char*)retval - (char*)zobj->properties->arData;
						CACHE_PTR_EX(cache_slot + 1, (void*)CREX_ENCODE_DYN_PROP_OFFSET(idx));
						if (0 || (IS_UNUSED & (IS_TMP_VAR|IS_VAR)) != 0) {
							goto fetch_obj_is_copy;
						} else {
							goto fetch_obj_is_fast_copy;
						}
					}
				}
			}
			name = C_STR_P(_get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC));
		} else {
			name = zval_try_get_tmp_string(_get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC), &tmp_name);
			if (UNEXPECTED(!name)) {
				ZVAL_UNDEF(EX_VAR(opline->result.var));
				break;
			}
		}

		retval = zobj->handlers->read_property(zobj, name, BP_VAR_IS, cache_slot, EX_VAR(opline->result.var));

		if (IS_CV != IS_CONST) {
			crex_tmp_string_release(tmp_name);
		}

		if (retval != EX_VAR(opline->result.var)) {
fetch_obj_is_copy:
			ZVAL_COPY_DEREF(EX_VAR(opline->result.var), retval);
		} else if (UNEXPECTED(C_ISREF_P(retval))) {
			crex_unwrap_reference(retval);
		}
	} while (0);

fetch_obj_is_finish:


	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FETCH_OBJ_FUNC_ARG_SPEC_UNUSED_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
#if 0
	USE_OPLINE
#endif

	if (UNEXPECTED(CREX_CALL_INFO(EX(call)) & CREX_CALL_SEND_ARG_BY_REF)) {
		/* Behave like FETCH_OBJ_W */
		if ((IS_UNUSED & (IS_CONST|IS_TMP_VAR))) {
			CREX_VM_TAIL_CALL(crex_use_tmp_in_write_context_helper_SPEC(CREX_OPCODE_HANDLER_ARGS_PASSTHRU));
		}
		CREX_VM_TAIL_CALL(CREX_FETCH_OBJ_W_SPEC_UNUSED_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU));
	} else {
		CREX_VM_TAIL_CALL(CREX_FETCH_OBJ_R_SPEC_UNUSED_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU));
	}
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FETCH_OBJ_UNSET_SPEC_UNUSED_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container, *property, *result;

	SAVE_OPLINE();
	container = &EX(This);
	property = _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC);
	result = EX_VAR(opline->result.var);
	crex_fetch_property_address(result, container, IS_UNUSED, property, IS_CV, ((IS_CV == IS_CONST) ? CACHE_ADDR(opline->extended_value) : NULL), BP_VAR_UNSET, 0 OPLINE_CC EXECUTE_DATA_CC);

	if (IS_UNUSED == IS_VAR) {
		FREE_VAR_PTR_AND_EXTRACT_RESULT_IF_NECESSARY(opline->op1.var);
	}
	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ASSIGN_OBJ_SPEC_UNUSED_CV_OP_DATA_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *object, *value, tmp;
	crex_object *zobj;
	crex_string *name, *tmp_name;
	crex_refcounted *garbage = NULL;

	SAVE_OPLINE();
	object = &EX(This);
	value = RT_CONSTANT((opline+1), (opline+1)->op1);

	if (IS_UNUSED != IS_UNUSED && UNEXPECTED(C_TYPE_P(object) != IS_OBJECT)) {
		if (C_ISREF_P(object) && C_TYPE_P(C_REFVAL_P(object)) == IS_OBJECT) {
			object = C_REFVAL_P(object);
			goto assign_object;
		}
		crex_throw_non_object_error(object, _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC) OPLINE_CC EXECUTE_DATA_CC);
		value = &EG(uninitialized_zval);
		goto free_and_exit_assign_obj;
	}

assign_object:
	zobj = C_OBJ_P(object);
	if (IS_CV == IS_CONST) {
		if (EXPECTED(zobj->ce == CACHED_PTR(opline->extended_value))) {
			void **cache_slot = CACHE_ADDR(opline->extended_value);
			uintptr_t prop_offset = (uintptr_t)CACHED_PTR_EX(cache_slot + 1);
			zval *property_val;

			if (EXPECTED(IS_VALID_PROPERTY_OFFSET(prop_offset))) {
				property_val = OBJ_PROP(zobj, prop_offset);
				if (C_TYPE_P(property_val) != IS_UNDEF) {
					crex_property_info *prop_info = (crex_property_info*) CACHED_PTR_EX(cache_slot + 2);

					if (UNEXPECTED(prop_info != NULL)) {
						value = crex_assign_to_typed_prop(prop_info, property_val, value, &garbage EXECUTE_DATA_CC);
						goto free_and_exit_assign_obj;
					} else {
fast_assign_obj:
						value = crex_assign_to_variable_ex(property_val, value, IS_CONST, EX_USES_STRICT_TYPES(), &garbage);
						if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
							ZVAL_COPY(EX_VAR(opline->result.var), value);
						}
						goto exit_assign_obj;
					}
				}
			} else {
				name = C_STR_P(_get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC));
				if (EXPECTED(zobj->properties != NULL)) {
					if (UNEXPECTED(GC_REFCOUNT(zobj->properties) > 1)) {
						if (EXPECTED(!(GC_FLAGS(zobj->properties) & IS_ARRAY_IMMUTABLE))) {
							GC_DELREF(zobj->properties);
						}
						zobj->properties = crex_array_dup(zobj->properties);
					}
					property_val = crex_hash_find_known_hash(zobj->properties, name);
					if (property_val) {
						goto fast_assign_obj;
					}
				}

				if (!zobj->ce->__set && (zobj->ce->ce_flags & CREX_ACC_ALLOW_DYNAMIC_PROPERTIES)) {
					if (EXPECTED(zobj->properties == NULL)) {
						rebuild_object_properties(zobj);
					}
					if (IS_CONST == IS_CONST) {
						if (UNEXPECTED(C_OPT_REFCOUNTED_P(value))) {
							C_ADDREF_P(value);
						}
					} else if (IS_CONST != IS_TMP_VAR) {
						if (C_ISREF_P(value)) {
							if (IS_CONST == IS_VAR) {
								crex_reference *ref = C_REF_P(value);
								if (GC_DELREF(ref) == 0) {
									ZVAL_COPY_VALUE(&tmp, C_REFVAL_P(value));
									efree_size(ref, sizeof(crex_reference));
									value = &tmp;
								} else {
									value = C_REFVAL_P(value);
									C_TRY_ADDREF_P(value);
								}
							} else {
								value = C_REFVAL_P(value);
								C_TRY_ADDREF_P(value);
							}
						} else if (IS_CONST == IS_CV) {
							C_TRY_ADDREF_P(value);
						}
						}
					crex_hash_add_new(zobj->properties, name, value);
					if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
						ZVAL_COPY(EX_VAR(opline->result.var), value);
					}
					goto exit_assign_obj;
				}
			}
		}
		name = C_STR_P(_get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC));
	} else {
		name = zval_try_get_tmp_string(_get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC), &tmp_name);
		if (UNEXPECTED(!name)) {

			UNDEF_RESULT();
			goto exit_assign_obj;
		}
	}

	if (IS_CONST == IS_CV || IS_CONST == IS_VAR) {
		ZVAL_DEREF(value);
	}

	value = zobj->handlers->write_property(zobj, name, value, (IS_CV == IS_CONST) ? CACHE_ADDR(opline->extended_value) : NULL);

	if (IS_CV != IS_CONST) {
		crex_tmp_string_release(tmp_name);
	}

free_and_exit_assign_obj:
	if (UNEXPECTED(RETURN_VALUE_USED(opline)) && value) {
		ZVAL_COPY_DEREF(EX_VAR(opline->result.var), value);
	}

exit_assign_obj:
	if (garbage) {
		GC_DTOR_NO_REF(garbage);
	}


	/* assign_obj has two opcodes! */
	CREX_VM_NEXT_OPCODE_EX(1, 2);
}

/* No specialization for op_types (CONST|TMPVAR|CV, UNUSED|CONST|VAR) */
static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ASSIGN_OBJ_SPEC_UNUSED_CV_OP_DATA_TMP_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *object, *value, tmp;
	crex_object *zobj;
	crex_string *name, *tmp_name;
	crex_refcounted *garbage = NULL;

	SAVE_OPLINE();
	object = &EX(This);
	value = _get_zval_ptr_tmp((opline+1)->op1.var EXECUTE_DATA_CC);

	if (IS_UNUSED != IS_UNUSED && UNEXPECTED(C_TYPE_P(object) != IS_OBJECT)) {
		if (C_ISREF_P(object) && C_TYPE_P(C_REFVAL_P(object)) == IS_OBJECT) {
			object = C_REFVAL_P(object);
			goto assign_object;
		}
		crex_throw_non_object_error(object, _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC) OPLINE_CC EXECUTE_DATA_CC);
		value = &EG(uninitialized_zval);
		goto free_and_exit_assign_obj;
	}

assign_object:
	zobj = C_OBJ_P(object);
	if (IS_CV == IS_CONST) {
		if (EXPECTED(zobj->ce == CACHED_PTR(opline->extended_value))) {
			void **cache_slot = CACHE_ADDR(opline->extended_value);
			uintptr_t prop_offset = (uintptr_t)CACHED_PTR_EX(cache_slot + 1);
			zval *property_val;

			if (EXPECTED(IS_VALID_PROPERTY_OFFSET(prop_offset))) {
				property_val = OBJ_PROP(zobj, prop_offset);
				if (C_TYPE_P(property_val) != IS_UNDEF) {
					crex_property_info *prop_info = (crex_property_info*) CACHED_PTR_EX(cache_slot + 2);

					if (UNEXPECTED(prop_info != NULL)) {
						value = crex_assign_to_typed_prop(prop_info, property_val, value, &garbage EXECUTE_DATA_CC);
						goto free_and_exit_assign_obj;
					} else {
fast_assign_obj:
						value = crex_assign_to_variable_ex(property_val, value, IS_TMP_VAR, EX_USES_STRICT_TYPES(), &garbage);
						if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
							ZVAL_COPY(EX_VAR(opline->result.var), value);
						}
						goto exit_assign_obj;
					}
				}
			} else {
				name = C_STR_P(_get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC));
				if (EXPECTED(zobj->properties != NULL)) {
					if (UNEXPECTED(GC_REFCOUNT(zobj->properties) > 1)) {
						if (EXPECTED(!(GC_FLAGS(zobj->properties) & IS_ARRAY_IMMUTABLE))) {
							GC_DELREF(zobj->properties);
						}
						zobj->properties = crex_array_dup(zobj->properties);
					}
					property_val = crex_hash_find_known_hash(zobj->properties, name);
					if (property_val) {
						goto fast_assign_obj;
					}
				}

				if (!zobj->ce->__set && (zobj->ce->ce_flags & CREX_ACC_ALLOW_DYNAMIC_PROPERTIES)) {
					if (EXPECTED(zobj->properties == NULL)) {
						rebuild_object_properties(zobj);
					}
					if (IS_TMP_VAR == IS_CONST) {
						if (UNEXPECTED(C_OPT_REFCOUNTED_P(value))) {
							C_ADDREF_P(value);
						}
					} else if (IS_TMP_VAR != IS_TMP_VAR) {
						if (C_ISREF_P(value)) {
							if (IS_TMP_VAR == IS_VAR) {
								crex_reference *ref = C_REF_P(value);
								if (GC_DELREF(ref) == 0) {
									ZVAL_COPY_VALUE(&tmp, C_REFVAL_P(value));
									efree_size(ref, sizeof(crex_reference));
									value = &tmp;
								} else {
									value = C_REFVAL_P(value);
									C_TRY_ADDREF_P(value);
								}
							} else {
								value = C_REFVAL_P(value);
								C_TRY_ADDREF_P(value);
							}
						} else if (IS_TMP_VAR == IS_CV) {
							C_TRY_ADDREF_P(value);
						}
						}
					crex_hash_add_new(zobj->properties, name, value);
					if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
						ZVAL_COPY(EX_VAR(opline->result.var), value);
					}
					goto exit_assign_obj;
				}
			}
		}
		name = C_STR_P(_get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC));
	} else {
		name = zval_try_get_tmp_string(_get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC), &tmp_name);
		if (UNEXPECTED(!name)) {
			zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
			UNDEF_RESULT();
			goto exit_assign_obj;
		}
	}

	if (IS_TMP_VAR == IS_CV || IS_TMP_VAR == IS_VAR) {
		ZVAL_DEREF(value);
	}

	value = zobj->handlers->write_property(zobj, name, value, (IS_CV == IS_CONST) ? CACHE_ADDR(opline->extended_value) : NULL);

	if (IS_CV != IS_CONST) {
		crex_tmp_string_release(tmp_name);
	}

free_and_exit_assign_obj:
	if (UNEXPECTED(RETURN_VALUE_USED(opline)) && value) {
		ZVAL_COPY_DEREF(EX_VAR(opline->result.var), value);
	}
	zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
exit_assign_obj:
	if (garbage) {
		GC_DTOR_NO_REF(garbage);
	}


	/* assign_obj has two opcodes! */
	CREX_VM_NEXT_OPCODE_EX(1, 2);
}

/* No specialization for op_types (CONST|TMPVAR|CV, UNUSED|CONST|VAR) */
static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ASSIGN_OBJ_SPEC_UNUSED_CV_OP_DATA_VAR_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *object, *value, tmp;
	crex_object *zobj;
	crex_string *name, *tmp_name;
	crex_refcounted *garbage = NULL;

	SAVE_OPLINE();
	object = &EX(This);
	value = _get_zval_ptr_var((opline+1)->op1.var EXECUTE_DATA_CC);

	if (IS_UNUSED != IS_UNUSED && UNEXPECTED(C_TYPE_P(object) != IS_OBJECT)) {
		if (C_ISREF_P(object) && C_TYPE_P(C_REFVAL_P(object)) == IS_OBJECT) {
			object = C_REFVAL_P(object);
			goto assign_object;
		}
		crex_throw_non_object_error(object, _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC) OPLINE_CC EXECUTE_DATA_CC);
		value = &EG(uninitialized_zval);
		goto free_and_exit_assign_obj;
	}

assign_object:
	zobj = C_OBJ_P(object);
	if (IS_CV == IS_CONST) {
		if (EXPECTED(zobj->ce == CACHED_PTR(opline->extended_value))) {
			void **cache_slot = CACHE_ADDR(opline->extended_value);
			uintptr_t prop_offset = (uintptr_t)CACHED_PTR_EX(cache_slot + 1);
			zval *property_val;

			if (EXPECTED(IS_VALID_PROPERTY_OFFSET(prop_offset))) {
				property_val = OBJ_PROP(zobj, prop_offset);
				if (C_TYPE_P(property_val) != IS_UNDEF) {
					crex_property_info *prop_info = (crex_property_info*) CACHED_PTR_EX(cache_slot + 2);

					if (UNEXPECTED(prop_info != NULL)) {
						value = crex_assign_to_typed_prop(prop_info, property_val, value, &garbage EXECUTE_DATA_CC);
						goto free_and_exit_assign_obj;
					} else {
fast_assign_obj:
						value = crex_assign_to_variable_ex(property_val, value, IS_VAR, EX_USES_STRICT_TYPES(), &garbage);
						if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
							ZVAL_COPY(EX_VAR(opline->result.var), value);
						}
						goto exit_assign_obj;
					}
				}
			} else {
				name = C_STR_P(_get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC));
				if (EXPECTED(zobj->properties != NULL)) {
					if (UNEXPECTED(GC_REFCOUNT(zobj->properties) > 1)) {
						if (EXPECTED(!(GC_FLAGS(zobj->properties) & IS_ARRAY_IMMUTABLE))) {
							GC_DELREF(zobj->properties);
						}
						zobj->properties = crex_array_dup(zobj->properties);
					}
					property_val = crex_hash_find_known_hash(zobj->properties, name);
					if (property_val) {
						goto fast_assign_obj;
					}
				}

				if (!zobj->ce->__set && (zobj->ce->ce_flags & CREX_ACC_ALLOW_DYNAMIC_PROPERTIES)) {
					if (EXPECTED(zobj->properties == NULL)) {
						rebuild_object_properties(zobj);
					}
					if (IS_VAR == IS_CONST) {
						if (UNEXPECTED(C_OPT_REFCOUNTED_P(value))) {
							C_ADDREF_P(value);
						}
					} else if (IS_VAR != IS_TMP_VAR) {
						if (C_ISREF_P(value)) {
							if (IS_VAR == IS_VAR) {
								crex_reference *ref = C_REF_P(value);
								if (GC_DELREF(ref) == 0) {
									ZVAL_COPY_VALUE(&tmp, C_REFVAL_P(value));
									efree_size(ref, sizeof(crex_reference));
									value = &tmp;
								} else {
									value = C_REFVAL_P(value);
									C_TRY_ADDREF_P(value);
								}
							} else {
								value = C_REFVAL_P(value);
								C_TRY_ADDREF_P(value);
							}
						} else if (IS_VAR == IS_CV) {
							C_TRY_ADDREF_P(value);
						}
						}
					crex_hash_add_new(zobj->properties, name, value);
					if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
						ZVAL_COPY(EX_VAR(opline->result.var), value);
					}
					goto exit_assign_obj;
				}
			}
		}
		name = C_STR_P(_get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC));
	} else {
		name = zval_try_get_tmp_string(_get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC), &tmp_name);
		if (UNEXPECTED(!name)) {
			zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
			UNDEF_RESULT();
			goto exit_assign_obj;
		}
	}

	if (IS_VAR == IS_CV || IS_VAR == IS_VAR) {
		ZVAL_DEREF(value);
	}

	value = zobj->handlers->write_property(zobj, name, value, (IS_CV == IS_CONST) ? CACHE_ADDR(opline->extended_value) : NULL);

	if (IS_CV != IS_CONST) {
		crex_tmp_string_release(tmp_name);
	}

free_and_exit_assign_obj:
	if (UNEXPECTED(RETURN_VALUE_USED(opline)) && value) {
		ZVAL_COPY_DEREF(EX_VAR(opline->result.var), value);
	}
	zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
exit_assign_obj:
	if (garbage) {
		GC_DTOR_NO_REF(garbage);
	}


	/* assign_obj has two opcodes! */
	CREX_VM_NEXT_OPCODE_EX(1, 2);
}

/* No specialization for op_types (CONST|TMPVAR|CV, UNUSED|CONST|VAR) */
static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ASSIGN_OBJ_SPEC_UNUSED_CV_OP_DATA_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *object, *value, tmp;
	crex_object *zobj;
	crex_string *name, *tmp_name;
	crex_refcounted *garbage = NULL;

	SAVE_OPLINE();
	object = &EX(This);
	value = _get_zval_ptr_cv_BP_VAR_R((opline+1)->op1.var EXECUTE_DATA_CC);

	if (IS_UNUSED != IS_UNUSED && UNEXPECTED(C_TYPE_P(object) != IS_OBJECT)) {
		if (C_ISREF_P(object) && C_TYPE_P(C_REFVAL_P(object)) == IS_OBJECT) {
			object = C_REFVAL_P(object);
			goto assign_object;
		}
		crex_throw_non_object_error(object, _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC) OPLINE_CC EXECUTE_DATA_CC);
		value = &EG(uninitialized_zval);
		goto free_and_exit_assign_obj;
	}

assign_object:
	zobj = C_OBJ_P(object);
	if (IS_CV == IS_CONST) {
		if (EXPECTED(zobj->ce == CACHED_PTR(opline->extended_value))) {
			void **cache_slot = CACHE_ADDR(opline->extended_value);
			uintptr_t prop_offset = (uintptr_t)CACHED_PTR_EX(cache_slot + 1);
			zval *property_val;

			if (EXPECTED(IS_VALID_PROPERTY_OFFSET(prop_offset))) {
				property_val = OBJ_PROP(zobj, prop_offset);
				if (C_TYPE_P(property_val) != IS_UNDEF) {
					crex_property_info *prop_info = (crex_property_info*) CACHED_PTR_EX(cache_slot + 2);

					if (UNEXPECTED(prop_info != NULL)) {
						value = crex_assign_to_typed_prop(prop_info, property_val, value, &garbage EXECUTE_DATA_CC);
						goto free_and_exit_assign_obj;
					} else {
fast_assign_obj:
						value = crex_assign_to_variable_ex(property_val, value, IS_CV, EX_USES_STRICT_TYPES(), &garbage);
						if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
							ZVAL_COPY(EX_VAR(opline->result.var), value);
						}
						goto exit_assign_obj;
					}
				}
			} else {
				name = C_STR_P(_get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC));
				if (EXPECTED(zobj->properties != NULL)) {
					if (UNEXPECTED(GC_REFCOUNT(zobj->properties) > 1)) {
						if (EXPECTED(!(GC_FLAGS(zobj->properties) & IS_ARRAY_IMMUTABLE))) {
							GC_DELREF(zobj->properties);
						}
						zobj->properties = crex_array_dup(zobj->properties);
					}
					property_val = crex_hash_find_known_hash(zobj->properties, name);
					if (property_val) {
						goto fast_assign_obj;
					}
				}

				if (!zobj->ce->__set && (zobj->ce->ce_flags & CREX_ACC_ALLOW_DYNAMIC_PROPERTIES)) {
					if (EXPECTED(zobj->properties == NULL)) {
						rebuild_object_properties(zobj);
					}
					if (IS_CV == IS_CONST) {
						if (UNEXPECTED(C_OPT_REFCOUNTED_P(value))) {
							C_ADDREF_P(value);
						}
					} else if (IS_CV != IS_TMP_VAR) {
						if (C_ISREF_P(value)) {
							if (IS_CV == IS_VAR) {
								crex_reference *ref = C_REF_P(value);
								if (GC_DELREF(ref) == 0) {
									ZVAL_COPY_VALUE(&tmp, C_REFVAL_P(value));
									efree_size(ref, sizeof(crex_reference));
									value = &tmp;
								} else {
									value = C_REFVAL_P(value);
									C_TRY_ADDREF_P(value);
								}
							} else {
								value = C_REFVAL_P(value);
								C_TRY_ADDREF_P(value);
							}
						} else if (IS_CV == IS_CV) {
							C_TRY_ADDREF_P(value);
						}
						}
					crex_hash_add_new(zobj->properties, name, value);
					if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
						ZVAL_COPY(EX_VAR(opline->result.var), value);
					}
					goto exit_assign_obj;
				}
			}
		}
		name = C_STR_P(_get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC));
	} else {
		name = zval_try_get_tmp_string(_get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC), &tmp_name);
		if (UNEXPECTED(!name)) {

			UNDEF_RESULT();
			goto exit_assign_obj;
		}
	}

	if (IS_CV == IS_CV || IS_CV == IS_VAR) {
		ZVAL_DEREF(value);
	}

	value = zobj->handlers->write_property(zobj, name, value, (IS_CV == IS_CONST) ? CACHE_ADDR(opline->extended_value) : NULL);

	if (IS_CV != IS_CONST) {
		crex_tmp_string_release(tmp_name);
	}

free_and_exit_assign_obj:
	if (UNEXPECTED(RETURN_VALUE_USED(opline)) && value) {
		ZVAL_COPY_DEREF(EX_VAR(opline->result.var), value);
	}

exit_assign_obj:
	if (garbage) {
		GC_DTOR_NO_REF(garbage);
	}


	/* assign_obj has two opcodes! */
	CREX_VM_NEXT_OPCODE_EX(1, 2);
}

/* No specialization for op_types (CONST|TMPVAR|CV, UNUSED|CONST|VAR) */
static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ASSIGN_OBJ_REF_SPEC_UNUSED_CV_OP_DATA_VAR_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *property, *container, *value_ptr;

	SAVE_OPLINE();

	container = &EX(This);
	property = _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC);

	value_ptr = _get_zval_ptr_ptr_var((opline+1)->op1.var EXECUTE_DATA_CC);

	if (1) {
		if (IS_UNUSED == IS_UNUSED) {
			if (IS_CV == IS_CONST) {
				crex_assign_to_property_reference_this_const(container, property, value_ptr OPLINE_CC EXECUTE_DATA_CC);
			} else {
				crex_assign_to_property_reference_this_var(container, property, value_ptr OPLINE_CC EXECUTE_DATA_CC);
			}
		} else {
			if (IS_CV == IS_CONST) {
				crex_assign_to_property_reference_var_const(container, property, value_ptr OPLINE_CC EXECUTE_DATA_CC);
			} else {
				crex_assign_to_property_reference_var_var(container, property, value_ptr OPLINE_CC EXECUTE_DATA_CC);
			}
		}
	} else {
		crex_assign_to_property_reference(container, IS_UNUSED, property, IS_CV, value_ptr OPLINE_CC EXECUTE_DATA_CC);
	}


	zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
	CREX_VM_NEXT_OPCODE_EX(1, 2);
}

/* No specialization for op_types (CONST|TMPVAR|CV, UNUSED|CONST|VAR) */
static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ASSIGN_OBJ_REF_SPEC_UNUSED_CV_OP_DATA_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *property, *container, *value_ptr;

	SAVE_OPLINE();

	container = &EX(This);
	property = _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC);

	value_ptr = _get_zval_ptr_cv_BP_VAR_W((opline+1)->op1.var EXECUTE_DATA_CC);

	if (1) {
		if (IS_UNUSED == IS_UNUSED) {
			if (IS_CV == IS_CONST) {
				crex_assign_to_property_reference_this_const(container, property, value_ptr OPLINE_CC EXECUTE_DATA_CC);
			} else {
				crex_assign_to_property_reference_this_var(container, property, value_ptr OPLINE_CC EXECUTE_DATA_CC);
			}
		} else {
			if (IS_CV == IS_CONST) {
				crex_assign_to_property_reference_var_const(container, property, value_ptr OPLINE_CC EXECUTE_DATA_CC);
			} else {
				crex_assign_to_property_reference_var_var(container, property, value_ptr OPLINE_CC EXECUTE_DATA_CC);
			}
		}
	} else {
		crex_assign_to_property_reference(container, IS_UNUSED, property, IS_CV, value_ptr OPLINE_CC EXECUTE_DATA_CC);
	}



	CREX_VM_NEXT_OPCODE_EX(1, 2);
}

/* No specialization for op_types (CONST|TMPVAR|CV, UNUSED|CONST|VAR) */
static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ROPE_INIT_SPEC_UNUSED_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	crex_string **rope;
	zval *var;

	/* Compiler allocates the necessary number of zval slots to keep the rope */
	rope = (crex_string**)EX_VAR(opline->result.var);
	if (IS_CV == IS_CONST) {
		var = _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC);
		rope[0] = C_STR_P(var);
		if (UNEXPECTED(C_REFCOUNTED_P(var))) {
			C_ADDREF_P(var);
		}
	} else {
		var = EX_VAR(opline->op2.var);
		if (EXPECTED(C_TYPE_P(var) == IS_STRING)) {
			if (IS_CV == IS_CV) {
				rope[0] = crex_string_copy(C_STR_P(var));
			} else {
				rope[0] = C_STR_P(var);
			}
		} else {
			SAVE_OPLINE();
			if (IS_CV == IS_CV && UNEXPECTED(C_TYPE_P(var) == IS_UNDEF)) {
				ZVAL_UNDEFINED_OP2();
			}
			rope[0] = zval_get_string_func(var);

			CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
		}
	}
	CREX_VM_NEXT_OPCODE();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FETCH_CLASS_SPEC_UNUSED_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	zval *class_name;
	USE_OPLINE

	SAVE_OPLINE();
	if (IS_CV == IS_UNUSED) {
		C_CE_P(EX_VAR(opline->result.var)) = crex_fetch_class(NULL, opline->op1.num);
		CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
	} else if (IS_CV == IS_CONST) {
		crex_class_entry *ce = CACHED_PTR(opline->extended_value);

		if (UNEXPECTED(ce == NULL)) {
			class_name = EX_VAR(opline->op2.var);
			ce = crex_fetch_class_by_name(C_STR_P(class_name), C_STR_P(class_name + 1), opline->op1.num);
			CACHE_PTR(opline->extended_value, ce);
		}
		C_CE_P(EX_VAR(opline->result.var)) = ce;
	} else {
		class_name = EX_VAR(opline->op2.var);
try_class_name:
		if (C_TYPE_P(class_name) == IS_OBJECT) {
			C_CE_P(EX_VAR(opline->result.var)) = C_OBJCE_P(class_name);
		} else if (C_TYPE_P(class_name) == IS_STRING) {
			C_CE_P(EX_VAR(opline->result.var)) = crex_fetch_class(C_STR_P(class_name), opline->op1.num);
		} else if ((IS_CV & (IS_VAR|IS_CV)) && C_TYPE_P(class_name) == IS_REFERENCE) {
			class_name = C_REFVAL_P(class_name);
			goto try_class_name;
		} else {
			if (IS_CV == IS_CV && UNEXPECTED(C_TYPE_P(class_name) == IS_UNDEF)) {
				ZVAL_UNDEFINED_OP2();
				if (UNEXPECTED(EG(exception) != NULL)) {
					HANDLE_EXCEPTION();
				}
			}
			crex_throw_error(NULL, "Class name must be a valid object or a string");
		}
	}

	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_INIT_METHOD_CALL_SPEC_UNUSED_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *function_name;
	zval *object;
	crex_function *fbc;
	crex_class_entry *called_scope;
	crex_object *obj;
	crex_execute_data *call;
	uint32_t call_info;

	SAVE_OPLINE();

	object = &EX(This);

	if (IS_CV != IS_CONST) {
		function_name = EX_VAR(opline->op2.var);
	}

	if (IS_CV != IS_CONST &&
	    UNEXPECTED(C_TYPE_P(function_name) != IS_STRING)) {
		do {
			if ((IS_CV & (IS_VAR|IS_CV)) && C_ISREF_P(function_name)) {
				function_name = C_REFVAL_P(function_name);
				if (EXPECTED(C_TYPE_P(function_name) == IS_STRING)) {
					break;
				}
			} else if (IS_CV == IS_CV && UNEXPECTED(C_TYPE_P(function_name) == IS_UNDEF)) {
				ZVAL_UNDEFINED_OP2();
				if (UNEXPECTED(EG(exception) != NULL)) {

					HANDLE_EXCEPTION();
				}
			}
			crex_throw_error(NULL, "Method name must be a string");


			HANDLE_EXCEPTION();
		} while (0);
	}

	if (IS_UNUSED == IS_UNUSED) {
		obj = C_OBJ_P(object);
	} else {
		do {
			if (IS_UNUSED != IS_CONST && EXPECTED(C_TYPE_P(object) == IS_OBJECT)) {
				obj = C_OBJ_P(object);
			} else {
				if ((IS_UNUSED & (IS_VAR|IS_CV)) && EXPECTED(C_ISREF_P(object))) {
					crex_reference *ref = C_REF_P(object);

					object = &ref->val;
					if (EXPECTED(C_TYPE_P(object) == IS_OBJECT)) {
						obj = C_OBJ_P(object);
						if (IS_UNUSED & IS_VAR) {
							if (UNEXPECTED(GC_DELREF(ref) == 0)) {
								efree_size(ref, sizeof(crex_reference));
							} else {
								C_ADDREF_P(object);
							}
						}
						break;
					}
				}
				if (IS_UNUSED == IS_CV && UNEXPECTED(C_TYPE_P(object) == IS_UNDEF)) {
					object = ZVAL_UNDEFINED_OP1();
					if (UNEXPECTED(EG(exception) != NULL)) {
						if (IS_CV != IS_CONST) {

						}
						HANDLE_EXCEPTION();
					}
				}
				if (IS_CV == IS_CONST) {
					function_name = EX_VAR(opline->op2.var);
				}
				crex_invalid_method_call(object, function_name);


				HANDLE_EXCEPTION();
			}
		} while (0);
	}

	called_scope = obj->ce;

	if (IS_CV == IS_CONST &&
	    EXPECTED(CACHED_PTR(opline->result.num) == called_scope)) {
		fbc = CACHED_PTR(opline->result.num + sizeof(void*));
	} else {
		crex_object *orig_obj = obj;

		if (IS_CV == IS_CONST) {
			function_name = EX_VAR(opline->op2.var);
		}

		/* First, locate the function. */
		fbc = obj->handlers->get_method(&obj, C_STR_P(function_name), ((IS_CV == IS_CONST) ? (RT_CONSTANT(opline, opline->op2) + 1) : NULL));
		if (UNEXPECTED(fbc == NULL)) {
			if (EXPECTED(!EG(exception))) {
				crex_undefined_method(obj->ce, C_STR_P(function_name));
			}

			if ((IS_UNUSED & (IS_VAR|IS_TMP_VAR)) && GC_DELREF(orig_obj) == 0) {
				crex_objects_store_del(orig_obj);
			}
			HANDLE_EXCEPTION();
		}
		if (IS_CV == IS_CONST &&
		    EXPECTED(!(fbc->common.fn_flags & (CREX_ACC_CALL_VIA_TRAMPOLINE|CREX_ACC_NEVER_CACHE))) &&
		    EXPECTED(obj == orig_obj)) {
			CACHE_POLYMORPHIC_PTR(opline->result.num, called_scope, fbc);
		}
		if ((IS_UNUSED & (IS_VAR|IS_TMP_VAR)) && UNEXPECTED(obj != orig_obj)) {
			GC_ADDREF(obj); /* For $this pointer */
			if (GC_DELREF(orig_obj) == 0) {
				crex_objects_store_del(orig_obj);
			}
		}
		if (EXPECTED(fbc->type == CREX_USER_FUNCTION) && UNEXPECTED(!RUN_TIME_CACHE(&fbc->op_array))) {
			init_func_run_time_cache(&fbc->op_array);
		}
	}

	if (IS_CV != IS_CONST) {

	}

	call_info = CREX_CALL_NESTED_FUNCTION | CREX_CALL_HAS_THIS;
	if (UNEXPECTED((fbc->common.fn_flags & CREX_ACC_STATIC) != 0)) {
		if ((IS_UNUSED & (IS_VAR|IS_TMP_VAR)) && GC_DELREF(obj) == 0) {
			crex_objects_store_del(obj);
			if (UNEXPECTED(EG(exception))) {
				HANDLE_EXCEPTION();
			}
		}
		/* call static method */
		obj = (crex_object*)called_scope;
		call_info = CREX_CALL_NESTED_FUNCTION;
	} else if (IS_UNUSED & (IS_VAR|IS_TMP_VAR|IS_CV)) {
		if (IS_UNUSED == IS_CV) {
			GC_ADDREF(obj); /* For $this pointer */
		}
		/* CV may be changed indirectly (e.g. when it's a reference) */
		call_info = CREX_CALL_NESTED_FUNCTION | CREX_CALL_HAS_THIS | CREX_CALL_RELEASE_THIS;
	}

	call = crex_vm_stack_push_call_frame(call_info,
		fbc, opline->extended_value, obj);
	call->prev_execute_data = EX(call);
	EX(call) = call;

	CREX_VM_NEXT_OPCODE();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_INIT_STATIC_METHOD_CALL_SPEC_UNUSED_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *function_name;
	crex_class_entry *ce;
	uint32_t call_info;
	crex_function *fbc;
	crex_execute_data *call;

	SAVE_OPLINE();

	if (IS_UNUSED == IS_CONST) {
		/* no function found. try a static method in class */
		ce = CACHED_PTR(opline->result.num);
		if (UNEXPECTED(ce == NULL)) {
			ce = crex_fetch_class_by_name(C_STR_P(RT_CONSTANT(opline, opline->op1)), C_STR_P(RT_CONSTANT(opline, opline->op1) + 1), CREX_FETCH_CLASS_DEFAULT | CREX_FETCH_CLASS_EXCEPTION);
			if (UNEXPECTED(ce == NULL)) {

				HANDLE_EXCEPTION();
			}
			if (IS_CV != IS_CONST) {
				CACHE_PTR(opline->result.num, ce);
			}
		}
	} else if (IS_UNUSED == IS_UNUSED) {
		ce = crex_fetch_class(NULL, opline->op1.num);
		if (UNEXPECTED(ce == NULL)) {

			HANDLE_EXCEPTION();
		}
	} else {
		ce = C_CE_P(EX_VAR(opline->op1.var));
	}

	if (IS_UNUSED == IS_CONST &&
	    IS_CV == IS_CONST &&
	    EXPECTED((fbc = CACHED_PTR(opline->result.num + sizeof(void*))) != NULL)) {
		/* nothing to do */
	} else if (IS_UNUSED != IS_CONST &&
	           IS_CV == IS_CONST &&
	           EXPECTED(CACHED_PTR(opline->result.num) == ce)) {
		fbc = CACHED_PTR(opline->result.num + sizeof(void*));
	} else if (IS_CV != IS_UNUSED) {
		function_name = EX_VAR(opline->op2.var);
		if (IS_CV != IS_CONST) {
			if (UNEXPECTED(C_TYPE_P(function_name) != IS_STRING)) {
				do {
					if (IS_CV & (IS_VAR|IS_CV) && C_ISREF_P(function_name)) {
						function_name = C_REFVAL_P(function_name);
						if (EXPECTED(C_TYPE_P(function_name) == IS_STRING)) {
							break;
						}
					} else if (IS_CV == IS_CV && UNEXPECTED(C_TYPE_P(function_name) == IS_UNDEF)) {
						ZVAL_UNDEFINED_OP2();
						if (UNEXPECTED(EG(exception) != NULL)) {
							HANDLE_EXCEPTION();
						}
					}
					crex_throw_error(NULL, "Method name must be a string");

					HANDLE_EXCEPTION();
				} while (0);
			}
		}

		if (ce->get_static_method) {
			fbc = ce->get_static_method(ce, C_STR_P(function_name));
		} else {
			fbc = crex_std_get_static_method(ce, C_STR_P(function_name), ((IS_CV == IS_CONST) ? (RT_CONSTANT(opline, opline->op2) + 1) : NULL));
		}
		if (UNEXPECTED(fbc == NULL)) {
			if (EXPECTED(!EG(exception))) {
				crex_undefined_method(ce, C_STR_P(function_name));
			}

			HANDLE_EXCEPTION();
		}
		if (IS_CV == IS_CONST &&
		    EXPECTED(!(fbc->common.fn_flags & (CREX_ACC_CALL_VIA_TRAMPOLINE|CREX_ACC_NEVER_CACHE))) &&
			EXPECTED(!(fbc->common.scope->ce_flags & CREX_ACC_TRAIT))) {
			CACHE_POLYMORPHIC_PTR(opline->result.num, ce, fbc);
		}
		if (EXPECTED(fbc->type == CREX_USER_FUNCTION) && UNEXPECTED(!RUN_TIME_CACHE(&fbc->op_array))) {
			init_func_run_time_cache(&fbc->op_array);
		}
		if (IS_CV != IS_CONST) {

		}
	} else {
		if (UNEXPECTED(ce->constructor == NULL)) {
			crex_throw_error(NULL, "Cannot call constructor");
			HANDLE_EXCEPTION();
		}
		if (C_TYPE(EX(This)) == IS_OBJECT && C_OBJ(EX(This))->ce != ce->constructor->common.scope && (ce->constructor->common.fn_flags & CREX_ACC_PRIVATE)) {
			crex_throw_error(NULL, "Cannot call private %s::__main()", ZSTR_VAL(ce->name));
			HANDLE_EXCEPTION();
		}
		fbc = ce->constructor;
		if (EXPECTED(fbc->type == CREX_USER_FUNCTION) && UNEXPECTED(!RUN_TIME_CACHE(&fbc->op_array))) {
			init_func_run_time_cache(&fbc->op_array);
		}
	}

	if (!(fbc->common.fn_flags & CREX_ACC_STATIC)) {
		if (C_TYPE(EX(This)) == IS_OBJECT && instanceof_function(C_OBJCE(EX(This)), ce)) {
			ce = (crex_class_entry*)C_OBJ(EX(This));
			call_info = CREX_CALL_NESTED_FUNCTION | CREX_CALL_HAS_THIS;
		} else {
			crex_non_static_method_call(fbc);
			HANDLE_EXCEPTION();
		}
	} else {
		/* previous opcode is CREX_FETCH_CLASS */
		if (IS_UNUSED == IS_UNUSED
		 && ((opline->op1.num & CREX_FETCH_CLASS_MASK) == CREX_FETCH_CLASS_PARENT ||
		     (opline->op1.num & CREX_FETCH_CLASS_MASK) == CREX_FETCH_CLASS_SELF)) {
			if (C_TYPE(EX(This)) == IS_OBJECT) {
				ce = C_OBJCE(EX(This));
			} else {
				ce = C_CE(EX(This));
			}
		}
		call_info = CREX_CALL_NESTED_FUNCTION;
	}

	call = crex_vm_stack_push_call_frame(call_info,
		fbc, opline->extended_value, ce);
	call->prev_execute_data = EX(call);
	EX(call) = call;

	CREX_VM_NEXT_OPCODE();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_INIT_ARRAY_SPEC_UNUSED_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	zval *array;
	uint32_t size;
	USE_OPLINE

	array = EX_VAR(opline->result.var);
	if (IS_UNUSED != IS_UNUSED) {
		size = opline->extended_value >> CREX_ARRAY_SIZE_SHIFT;
		ZVAL_ARR(array, crex_new_array(size));
		/* Explicitly initialize array as not-packed if flag is set */
		if (opline->extended_value & CREX_ARRAY_NOT_PACKED) {
			crex_hash_real_init_mixed(C_ARRVAL_P(array));
		}
		CREX_VM_TAIL_CALL(CREX_NULL_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU));
	} else {
		ZVAL_ARR(array, crex_new_array(0));
		CREX_VM_NEXT_OPCODE();
	}
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_UNSET_OBJ_SPEC_UNUSED_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;
	zval *offset;
	crex_string *name, *tmp_name;

	SAVE_OPLINE();
	container = &EX(This);
	offset = _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC);

	do {
		if (IS_UNUSED != IS_UNUSED && UNEXPECTED(C_TYPE_P(container) != IS_OBJECT)) {
			if (C_ISREF_P(container)) {
				container = C_REFVAL_P(container);
				if (C_TYPE_P(container) != IS_OBJECT) {
					if (IS_UNUSED == IS_CV
					 && UNEXPECTED(C_TYPE_P(container) == IS_UNDEF)) {
						ZVAL_UNDEFINED_OP1();
					}
					break;
				}
			} else {
				break;
			}
		}
		if (IS_CV == IS_CONST) {
			name = C_STR_P(offset);
		} else {
			name = zval_try_get_tmp_string(offset, &tmp_name);
			if (UNEXPECTED(!name)) {
				break;
			}
		}
		C_OBJ_HT_P(container)->unset_property(C_OBJ_P(container), name, ((IS_CV == IS_CONST) ? CACHE_ADDR(opline->extended_value) : NULL));
		if (IS_CV != IS_CONST) {
			crex_tmp_string_release(tmp_name);
		}
	} while (0);


	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ISSET_ISEMPTY_PROP_OBJ_SPEC_UNUSED_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;
	int result;
	zval *offset;
	crex_string *name, *tmp_name;

	SAVE_OPLINE();
	container = &EX(This);
	offset = _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC);

	if (IS_UNUSED == IS_CONST ||
	    (IS_UNUSED != IS_UNUSED && UNEXPECTED(C_TYPE_P(container) != IS_OBJECT))) {
		if ((IS_UNUSED & (IS_VAR|IS_CV)) && C_ISREF_P(container)) {
			container = C_REFVAL_P(container);
			if (UNEXPECTED(C_TYPE_P(container) != IS_OBJECT)) {
				result = (opline->extended_value & CREX_ISEMPTY);
				goto isset_object_finish;
			}
		} else {
			result = (opline->extended_value & CREX_ISEMPTY);
			goto isset_object_finish;
		}
	}

	if (IS_CV == IS_CONST) {
		name = C_STR_P(offset);
	} else {
		name = zval_try_get_tmp_string(offset, &tmp_name);
		if (UNEXPECTED(!name)) {
			result = 0;
			goto isset_object_finish;
		}
	}

	result =
		(opline->extended_value & CREX_ISEMPTY) ^
		C_OBJ_HT_P(container)->has_property(C_OBJ_P(container), name, (opline->extended_value & CREX_ISEMPTY), ((IS_CV == IS_CONST) ? CACHE_ADDR(opline->extended_value & ~CREX_ISEMPTY) : NULL));

	if (IS_CV != IS_CONST) {
		crex_tmp_string_release(tmp_name);
	}

isset_object_finish:


	CREX_VM_SMART_BRANCH(result, 1);
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_YIELD_SPEC_UNUSED_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	crex_generator *generator = crex_get_running_generator(EXECUTE_DATA_C);

	SAVE_OPLINE();
	if (UNEXPECTED(generator->flags & CREX_GENERATOR_FORCED_CLOSE)) {
		CREX_VM_TAIL_CALL(crex_yield_in_closed_generator_helper_SPEC(CREX_OPCODE_HANDLER_ARGS_PASSTHRU));
	}

	/* Destroy the previously yielded value */
	zval_ptr_dtor(&generator->value);

	/* Destroy the previously yielded key */
	zval_ptr_dtor(&generator->key);

	/* Set the new yielded value */
	if (IS_UNUSED != IS_UNUSED) {
		if (UNEXPECTED(EX(func)->op_array.fn_flags & CREX_ACC_RETURN_REFERENCE)) {
			/* Constants and temporary variables aren't yieldable by reference,
			 * but we still allow them with a notice. */
			if (IS_UNUSED & (IS_CONST|IS_TMP_VAR)) {
				zval *value;

				crex_error(E_NOTICE, "Only variable references should be yielded by reference");

				value = NULL;
				ZVAL_COPY_VALUE(&generator->value, value);
				if (IS_UNUSED == IS_CONST) {
					if (UNEXPECTED(C_OPT_REFCOUNTED(generator->value))) {
						C_ADDREF(generator->value);
					}
				}
			} else {
				zval *value_ptr = NULL;

				/* If a function call result is yielded and the function did
				 * not return by reference we throw a notice. */
				do {
					if (IS_UNUSED == IS_VAR) {
						CREX_ASSERT(value_ptr != &EG(uninitialized_zval));
						if (opline->extended_value == CREX_RETURNS_FUNCTION
						 && !C_ISREF_P(value_ptr)) {
							crex_error(E_NOTICE, "Only variable references should be yielded by reference");
							ZVAL_COPY(&generator->value, value_ptr);
							break;
						}
					}
					if (C_ISREF_P(value_ptr)) {
						C_ADDREF_P(value_ptr);
					} else {
						ZVAL_MAKE_REF_EX(value_ptr, 2);
					}
					ZVAL_REF(&generator->value, C_REF_P(value_ptr));
				} while (0);

			}
		} else {
			zval *value = NULL;

			/* Consts, temporary variables and references need copying */
			if (IS_UNUSED == IS_CONST) {
				ZVAL_COPY_VALUE(&generator->value, value);
				if (UNEXPECTED(C_OPT_REFCOUNTED(generator->value))) {
					C_ADDREF(generator->value);
				}
			} else if (IS_UNUSED == IS_TMP_VAR) {
				ZVAL_COPY_VALUE(&generator->value, value);
			} else if ((IS_UNUSED & (IS_VAR|IS_CV)) && C_ISREF_P(value)) {
				ZVAL_COPY(&generator->value, C_REFVAL_P(value));

			} else {
				ZVAL_COPY_VALUE(&generator->value, value);
				if (IS_UNUSED == IS_CV) {
					if (C_OPT_REFCOUNTED_P(value)) C_ADDREF_P(value);
				}
			}
		}
	} else {
		/* If no value was specified yield null */
		ZVAL_NULL(&generator->value);
	}

	/* Set the new yielded key */
	if (IS_CV != IS_UNUSED) {
		zval *key = _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC);
		if ((IS_CV & (IS_CV|IS_VAR)) && UNEXPECTED(C_TYPE_P(key) == IS_REFERENCE)) {
			key = C_REFVAL_P(key);
		}
		ZVAL_COPY(&generator->key, key);

		if (C_TYPE(generator->key) == IS_LONG
		    && C_LVAL(generator->key) > generator->largest_used_integer_key
		) {
			generator->largest_used_integer_key = C_LVAL(generator->key);
		}
	} else {
		/* If no key was specified we use auto-increment keys */
		generator->largest_used_integer_key++;
		ZVAL_LONG(&generator->key, generator->largest_used_integer_key);
	}

	if (RETURN_VALUE_USED(opline)) {
		/* If the return value of yield is used set the send
		 * target and initialize it to NULL */
		generator->send_target = EX_VAR(opline->result.var);
		ZVAL_NULL(generator->send_target);
	} else {
		generator->send_target = NULL;
	}

	/* We increment to the next op, so we are at the correct position when the
	 * generator is resumed. */
	CREX_VM_INC_OPCODE();

	/* The GOTO VM uses a local opline variable. We need to set the opline
	 * variable in execute_data so we don't resume at an old position. */
	SAVE_OPLINE();

	CREX_VM_RETURN();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_BOOL_NOT_SPEC_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *val;

	val = EX_VAR(opline->op1.var);
	if (C_TYPE_INFO_P(val) == IS_TRUE) {
		ZVAL_FALSE(EX_VAR(opline->result.var));
	} else if (EXPECTED(C_TYPE_INFO_P(val) <= IS_TRUE)) {
		/* The result and op1 can be the same cv zval */
		const uint32_t orig_val_type = C_TYPE_INFO_P(val);
		ZVAL_TRUE(EX_VAR(opline->result.var));
		if (IS_CV == IS_CV && UNEXPECTED(orig_val_type == IS_UNDEF)) {
			SAVE_OPLINE();
			ZVAL_UNDEFINED_OP1();
			CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
		}
	} else {
		SAVE_OPLINE();
		ZVAL_BOOL(EX_VAR(opline->result.var), !i_crex_is_true(val));

		CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
	}
	CREX_VM_NEXT_OPCODE();
}

static crex_never_inline CREX_OPCODE_HANDLER_RET CREX_FASTCALL crex_pre_inc_helper_SPEC_CV(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *var_ptr;

	var_ptr = EX_VAR(opline->op1.var);

	SAVE_OPLINE();
	if (IS_CV == IS_CV && UNEXPECTED(C_TYPE_P(var_ptr) == IS_UNDEF)) {
		ZVAL_UNDEFINED_OP1();
		ZVAL_NULL(var_ptr);
	}

	do {
		if (UNEXPECTED(C_TYPE_P(var_ptr) == IS_REFERENCE)) {
			crex_reference *ref = C_REF_P(var_ptr);
			var_ptr = C_REFVAL_P(var_ptr);
			if (UNEXPECTED(CREX_REF_HAS_TYPE_SOURCES(ref))) {
				crex_incdec_typed_ref(ref, NULL OPLINE_CC EXECUTE_DATA_CC);
				break;
			}
		}
		increment_function(var_ptr);
	} while (0);

	if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
		ZVAL_COPY(EX_VAR(opline->result.var), var_ptr);
	}

	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_VM_HOT CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_PRE_INC_SPEC_CV_RETVAL_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *var_ptr;

	var_ptr = EX_VAR(opline->op1.var);

	if (EXPECTED(C_TYPE_P(var_ptr) == IS_LONG)) {
		fast_long_increment_function(var_ptr);
		if (UNEXPECTED(0)) {
			ZVAL_COPY_VALUE(EX_VAR(opline->result.var), var_ptr);
		}
		CREX_VM_NEXT_OPCODE();
	}

	CREX_VM_TAIL_CALL(crex_pre_inc_helper_SPEC_CV(CREX_OPCODE_HANDLER_ARGS_PASSTHRU));
}

static CREX_VM_HOT CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_PRE_INC_SPEC_CV_RETVAL_USED_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *var_ptr;

	var_ptr = EX_VAR(opline->op1.var);

	if (EXPECTED(C_TYPE_P(var_ptr) == IS_LONG)) {
		fast_long_increment_function(var_ptr);
		if (UNEXPECTED(1)) {
			ZVAL_COPY_VALUE(EX_VAR(opline->result.var), var_ptr);
		}
		CREX_VM_NEXT_OPCODE();
	}

	CREX_VM_TAIL_CALL(crex_pre_inc_helper_SPEC_CV(CREX_OPCODE_HANDLER_ARGS_PASSTHRU));
}

static crex_never_inline CREX_OPCODE_HANDLER_RET CREX_FASTCALL crex_pre_dec_helper_SPEC_CV(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *var_ptr;

	var_ptr = EX_VAR(opline->op1.var);

	SAVE_OPLINE();
	if (IS_CV == IS_CV && UNEXPECTED(C_TYPE_P(var_ptr) == IS_UNDEF)) {
		ZVAL_UNDEFINED_OP1();
		ZVAL_NULL(var_ptr);
	}

	do {
		if (UNEXPECTED(C_TYPE_P(var_ptr) == IS_REFERENCE)) {
			crex_reference *ref = C_REF_P(var_ptr);
			var_ptr = C_REFVAL_P(var_ptr);

			if (UNEXPECTED(CREX_REF_HAS_TYPE_SOURCES(ref))) {
				crex_incdec_typed_ref(ref, NULL OPLINE_CC EXECUTE_DATA_CC);
				break;
			}
		}
		decrement_function(var_ptr);
	} while (0);

	if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
		ZVAL_COPY(EX_VAR(opline->result.var), var_ptr);
	}

	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_VM_HOT CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_PRE_DEC_SPEC_CV_RETVAL_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *var_ptr;

	var_ptr = EX_VAR(opline->op1.var);

	if (EXPECTED(C_TYPE_P(var_ptr) == IS_LONG)) {
		fast_long_decrement_function(var_ptr);
		if (UNEXPECTED(0)) {
			ZVAL_COPY_VALUE(EX_VAR(opline->result.var), var_ptr);
		}
		CREX_VM_NEXT_OPCODE();
	}

	CREX_VM_TAIL_CALL(crex_pre_dec_helper_SPEC_CV(CREX_OPCODE_HANDLER_ARGS_PASSTHRU));
}

static CREX_VM_HOT CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_PRE_DEC_SPEC_CV_RETVAL_USED_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *var_ptr;

	var_ptr = EX_VAR(opline->op1.var);

	if (EXPECTED(C_TYPE_P(var_ptr) == IS_LONG)) {
		fast_long_decrement_function(var_ptr);
		if (UNEXPECTED(1)) {
			ZVAL_COPY_VALUE(EX_VAR(opline->result.var), var_ptr);
		}
		CREX_VM_NEXT_OPCODE();
	}

	CREX_VM_TAIL_CALL(crex_pre_dec_helper_SPEC_CV(CREX_OPCODE_HANDLER_ARGS_PASSTHRU));
}

static crex_never_inline CREX_OPCODE_HANDLER_RET CREX_FASTCALL crex_post_inc_helper_SPEC_CV(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *var_ptr;

	var_ptr = EX_VAR(opline->op1.var);

	SAVE_OPLINE();
	if (IS_CV == IS_CV && UNEXPECTED(C_TYPE_P(var_ptr) == IS_UNDEF)) {
		ZVAL_UNDEFINED_OP1();
		ZVAL_NULL(var_ptr);
	}

	do {
		if (UNEXPECTED(C_TYPE_P(var_ptr) == IS_REFERENCE)) {
			crex_reference *ref = C_REF_P(var_ptr);
			var_ptr = C_REFVAL_P(var_ptr);

			if (UNEXPECTED(CREX_REF_HAS_TYPE_SOURCES(ref))) {
				crex_incdec_typed_ref(ref, EX_VAR(opline->result.var) OPLINE_CC EXECUTE_DATA_CC);
				break;
			}
		}
		ZVAL_COPY(EX_VAR(opline->result.var), var_ptr);

		increment_function(var_ptr);
	} while (0);

	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_VM_HOT CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_POST_INC_SPEC_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *var_ptr;

	var_ptr = EX_VAR(opline->op1.var);

	if (EXPECTED(C_TYPE_P(var_ptr) == IS_LONG)) {
		ZVAL_LONG(EX_VAR(opline->result.var), C_LVAL_P(var_ptr));
		fast_long_increment_function(var_ptr);
		CREX_VM_NEXT_OPCODE();
	}

	CREX_VM_TAIL_CALL(crex_post_inc_helper_SPEC_CV(CREX_OPCODE_HANDLER_ARGS_PASSTHRU));
}

static crex_never_inline CREX_OPCODE_HANDLER_RET CREX_FASTCALL crex_post_dec_helper_SPEC_CV(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *var_ptr;

	var_ptr = EX_VAR(opline->op1.var);

	SAVE_OPLINE();
	if (IS_CV == IS_CV && UNEXPECTED(C_TYPE_P(var_ptr) == IS_UNDEF)) {
		ZVAL_UNDEFINED_OP1();
		ZVAL_NULL(var_ptr);
	}

	do {
		if (UNEXPECTED(C_TYPE_P(var_ptr) == IS_REFERENCE)) {
			crex_reference *ref = C_REF_P(var_ptr);
			var_ptr = C_REFVAL_P(var_ptr);

			if (UNEXPECTED(CREX_REF_HAS_TYPE_SOURCES(ref))) {
				crex_incdec_typed_ref(ref, EX_VAR(opline->result.var) OPLINE_CC EXECUTE_DATA_CC);
				break;
			}
		}
		ZVAL_COPY(EX_VAR(opline->result.var), var_ptr);

		decrement_function(var_ptr);
	} while (0);

	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_VM_HOT CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_POST_DEC_SPEC_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *var_ptr;

	var_ptr = EX_VAR(opline->op1.var);

	if (EXPECTED(C_TYPE_P(var_ptr) == IS_LONG)) {
		ZVAL_LONG(EX_VAR(opline->result.var), C_LVAL_P(var_ptr));
		fast_long_decrement_function(var_ptr);
		CREX_VM_NEXT_OPCODE();
	}

	CREX_VM_TAIL_CALL(crex_post_dec_helper_SPEC_CV(CREX_OPCODE_HANDLER_ARGS_PASSTHRU));
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ECHO_SPEC_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *z;

	SAVE_OPLINE();
	z = EX_VAR(opline->op1.var);

	if (C_TYPE_P(z) == IS_STRING) {
		crex_string *str = C_STR_P(z);

		if (ZSTR_LEN(str) != 0) {
			crex_write(ZSTR_VAL(str), ZSTR_LEN(str));
		}
	} else {
		crex_string *str = zval_get_string_func(z);

		if (ZSTR_LEN(str) != 0) {
			crex_write(ZSTR_VAL(str), ZSTR_LEN(str));
		} else if (IS_CV == IS_CV && UNEXPECTED(C_TYPE_P(z) == IS_UNDEF)) {
			ZVAL_UNDEFINED_OP1();
		}
		crex_string_release_ex(str, 0);
	}

	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_VM_HOT CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_JMPC_SPEC_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *val;
	uint8_t op1_type;

	val = EX_VAR(opline->op1.var);

	if (C_TYPE_INFO_P(val) == IS_TRUE) {
		CREX_VM_NEXT_OPCODE();
	} else if (EXPECTED(C_TYPE_INFO_P(val) <= IS_TRUE)) {
		if (IS_CV == IS_CV && UNEXPECTED(C_TYPE_INFO_P(val) == IS_UNDEF)) {
			SAVE_OPLINE();
			ZVAL_UNDEFINED_OP1();
			if (UNEXPECTED(EG(exception))) {
				HANDLE_EXCEPTION();
			}
		}
		CREX_VM_JMP_EX(OP_JMP_ADDR(opline, opline->op2), 0);
	}

	SAVE_OPLINE();
	op1_type = IS_CV;
	if (i_crex_is_true(val)) {
		opline++;
	} else {
		opline = OP_JMP_ADDR(opline, opline->op2);
	}
	if (op1_type & (IS_TMP_VAR|IS_VAR)) {
		zval_ptr_dtor_nogc(val);
	}
	CREX_VM_JMP(opline);
}

static CREX_VM_HOT CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_JMPNC_SPEC_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *val;
	uint8_t op1_type;

	val = EX_VAR(opline->op1.var);

	if (C_TYPE_INFO_P(val) == IS_TRUE) {
		CREX_VM_JMP_EX(OP_JMP_ADDR(opline, opline->op2), 0);
	} else if (EXPECTED(C_TYPE_INFO_P(val) <= IS_TRUE)) {
		if (IS_CV == IS_CV && UNEXPECTED(C_TYPE_INFO_P(val) == IS_UNDEF)) {
			SAVE_OPLINE();
			ZVAL_UNDEFINED_OP1();
			if (UNEXPECTED(EG(exception))) {
				HANDLE_EXCEPTION();
			}
		}
		CREX_VM_NEXT_OPCODE();
	}

	SAVE_OPLINE();
	op1_type = IS_CV;
	if (i_crex_is_true(val)) {
		opline = OP_JMP_ADDR(opline, opline->op2);
	} else {
		opline++;
	}
	if (op1_type & (IS_TMP_VAR|IS_VAR)) {
		zval_ptr_dtor_nogc(val);
	}
	CREX_VM_JMP(opline);
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_JMPC_EX_SPEC_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *val;
	bool ret;

	val = EX_VAR(opline->op1.var);

	if (C_TYPE_INFO_P(val) == IS_TRUE) {
		ZVAL_TRUE(EX_VAR(opline->result.var));
		CREX_VM_NEXT_OPCODE();
	} else if (EXPECTED(C_TYPE_INFO_P(val) <= IS_TRUE)) {
		ZVAL_FALSE(EX_VAR(opline->result.var));
		if (IS_CV == IS_CV && UNEXPECTED(C_TYPE_INFO_P(val) == IS_UNDEF)) {
			SAVE_OPLINE();
			ZVAL_UNDEFINED_OP1();
			if (UNEXPECTED(EG(exception))) {
				HANDLE_EXCEPTION();
			}
		}
		CREX_VM_JMP_EX(OP_JMP_ADDR(opline, opline->op2), 0);
	}

	SAVE_OPLINE();
	ret = i_crex_is_true(val);

	if (ret) {
		ZVAL_TRUE(EX_VAR(opline->result.var));
		opline++;
	} else {
		ZVAL_FALSE(EX_VAR(opline->result.var));
		opline = OP_JMP_ADDR(opline, opline->op2);
	}
	CREX_VM_JMP(opline);
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_JMPNC_EX_SPEC_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *val;
	bool ret;

	val = EX_VAR(opline->op1.var);

	if (C_TYPE_INFO_P(val) == IS_TRUE) {
		ZVAL_TRUE(EX_VAR(opline->result.var));
		CREX_VM_JMP_EX(OP_JMP_ADDR(opline, opline->op2), 0);
	} else if (EXPECTED(C_TYPE_INFO_P(val) <= IS_TRUE)) {
		ZVAL_FALSE(EX_VAR(opline->result.var));
		if (IS_CV == IS_CV && UNEXPECTED(C_TYPE_INFO_P(val) == IS_UNDEF)) {
			SAVE_OPLINE();
			ZVAL_UNDEFINED_OP1();
			CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
		} else {
			CREX_VM_NEXT_OPCODE();
		}
	}

	SAVE_OPLINE();
	ret = i_crex_is_true(val);

	if (ret) {
		ZVAL_TRUE(EX_VAR(opline->result.var));
		opline = OP_JMP_ADDR(opline, opline->op2);
	} else {
		ZVAL_FALSE(EX_VAR(opline->result.var));
		opline++;
	}
	CREX_VM_JMP(opline);
}

static CREX_VM_HOT CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_RETURN_SPEC_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *retval_ptr;
	zval *return_value;

	retval_ptr = EX_VAR(opline->op1.var);
	return_value = EX(return_value);

	if (IS_CV == IS_CV && UNEXPECTED(C_TYPE_INFO_P(retval_ptr) == IS_UNDEF)) {
		SAVE_OPLINE();
		retval_ptr = ZVAL_UNDEFINED_OP1();
		if (return_value) {
			ZVAL_NULL(return_value);
		}
	} else if (!return_value) {
		if (IS_CV & (IS_VAR|IS_TMP_VAR)) {
			if (C_REFCOUNTED_P(retval_ptr) && !C_DELREF_P(retval_ptr)) {
				SAVE_OPLINE();
				rc_dtor_func(C_COUNTED_P(retval_ptr));
			}
		}
	} else {
		if ((IS_CV & (IS_CONST|IS_TMP_VAR))) {
			ZVAL_COPY_VALUE(return_value, retval_ptr);
			if (IS_CV == IS_CONST) {
				if (UNEXPECTED(C_OPT_REFCOUNTED_P(return_value))) {
					C_ADDREF_P(return_value);
				}
			}
		} else if (IS_CV == IS_CV) {
			do {
				if (C_OPT_REFCOUNTED_P(retval_ptr)) {
					if (EXPECTED(!C_OPT_ISREF_P(retval_ptr))) {
						if (EXPECTED(!(EX_CALL_INFO() & (CREX_CALL_CODE|CREX_CALL_OBSERVED)))) {
							crex_refcounted *ref = C_COUNTED_P(retval_ptr);
							ZVAL_COPY_VALUE(return_value, retval_ptr);
							if (GC_MAY_LEAK(ref)) {
								SAVE_OPLINE();
								gc_possible_root(ref);
							}
							ZVAL_NULL(retval_ptr);
							break;
						} else {
							C_ADDREF_P(retval_ptr);
						}
					} else {
						retval_ptr = C_REFVAL_P(retval_ptr);
						if (C_OPT_REFCOUNTED_P(retval_ptr)) {
							C_ADDREF_P(retval_ptr);
						}
					}
				}
				ZVAL_COPY_VALUE(return_value, retval_ptr);
			} while (0);
		} else /* if (IS_CV == IS_VAR) */ {
			if (UNEXPECTED(C_ISREF_P(retval_ptr))) {
				crex_refcounted *ref = C_COUNTED_P(retval_ptr);

				retval_ptr = C_REFVAL_P(retval_ptr);
				ZVAL_COPY_VALUE(return_value, retval_ptr);
				if (UNEXPECTED(GC_DELREF(ref) == 0)) {
					efree_size(ref, sizeof(crex_reference));
				} else if (C_OPT_REFCOUNTED_P(retval_ptr)) {
					C_ADDREF_P(retval_ptr);
				}
			} else {
				ZVAL_COPY_VALUE(return_value, retval_ptr);
			}
		}
	}



	CREX_VM_TAIL_CALL(crex_leave_helper_SPEC(CREX_OPCODE_HANDLER_ARGS_PASSTHRU));
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_RETURN_BY_REF_SPEC_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *retval_ptr;
	zval *return_value;

	SAVE_OPLINE();

	return_value = EX(return_value);

	do {
		if ((IS_CV & (IS_CONST|IS_TMP_VAR)) ||
		    (IS_CV == IS_VAR && opline->extended_value == CREX_RETURNS_VALUE)) {
			/* Not supposed to happen, but we'll allow it */
			crex_error(E_NOTICE, "Only variable references should be returned by reference");

			retval_ptr = _get_zval_ptr_cv_BP_VAR_R(opline->op1.var EXECUTE_DATA_CC);
			if (!return_value) {

			} else {
				if (IS_CV == IS_VAR && UNEXPECTED(C_ISREF_P(retval_ptr))) {
					ZVAL_COPY_VALUE(return_value, retval_ptr);
					break;
				}

				ZVAL_NEW_REF(return_value, retval_ptr);
				if (IS_CV == IS_CONST) {
					C_TRY_ADDREF_P(retval_ptr);
				}
			}
			break;
		}

		retval_ptr = _get_zval_ptr_cv_BP_VAR_W(opline->op1.var EXECUTE_DATA_CC);

		if (IS_CV == IS_VAR) {
			CREX_ASSERT(retval_ptr != &EG(uninitialized_zval));
			if (opline->extended_value == CREX_RETURNS_FUNCTION && !C_ISREF_P(retval_ptr)) {
				crex_error(E_NOTICE, "Only variable references should be returned by reference");
				if (return_value) {
					ZVAL_NEW_REF(return_value, retval_ptr);
				} else {

				}
				break;
			}
		}

		if (return_value) {
			if (C_ISREF_P(retval_ptr)) {
				C_ADDREF_P(retval_ptr);
			} else {
				ZVAL_MAKE_REF_EX(retval_ptr, 2);
			}
			ZVAL_REF(return_value, C_REF_P(retval_ptr));
		}

	} while (0);


	CREX_VM_TAIL_CALL(crex_leave_helper_SPEC(CREX_OPCODE_HANDLER_ARGS_PASSTHRU));
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_GENERATOR_RETURN_SPEC_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *retval;

	crex_generator *generator = crex_get_running_generator(EXECUTE_DATA_C);

	SAVE_OPLINE();
	retval = _get_zval_ptr_cv_BP_VAR_R(opline->op1.var EXECUTE_DATA_CC);

	/* Copy return value into generator->retval */
	if ((IS_CV & (IS_CONST|IS_TMP_VAR))) {
		ZVAL_COPY_VALUE(&generator->retval, retval);
		if (IS_CV == IS_CONST) {
			if (UNEXPECTED(C_OPT_REFCOUNTED(generator->retval))) {
				C_ADDREF(generator->retval);
			}
		}
	} else if (IS_CV == IS_CV) {
		ZVAL_COPY_DEREF(&generator->retval, retval);
	} else /* if (IS_CV == IS_VAR) */ {
		if (UNEXPECTED(C_ISREF_P(retval))) {
			crex_refcounted *ref = C_COUNTED_P(retval);

			retval = C_REFVAL_P(retval);
			ZVAL_COPY_VALUE(&generator->retval, retval);
			if (UNEXPECTED(GC_DELREF(ref) == 0)) {
				efree_size(ref, sizeof(crex_reference));
			} else if (C_OPT_REFCOUNTED_P(retval)) {
				C_ADDREF_P(retval);
			}
		} else {
			ZVAL_COPY_VALUE(&generator->retval, retval);
		}
	}

	EG(current_execute_data) = EX(prev_execute_data);

	/* Close the generator to free up resources */
	crex_generator_close(generator, 1);

	/* Pass execution back to handling code */
	CREX_VM_RETURN();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_THROW_SPEC_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *value;

	SAVE_OPLINE();
	value = EX_VAR(opline->op1.var);

	do {
		if (IS_CV == IS_CONST || UNEXPECTED(C_TYPE_P(value) != IS_OBJECT)) {
			if ((IS_CV & (IS_VAR|IS_CV)) && C_ISREF_P(value)) {
				value = C_REFVAL_P(value);
				if (EXPECTED(C_TYPE_P(value) == IS_OBJECT)) {
					break;
				}
			}
			if (IS_CV == IS_CV && UNEXPECTED(C_TYPE_P(value) == IS_UNDEF)) {
				ZVAL_UNDEFINED_OP1();
				if (UNEXPECTED(EG(exception) != NULL)) {
					HANDLE_EXCEPTION();
				}
			}
			crex_throw_error(NULL, "Can only throw objects");

			HANDLE_EXCEPTION();
		}
	} while (0);

	crex_exception_save();
	C_TRY_ADDREF_P(value);
	crex_throw_exception_object(value);
	crex_exception_restore();

	HANDLE_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_SEND_USER_SPEC_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *arg, *param;

	SAVE_OPLINE();

	arg = _get_zval_ptr_cv_deref_BP_VAR_R(opline->op1.var EXECUTE_DATA_CC);
	param = CREX_CALL_VAR(EX(call), opline->result.var);
	if (UNEXPECTED(ARG_MUST_BE_SENT_BY_REF(EX(call)->func, opline->op2.num))) {
		crex_param_must_be_ref(EX(call)->func, opline->op2.num);
		C_TRY_ADDREF_P(arg);
		ZVAL_NEW_REF(param, arg);
	} else {
		ZVAL_COPY(param, arg);
	}

	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_BOOL_SPEC_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *val;

	val = EX_VAR(opline->op1.var);
	if (C_TYPE_INFO_P(val) == IS_TRUE) {
		ZVAL_TRUE(EX_VAR(opline->result.var));
	} else if (EXPECTED(C_TYPE_INFO_P(val) <= IS_TRUE)) {
		/* The result and op1 can be the same cv zval */
		const uint32_t orig_val_type = C_TYPE_INFO_P(val);
		ZVAL_FALSE(EX_VAR(opline->result.var));
		if (IS_CV == IS_CV && UNEXPECTED(orig_val_type == IS_UNDEF)) {
			SAVE_OPLINE();
			ZVAL_UNDEFINED_OP1();
			CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
		}
	} else {
		SAVE_OPLINE();
		ZVAL_BOOL(EX_VAR(opline->result.var), i_crex_is_true(val));

		CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
	}
	CREX_VM_NEXT_OPCODE();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_CLONE_SPEC_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *obj;
	crex_object *zobj;
	crex_class_entry *ce, *scope;
	crex_function *clone;
	crex_object_clone_obj_t clone_call;

	SAVE_OPLINE();
	obj = EX_VAR(opline->op1.var);

	do {
		if (IS_CV == IS_CONST ||
		    (IS_CV != IS_UNUSED && UNEXPECTED(C_TYPE_P(obj) != IS_OBJECT))) {
			if ((IS_CV & (IS_VAR|IS_CV)) && C_ISREF_P(obj)) {
				obj = C_REFVAL_P(obj);
				if (EXPECTED(C_TYPE_P(obj) == IS_OBJECT)) {
					break;
				}
			}
			ZVAL_UNDEF(EX_VAR(opline->result.var));
			if (IS_CV == IS_CV && UNEXPECTED(C_TYPE_P(obj) == IS_UNDEF)) {
				ZVAL_UNDEFINED_OP1();
				if (UNEXPECTED(EG(exception) != NULL)) {
					HANDLE_EXCEPTION();
				}
			}
			crex_throw_error(NULL, "__clone method called on non-object");

			HANDLE_EXCEPTION();
		}
	} while (0);

	zobj = C_OBJ_P(obj);
	ce = zobj->ce;
	clone = ce->clone;
	clone_call = zobj->handlers->clone_obj;
	if (UNEXPECTED(clone_call == NULL)) {
		crex_throw_error(NULL, "Trying to clone an uncloneable object of class %s", ZSTR_VAL(ce->name));

		ZVAL_UNDEF(EX_VAR(opline->result.var));
		HANDLE_EXCEPTION();
	}

	if (clone && !(clone->common.fn_flags & CREX_ACC_PUBLIC)) {
		scope = EX(func)->op_array.scope;
		if (clone->common.scope != scope) {
			if (UNEXPECTED(clone->common.fn_flags & CREX_ACC_PRIVATE)
			 || UNEXPECTED(!crex_check_protected(crex_get_function_root_class(clone), scope))) {
				crex_wrong_clone_call(clone, scope);

				ZVAL_UNDEF(EX_VAR(opline->result.var));
				HANDLE_EXCEPTION();
			}
		}
	}

	ZVAL_OBJ(EX_VAR(opline->result.var), clone_call(zobj));

	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_CAST_SPEC_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *expr;
	zval *result = EX_VAR(opline->result.var);
	HashTable *ht;

	SAVE_OPLINE();
	expr = _get_zval_ptr_cv_BP_VAR_R(opline->op1.var EXECUTE_DATA_CC);

	switch (opline->extended_value) {
		case IS_LONG:
			ZVAL_LONG(result, zval_get_long(expr));
			break;
		case IS_DOUBLE:
			ZVAL_DOUBLE(result, zval_get_double(expr));
			break;
		case IS_STRING:
			ZVAL_STR(result, zval_get_string(expr));
			break;
		default:
			CREX_ASSERT(opline->extended_value != _IS_BOOL && "Must use CREX_BOOL instead");
			if (IS_CV & (IS_VAR|IS_CV)) {
				ZVAL_DEREF(expr);
			}
			/* If value is already of correct type, return it directly */
			if (C_TYPE_P(expr) == opline->extended_value) {
				ZVAL_COPY_VALUE(result, expr);
				if (IS_CV == IS_CONST) {
					if (UNEXPECTED(C_OPT_REFCOUNTED_P(result))) C_ADDREF_P(result);
				} else if (IS_CV != IS_TMP_VAR) {
					if (C_OPT_REFCOUNTED_P(result)) C_ADDREF_P(result);
				}

				CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
			}

			if (opline->extended_value == IS_ARRAY) {
				if (IS_CV == IS_CONST || C_TYPE_P(expr) != IS_OBJECT || C_OBJCE_P(expr) == crex_ce_closure) {
					if (C_TYPE_P(expr) != IS_NULL) {
						ZVAL_ARR(result, crex_new_array(1));
						expr = crex_hash_index_add_new(C_ARRVAL_P(result), 0, expr);
						if (IS_CV == IS_CONST) {
							if (UNEXPECTED(C_OPT_REFCOUNTED_P(expr))) C_ADDREF_P(expr);
						} else {
							if (C_OPT_REFCOUNTED_P(expr)) C_ADDREF_P(expr);
						}
					} else {
						ZVAL_EMPTY_ARRAY(result);
					}
				} else if (C_OBJ_P(expr)->properties == NULL
				 && C_OBJ_HT_P(expr)->get_properties_for == NULL
				 && C_OBJ_HT_P(expr)->get_properties == crex_std_get_properties) {
					/* Optimized version without rebuilding properties HashTable */
					ZVAL_ARR(result, crex_std_build_object_properties_array(C_OBJ_P(expr)));
				} else {
					HashTable *obj_ht = crex_get_properties_for(expr, CREX_PROP_PURPOSE_ARRAY_CAST);
					if (obj_ht) {
						/* fast copy */
						ZVAL_ARR(result, crex_proptable_to_symtable(obj_ht,
							(C_OBJCE_P(expr)->default_properties_count ||
							 C_OBJ_P(expr)->handlers != &std_object_handlers ||
							 GC_IS_RECURSIVE(obj_ht))));
						crex_release_properties(obj_ht);
					} else {
						ZVAL_EMPTY_ARRAY(result);
					}
				}
			} else {
				CREX_ASSERT(opline->extended_value == IS_OBJECT);
				ZVAL_OBJ(result, crex_objects_new(crex_standard_class_def));
				if (C_TYPE_P(expr) == IS_ARRAY) {
					ht = crex_symtable_to_proptable(C_ARR_P(expr));
					if (GC_FLAGS(ht) & IS_ARRAY_IMMUTABLE) {
						/* TODO: try not to duplicate immutable arrays as well ??? */
						ht = crex_array_dup(ht);
					}
					C_OBJ_P(result)->properties = ht;
				} else if (C_TYPE_P(expr) != IS_NULL) {
					C_OBJ_P(result)->properties = ht = crex_new_array(1);
					expr = crex_hash_add_new(ht, ZSTR_KNOWN(CREX_STR_SCALAR), expr);
					if (IS_CV == IS_CONST) {
						if (UNEXPECTED(C_OPT_REFCOUNTED_P(expr))) C_ADDREF_P(expr);
					} else {
						if (C_OPT_REFCOUNTED_P(expr)) C_ADDREF_P(expr);
					}
				}
			}
	}

	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_INCLUDE_OR_EVAL_SPEC_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	crex_op_array *new_op_array;
	zval *inc_filename;

	SAVE_OPLINE();
	inc_filename = _get_zval_ptr_cv_BP_VAR_R(opline->op1.var EXECUTE_DATA_CC);
	new_op_array = crex_include_or_eval(inc_filename, opline->extended_value);
	if (UNEXPECTED(EG(exception) != NULL)) {

		if (new_op_array != CREX_FAKE_OP_ARRAY && new_op_array != NULL) {
			destroy_op_array(new_op_array);
			efree_size(new_op_array, sizeof(crex_op_array));
		}
		UNDEF_RESULT();
		HANDLE_EXCEPTION();
	} else if (new_op_array == CREX_FAKE_OP_ARRAY) {
		if (RETURN_VALUE_USED(opline)) {
			ZVAL_TRUE(EX_VAR(opline->result.var));
		}
	} else if (UNEXPECTED(new_op_array == NULL)) {
		if (RETURN_VALUE_USED(opline)) {
			ZVAL_FALSE(EX_VAR(opline->result.var));
		}
	} else if (new_op_array->last == 1
			&& new_op_array->opcodes[0].opcode == CREX_RETURN
			&& new_op_array->opcodes[0].op1_type == IS_CONST
			&& EXPECTED(crex_execute_ex == execute_ex)) {
		if (RETURN_VALUE_USED(opline)) {
			const crex_op *op = new_op_array->opcodes;

			ZVAL_COPY(EX_VAR(opline->result.var), RT_CONSTANT(op, op->op1));
		}
		crex_destroy_static_vars(new_op_array);
		destroy_op_array(new_op_array);
		efree_size(new_op_array, sizeof(crex_op_array));
	} else {
		zval *return_value = NULL;
		crex_execute_data *call;
		if (RETURN_VALUE_USED(opline)) {
			return_value = EX_VAR(opline->result.var);
		}

		new_op_array->scope = EX(func)->op_array.scope;

		call = crex_vm_stack_push_call_frame(
			(C_TYPE_INFO(EX(This)) & CREX_CALL_HAS_THIS) | CREX_CALL_NESTED_CODE | CREX_CALL_HAS_SYMBOL_TABLE,
			(crex_function*)new_op_array, 0,
			C_PTR(EX(This)));

		if (EX_CALL_INFO() & CREX_CALL_HAS_SYMBOL_TABLE) {
			call->symbol_table = EX(symbol_table);
		} else {
			call->symbol_table = crex_rebuild_symbol_table();
		}

		call->prev_execute_data = execute_data;
		i_init_code_execute_data(call, new_op_array, return_value);

		if (EXPECTED(crex_execute_ex == execute_ex)) {

			CREX_VM_ENTER();
		} else {
			CREX_ADD_CALL_FLAG(call, CREX_CALL_TOP);
			crex_execute_ex(call);
			crex_vm_stack_free_call_frame(call);
		}

		crex_destroy_static_vars(new_op_array);
		destroy_op_array(new_op_array);
		efree_size(new_op_array, sizeof(crex_op_array));
		if (UNEXPECTED(EG(exception) != NULL)) {
			crex_rethrow_exception(execute_data);

			UNDEF_RESULT();
			HANDLE_EXCEPTION();
		}
	}

	CREX_VM_NEXT_OPCODE();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FE_RESET_R_SPEC_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *array_ptr, *result;

	SAVE_OPLINE();

	array_ptr = _get_zval_ptr_cv_deref_BP_VAR_R(opline->op1.var EXECUTE_DATA_CC);
	if (EXPECTED(C_TYPE_P(array_ptr) == IS_ARRAY)) {
		result = EX_VAR(opline->result.var);
		ZVAL_COPY_VALUE(result, array_ptr);
		if (IS_CV != IS_TMP_VAR && C_OPT_REFCOUNTED_P(result)) {
			C_ADDREF_P(array_ptr);
		}
		C_FE_POS_P(result) = 0;

		CREX_VM_NEXT_OPCODE();
	} else if (IS_CV != IS_CONST && EXPECTED(C_TYPE_P(array_ptr) == IS_OBJECT)) {
		crex_object *zobj = C_OBJ_P(array_ptr);
		if (!zobj->ce->get_iterator) {
			HashTable *properties = zobj->properties;
			if (properties) {
				if (UNEXPECTED(GC_REFCOUNT(properties) > 1)) {
					if (EXPECTED(!(GC_FLAGS(properties) & IS_ARRAY_IMMUTABLE))) {
						GC_DELREF(properties);
					}
					properties = zobj->properties = crex_array_dup(properties);
				}
			} else {
				properties = zobj->handlers->get_properties(zobj);
			}

			result = EX_VAR(opline->result.var);
			ZVAL_COPY_VALUE(result, array_ptr);
			if (IS_CV != IS_TMP_VAR) {
				C_ADDREF_P(array_ptr);
			}

			if (crex_hash_num_elements(properties) == 0) {
				C_FE_ITER_P(result) = (uint32_t) -1;

				CREX_VM_JMP(OP_JMP_ADDR(opline, opline->op2));
			}

			C_FE_ITER_P(result) = crex_hash_iterator_add(properties, 0);

			CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
		} else {
			bool is_empty = crex_fe_reset_iterator(array_ptr, 0 OPLINE_CC EXECUTE_DATA_CC);

			if (UNEXPECTED(EG(exception))) {
				HANDLE_EXCEPTION();
			} else if (is_empty) {
				CREX_VM_JMP_EX(OP_JMP_ADDR(opline, opline->op2), 0);
			} else {
				CREX_VM_NEXT_OPCODE();
			}
		}
	} else {
		crex_error(E_WARNING, "foreach() argument must be of type array|object, %s given", crex_zval_value_name(array_ptr));
		ZVAL_UNDEF(EX_VAR(opline->result.var));
		C_FE_ITER_P(EX_VAR(opline->result.var)) = (uint32_t)-1;

		CREX_VM_JMP(OP_JMP_ADDR(opline, opline->op2));
	}
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FE_RESET_RW_SPEC_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *array_ptr, *array_ref;

	SAVE_OPLINE();

	if (IS_CV == IS_VAR || IS_CV == IS_CV) {
		array_ref = array_ptr = _get_zval_ptr_cv_BP_VAR_R(opline->op1.var EXECUTE_DATA_CC);
		if (C_ISREF_P(array_ref)) {
			array_ptr = C_REFVAL_P(array_ref);
		}
	} else {
		array_ref = array_ptr = _get_zval_ptr_cv_BP_VAR_R(opline->op1.var EXECUTE_DATA_CC);
	}

	if (EXPECTED(C_TYPE_P(array_ptr) == IS_ARRAY)) {
		if (IS_CV == IS_VAR || IS_CV == IS_CV) {
			if (array_ptr == array_ref) {
				ZVAL_NEW_REF(array_ref, array_ref);
				array_ptr = C_REFVAL_P(array_ref);
			}
			C_ADDREF_P(array_ref);
			ZVAL_COPY_VALUE(EX_VAR(opline->result.var), array_ref);
		} else {
			array_ref = EX_VAR(opline->result.var);
			ZVAL_NEW_REF(array_ref, array_ptr);
			array_ptr = C_REFVAL_P(array_ref);
		}
		if (IS_CV == IS_CONST) {
			ZVAL_ARR(array_ptr, crex_array_dup(C_ARRVAL_P(array_ptr)));
		} else {
			SEPARATE_ARRAY(array_ptr);
		}
		C_FE_ITER_P(EX_VAR(opline->result.var)) = crex_hash_iterator_add(C_ARRVAL_P(array_ptr), 0);

		CREX_VM_NEXT_OPCODE();
	} else if (IS_CV != IS_CONST && EXPECTED(C_TYPE_P(array_ptr) == IS_OBJECT)) {
		if (!C_OBJCE_P(array_ptr)->get_iterator) {
			HashTable *properties;
			if (IS_CV == IS_VAR || IS_CV == IS_CV) {
				if (array_ptr == array_ref) {
					ZVAL_NEW_REF(array_ref, array_ref);
					array_ptr = C_REFVAL_P(array_ref);
				}
				C_ADDREF_P(array_ref);
				ZVAL_COPY_VALUE(EX_VAR(opline->result.var), array_ref);
			} else {
				array_ptr = EX_VAR(opline->result.var);
				ZVAL_COPY_VALUE(array_ptr, array_ref);
			}
			if (C_OBJ_P(array_ptr)->properties
			 && UNEXPECTED(GC_REFCOUNT(C_OBJ_P(array_ptr)->properties) > 1)) {
				if (EXPECTED(!(GC_FLAGS(C_OBJ_P(array_ptr)->properties) & IS_ARRAY_IMMUTABLE))) {
					GC_DELREF(C_OBJ_P(array_ptr)->properties);
				}
				C_OBJ_P(array_ptr)->properties = crex_array_dup(C_OBJ_P(array_ptr)->properties);
			}

			properties = C_OBJPROP_P(array_ptr);
			if (crex_hash_num_elements(properties) == 0) {
				C_FE_ITER_P(EX_VAR(opline->result.var)) = (uint32_t) -1;

				CREX_VM_JMP(OP_JMP_ADDR(opline, opline->op2));
			}

			C_FE_ITER_P(EX_VAR(opline->result.var)) = crex_hash_iterator_add(properties, 0);

			CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
		} else {
			bool is_empty = crex_fe_reset_iterator(array_ptr, 1 OPLINE_CC EXECUTE_DATA_CC);

			if (UNEXPECTED(EG(exception))) {
				HANDLE_EXCEPTION();
			} else if (is_empty) {
				CREX_VM_JMP_EX(OP_JMP_ADDR(opline, opline->op2), 0);
			} else {
				CREX_VM_NEXT_OPCODE();
			}
		}
	} else {
		crex_error(E_WARNING, "foreach() argument must be of type array|object, %s given", crex_zval_value_name(array_ptr));
		ZVAL_UNDEF(EX_VAR(opline->result.var));
		C_FE_ITER_P(EX_VAR(opline->result.var)) = (uint32_t)-1;

		CREX_VM_JMP(OP_JMP_ADDR(opline, opline->op2));
	}
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_JMP_SET_SPEC_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *value;
	crex_reference *ref = NULL;
	bool ret;

	SAVE_OPLINE();
	value = _get_zval_ptr_cv_BP_VAR_R(opline->op1.var EXECUTE_DATA_CC);

	if ((IS_CV == IS_VAR || IS_CV == IS_CV) && C_ISREF_P(value)) {
		if (IS_CV == IS_VAR) {
			ref = C_REF_P(value);
		}
		value = C_REFVAL_P(value);
	}

	ret = i_crex_is_true(value);

	if (UNEXPECTED(EG(exception))) {

		ZVAL_UNDEF(EX_VAR(opline->result.var));
		HANDLE_EXCEPTION();
	}

	if (ret) {
		zval *result = EX_VAR(opline->result.var);

		ZVAL_COPY_VALUE(result, value);
		if (IS_CV == IS_CONST) {
			if (UNEXPECTED(C_OPT_REFCOUNTED_P(result))) C_ADDREF_P(result);
		} else if (IS_CV == IS_CV) {
			if (C_OPT_REFCOUNTED_P(result)) C_ADDREF_P(result);
		} else if (IS_CV == IS_VAR && ref) {
			if (UNEXPECTED(GC_DELREF(ref) == 0)) {
				efree_size(ref, sizeof(crex_reference));
			} else if (C_OPT_REFCOUNTED_P(result)) {
				C_ADDREF_P(result);
			}
		}
		CREX_VM_JMP_EX(OP_JMP_ADDR(opline, opline->op2), 0);
	}

	CREX_VM_NEXT_OPCODE();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_COALESCE_SPEC_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *value;
	crex_reference *ref = NULL;

	SAVE_OPLINE();
	value = _get_zval_ptr_cv_BP_VAR_IS(opline->op1.var EXECUTE_DATA_CC);

	if ((IS_CV & (IS_VAR|IS_CV)) && C_ISREF_P(value)) {
		if (IS_CV & IS_VAR) {
			ref = C_REF_P(value);
		}
		value = C_REFVAL_P(value);
	}

	if (C_TYPE_P(value) > IS_NULL) {
		zval *result = EX_VAR(opline->result.var);
		ZVAL_COPY_VALUE(result, value);
		if (IS_CV == IS_CONST) {
			if (UNEXPECTED(C_OPT_REFCOUNTED_P(result))) C_ADDREF_P(result);
		} else if (IS_CV == IS_CV) {
			if (C_OPT_REFCOUNTED_P(result)) C_ADDREF_P(result);
		} else if ((IS_CV & IS_VAR) && ref) {
			if (UNEXPECTED(GC_DELREF(ref) == 0)) {
				efree_size(ref, sizeof(crex_reference));
			} else if (C_OPT_REFCOUNTED_P(result)) {
				C_ADDREF_P(result);
			}
		}
		CREX_VM_JMP_EX(OP_JMP_ADDR(opline, opline->op2), 0);
	}

	if ((IS_CV & IS_VAR) && ref) {
		if (UNEXPECTED(GC_DELREF(ref) == 0)) {
			efree_size(ref, sizeof(crex_reference));
		}
	}
	CREX_VM_NEXT_OPCODE();
}

static CREX_VM_HOT CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_JMP_NULL_SPEC_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *val, *result;

	val = EX_VAR(opline->op1.var);

	if (C_TYPE_P(val) > IS_NULL) {
		do {
			if ((IS_CV == IS_CV || IS_CV == IS_VAR) && C_TYPE_P(val) == IS_REFERENCE) {
				val = C_REFVAL_P(val);
				if (C_TYPE_P(val) <= IS_NULL) {

					break;
				}
			}
			CREX_VM_NEXT_OPCODE();
		} while (0);
	}

	result = EX_VAR(opline->result.var);
	uint32_t short_circuiting_type = opline->extended_value & CREX_SHORT_CIRCUITING_CHAIN_MASK;
	if (EXPECTED(short_circuiting_type == CREX_SHORT_CIRCUITING_CHAIN_EXPR)) {
		ZVAL_NULL(result);
		if (IS_CV == IS_CV
			&& UNEXPECTED(C_TYPE_P(val) == IS_UNDEF)
			&& (opline->extended_value & CREX_JMP_NULL_BP_VAR_IS) == 0
		) {
			SAVE_OPLINE();
			ZVAL_UNDEFINED_OP1();
			if (UNEXPECTED(EG(exception) != NULL)) {
				HANDLE_EXCEPTION();
			}
		}
	} else if (short_circuiting_type == CREX_SHORT_CIRCUITING_CHAIN_ISSET) {
		ZVAL_FALSE(result);
	} else {
		CREX_ASSERT(short_circuiting_type == CREX_SHORT_CIRCUITING_CHAIN_EMPTY);
		ZVAL_TRUE(result);
	}

	CREX_VM_JMP_EX(OP_JMP_ADDR(opline, opline->op2), 0);
}

static CREX_VM_HOT CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_QM_ASSIGN_SPEC_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *value;
	zval *result = EX_VAR(opline->result.var);

	value = EX_VAR(opline->op1.var);
	if (IS_CV == IS_CV && UNEXPECTED(C_TYPE_P(value) == IS_UNDEF)) {
		SAVE_OPLINE();
		ZVAL_UNDEFINED_OP1();
		ZVAL_NULL(result);
		CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
	}

	if (IS_CV == IS_CV) {
		ZVAL_COPY_DEREF(result, value);
	} else if (IS_CV == IS_VAR) {
		if (UNEXPECTED(C_ISREF_P(value))) {
			ZVAL_COPY_VALUE(result, C_REFVAL_P(value));
			if (UNEXPECTED(C_DELREF_P(value) == 0)) {
				efree_size(C_REF_P(value), sizeof(crex_reference));
			} else if (C_OPT_REFCOUNTED_P(result)) {
				C_ADDREF_P(result);
			}
		} else {
			ZVAL_COPY_VALUE(result, value);
		}
	} else {
		ZVAL_COPY_VALUE(result, value);
		if (IS_CV == IS_CONST) {
			if (UNEXPECTED(C_OPT_REFCOUNTED_P(result))) {
				C_ADDREF_P(result);
			}
		}
	}
	CREX_VM_NEXT_OPCODE();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_YIELD_FROM_SPEC_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	crex_generator *generator = crex_get_running_generator(EXECUTE_DATA_C);
	zval *val;

	SAVE_OPLINE();
	val = _get_zval_ptr_cv_BP_VAR_R(opline->op1.var EXECUTE_DATA_CC);

	if (UNEXPECTED(generator->flags & CREX_GENERATOR_FORCED_CLOSE)) {
		crex_throw_error(NULL, "Cannot use \"yield from\" in a force-closed generator");

		UNDEF_RESULT();
		HANDLE_EXCEPTION();
	}

yield_from_try_again:
	if (C_TYPE_P(val) == IS_ARRAY) {
		ZVAL_COPY_VALUE(&generator->values, val);
		if (C_OPT_REFCOUNTED_P(val)) {
			C_ADDREF_P(val);
		}
		C_FE_POS(generator->values) = 0;

	} else if (IS_CV != IS_CONST && C_TYPE_P(val) == IS_OBJECT && C_OBJCE_P(val)->get_iterator) {
		crex_class_entry *ce = C_OBJCE_P(val);
		if (ce == crex_ce_generator) {
			crex_generator *new_gen = (crex_generator *) C_OBJ_P(val);

			C_ADDREF_P(val);

			if (UNEXPECTED(new_gen->execute_data == NULL)) {
				crex_throw_error(NULL, "Generator passed to yield from was aborted without proper return and is unable to continue");
				zval_ptr_dtor(val);
				UNDEF_RESULT();
				HANDLE_EXCEPTION();
			} else if (C_ISUNDEF(new_gen->retval)) {
				if (UNEXPECTED(crex_generator_get_current(new_gen) == generator)) {
					crex_throw_error(NULL, "Impossible to yield from the Generator being currently run");
					zval_ptr_dtor(val);
					UNDEF_RESULT();
					HANDLE_EXCEPTION();
				} else {
					crex_generator_yield_from(generator, new_gen);
				}
			} else {
				if (RETURN_VALUE_USED(opline)) {
					ZVAL_COPY(EX_VAR(opline->result.var), &new_gen->retval);
				}
				CREX_VM_NEXT_OPCODE();
			}
		} else {
			crex_object_iterator *iter = ce->get_iterator(ce, val, 0);

			if (UNEXPECTED(!iter) || UNEXPECTED(EG(exception))) {
				if (!EG(exception)) {
					crex_throw_error(NULL, "Object of type %s did not create an Iterator", ZSTR_VAL(ce->name));
				}
				UNDEF_RESULT();
				HANDLE_EXCEPTION();
			}

			iter->index = 0;
			if (iter->funcs->rewind) {
				iter->funcs->rewind(iter);
				if (UNEXPECTED(EG(exception) != NULL)) {
					OBJ_RELEASE(&iter->std);
					UNDEF_RESULT();
					HANDLE_EXCEPTION();
				}
			}

			ZVAL_OBJ(&generator->values, &iter->std);
		}
	} else if ((IS_CV & (IS_VAR|IS_CV)) && C_TYPE_P(val) == IS_REFERENCE) {
		val = C_REFVAL_P(val);
		goto yield_from_try_again;
	} else {
		crex_throw_error(NULL, "Can use \"yield from\" only with arrays and Traversables");

		UNDEF_RESULT();
		HANDLE_EXCEPTION();
	}

	/* This is the default return value
	 * when the expression is a Generator, it will be overwritten in crex_generator_resume() */
	if (RETURN_VALUE_USED(opline)) {
		ZVAL_NULL(EX_VAR(opline->result.var));
	}

	/* This generator has no send target (though the generator we delegate to might have one) */
	generator->send_target = NULL;

	/* We increment to the next op, so we are at the correct position when the
	 * generator is resumed. */
	CREX_VM_INC_OPCODE();

	/* The GOTO VM uses a local opline variable. We need to set the opline
	 * variable in execute_data so we don't resume at an old position. */
	SAVE_OPLINE();

	CREX_VM_RETURN();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_STRLEN_SPEC_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *value;

	value = EX_VAR(opline->op1.var);
	if (EXPECTED(C_TYPE_P(value) == IS_STRING)) {
		ZVAL_LONG(EX_VAR(opline->result.var), C_STRLEN_P(value));
		if (IS_CV & (IS_TMP_VAR|IS_VAR)) {
			zval_ptr_dtor_str(value);
		}
		CREX_VM_NEXT_OPCODE();
	} else {
		bool strict;

		if ((IS_CV & (IS_VAR|IS_CV)) && C_TYPE_P(value) == IS_REFERENCE) {
			value = C_REFVAL_P(value);
			if (EXPECTED(C_TYPE_P(value) == IS_STRING)) {
				ZVAL_LONG(EX_VAR(opline->result.var), C_STRLEN_P(value));

				CREX_VM_NEXT_OPCODE();
			}
		}

		SAVE_OPLINE();
		if (IS_CV == IS_CV && UNEXPECTED(C_TYPE_P(value) == IS_UNDEF)) {
			value = ZVAL_UNDEFINED_OP1();
		}
		strict = EX_USES_STRICT_TYPES();
		do {
			if (EXPECTED(!strict)) {
				crex_string *str;
				zval tmp;

				if (UNEXPECTED(C_TYPE_P(value) == IS_NULL)) {
					crex_error(E_DEPRECATED,
						"strlen(): Passing null to parameter #1 ($string) of type string is deprecated");
					ZVAL_LONG(EX_VAR(opline->result.var), 0);
					if (UNEXPECTED(EG(exception))) {
						HANDLE_EXCEPTION();
					}
					break;
				}

				ZVAL_COPY(&tmp, value);
				if (crex_parse_arg_str_weak(&tmp, &str, 1)) {
					ZVAL_LONG(EX_VAR(opline->result.var), ZSTR_LEN(str));
					zval_ptr_dtor(&tmp);
					break;
				}
				zval_ptr_dtor(&tmp);
			}
			if (!EG(exception)) {
				crex_type_error("strlen(): Argument #1 ($string) must be of type string, %s given", crex_zval_value_name(value));
			}
			ZVAL_UNDEF(EX_VAR(opline->result.var));
		} while (0);
	}

	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_VM_HOT CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_TYPE_CHECK_SPEC_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *value;
	int result = 0;

	value = EX_VAR(opline->op1.var);
	if ((opline->extended_value >> (uint32_t)C_TYPE_P(value)) & 1) {
type_check_resource:
		if (opline->extended_value != MAY_BE_RESOURCE
		 || EXPECTED(NULL != crex_rsrc_list_get_rsrc_type(C_RES_P(value)))) {
			result = 1;
		}
	} else if ((IS_CV & (IS_CV|IS_VAR)) && C_ISREF_P(value)) {
		value = C_REFVAL_P(value);
		if ((opline->extended_value >> (uint32_t)C_TYPE_P(value)) & 1) {
			goto type_check_resource;
		}
	} else if (IS_CV == IS_CV && UNEXPECTED(C_TYPE_P(value) == IS_UNDEF)) {
		result = ((1 << IS_NULL) & opline->extended_value) != 0;
		SAVE_OPLINE();
		ZVAL_UNDEFINED_OP1();
		if (UNEXPECTED(EG(exception))) {
			ZVAL_UNDEF(EX_VAR(opline->result.var));
			HANDLE_EXCEPTION();
		}
	}
	if (IS_CV & (IS_TMP_VAR|IS_VAR)) {
		SAVE_OPLINE();

		CREX_VM_SMART_BRANCH(result, 1);
	} else {
		CREX_VM_SMART_BRANCH(result, 0);
	}
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FETCH_CLASS_NAME_SPEC_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	uint32_t fetch_type;
	crex_class_entry *called_scope, *scope;
	USE_OPLINE

	if (IS_CV != IS_UNUSED) {
		SAVE_OPLINE();
		zval *op = _get_zval_ptr_cv_BP_VAR_R(opline->op1.var EXECUTE_DATA_CC);
		if (UNEXPECTED(C_TYPE_P(op) != IS_OBJECT)) {
			ZVAL_DEREF(op);
			if (C_TYPE_P(op) != IS_OBJECT) {
				crex_type_error("Cannot use \"::class\" on %s", crex_zval_value_name(op));
				ZVAL_UNDEF(EX_VAR(opline->result.var));

				HANDLE_EXCEPTION();
			}
		}

		ZVAL_STR_COPY(EX_VAR(opline->result.var), C_OBJCE_P(op)->name);

		CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
	}

	fetch_type = opline->op1.num;
	scope = EX(func)->op_array.scope;
	if (UNEXPECTED(scope == NULL)) {
		SAVE_OPLINE();
		crex_throw_error(NULL, "Cannot use \"%s\" in the global scope",
			fetch_type == CREX_FETCH_CLASS_SELF ? "self" :
			fetch_type == CREX_FETCH_CLASS_PARENT ? "parent" : "static");
		ZVAL_UNDEF(EX_VAR(opline->result.var));
		HANDLE_EXCEPTION();
	}

	switch (fetch_type) {
		case CREX_FETCH_CLASS_SELF:
			ZVAL_STR_COPY(EX_VAR(opline->result.var), scope->name);
			break;
		case CREX_FETCH_CLASS_PARENT:
			if (UNEXPECTED(scope->parent == NULL)) {
				SAVE_OPLINE();
				crex_throw_error(NULL,
					"Cannot use \"parent\" when current class scope has no parent");
				ZVAL_UNDEF(EX_VAR(opline->result.var));
				HANDLE_EXCEPTION();
			}
			ZVAL_STR_COPY(EX_VAR(opline->result.var), scope->parent->name);
			break;
		case CREX_FETCH_CLASS_STATIC:
			if (C_TYPE(EX(This)) == IS_OBJECT) {
				called_scope = C_OBJCE(EX(This));
			} else {
				called_scope = C_CE(EX(This));
			}
			ZVAL_STR_COPY(EX_VAR(opline->result.var), called_scope->name);
			break;
		EMPTY_SWITCH_DEFAULT_CASE()
	}
	CREX_VM_NEXT_OPCODE();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_BIND_STATIC_SPEC_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	HashTable *ht;
	zval *value;
	zval *variable_ptr;

	variable_ptr = EX_VAR(opline->op1.var);

	ht = CREX_MAP_PTR_GET(EX(func)->op_array.static_variables_ptr);
	if (!ht) {
		ht = crex_array_dup(EX(func)->op_array.static_variables);
		CREX_MAP_PTR_SET(EX(func)->op_array.static_variables_ptr, ht);
	}
	CREX_ASSERT(GC_REFCOUNT(ht) == 1);

	value = (zval*)((char*)ht->arData + (opline->extended_value & ~(CREX_BIND_REF|CREX_BIND_IMPLICIT|CREX_BIND_EXPLICIT)));

	SAVE_OPLINE();
	if (opline->extended_value & CREX_BIND_REF) {
		i_zval_ptr_dtor(variable_ptr);
		if (UNEXPECTED(!C_ISREF_P(value))) {
			crex_reference *ref = (crex_reference*)emalloc(sizeof(crex_reference));
			GC_SET_REFCOUNT(ref, 2);
			GC_TYPE_INFO(ref) = GC_REFERENCE;
			if (opline->op2_type == IS_UNUSED) {
				ZVAL_COPY_VALUE(&ref->val, value);
			} else {
				CREX_ASSERT(!C_REFCOUNTED_P(value));
				ZVAL_COPY(&ref->val, get_zval_ptr_deref(opline->op2_type, opline->op2, BP_VAR_R));
				FREE_OP(opline->op2_type, opline->op2.var);
			}
			ref->sources.ptr = NULL;
			C_REF_P(value) = ref;
			C_TYPE_INFO_P(value) = IS_REFERENCE_EX;
			ZVAL_REF(variable_ptr, ref);
		} else {
			C_ADDREF_P(value);
			ZVAL_REF(variable_ptr, C_REF_P(value));
			if (opline->op2_type != IS_UNUSED) {
				FREE_OP(opline->op2_type, opline->op2.var);
			}
		}
	} else {
		i_zval_ptr_dtor(variable_ptr);
		ZVAL_COPY(variable_ptr, value);
	}

	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_BIND_INIT_STATIC_OR_JMP_SPEC_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	HashTable *ht;
	zval *value;
	zval *variable_ptr;

	variable_ptr = EX_VAR(opline->op1.var);

	ht = CREX_MAP_PTR_GET(EX(func)->op_array.static_variables_ptr);
	if (!ht) {
		CREX_VM_NEXT_OPCODE();
	}
	CREX_ASSERT(GC_REFCOUNT(ht) == 1);

	value = (zval*)((char*)ht->arData + opline->extended_value);
	if (C_TYPE_EXTRA_P(value) & IS_STATIC_VAR_UNINITIALIZED) {
		CREX_VM_NEXT_OPCODE();
	} else {
		SAVE_OPLINE();
		zval_ptr_dtor(variable_ptr);
		CREX_ASSERT(C_TYPE_P(value) == IS_REFERENCE);
		C_ADDREF_P(value);
		ZVAL_REF(variable_ptr, C_REF_P(value));
		CREX_VM_JMP_EX(OP_JMP_ADDR(opline, opline->op2), 1);
	}
}

static CREX_VM_HOT CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_PRE_INC_LONG_NO_OVERFLOW_SPEC_CV_RETVAL_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *var_ptr;

	var_ptr = EX_VAR(opline->op1.var);
	C_LVAL_P(var_ptr)++;
	if (UNEXPECTED(0)) {
		ZVAL_LONG(EX_VAR(opline->result.var), C_LVAL_P(var_ptr));
	}
	CREX_VM_NEXT_OPCODE();
}

static CREX_VM_HOT CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_PRE_INC_LONG_NO_OVERFLOW_SPEC_CV_RETVAL_USED_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *var_ptr;

	var_ptr = EX_VAR(opline->op1.var);
	C_LVAL_P(var_ptr)++;
	if (UNEXPECTED(1)) {
		ZVAL_LONG(EX_VAR(opline->result.var), C_LVAL_P(var_ptr));
	}
	CREX_VM_NEXT_OPCODE();
}

static CREX_VM_HOT CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_PRE_INC_LONG_SPEC_CV_RETVAL_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *var_ptr;

	var_ptr = EX_VAR(opline->op1.var);
	fast_long_increment_function(var_ptr);
	if (UNEXPECTED(0)) {
		ZVAL_COPY_VALUE(EX_VAR(opline->result.var), var_ptr);
	}
	CREX_VM_NEXT_OPCODE();
}

static CREX_VM_HOT CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_PRE_INC_LONG_SPEC_CV_RETVAL_USED_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *var_ptr;

	var_ptr = EX_VAR(opline->op1.var);
	fast_long_increment_function(var_ptr);
	if (UNEXPECTED(1)) {
		ZVAL_COPY_VALUE(EX_VAR(opline->result.var), var_ptr);
	}
	CREX_VM_NEXT_OPCODE();
}

static CREX_VM_HOT CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_PRE_DEC_LONG_NO_OVERFLOW_SPEC_CV_RETVAL_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *var_ptr;

	var_ptr = EX_VAR(opline->op1.var);
	C_LVAL_P(var_ptr)--;
	if (UNEXPECTED(0)) {
		ZVAL_LONG(EX_VAR(opline->result.var), C_LVAL_P(var_ptr));
	}
	CREX_VM_NEXT_OPCODE();
}

static CREX_VM_HOT CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_PRE_DEC_LONG_NO_OVERFLOW_SPEC_CV_RETVAL_USED_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *var_ptr;

	var_ptr = EX_VAR(opline->op1.var);
	C_LVAL_P(var_ptr)--;
	if (UNEXPECTED(1)) {
		ZVAL_LONG(EX_VAR(opline->result.var), C_LVAL_P(var_ptr));
	}
	CREX_VM_NEXT_OPCODE();
}

static CREX_VM_HOT CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_PRE_DEC_LONG_SPEC_CV_RETVAL_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *var_ptr;

	var_ptr = EX_VAR(opline->op1.var);
	fast_long_decrement_function(var_ptr);
	if (UNEXPECTED(0)) {
		ZVAL_COPY_VALUE(EX_VAR(opline->result.var), var_ptr);
	}
	CREX_VM_NEXT_OPCODE();
}

static CREX_VM_HOT CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_PRE_DEC_LONG_SPEC_CV_RETVAL_USED_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *var_ptr;

	var_ptr = EX_VAR(opline->op1.var);
	fast_long_decrement_function(var_ptr);
	if (UNEXPECTED(1)) {
		ZVAL_COPY_VALUE(EX_VAR(opline->result.var), var_ptr);
	}
	CREX_VM_NEXT_OPCODE();
}

static CREX_VM_HOT CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_POST_INC_LONG_NO_OVERFLOW_SPEC_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *var_ptr;

	var_ptr = EX_VAR(opline->op1.var);
	ZVAL_LONG(EX_VAR(opline->result.var), C_LVAL_P(var_ptr));
	C_LVAL_P(var_ptr)++;
	CREX_VM_NEXT_OPCODE();
}

static CREX_VM_HOT CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_POST_INC_LONG_SPEC_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *var_ptr;

	var_ptr = EX_VAR(opline->op1.var);
	ZVAL_LONG(EX_VAR(opline->result.var), C_LVAL_P(var_ptr));
	fast_long_increment_function(var_ptr);
	CREX_VM_NEXT_OPCODE();
}

static CREX_VM_HOT CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_POST_DEC_LONG_NO_OVERFLOW_SPEC_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *var_ptr;

	var_ptr = EX_VAR(opline->op1.var);
	ZVAL_LONG(EX_VAR(opline->result.var), C_LVAL_P(var_ptr));
	C_LVAL_P(var_ptr)--;
	CREX_VM_NEXT_OPCODE();
}

static CREX_VM_HOT CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_POST_DEC_LONG_SPEC_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *var_ptr;

	var_ptr = EX_VAR(opline->op1.var);
	ZVAL_LONG(EX_VAR(opline->result.var), C_LVAL_P(var_ptr));
	fast_long_decrement_function(var_ptr);
	CREX_VM_NEXT_OPCODE();
}

static CREX_VM_HOT CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_SEND_VAR_SIMPLE_SPEC_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *varptr, *arg;

	varptr = EX_VAR(opline->op1.var);
	arg = CREX_CALL_VAR(EX(call), opline->result.var);

	if (IS_CV == IS_CV) {
		ZVAL_COPY(arg, varptr);
	} else /* if (IS_CV == IS_VAR) */ {
		ZVAL_COPY_VALUE(arg, varptr);
	}

	CREX_VM_NEXT_OPCODE();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_DIV_SPEC_CV_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;

	SAVE_OPLINE();
	op1 = _get_zval_ptr_cv_BP_VAR_R(opline->op1.var EXECUTE_DATA_CC);
	op2 = RT_CONSTANT(opline, opline->op2);
	div_function(EX_VAR(opline->result.var), op1, op2);


	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_POW_SPEC_CV_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;

	SAVE_OPLINE();
	op1 = _get_zval_ptr_cv_BP_VAR_R(opline->op1.var EXECUTE_DATA_CC);
	op2 = RT_CONSTANT(opline, opline->op2);
	pow_function(EX_VAR(opline->result.var), op1, op2);


	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_CONCAT_SPEC_CV_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;

	op1 = EX_VAR(opline->op1.var);
	op2 = RT_CONSTANT(opline, opline->op2);

	if ((IS_CV == IS_CONST || EXPECTED(C_TYPE_P(op1) == IS_STRING)) &&
	    (IS_CONST == IS_CONST || EXPECTED(C_TYPE_P(op2) == IS_STRING))) {
		crex_string *op1_str = C_STR_P(op1);
		crex_string *op2_str = C_STR_P(op2);
		crex_string *str;
		uint32_t flags = ZSTR_GET_COPYABLE_CONCAT_PROPERTIES_BOTH(op1_str, op2_str);

		if (IS_CV != IS_CONST && UNEXPECTED(ZSTR_LEN(op1_str) == 0)) {
			if (IS_CONST == IS_CONST || IS_CONST == IS_CV) {
				ZVAL_STR_COPY(EX_VAR(opline->result.var), op2_str);
			} else {
				ZVAL_STR(EX_VAR(opline->result.var), op2_str);
			}
			if (IS_CV & (IS_TMP_VAR|IS_VAR)) {
				crex_string_release_ex(op1_str, 0);
			}
		} else if (IS_CONST != IS_CONST && UNEXPECTED(ZSTR_LEN(op2_str) == 0)) {
			if (IS_CV == IS_CONST || IS_CV == IS_CV) {
				ZVAL_STR_COPY(EX_VAR(opline->result.var), op1_str);
			} else {
				ZVAL_STR(EX_VAR(opline->result.var), op1_str);
			}
			if (IS_CONST & (IS_TMP_VAR|IS_VAR)) {
				crex_string_release_ex(op2_str, 0);
			}
		} else if (IS_CV != IS_CONST && IS_CV != IS_CV &&
		    !ZSTR_IS_INTERNED(op1_str) && GC_REFCOUNT(op1_str) == 1) {
			size_t len = ZSTR_LEN(op1_str);

			if (UNEXPECTED(len > ZSTR_MAX_LEN - ZSTR_LEN(op2_str))) {
				crex_error_noreturn(E_ERROR, "Integer overflow in memory allocation");
			}
			str = crex_string_extend(op1_str, len + ZSTR_LEN(op2_str), 0);
			memcpy(ZSTR_VAL(str) + len, ZSTR_VAL(op2_str), ZSTR_LEN(op2_str)+1);
			GC_ADD_FLAGS(str, flags);
			ZVAL_NEW_STR(EX_VAR(opline->result.var), str);
			if (IS_CONST & (IS_TMP_VAR|IS_VAR)) {
				crex_string_release_ex(op2_str, 0);
			}
		} else {
			str = crex_string_alloc(ZSTR_LEN(op1_str) + ZSTR_LEN(op2_str), 0);
			memcpy(ZSTR_VAL(str), ZSTR_VAL(op1_str), ZSTR_LEN(op1_str));
			memcpy(ZSTR_VAL(str) + ZSTR_LEN(op1_str), ZSTR_VAL(op2_str), ZSTR_LEN(op2_str)+1);
			GC_ADD_FLAGS(str, flags);
			ZVAL_NEW_STR(EX_VAR(opline->result.var), str);
			if (IS_CV & (IS_TMP_VAR|IS_VAR)) {
				crex_string_release_ex(op1_str, 0);
			}
			if (IS_CONST & (IS_TMP_VAR|IS_VAR)) {
				crex_string_release_ex(op2_str, 0);
			}
		}
		CREX_VM_NEXT_OPCODE();
	} else {
		SAVE_OPLINE();

		if (IS_CV == IS_CV && UNEXPECTED(C_TYPE_P(op1) == IS_UNDEF)) {
			op1 = ZVAL_UNDEFINED_OP1();
		}
		if (IS_CONST == IS_CV && UNEXPECTED(C_TYPE_P(op2) == IS_UNDEF)) {
			op2 = ZVAL_UNDEFINED_OP2();
		}
		concat_function(EX_VAR(opline->result.var), op1, op2);


		CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
	}
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_IS_IDENTICAL_SPEC_CV_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	bool result;

	SAVE_OPLINE();
	op1 = _get_zval_ptr_cv_deref_BP_VAR_R(opline->op1.var EXECUTE_DATA_CC);
	op2 = RT_CONSTANT(opline, opline->op2);
	result = fast_is_identical_function(op1, op2);


	CREX_VM_SMART_BRANCH(result, 1);
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_IS_NOT_IDENTICAL_SPEC_CV_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	bool result;

	SAVE_OPLINE();
	op1 = _get_zval_ptr_cv_deref_BP_VAR_R(opline->op1.var EXECUTE_DATA_CC);
	op2 = RT_CONSTANT(opline, opline->op2);
	result = fast_is_not_identical_function(op1, op2);


	CREX_VM_SMART_BRANCH(result, 1);
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_IS_EQUAL_SPEC_CV_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	double d1, d2;

	op1 = EX_VAR(opline->op1.var);
	op2 = RT_CONSTANT(opline, opline->op2);
	if (1 && IS_CV == IS_CONST && IS_CONST == IS_CONST) {
		/* pass */
	} else if (EXPECTED(C_TYPE_P(op1) == IS_LONG)) {
		if (EXPECTED(C_TYPE_P(op2) == IS_LONG)) {
			if (EXPECTED(C_LVAL_P(op1) == C_LVAL_P(op2))) {
is_equal_true:
				CREX_VM_SMART_BRANCH_TRUE_NONE();
			} else {
is_equal_false:
				CREX_VM_SMART_BRANCH_FALSE_NONE();
			}
		} else if (EXPECTED(C_TYPE_P(op2) == IS_DOUBLE)) {
			d1 = (double)C_LVAL_P(op1);
			d2 = C_DVAL_P(op2);
			goto is_equal_double;
		}
	} else if (EXPECTED(C_TYPE_P(op1) == IS_DOUBLE)) {
		if (EXPECTED(C_TYPE_P(op2) == IS_DOUBLE)) {
			d1 = C_DVAL_P(op1);
			d2 = C_DVAL_P(op2);
is_equal_double:
			if (d1 == d2) {
				goto is_equal_true;
			} else {
				goto is_equal_false;
			}
		} else if (EXPECTED(C_TYPE_P(op2) == IS_LONG)) {
			d1 = C_DVAL_P(op1);
			d2 = (double)C_LVAL_P(op2);
			goto is_equal_double;
		}
	} else if (EXPECTED(C_TYPE_P(op1) == IS_STRING)) {
		if (EXPECTED(C_TYPE_P(op2) == IS_STRING)) {
			bool result = crex_fast_equal_strings(C_STR_P(op1), C_STR_P(op2));
			if (IS_CV & (IS_TMP_VAR|IS_VAR)) {
				zval_ptr_dtor_str(op1);
			}
			if (IS_CONST & (IS_TMP_VAR|IS_VAR)) {
				zval_ptr_dtor_str(op2);
			}
			if (result) {
				goto is_equal_true;
			} else {
				goto is_equal_false;
			}
		}
	}
	CREX_VM_TAIL_CALL(crex_is_equal_helper_SPEC(op1, op2 CREX_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_IS_EQUAL_SPEC_CV_CONST_JMPC_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	double d1, d2;

	op1 = EX_VAR(opline->op1.var);
	op2 = RT_CONSTANT(opline, opline->op2);
	if (1 && IS_CV == IS_CONST && IS_CONST == IS_CONST) {
		/* pass */
	} else if (EXPECTED(C_TYPE_P(op1) == IS_LONG)) {
		if (EXPECTED(C_TYPE_P(op2) == IS_LONG)) {
			if (EXPECTED(C_LVAL_P(op1) == C_LVAL_P(op2))) {
is_equal_true:
				CREX_VM_SMART_BRANCH_TRUE_JMPZ();
			} else {
is_equal_false:
				CREX_VM_SMART_BRANCH_FALSE_JMPZ();
			}
		} else if (EXPECTED(C_TYPE_P(op2) == IS_DOUBLE)) {
			d1 = (double)C_LVAL_P(op1);
			d2 = C_DVAL_P(op2);
			goto is_equal_double;
		}
	} else if (EXPECTED(C_TYPE_P(op1) == IS_DOUBLE)) {
		if (EXPECTED(C_TYPE_P(op2) == IS_DOUBLE)) {
			d1 = C_DVAL_P(op1);
			d2 = C_DVAL_P(op2);
is_equal_double:
			if (d1 == d2) {
				goto is_equal_true;
			} else {
				goto is_equal_false;
			}
		} else if (EXPECTED(C_TYPE_P(op2) == IS_LONG)) {
			d1 = C_DVAL_P(op1);
			d2 = (double)C_LVAL_P(op2);
			goto is_equal_double;
		}
	} else if (EXPECTED(C_TYPE_P(op1) == IS_STRING)) {
		if (EXPECTED(C_TYPE_P(op2) == IS_STRING)) {
			bool result = crex_fast_equal_strings(C_STR_P(op1), C_STR_P(op2));
			if (IS_CV & (IS_TMP_VAR|IS_VAR)) {
				zval_ptr_dtor_str(op1);
			}
			if (IS_CONST & (IS_TMP_VAR|IS_VAR)) {
				zval_ptr_dtor_str(op2);
			}
			if (result) {
				goto is_equal_true;
			} else {
				goto is_equal_false;
			}
		}
	}
	CREX_VM_TAIL_CALL(crex_is_equal_helper_SPEC(op1, op2 CREX_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_IS_EQUAL_SPEC_CV_CONST_JMPNC_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	double d1, d2;

	op1 = EX_VAR(opline->op1.var);
	op2 = RT_CONSTANT(opline, opline->op2);
	if (1 && IS_CV == IS_CONST && IS_CONST == IS_CONST) {
		/* pass */
	} else if (EXPECTED(C_TYPE_P(op1) == IS_LONG)) {
		if (EXPECTED(C_TYPE_P(op2) == IS_LONG)) {
			if (EXPECTED(C_LVAL_P(op1) == C_LVAL_P(op2))) {
is_equal_true:
				CREX_VM_SMART_BRANCH_TRUE_JMPNZ();
			} else {
is_equal_false:
				CREX_VM_SMART_BRANCH_FALSE_JMPNZ();
			}
		} else if (EXPECTED(C_TYPE_P(op2) == IS_DOUBLE)) {
			d1 = (double)C_LVAL_P(op1);
			d2 = C_DVAL_P(op2);
			goto is_equal_double;
		}
	} else if (EXPECTED(C_TYPE_P(op1) == IS_DOUBLE)) {
		if (EXPECTED(C_TYPE_P(op2) == IS_DOUBLE)) {
			d1 = C_DVAL_P(op1);
			d2 = C_DVAL_P(op2);
is_equal_double:
			if (d1 == d2) {
				goto is_equal_true;
			} else {
				goto is_equal_false;
			}
		} else if (EXPECTED(C_TYPE_P(op2) == IS_LONG)) {
			d1 = C_DVAL_P(op1);
			d2 = (double)C_LVAL_P(op2);
			goto is_equal_double;
		}
	} else if (EXPECTED(C_TYPE_P(op1) == IS_STRING)) {
		if (EXPECTED(C_TYPE_P(op2) == IS_STRING)) {
			bool result = crex_fast_equal_strings(C_STR_P(op1), C_STR_P(op2));
			if (IS_CV & (IS_TMP_VAR|IS_VAR)) {
				zval_ptr_dtor_str(op1);
			}
			if (IS_CONST & (IS_TMP_VAR|IS_VAR)) {
				zval_ptr_dtor_str(op2);
			}
			if (result) {
				goto is_equal_true;
			} else {
				goto is_equal_false;
			}
		}
	}
	CREX_VM_TAIL_CALL(crex_is_equal_helper_SPEC(op1, op2 CREX_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_IS_NOT_EQUAL_SPEC_CV_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	double d1, d2;

	op1 = EX_VAR(opline->op1.var);
	op2 = RT_CONSTANT(opline, opline->op2);
	if (1 && IS_CV == IS_CONST && IS_CONST == IS_CONST) {
		/* pass */
	} else if (EXPECTED(C_TYPE_P(op1) == IS_LONG)) {
		if (EXPECTED(C_TYPE_P(op2) == IS_LONG)) {
			if (EXPECTED(C_LVAL_P(op1) != C_LVAL_P(op2))) {
is_not_equal_true:
				CREX_VM_SMART_BRANCH_TRUE_NONE();
			} else {
is_not_equal_false:
				CREX_VM_SMART_BRANCH_FALSE_NONE();
			}
		} else if (EXPECTED(C_TYPE_P(op2) == IS_DOUBLE)) {
			d1 = (double)C_LVAL_P(op1);
			d2 = C_DVAL_P(op2);
			goto is_not_equal_double;
		}
	} else if (EXPECTED(C_TYPE_P(op1) == IS_DOUBLE)) {
		if (EXPECTED(C_TYPE_P(op2) == IS_DOUBLE)) {
			d1 = C_DVAL_P(op1);
			d2 = C_DVAL_P(op2);
is_not_equal_double:
			if (d1 != d2) {
				goto is_not_equal_true;
			} else {
				goto is_not_equal_false;
			}
		} else if (EXPECTED(C_TYPE_P(op2) == IS_LONG)) {
			d1 = C_DVAL_P(op1);
			d2 = (double)C_LVAL_P(op2);
			goto is_not_equal_double;
		}
	} else if (EXPECTED(C_TYPE_P(op1) == IS_STRING)) {
		if (EXPECTED(C_TYPE_P(op2) == IS_STRING)) {
			bool result = crex_fast_equal_strings(C_STR_P(op1), C_STR_P(op2));
			if (IS_CV & (IS_TMP_VAR|IS_VAR)) {
				zval_ptr_dtor_str(op1);
			}
			if (IS_CONST & (IS_TMP_VAR|IS_VAR)) {
				zval_ptr_dtor_str(op2);
			}
			if (!result) {
				goto is_not_equal_true;
			} else {
				goto is_not_equal_false;
			}
		}
	}
	CREX_VM_TAIL_CALL(crex_is_not_equal_helper_SPEC(op1, op2 CREX_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_IS_NOT_EQUAL_SPEC_CV_CONST_JMPC_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	double d1, d2;

	op1 = EX_VAR(opline->op1.var);
	op2 = RT_CONSTANT(opline, opline->op2);
	if (1 && IS_CV == IS_CONST && IS_CONST == IS_CONST) {
		/* pass */
	} else if (EXPECTED(C_TYPE_P(op1) == IS_LONG)) {
		if (EXPECTED(C_TYPE_P(op2) == IS_LONG)) {
			if (EXPECTED(C_LVAL_P(op1) != C_LVAL_P(op2))) {
is_not_equal_true:
				CREX_VM_SMART_BRANCH_TRUE_JMPZ();
			} else {
is_not_equal_false:
				CREX_VM_SMART_BRANCH_FALSE_JMPZ();
			}
		} else if (EXPECTED(C_TYPE_P(op2) == IS_DOUBLE)) {
			d1 = (double)C_LVAL_P(op1);
			d2 = C_DVAL_P(op2);
			goto is_not_equal_double;
		}
	} else if (EXPECTED(C_TYPE_P(op1) == IS_DOUBLE)) {
		if (EXPECTED(C_TYPE_P(op2) == IS_DOUBLE)) {
			d1 = C_DVAL_P(op1);
			d2 = C_DVAL_P(op2);
is_not_equal_double:
			if (d1 != d2) {
				goto is_not_equal_true;
			} else {
				goto is_not_equal_false;
			}
		} else if (EXPECTED(C_TYPE_P(op2) == IS_LONG)) {
			d1 = C_DVAL_P(op1);
			d2 = (double)C_LVAL_P(op2);
			goto is_not_equal_double;
		}
	} else if (EXPECTED(C_TYPE_P(op1) == IS_STRING)) {
		if (EXPECTED(C_TYPE_P(op2) == IS_STRING)) {
			bool result = crex_fast_equal_strings(C_STR_P(op1), C_STR_P(op2));
			if (IS_CV & (IS_TMP_VAR|IS_VAR)) {
				zval_ptr_dtor_str(op1);
			}
			if (IS_CONST & (IS_TMP_VAR|IS_VAR)) {
				zval_ptr_dtor_str(op2);
			}
			if (!result) {
				goto is_not_equal_true;
			} else {
				goto is_not_equal_false;
			}
		}
	}
	CREX_VM_TAIL_CALL(crex_is_not_equal_helper_SPEC(op1, op2 CREX_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_IS_NOT_EQUAL_SPEC_CV_CONST_JMPNC_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	double d1, d2;

	op1 = EX_VAR(opline->op1.var);
	op2 = RT_CONSTANT(opline, opline->op2);
	if (1 && IS_CV == IS_CONST && IS_CONST == IS_CONST) {
		/* pass */
	} else if (EXPECTED(C_TYPE_P(op1) == IS_LONG)) {
		if (EXPECTED(C_TYPE_P(op2) == IS_LONG)) {
			if (EXPECTED(C_LVAL_P(op1) != C_LVAL_P(op2))) {
is_not_equal_true:
				CREX_VM_SMART_BRANCH_TRUE_JMPNZ();
			} else {
is_not_equal_false:
				CREX_VM_SMART_BRANCH_FALSE_JMPNZ();
			}
		} else if (EXPECTED(C_TYPE_P(op2) == IS_DOUBLE)) {
			d1 = (double)C_LVAL_P(op1);
			d2 = C_DVAL_P(op2);
			goto is_not_equal_double;
		}
	} else if (EXPECTED(C_TYPE_P(op1) == IS_DOUBLE)) {
		if (EXPECTED(C_TYPE_P(op2) == IS_DOUBLE)) {
			d1 = C_DVAL_P(op1);
			d2 = C_DVAL_P(op2);
is_not_equal_double:
			if (d1 != d2) {
				goto is_not_equal_true;
			} else {
				goto is_not_equal_false;
			}
		} else if (EXPECTED(C_TYPE_P(op2) == IS_LONG)) {
			d1 = C_DVAL_P(op1);
			d2 = (double)C_LVAL_P(op2);
			goto is_not_equal_double;
		}
	} else if (EXPECTED(C_TYPE_P(op1) == IS_STRING)) {
		if (EXPECTED(C_TYPE_P(op2) == IS_STRING)) {
			bool result = crex_fast_equal_strings(C_STR_P(op1), C_STR_P(op2));
			if (IS_CV & (IS_TMP_VAR|IS_VAR)) {
				zval_ptr_dtor_str(op1);
			}
			if (IS_CONST & (IS_TMP_VAR|IS_VAR)) {
				zval_ptr_dtor_str(op2);
			}
			if (!result) {
				goto is_not_equal_true;
			} else {
				goto is_not_equal_false;
			}
		}
	}
	CREX_VM_TAIL_CALL(crex_is_not_equal_helper_SPEC(op1, op2 CREX_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_SPACESHIP_SPEC_CV_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;

	SAVE_OPLINE();
	op1 = _get_zval_ptr_cv_BP_VAR_R(opline->op1.var EXECUTE_DATA_CC);
	op2 = RT_CONSTANT(opline, opline->op2);
	compare_function(EX_VAR(opline->result.var), op1, op2);


	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_BOOL_XOR_SPEC_CV_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;

	SAVE_OPLINE();
	op1 = _get_zval_ptr_cv_BP_VAR_R(opline->op1.var EXECUTE_DATA_CC);
	op2 = RT_CONSTANT(opline, opline->op2);
	boolean_xor_function(EX_VAR(opline->result.var), op1, op2);


	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ASSIGN_OBJ_OP_SPEC_CV_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *object;
	zval *property;
	zval *value;
	zval *zptr;
	void **cache_slot;
	crex_property_info *prop_info;
	crex_object *zobj;
	crex_string *name, *tmp_name;

	SAVE_OPLINE();
	object = EX_VAR(opline->op1.var);
	property = RT_CONSTANT(opline, opline->op2);

	do {
		value = get_op_data_zval_ptr_r((opline+1)->op1_type, (opline+1)->op1);

		if (IS_CV != IS_UNUSED && UNEXPECTED(C_TYPE_P(object) != IS_OBJECT)) {
			if (C_ISREF_P(object) && C_TYPE_P(C_REFVAL_P(object)) == IS_OBJECT) {
				object = C_REFVAL_P(object);
				goto assign_op_object;
			}
			if (IS_CV == IS_CV
			 && UNEXPECTED(C_TYPE_P(object) == IS_UNDEF)) {
				ZVAL_UNDEFINED_OP1();
			}
			crex_throw_non_object_error(object, property OPLINE_CC EXECUTE_DATA_CC);
			break;
		}

assign_op_object:
		/* here we are sure we are dealing with an object */
		zobj = C_OBJ_P(object);
		if (IS_CONST == IS_CONST) {
			name = C_STR_P(property);
		} else {
			name = zval_try_get_tmp_string(property, &tmp_name);
			if (UNEXPECTED(!name)) {
				UNDEF_RESULT();
				break;
			}
		}
		cache_slot = (IS_CONST == IS_CONST) ? CACHE_ADDR((opline+1)->extended_value) : NULL;
		if (EXPECTED((zptr = zobj->handlers->get_property_ptr_ptr(zobj, name, BP_VAR_RW, cache_slot)) != NULL)) {
			if (UNEXPECTED(C_ISERROR_P(zptr))) {
				if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
					ZVAL_NULL(EX_VAR(opline->result.var));
				}
			} else {
				zval *orig_zptr = zptr;
				crex_reference *ref;

				do {
					if (UNEXPECTED(C_ISREF_P(zptr))) {
						ref = C_REF_P(zptr);
						zptr = C_REFVAL_P(zptr);
						if (UNEXPECTED(CREX_REF_HAS_TYPE_SOURCES(ref))) {
							crex_binary_assign_op_typed_ref(ref, value OPLINE_CC EXECUTE_DATA_CC);
							break;
						}
					}

					if (IS_CONST == IS_CONST) {
						prop_info = (crex_property_info*)CACHED_PTR_EX(cache_slot + 2);
					} else {
						prop_info = crex_object_fetch_property_type_info(C_OBJ_P(object), orig_zptr);
					}
					if (UNEXPECTED(prop_info)) {
						/* special case for typed properties */
						crex_binary_assign_op_typed_prop(prop_info, zptr, value OPLINE_CC EXECUTE_DATA_CC);
					} else {
						crex_binary_op(zptr, zptr, value OPLINE_CC);
					}
				} while (0);

				if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
					ZVAL_COPY(EX_VAR(opline->result.var), zptr);
				}
			}
		} else {
			crex_assign_op_overloaded_property(zobj, name, cache_slot, value OPLINE_CC EXECUTE_DATA_CC);
		}
		if (IS_CONST != IS_CONST) {
			crex_tmp_string_release(tmp_name);
		}
	} while (0);

	FREE_OP((opline+1)->op1_type, (opline+1)->op1.var);


	/* assign_obj has two opcodes! */
	CREX_VM_NEXT_OPCODE_EX(1, 2);
}

/* No specialization for op_types (CONST|TMP|VAR|CV, UNUSED|CONST|TMPVAR) */
static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ASSIGN_DIM_OP_SPEC_CV_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *var_ptr;
	zval *value, *container, *dim;
	HashTable *ht;

	SAVE_OPLINE();
	container = EX_VAR(opline->op1.var);

	if (EXPECTED(C_TYPE_P(container) == IS_ARRAY)) {
assign_dim_op_array:
		SEPARATE_ARRAY(container);
		ht = C_ARRVAL_P(container);
assign_dim_op_new_array:
		dim = RT_CONSTANT(opline, opline->op2);
		if (IS_CONST == IS_UNUSED) {
			var_ptr = crex_hash_next_index_insert(ht, &EG(uninitialized_zval));
			if (UNEXPECTED(!var_ptr)) {
				crex_cannot_add_element();
				goto assign_dim_op_ret_null;
			}
		} else {
			if (IS_CONST == IS_CONST) {
				var_ptr = crex_fetch_dimension_address_inner_RW_CONST(ht, dim EXECUTE_DATA_CC);
			} else {
				var_ptr = crex_fetch_dimension_address_inner_RW(ht, dim EXECUTE_DATA_CC);
			}
			if (UNEXPECTED(!var_ptr)) {
				goto assign_dim_op_ret_null;
			}
		}

		value = get_op_data_zval_ptr_r((opline+1)->op1_type, (opline+1)->op1);

		do {
			if (IS_CONST != IS_UNUSED && UNEXPECTED(C_ISREF_P(var_ptr))) {
				crex_reference *ref = C_REF_P(var_ptr);
				var_ptr = C_REFVAL_P(var_ptr);
				if (UNEXPECTED(CREX_REF_HAS_TYPE_SOURCES(ref))) {
					crex_binary_assign_op_typed_ref(ref, value OPLINE_CC EXECUTE_DATA_CC);
					break;
				}
			}
			crex_binary_op(var_ptr, var_ptr, value OPLINE_CC);
		} while (0);

		if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
			ZVAL_COPY(EX_VAR(opline->result.var), var_ptr);
		}
		FREE_OP((opline+1)->op1_type, (opline+1)->op1.var);
	} else {
		if (EXPECTED(C_ISREF_P(container))) {
			container = C_REFVAL_P(container);
			if (EXPECTED(C_TYPE_P(container) == IS_ARRAY)) {
				goto assign_dim_op_array;
			}
		}

		if (EXPECTED(C_TYPE_P(container) == IS_OBJECT)) {
			crex_object *obj = C_OBJ_P(container);

			dim = RT_CONSTANT(opline, opline->op2);
			if (IS_CONST == IS_CONST && C_EXTRA_P(dim) == CREX_EXTRA_VALUE) {
				dim++;
			}
			crex_binary_assign_op_obj_dim(obj, dim OPLINE_CC EXECUTE_DATA_CC);
		} else if (EXPECTED(C_TYPE_P(container) <= IS_FALSE)) {
			uint8_t old_type;

			if (IS_CV == IS_CV && UNEXPECTED(C_TYPE_INFO_P(container) == IS_UNDEF)) {
				ZVAL_UNDEFINED_OP1();
			}
			ht = crex_new_array(8);
			old_type = C_TYPE_P(container);
			ZVAL_ARR(container, ht);
			if (UNEXPECTED(old_type == IS_FALSE)) {
				GC_ADDREF(ht);
				crex_false_to_array_deprecated();
				if (UNEXPECTED(GC_DELREF(ht) == 0)) {
					crex_array_destroy(ht);
					goto assign_dim_op_ret_null;
				}
			}
			goto assign_dim_op_new_array;
		} else {
			dim = RT_CONSTANT(opline, opline->op2);
			crex_binary_assign_op_dim_slow(container, dim OPLINE_CC EXECUTE_DATA_CC);
assign_dim_op_ret_null:
			FREE_OP((opline+1)->op1_type, (opline+1)->op1.var);
			if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
				ZVAL_NULL(EX_VAR(opline->result.var));
			}
		}
	}


	CREX_VM_NEXT_OPCODE_EX(1, 2);
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ASSIGN_OP_SPEC_CV_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *var_ptr;
	zval *value;

	SAVE_OPLINE();
	value = RT_CONSTANT(opline, opline->op2);
	var_ptr = _get_zval_ptr_cv_BP_VAR_RW(opline->op1.var EXECUTE_DATA_CC);

	do {
		if (UNEXPECTED(C_TYPE_P(var_ptr) == IS_REFERENCE)) {
			crex_reference *ref = C_REF_P(var_ptr);
			var_ptr = C_REFVAL_P(var_ptr);
			if (UNEXPECTED(CREX_REF_HAS_TYPE_SOURCES(ref))) {
				crex_binary_assign_op_typed_ref(ref, value OPLINE_CC EXECUTE_DATA_CC);
				break;
			}
		}
		crex_binary_op(var_ptr, var_ptr, value OPLINE_CC);
	} while (0);

	if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
		ZVAL_COPY(EX_VAR(opline->result.var), var_ptr);
	}


	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_PRE_INC_OBJ_SPEC_CV_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *object;
	zval *property;
	zval *zptr;
	void **cache_slot;
	crex_property_info *prop_info;
	crex_object *zobj;
	crex_string *name, *tmp_name;

	SAVE_OPLINE();
	object = EX_VAR(opline->op1.var);
	property = RT_CONSTANT(opline, opline->op2);

	do {
		if (IS_CV != IS_UNUSED && UNEXPECTED(C_TYPE_P(object) != IS_OBJECT)) {
			if (C_ISREF_P(object) && C_TYPE_P(C_REFVAL_P(object)) == IS_OBJECT) {
				object = C_REFVAL_P(object);
				goto pre_incdec_object;
			}
			if (IS_CV == IS_CV
			 && UNEXPECTED(C_TYPE_P(object) == IS_UNDEF)) {
				ZVAL_UNDEFINED_OP1();
			}
			crex_throw_non_object_error(object, property OPLINE_CC EXECUTE_DATA_CC);
			break;
		}

pre_incdec_object:
		/* here we are sure we are dealing with an object */
		zobj = C_OBJ_P(object);
		if (IS_CONST == IS_CONST) {
			name = C_STR_P(property);
		} else {
			name = zval_try_get_tmp_string(property, &tmp_name);
			if (UNEXPECTED(!name)) {
				UNDEF_RESULT();
				break;
			}
		}
		cache_slot = (IS_CONST == IS_CONST) ? CACHE_ADDR(opline->extended_value) : NULL;
		if (EXPECTED((zptr = zobj->handlers->get_property_ptr_ptr(zobj, name, BP_VAR_RW, cache_slot)) != NULL)) {
			if (UNEXPECTED(C_ISERROR_P(zptr))) {
				if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
					ZVAL_NULL(EX_VAR(opline->result.var));
				}
			} else {
				if (IS_CONST == IS_CONST) {
					prop_info = (crex_property_info *) CACHED_PTR_EX(cache_slot + 2);
				} else {
					prop_info = crex_object_fetch_property_type_info(C_OBJ_P(object), zptr);
				}
				crex_pre_incdec_property_zval(zptr, prop_info OPLINE_CC EXECUTE_DATA_CC);
			}
		} else {
			crex_pre_incdec_overloaded_property(zobj, name, cache_slot OPLINE_CC EXECUTE_DATA_CC);
		}
		if (IS_CONST != IS_CONST) {
			crex_tmp_string_release(tmp_name);
		}
	} while (0);


	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_POST_INC_OBJ_SPEC_CV_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *object;
	zval *property;
	zval *zptr;
	void **cache_slot;
	crex_property_info *prop_info;
	crex_object *zobj;
	crex_string *name, *tmp_name;

	SAVE_OPLINE();
	object = EX_VAR(opline->op1.var);
	property = RT_CONSTANT(opline, opline->op2);

	do {
		if (IS_CV != IS_UNUSED && UNEXPECTED(C_TYPE_P(object) != IS_OBJECT)) {
			if (C_ISREF_P(object) && C_TYPE_P(C_REFVAL_P(object)) == IS_OBJECT) {
				object = C_REFVAL_P(object);
				goto post_incdec_object;
			}
			if (IS_CV == IS_CV
			 && UNEXPECTED(C_TYPE_P(object) == IS_UNDEF)) {
				ZVAL_UNDEFINED_OP1();
			}
			crex_throw_non_object_error(object, property OPLINE_CC EXECUTE_DATA_CC);
			break;
		}

post_incdec_object:
		/* here we are sure we are dealing with an object */
		zobj = C_OBJ_P(object);
		if (IS_CONST == IS_CONST) {
			name = C_STR_P(property);
		} else {
			name = zval_try_get_tmp_string(property, &tmp_name);
			if (UNEXPECTED(!name)) {
				ZVAL_UNDEF(EX_VAR(opline->result.var));
				break;
			}
		}
		cache_slot = (IS_CONST == IS_CONST) ? CACHE_ADDR(opline->extended_value) : NULL;
		if (EXPECTED((zptr = zobj->handlers->get_property_ptr_ptr(zobj, name, BP_VAR_RW, cache_slot)) != NULL)) {
			if (UNEXPECTED(C_ISERROR_P(zptr))) {
				ZVAL_NULL(EX_VAR(opline->result.var));
			} else {
				if (IS_CONST == IS_CONST) {
					prop_info = (crex_property_info*)CACHED_PTR_EX(cache_slot + 2);
				} else {
					prop_info = crex_object_fetch_property_type_info(C_OBJ_P(object), zptr);
				}

				crex_post_incdec_property_zval(zptr, prop_info OPLINE_CC EXECUTE_DATA_CC);
			}
		} else {
			crex_post_incdec_overloaded_property(zobj, name, cache_slot OPLINE_CC EXECUTE_DATA_CC);
		}
		if (IS_CONST != IS_CONST) {
			crex_tmp_string_release(tmp_name);
		}
	} while (0);


	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FETCH_DIM_R_SPEC_CV_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container, *dim, *value;

	SAVE_OPLINE();
	container = EX_VAR(opline->op1.var);
	dim = RT_CONSTANT(opline, opline->op2);
	if (IS_CV != IS_CONST) {
		if (EXPECTED(C_TYPE_P(container) == IS_ARRAY)) {
fetch_dim_r_array:
			value = crex_fetch_dimension_address_inner(C_ARRVAL_P(container), dim, IS_CONST, BP_VAR_R EXECUTE_DATA_CC);
			ZVAL_COPY_DEREF(EX_VAR(opline->result.var), value);
		} else if (EXPECTED(C_TYPE_P(container) == IS_REFERENCE)) {
			container = C_REFVAL_P(container);
			if (EXPECTED(C_TYPE_P(container) == IS_ARRAY)) {
				goto fetch_dim_r_array;
			} else {
				goto fetch_dim_r_slow;
			}
		} else {
fetch_dim_r_slow:
			if (IS_CONST == IS_CONST && C_EXTRA_P(dim) == CREX_EXTRA_VALUE) {
				dim++;
			}
			crex_fetch_dimension_address_read_R_slow(container, dim OPLINE_CC EXECUTE_DATA_CC);
		}
	} else {
		crex_fetch_dimension_address_read_R(container, dim, IS_CONST OPLINE_CC EXECUTE_DATA_CC);
	}


	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FETCH_DIM_W_SPEC_CV_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;

	SAVE_OPLINE();
	container = EX_VAR(opline->op1.var);
	crex_fetch_dimension_address_W(container, RT_CONSTANT(opline, opline->op2), IS_CONST OPLINE_CC EXECUTE_DATA_CC);

	if (IS_CV == IS_VAR) {
		FREE_VAR_PTR_AND_EXTRACT_RESULT_IF_NECESSARY(opline->op1.var);
	}
	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FETCH_DIM_RW_SPEC_CV_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;

	SAVE_OPLINE();
	container = EX_VAR(opline->op1.var);
	crex_fetch_dimension_address_RW(container, RT_CONSTANT(opline, opline->op2), IS_CONST OPLINE_CC EXECUTE_DATA_CC);

	if (IS_CV == IS_VAR) {
		FREE_VAR_PTR_AND_EXTRACT_RESULT_IF_NECESSARY(opline->op1.var);
	}
	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FETCH_DIM_IS_SPEC_CV_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;

	SAVE_OPLINE();
	container = EX_VAR(opline->op1.var);
	crex_fetch_dimension_address_read_IS(container, RT_CONSTANT(opline, opline->op2), IS_CONST OPLINE_CC EXECUTE_DATA_CC);


	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FETCH_DIM_FUNC_ARG_SPEC_CV_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
#if 0
	USE_OPLINE
#endif

	if (UNEXPECTED(CREX_CALL_INFO(EX(call)) & CREX_CALL_SEND_ARG_BY_REF)) {
		if ((IS_CV & (IS_CONST|IS_TMP_VAR))) {
			CREX_VM_TAIL_CALL(crex_use_tmp_in_write_context_helper_SPEC(CREX_OPCODE_HANDLER_ARGS_PASSTHRU));
		}
		CREX_VM_TAIL_CALL(CREX_FETCH_DIM_W_SPEC_CV_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU));
	} else {
		if (IS_CONST == IS_UNUSED) {
			CREX_VM_TAIL_CALL(crex_use_undef_in_read_context_helper_SPEC(CREX_OPCODE_HANDLER_ARGS_PASSTHRU));
		}
		CREX_VM_TAIL_CALL(CREX_FETCH_DIM_R_SPEC_CV_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU));
	}
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FETCH_DIM_UNSET_SPEC_CV_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;

	SAVE_OPLINE();
	container = EX_VAR(opline->op1.var);
	crex_fetch_dimension_address_UNSET(container, RT_CONSTANT(opline, opline->op2), IS_CONST OPLINE_CC EXECUTE_DATA_CC);

	if (IS_CV == IS_VAR) {
		FREE_VAR_PTR_AND_EXTRACT_RESULT_IF_NECESSARY(opline->op1.var);
	}
	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static crex_always_inline CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FETCH_OBJ_R_SPEC_CV_CONST_INLINE_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;
	void **cache_slot = NULL;

	SAVE_OPLINE();
	container = EX_VAR(opline->op1.var);

	if (IS_CV == IS_CONST ||
	    (IS_CV != IS_UNUSED && UNEXPECTED(C_TYPE_P(container) != IS_OBJECT))) {
		do {
			if ((IS_CV & (IS_VAR|IS_CV)) && C_ISREF_P(container)) {
				container = C_REFVAL_P(container);
				if (EXPECTED(C_TYPE_P(container) == IS_OBJECT)) {
					break;
				}
			}
			if (IS_CV == IS_CV && UNEXPECTED(C_TYPE_P(container) == IS_UNDEF)) {
				ZVAL_UNDEFINED_OP1();
			}
			crex_wrong_property_read(container, RT_CONSTANT(opline, opline->op2));
			ZVAL_NULL(EX_VAR(opline->result.var));
			goto fetch_obj_r_finish;
		} while (0);
	}

	/* here we are sure we are dealing with an object */
	do {
		crex_object *zobj = C_OBJ_P(container);
		crex_string *name, *tmp_name;
		zval *retval;

		if (IS_CONST == IS_CONST) {
			cache_slot = CACHE_ADDR(opline->extended_value & ~CREX_FETCH_REF /* FUNC_ARG fetch may contain it */);

			if (EXPECTED(zobj->ce == CACHED_PTR_EX(cache_slot))) {
				uintptr_t prop_offset = (uintptr_t)CACHED_PTR_EX(cache_slot + 1);

				if (EXPECTED(IS_VALID_PROPERTY_OFFSET(prop_offset))) {
					retval = OBJ_PROP(zobj, prop_offset);
					if (EXPECTED(C_TYPE_INFO_P(retval) != IS_UNDEF)) {
						if (0 || (IS_CV & (IS_TMP_VAR|IS_VAR)) != 0) {
							goto fetch_obj_r_copy;
						} else {
fetch_obj_r_fast_copy:
							ZVAL_COPY_DEREF(EX_VAR(opline->result.var), retval);
							CREX_VM_NEXT_OPCODE();
						}
					}
				} else if (EXPECTED(zobj->properties != NULL)) {
					name = C_STR_P(RT_CONSTANT(opline, opline->op2));
					if (!IS_UNKNOWN_DYNAMIC_PROPERTY_OFFSET(prop_offset)) {
						uintptr_t idx = CREX_DECODE_DYN_PROP_OFFSET(prop_offset);

						if (EXPECTED(idx < zobj->properties->nNumUsed * sizeof(Bucket))) {
							Bucket *p = (Bucket*)((char*)zobj->properties->arData + idx);

							if (EXPECTED(p->key == name) ||
							    (EXPECTED(p->h == ZSTR_H(name)) &&
							     EXPECTED(p->key != NULL) &&
							     EXPECTED(crex_string_equal_content(p->key, name)))) {
								retval = &p->val;
								if (0 || (IS_CV & (IS_TMP_VAR|IS_VAR)) != 0) {
									goto fetch_obj_r_copy;
								} else {
									goto fetch_obj_r_fast_copy;
								}
							}
						}
						CACHE_PTR_EX(cache_slot + 1, (void*)CREX_DYNAMIC_PROPERTY_OFFSET);
					}
					retval = crex_hash_find_known_hash(zobj->properties, name);
					if (EXPECTED(retval)) {
						uintptr_t idx = (char*)retval - (char*)zobj->properties->arData;
						CACHE_PTR_EX(cache_slot + 1, (void*)CREX_ENCODE_DYN_PROP_OFFSET(idx));
						if (0 || (IS_CV & (IS_TMP_VAR|IS_VAR)) != 0) {
							goto fetch_obj_r_copy;
						} else {
							goto fetch_obj_r_fast_copy;
						}
					}
				}
			}
			name = C_STR_P(RT_CONSTANT(opline, opline->op2));
		} else {
			name = zval_try_get_tmp_string(RT_CONSTANT(opline, opline->op2), &tmp_name);
			if (UNEXPECTED(!name)) {
				ZVAL_UNDEF(EX_VAR(opline->result.var));
				break;
			}
		}

#if CREX_DEBUG
		/* For non-standard object handlers, verify a declared property type in debug builds.
		 * Fetch prop_info before calling read_property(), as it may deallocate the object. */
		crex_property_info *prop_info = NULL;
		if (zobj->handlers->read_property != crex_std_read_property) {
			prop_info = crex_get_property_info(zobj->ce, name, /* silent */ true);
		}
#endif
		retval = zobj->handlers->read_property(zobj, name, BP_VAR_R, cache_slot, EX_VAR(opline->result.var));
#if CREX_DEBUG
		if (!EG(exception) && prop_info && prop_info != CREX_WRONG_PROPERTY_INFO
				&& CREX_TYPE_IS_SET(prop_info->type)) {
			ZVAL_OPT_DEREF(retval);
			crex_verify_property_type(prop_info, retval, /* strict */ true);
		}
#endif

		if (IS_CONST != IS_CONST) {
			crex_tmp_string_release(tmp_name);
		}

		if (retval != EX_VAR(opline->result.var)) {
fetch_obj_r_copy:
			ZVAL_COPY_DEREF(EX_VAR(opline->result.var), retval);
		} else if (UNEXPECTED(C_ISREF_P(retval))) {
			crex_unwrap_reference(retval);
		}
	} while (0);

fetch_obj_r_finish:


	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FETCH_OBJ_R_SPEC_CV_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	CREX_VM_TAIL_CALL(CREX_FETCH_OBJ_R_SPEC_CV_CONST_INLINE_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU));
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FETCH_OBJ_W_SPEC_CV_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *property, *container, *result;

	SAVE_OPLINE();

	container = EX_VAR(opline->op1.var);
	property = RT_CONSTANT(opline, opline->op2);
	result = EX_VAR(opline->result.var);
	crex_fetch_property_address(
		result, container, IS_CV, property, IS_CONST,
		((IS_CONST == IS_CONST) ? CACHE_ADDR(opline->extended_value & ~CREX_FETCH_OBJ_FLAGS) : NULL),
		BP_VAR_W, opline->extended_value OPLINE_CC EXECUTE_DATA_CC);

	if (IS_CV == IS_VAR) {
		FREE_VAR_PTR_AND_EXTRACT_RESULT_IF_NECESSARY(opline->op1.var);
	}
	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FETCH_OBJ_RW_SPEC_CV_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *property, *container, *result;

	SAVE_OPLINE();
	container = EX_VAR(opline->op1.var);
	property = RT_CONSTANT(opline, opline->op2);
	result = EX_VAR(opline->result.var);
	crex_fetch_property_address(result, container, IS_CV, property, IS_CONST, ((IS_CONST == IS_CONST) ? CACHE_ADDR(opline->extended_value) : NULL), BP_VAR_RW, 0 OPLINE_CC EXECUTE_DATA_CC);

	if (IS_CV == IS_VAR) {
		FREE_VAR_PTR_AND_EXTRACT_RESULT_IF_NECESSARY(opline->op1.var);
	}
	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FETCH_OBJ_IS_SPEC_CV_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;
	void **cache_slot = NULL;

	SAVE_OPLINE();
	container = _get_zval_ptr_cv_BP_VAR_IS(opline->op1.var EXECUTE_DATA_CC);

	if (IS_CV == IS_CONST ||
	    (IS_CV != IS_UNUSED && UNEXPECTED(C_TYPE_P(container) != IS_OBJECT))) {
		do {
			if ((IS_CV & (IS_VAR|IS_CV)) && C_ISREF_P(container)) {
				container = C_REFVAL_P(container);
				if (EXPECTED(C_TYPE_P(container) == IS_OBJECT)) {
					break;
				}
			}
			if (IS_CONST == IS_CV && C_TYPE_P(EX_VAR(opline->op2.var)) == IS_UNDEF) {
				ZVAL_UNDEFINED_OP2();
			}
			ZVAL_NULL(EX_VAR(opline->result.var));
			goto fetch_obj_is_finish;
		} while (0);
	}

	/* here we are sure we are dealing with an object */
	do {
		crex_object *zobj = C_OBJ_P(container);
		crex_string *name, *tmp_name;
		zval *retval;

		if (IS_CONST == IS_CONST) {
			cache_slot = CACHE_ADDR(opline->extended_value);

			if (EXPECTED(zobj->ce == CACHED_PTR_EX(cache_slot))) {
				uintptr_t prop_offset = (uintptr_t)CACHED_PTR_EX(cache_slot + 1);

				if (EXPECTED(IS_VALID_PROPERTY_OFFSET(prop_offset))) {
					retval = OBJ_PROP(zobj, prop_offset);
					if (EXPECTED(C_TYPE_P(retval) != IS_UNDEF)) {
						if (0 || (IS_CV & (IS_TMP_VAR|IS_VAR)) != 0) {
							goto fetch_obj_is_copy;
						} else {
fetch_obj_is_fast_copy:
							ZVAL_COPY_DEREF(EX_VAR(opline->result.var), retval);
							CREX_VM_NEXT_OPCODE();
						}
					}
				} else if (EXPECTED(zobj->properties != NULL)) {
					name = C_STR_P(RT_CONSTANT(opline, opline->op2));
					if (!IS_UNKNOWN_DYNAMIC_PROPERTY_OFFSET(prop_offset)) {
						uintptr_t idx = CREX_DECODE_DYN_PROP_OFFSET(prop_offset);

						if (EXPECTED(idx < zobj->properties->nNumUsed * sizeof(Bucket))) {
							Bucket *p = (Bucket*)((char*)zobj->properties->arData + idx);

							if (EXPECTED(p->key == name) ||
							    (EXPECTED(p->h == ZSTR_H(name)) &&
							     EXPECTED(p->key != NULL) &&
							     EXPECTED(crex_string_equal_content(p->key, name)))) {
								retval = &p->val;
								if (0 || (IS_CV & (IS_TMP_VAR|IS_VAR)) != 0) {
									goto fetch_obj_is_copy;
								} else {
									goto fetch_obj_is_fast_copy;
								}
							}
						}
						CACHE_PTR_EX(cache_slot + 1, (void*)CREX_DYNAMIC_PROPERTY_OFFSET);
					}
					retval = crex_hash_find_known_hash(zobj->properties, name);
					if (EXPECTED(retval)) {
						uintptr_t idx = (char*)retval - (char*)zobj->properties->arData;
						CACHE_PTR_EX(cache_slot + 1, (void*)CREX_ENCODE_DYN_PROP_OFFSET(idx));
						if (0 || (IS_CV & (IS_TMP_VAR|IS_VAR)) != 0) {
							goto fetch_obj_is_copy;
						} else {
							goto fetch_obj_is_fast_copy;
						}
					}
				}
			}
			name = C_STR_P(RT_CONSTANT(opline, opline->op2));
		} else {
			name = zval_try_get_tmp_string(RT_CONSTANT(opline, opline->op2), &tmp_name);
			if (UNEXPECTED(!name)) {
				ZVAL_UNDEF(EX_VAR(opline->result.var));
				break;
			}
		}

		retval = zobj->handlers->read_property(zobj, name, BP_VAR_IS, cache_slot, EX_VAR(opline->result.var));

		if (IS_CONST != IS_CONST) {
			crex_tmp_string_release(tmp_name);
		}

		if (retval != EX_VAR(opline->result.var)) {
fetch_obj_is_copy:
			ZVAL_COPY_DEREF(EX_VAR(opline->result.var), retval);
		} else if (UNEXPECTED(C_ISREF_P(retval))) {
			crex_unwrap_reference(retval);
		}
	} while (0);

fetch_obj_is_finish:


	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FETCH_OBJ_FUNC_ARG_SPEC_CV_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
#if 0
	USE_OPLINE
#endif

	if (UNEXPECTED(CREX_CALL_INFO(EX(call)) & CREX_CALL_SEND_ARG_BY_REF)) {
		/* Behave like FETCH_OBJ_W */
		if ((IS_CV & (IS_CONST|IS_TMP_VAR))) {
			CREX_VM_TAIL_CALL(crex_use_tmp_in_write_context_helper_SPEC(CREX_OPCODE_HANDLER_ARGS_PASSTHRU));
		}
		CREX_VM_TAIL_CALL(CREX_FETCH_OBJ_W_SPEC_CV_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU));
	} else {
		CREX_VM_TAIL_CALL(CREX_FETCH_OBJ_R_SPEC_CV_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU));
	}
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FETCH_OBJ_UNSET_SPEC_CV_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container, *property, *result;

	SAVE_OPLINE();
	container = EX_VAR(opline->op1.var);
	property = RT_CONSTANT(opline, opline->op2);
	result = EX_VAR(opline->result.var);
	crex_fetch_property_address(result, container, IS_CV, property, IS_CONST, ((IS_CONST == IS_CONST) ? CACHE_ADDR(opline->extended_value) : NULL), BP_VAR_UNSET, 0 OPLINE_CC EXECUTE_DATA_CC);

	if (IS_CV == IS_VAR) {
		FREE_VAR_PTR_AND_EXTRACT_RESULT_IF_NECESSARY(opline->op1.var);
	}
	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ASSIGN_OBJ_SPEC_CV_CONST_OP_DATA_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *object, *value, tmp;
	crex_object *zobj;
	crex_string *name, *tmp_name;
	crex_refcounted *garbage = NULL;

	SAVE_OPLINE();
	object = EX_VAR(opline->op1.var);
	value = RT_CONSTANT((opline+1), (opline+1)->op1);

	if (IS_CV != IS_UNUSED && UNEXPECTED(C_TYPE_P(object) != IS_OBJECT)) {
		if (C_ISREF_P(object) && C_TYPE_P(C_REFVAL_P(object)) == IS_OBJECT) {
			object = C_REFVAL_P(object);
			goto assign_object;
		}
		crex_throw_non_object_error(object, RT_CONSTANT(opline, opline->op2) OPLINE_CC EXECUTE_DATA_CC);
		value = &EG(uninitialized_zval);
		goto free_and_exit_assign_obj;
	}

assign_object:
	zobj = C_OBJ_P(object);
	if (IS_CONST == IS_CONST) {
		if (EXPECTED(zobj->ce == CACHED_PTR(opline->extended_value))) {
			void **cache_slot = CACHE_ADDR(opline->extended_value);
			uintptr_t prop_offset = (uintptr_t)CACHED_PTR_EX(cache_slot + 1);
			zval *property_val;

			if (EXPECTED(IS_VALID_PROPERTY_OFFSET(prop_offset))) {
				property_val = OBJ_PROP(zobj, prop_offset);
				if (C_TYPE_P(property_val) != IS_UNDEF) {
					crex_property_info *prop_info = (crex_property_info*) CACHED_PTR_EX(cache_slot + 2);

					if (UNEXPECTED(prop_info != NULL)) {
						value = crex_assign_to_typed_prop(prop_info, property_val, value, &garbage EXECUTE_DATA_CC);
						goto free_and_exit_assign_obj;
					} else {
fast_assign_obj:
						value = crex_assign_to_variable_ex(property_val, value, IS_CONST, EX_USES_STRICT_TYPES(), &garbage);
						if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
							ZVAL_COPY(EX_VAR(opline->result.var), value);
						}
						goto exit_assign_obj;
					}
				}
			} else {
				name = C_STR_P(RT_CONSTANT(opline, opline->op2));
				if (EXPECTED(zobj->properties != NULL)) {
					if (UNEXPECTED(GC_REFCOUNT(zobj->properties) > 1)) {
						if (EXPECTED(!(GC_FLAGS(zobj->properties) & IS_ARRAY_IMMUTABLE))) {
							GC_DELREF(zobj->properties);
						}
						zobj->properties = crex_array_dup(zobj->properties);
					}
					property_val = crex_hash_find_known_hash(zobj->properties, name);
					if (property_val) {
						goto fast_assign_obj;
					}
				}

				if (!zobj->ce->__set && (zobj->ce->ce_flags & CREX_ACC_ALLOW_DYNAMIC_PROPERTIES)) {
					if (EXPECTED(zobj->properties == NULL)) {
						rebuild_object_properties(zobj);
					}
					if (IS_CONST == IS_CONST) {
						if (UNEXPECTED(C_OPT_REFCOUNTED_P(value))) {
							C_ADDREF_P(value);
						}
					} else if (IS_CONST != IS_TMP_VAR) {
						if (C_ISREF_P(value)) {
							if (IS_CONST == IS_VAR) {
								crex_reference *ref = C_REF_P(value);
								if (GC_DELREF(ref) == 0) {
									ZVAL_COPY_VALUE(&tmp, C_REFVAL_P(value));
									efree_size(ref, sizeof(crex_reference));
									value = &tmp;
								} else {
									value = C_REFVAL_P(value);
									C_TRY_ADDREF_P(value);
								}
							} else {
								value = C_REFVAL_P(value);
								C_TRY_ADDREF_P(value);
							}
						} else if (IS_CONST == IS_CV) {
							C_TRY_ADDREF_P(value);
						}
						}
					crex_hash_add_new(zobj->properties, name, value);
					if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
						ZVAL_COPY(EX_VAR(opline->result.var), value);
					}
					goto exit_assign_obj;
				}
			}
		}
		name = C_STR_P(RT_CONSTANT(opline, opline->op2));
	} else {
		name = zval_try_get_tmp_string(RT_CONSTANT(opline, opline->op2), &tmp_name);
		if (UNEXPECTED(!name)) {

			UNDEF_RESULT();
			goto exit_assign_obj;
		}
	}

	if (IS_CONST == IS_CV || IS_CONST == IS_VAR) {
		ZVAL_DEREF(value);
	}

	value = zobj->handlers->write_property(zobj, name, value, (IS_CONST == IS_CONST) ? CACHE_ADDR(opline->extended_value) : NULL);

	if (IS_CONST != IS_CONST) {
		crex_tmp_string_release(tmp_name);
	}

free_and_exit_assign_obj:
	if (UNEXPECTED(RETURN_VALUE_USED(opline)) && value) {
		ZVAL_COPY_DEREF(EX_VAR(opline->result.var), value);
	}

exit_assign_obj:
	if (garbage) {
		GC_DTOR_NO_REF(garbage);
	}


	/* assign_obj has two opcodes! */
	CREX_VM_NEXT_OPCODE_EX(1, 2);
}

/* No specialization for op_types (CONST|TMPVAR|CV, UNUSED|CONST|VAR) */
static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ASSIGN_OBJ_SPEC_CV_CONST_OP_DATA_TMP_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *object, *value, tmp;
	crex_object *zobj;
	crex_string *name, *tmp_name;
	crex_refcounted *garbage = NULL;

	SAVE_OPLINE();
	object = EX_VAR(opline->op1.var);
	value = _get_zval_ptr_tmp((opline+1)->op1.var EXECUTE_DATA_CC);

	if (IS_CV != IS_UNUSED && UNEXPECTED(C_TYPE_P(object) != IS_OBJECT)) {
		if (C_ISREF_P(object) && C_TYPE_P(C_REFVAL_P(object)) == IS_OBJECT) {
			object = C_REFVAL_P(object);
			goto assign_object;
		}
		crex_throw_non_object_error(object, RT_CONSTANT(opline, opline->op2) OPLINE_CC EXECUTE_DATA_CC);
		value = &EG(uninitialized_zval);
		goto free_and_exit_assign_obj;
	}

assign_object:
	zobj = C_OBJ_P(object);
	if (IS_CONST == IS_CONST) {
		if (EXPECTED(zobj->ce == CACHED_PTR(opline->extended_value))) {
			void **cache_slot = CACHE_ADDR(opline->extended_value);
			uintptr_t prop_offset = (uintptr_t)CACHED_PTR_EX(cache_slot + 1);
			zval *property_val;

			if (EXPECTED(IS_VALID_PROPERTY_OFFSET(prop_offset))) {
				property_val = OBJ_PROP(zobj, prop_offset);
				if (C_TYPE_P(property_val) != IS_UNDEF) {
					crex_property_info *prop_info = (crex_property_info*) CACHED_PTR_EX(cache_slot + 2);

					if (UNEXPECTED(prop_info != NULL)) {
						value = crex_assign_to_typed_prop(prop_info, property_val, value, &garbage EXECUTE_DATA_CC);
						goto free_and_exit_assign_obj;
					} else {
fast_assign_obj:
						value = crex_assign_to_variable_ex(property_val, value, IS_TMP_VAR, EX_USES_STRICT_TYPES(), &garbage);
						if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
							ZVAL_COPY(EX_VAR(opline->result.var), value);
						}
						goto exit_assign_obj;
					}
				}
			} else {
				name = C_STR_P(RT_CONSTANT(opline, opline->op2));
				if (EXPECTED(zobj->properties != NULL)) {
					if (UNEXPECTED(GC_REFCOUNT(zobj->properties) > 1)) {
						if (EXPECTED(!(GC_FLAGS(zobj->properties) & IS_ARRAY_IMMUTABLE))) {
							GC_DELREF(zobj->properties);
						}
						zobj->properties = crex_array_dup(zobj->properties);
					}
					property_val = crex_hash_find_known_hash(zobj->properties, name);
					if (property_val) {
						goto fast_assign_obj;
					}
				}

				if (!zobj->ce->__set && (zobj->ce->ce_flags & CREX_ACC_ALLOW_DYNAMIC_PROPERTIES)) {
					if (EXPECTED(zobj->properties == NULL)) {
						rebuild_object_properties(zobj);
					}
					if (IS_TMP_VAR == IS_CONST) {
						if (UNEXPECTED(C_OPT_REFCOUNTED_P(value))) {
							C_ADDREF_P(value);
						}
					} else if (IS_TMP_VAR != IS_TMP_VAR) {
						if (C_ISREF_P(value)) {
							if (IS_TMP_VAR == IS_VAR) {
								crex_reference *ref = C_REF_P(value);
								if (GC_DELREF(ref) == 0) {
									ZVAL_COPY_VALUE(&tmp, C_REFVAL_P(value));
									efree_size(ref, sizeof(crex_reference));
									value = &tmp;
								} else {
									value = C_REFVAL_P(value);
									C_TRY_ADDREF_P(value);
								}
							} else {
								value = C_REFVAL_P(value);
								C_TRY_ADDREF_P(value);
							}
						} else if (IS_TMP_VAR == IS_CV) {
							C_TRY_ADDREF_P(value);
						}
						}
					crex_hash_add_new(zobj->properties, name, value);
					if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
						ZVAL_COPY(EX_VAR(opline->result.var), value);
					}
					goto exit_assign_obj;
				}
			}
		}
		name = C_STR_P(RT_CONSTANT(opline, opline->op2));
	} else {
		name = zval_try_get_tmp_string(RT_CONSTANT(opline, opline->op2), &tmp_name);
		if (UNEXPECTED(!name)) {
			zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
			UNDEF_RESULT();
			goto exit_assign_obj;
		}
	}

	if (IS_TMP_VAR == IS_CV || IS_TMP_VAR == IS_VAR) {
		ZVAL_DEREF(value);
	}

	value = zobj->handlers->write_property(zobj, name, value, (IS_CONST == IS_CONST) ? CACHE_ADDR(opline->extended_value) : NULL);

	if (IS_CONST != IS_CONST) {
		crex_tmp_string_release(tmp_name);
	}

free_and_exit_assign_obj:
	if (UNEXPECTED(RETURN_VALUE_USED(opline)) && value) {
		ZVAL_COPY_DEREF(EX_VAR(opline->result.var), value);
	}
	zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
exit_assign_obj:
	if (garbage) {
		GC_DTOR_NO_REF(garbage);
	}


	/* assign_obj has two opcodes! */
	CREX_VM_NEXT_OPCODE_EX(1, 2);
}

/* No specialization for op_types (CONST|TMPVAR|CV, UNUSED|CONST|VAR) */
static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ASSIGN_OBJ_SPEC_CV_CONST_OP_DATA_VAR_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *object, *value, tmp;
	crex_object *zobj;
	crex_string *name, *tmp_name;
	crex_refcounted *garbage = NULL;

	SAVE_OPLINE();
	object = EX_VAR(opline->op1.var);
	value = _get_zval_ptr_var((opline+1)->op1.var EXECUTE_DATA_CC);

	if (IS_CV != IS_UNUSED && UNEXPECTED(C_TYPE_P(object) != IS_OBJECT)) {
		if (C_ISREF_P(object) && C_TYPE_P(C_REFVAL_P(object)) == IS_OBJECT) {
			object = C_REFVAL_P(object);
			goto assign_object;
		}
		crex_throw_non_object_error(object, RT_CONSTANT(opline, opline->op2) OPLINE_CC EXECUTE_DATA_CC);
		value = &EG(uninitialized_zval);
		goto free_and_exit_assign_obj;
	}

assign_object:
	zobj = C_OBJ_P(object);
	if (IS_CONST == IS_CONST) {
		if (EXPECTED(zobj->ce == CACHED_PTR(opline->extended_value))) {
			void **cache_slot = CACHE_ADDR(opline->extended_value);
			uintptr_t prop_offset = (uintptr_t)CACHED_PTR_EX(cache_slot + 1);
			zval *property_val;

			if (EXPECTED(IS_VALID_PROPERTY_OFFSET(prop_offset))) {
				property_val = OBJ_PROP(zobj, prop_offset);
				if (C_TYPE_P(property_val) != IS_UNDEF) {
					crex_property_info *prop_info = (crex_property_info*) CACHED_PTR_EX(cache_slot + 2);

					if (UNEXPECTED(prop_info != NULL)) {
						value = crex_assign_to_typed_prop(prop_info, property_val, value, &garbage EXECUTE_DATA_CC);
						goto free_and_exit_assign_obj;
					} else {
fast_assign_obj:
						value = crex_assign_to_variable_ex(property_val, value, IS_VAR, EX_USES_STRICT_TYPES(), &garbage);
						if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
							ZVAL_COPY(EX_VAR(opline->result.var), value);
						}
						goto exit_assign_obj;
					}
				}
			} else {
				name = C_STR_P(RT_CONSTANT(opline, opline->op2));
				if (EXPECTED(zobj->properties != NULL)) {
					if (UNEXPECTED(GC_REFCOUNT(zobj->properties) > 1)) {
						if (EXPECTED(!(GC_FLAGS(zobj->properties) & IS_ARRAY_IMMUTABLE))) {
							GC_DELREF(zobj->properties);
						}
						zobj->properties = crex_array_dup(zobj->properties);
					}
					property_val = crex_hash_find_known_hash(zobj->properties, name);
					if (property_val) {
						goto fast_assign_obj;
					}
				}

				if (!zobj->ce->__set && (zobj->ce->ce_flags & CREX_ACC_ALLOW_DYNAMIC_PROPERTIES)) {
					if (EXPECTED(zobj->properties == NULL)) {
						rebuild_object_properties(zobj);
					}
					if (IS_VAR == IS_CONST) {
						if (UNEXPECTED(C_OPT_REFCOUNTED_P(value))) {
							C_ADDREF_P(value);
						}
					} else if (IS_VAR != IS_TMP_VAR) {
						if (C_ISREF_P(value)) {
							if (IS_VAR == IS_VAR) {
								crex_reference *ref = C_REF_P(value);
								if (GC_DELREF(ref) == 0) {
									ZVAL_COPY_VALUE(&tmp, C_REFVAL_P(value));
									efree_size(ref, sizeof(crex_reference));
									value = &tmp;
								} else {
									value = C_REFVAL_P(value);
									C_TRY_ADDREF_P(value);
								}
							} else {
								value = C_REFVAL_P(value);
								C_TRY_ADDREF_P(value);
							}
						} else if (IS_VAR == IS_CV) {
							C_TRY_ADDREF_P(value);
						}
						}
					crex_hash_add_new(zobj->properties, name, value);
					if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
						ZVAL_COPY(EX_VAR(opline->result.var), value);
					}
					goto exit_assign_obj;
				}
			}
		}
		name = C_STR_P(RT_CONSTANT(opline, opline->op2));
	} else {
		name = zval_try_get_tmp_string(RT_CONSTANT(opline, opline->op2), &tmp_name);
		if (UNEXPECTED(!name)) {
			zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
			UNDEF_RESULT();
			goto exit_assign_obj;
		}
	}

	if (IS_VAR == IS_CV || IS_VAR == IS_VAR) {
		ZVAL_DEREF(value);
	}

	value = zobj->handlers->write_property(zobj, name, value, (IS_CONST == IS_CONST) ? CACHE_ADDR(opline->extended_value) : NULL);

	if (IS_CONST != IS_CONST) {
		crex_tmp_string_release(tmp_name);
	}

free_and_exit_assign_obj:
	if (UNEXPECTED(RETURN_VALUE_USED(opline)) && value) {
		ZVAL_COPY_DEREF(EX_VAR(opline->result.var), value);
	}
	zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
exit_assign_obj:
	if (garbage) {
		GC_DTOR_NO_REF(garbage);
	}


	/* assign_obj has two opcodes! */
	CREX_VM_NEXT_OPCODE_EX(1, 2);
}

/* No specialization for op_types (CONST|TMPVAR|CV, UNUSED|CONST|VAR) */
static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ASSIGN_OBJ_SPEC_CV_CONST_OP_DATA_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *object, *value, tmp;
	crex_object *zobj;
	crex_string *name, *tmp_name;
	crex_refcounted *garbage = NULL;

	SAVE_OPLINE();
	object = EX_VAR(opline->op1.var);
	value = _get_zval_ptr_cv_BP_VAR_R((opline+1)->op1.var EXECUTE_DATA_CC);

	if (IS_CV != IS_UNUSED && UNEXPECTED(C_TYPE_P(object) != IS_OBJECT)) {
		if (C_ISREF_P(object) && C_TYPE_P(C_REFVAL_P(object)) == IS_OBJECT) {
			object = C_REFVAL_P(object);
			goto assign_object;
		}
		crex_throw_non_object_error(object, RT_CONSTANT(opline, opline->op2) OPLINE_CC EXECUTE_DATA_CC);
		value = &EG(uninitialized_zval);
		goto free_and_exit_assign_obj;
	}

assign_object:
	zobj = C_OBJ_P(object);
	if (IS_CONST == IS_CONST) {
		if (EXPECTED(zobj->ce == CACHED_PTR(opline->extended_value))) {
			void **cache_slot = CACHE_ADDR(opline->extended_value);
			uintptr_t prop_offset = (uintptr_t)CACHED_PTR_EX(cache_slot + 1);
			zval *property_val;

			if (EXPECTED(IS_VALID_PROPERTY_OFFSET(prop_offset))) {
				property_val = OBJ_PROP(zobj, prop_offset);
				if (C_TYPE_P(property_val) != IS_UNDEF) {
					crex_property_info *prop_info = (crex_property_info*) CACHED_PTR_EX(cache_slot + 2);

					if (UNEXPECTED(prop_info != NULL)) {
						value = crex_assign_to_typed_prop(prop_info, property_val, value, &garbage EXECUTE_DATA_CC);
						goto free_and_exit_assign_obj;
					} else {
fast_assign_obj:
						value = crex_assign_to_variable_ex(property_val, value, IS_CV, EX_USES_STRICT_TYPES(), &garbage);
						if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
							ZVAL_COPY(EX_VAR(opline->result.var), value);
						}
						goto exit_assign_obj;
					}
				}
			} else {
				name = C_STR_P(RT_CONSTANT(opline, opline->op2));
				if (EXPECTED(zobj->properties != NULL)) {
					if (UNEXPECTED(GC_REFCOUNT(zobj->properties) > 1)) {
						if (EXPECTED(!(GC_FLAGS(zobj->properties) & IS_ARRAY_IMMUTABLE))) {
							GC_DELREF(zobj->properties);
						}
						zobj->properties = crex_array_dup(zobj->properties);
					}
					property_val = crex_hash_find_known_hash(zobj->properties, name);
					if (property_val) {
						goto fast_assign_obj;
					}
				}

				if (!zobj->ce->__set && (zobj->ce->ce_flags & CREX_ACC_ALLOW_DYNAMIC_PROPERTIES)) {
					if (EXPECTED(zobj->properties == NULL)) {
						rebuild_object_properties(zobj);
					}
					if (IS_CV == IS_CONST) {
						if (UNEXPECTED(C_OPT_REFCOUNTED_P(value))) {
							C_ADDREF_P(value);
						}
					} else if (IS_CV != IS_TMP_VAR) {
						if (C_ISREF_P(value)) {
							if (IS_CV == IS_VAR) {
								crex_reference *ref = C_REF_P(value);
								if (GC_DELREF(ref) == 0) {
									ZVAL_COPY_VALUE(&tmp, C_REFVAL_P(value));
									efree_size(ref, sizeof(crex_reference));
									value = &tmp;
								} else {
									value = C_REFVAL_P(value);
									C_TRY_ADDREF_P(value);
								}
							} else {
								value = C_REFVAL_P(value);
								C_TRY_ADDREF_P(value);
							}
						} else if (IS_CV == IS_CV) {
							C_TRY_ADDREF_P(value);
						}
						}
					crex_hash_add_new(zobj->properties, name, value);
					if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
						ZVAL_COPY(EX_VAR(opline->result.var), value);
					}
					goto exit_assign_obj;
				}
			}
		}
		name = C_STR_P(RT_CONSTANT(opline, opline->op2));
	} else {
		name = zval_try_get_tmp_string(RT_CONSTANT(opline, opline->op2), &tmp_name);
		if (UNEXPECTED(!name)) {

			UNDEF_RESULT();
			goto exit_assign_obj;
		}
	}

	if (IS_CV == IS_CV || IS_CV == IS_VAR) {
		ZVAL_DEREF(value);
	}

	value = zobj->handlers->write_property(zobj, name, value, (IS_CONST == IS_CONST) ? CACHE_ADDR(opline->extended_value) : NULL);

	if (IS_CONST != IS_CONST) {
		crex_tmp_string_release(tmp_name);
	}

free_and_exit_assign_obj:
	if (UNEXPECTED(RETURN_VALUE_USED(opline)) && value) {
		ZVAL_COPY_DEREF(EX_VAR(opline->result.var), value);
	}

exit_assign_obj:
	if (garbage) {
		GC_DTOR_NO_REF(garbage);
	}


	/* assign_obj has two opcodes! */
	CREX_VM_NEXT_OPCODE_EX(1, 2);
}

/* No specialization for op_types (CONST|TMPVAR|CV, UNUSED|CONST|VAR) */
static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ASSIGN_DIM_SPEC_CV_CONST_OP_DATA_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *object_ptr, *orig_object_ptr;
	zval *value;
	zval *variable_ptr;
	zval *dim;
	crex_refcounted *garbage = NULL;

	SAVE_OPLINE();
	orig_object_ptr = object_ptr = EX_VAR(opline->op1.var);

	if (EXPECTED(C_TYPE_P(object_ptr) == IS_ARRAY)) {
try_assign_dim_array:
		SEPARATE_ARRAY(object_ptr);
		if (IS_CONST == IS_UNUSED) {
			value = RT_CONSTANT((opline+1), (opline+1)->op1);
			if (IS_CONST == IS_CV && UNEXPECTED(C_TYPE_P(value) == IS_UNDEF)) {
				HashTable *ht = C_ARRVAL_P(object_ptr);
				if (!(GC_FLAGS(ht) & IS_ARRAY_IMMUTABLE)) {
					GC_ADDREF(ht);
				}
				value = zval_undefined_cv((opline+1)->op1.var EXECUTE_DATA_CC);
				if (!(GC_FLAGS(ht) & IS_ARRAY_IMMUTABLE) && !GC_DELREF(ht)) {
					crex_array_destroy(ht);
					goto assign_dim_error;
				}
			}
			if (IS_CONST == IS_CV || IS_CONST == IS_VAR) {
				ZVAL_DEREF(value);
			}
			value = crex_hash_next_index_insert(C_ARRVAL_P(object_ptr), value);
			if (UNEXPECTED(value == NULL)) {
				crex_cannot_add_element();
				goto assign_dim_error;
			} else if (IS_CONST == IS_CV) {
				if (C_REFCOUNTED_P(value)) {
					C_ADDREF_P(value);
				}
			} else if (IS_CONST == IS_VAR) {
				zval *free_op_data = EX_VAR((opline+1)->op1.var);
				if (C_ISREF_P(free_op_data)) {
					if (C_REFCOUNTED_P(value)) {
						C_ADDREF_P(value);
					}
					zval_ptr_dtor_nogc(free_op_data);
				}
			} else if (IS_CONST == IS_CONST) {
				if (UNEXPECTED(C_REFCOUNTED_P(value))) {
					C_ADDREF_P(value);
				}
			}
		} else {
			dim = RT_CONSTANT(opline, opline->op2);
			if (IS_CONST == IS_CONST) {
				variable_ptr = crex_fetch_dimension_address_inner_W_CONST(C_ARRVAL_P(object_ptr), dim EXECUTE_DATA_CC);
			} else {
				variable_ptr = crex_fetch_dimension_address_inner_W(C_ARRVAL_P(object_ptr), dim EXECUTE_DATA_CC);
			}
			if (UNEXPECTED(variable_ptr == NULL)) {
				goto assign_dim_error;
			}
			value = RT_CONSTANT((opline+1), (opline+1)->op1);
			value = crex_assign_to_variable_ex(variable_ptr, value, IS_CONST, EX_USES_STRICT_TYPES(), &garbage);
		}
		if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
			ZVAL_COPY(EX_VAR(opline->result.var), value);
		}
		if (garbage) {
			GC_DTOR_NO_REF(garbage);
		}
	} else {
		if (EXPECTED(C_ISREF_P(object_ptr))) {
			object_ptr = C_REFVAL_P(object_ptr);
			if (EXPECTED(C_TYPE_P(object_ptr) == IS_ARRAY)) {
				goto try_assign_dim_array;
			}
		}
		if (EXPECTED(C_TYPE_P(object_ptr) == IS_OBJECT)) {
			crex_object *obj = C_OBJ_P(object_ptr);

			GC_ADDREF(obj);
			dim = RT_CONSTANT(opline, opline->op2);
			if (IS_CONST == IS_CV && UNEXPECTED(C_ISUNDEF_P(dim))) {
				dim = ZVAL_UNDEFINED_OP2();
			} else if (IS_CONST == IS_CONST && C_EXTRA_P(dim) == CREX_EXTRA_VALUE) {
				dim++;
			}

			value = RT_CONSTANT((opline+1), (opline+1)->op1);
			if (IS_CONST == IS_CV && UNEXPECTED(C_ISUNDEF_P(value))) {
				value = zval_undefined_cv((opline+1)->op1.var EXECUTE_DATA_CC);
			} else if (IS_CONST & (IS_CV|IS_VAR)) {
				ZVAL_DEREF(value);
			}

			crex_assign_to_object_dim(obj, dim, value OPLINE_CC EXECUTE_DATA_CC);

			if (UNEXPECTED(GC_DELREF(obj) == 0)) {
				crex_objects_store_del(obj);
			}
		} else if (EXPECTED(C_TYPE_P(object_ptr) == IS_STRING)) {
			if (IS_CONST == IS_UNUSED) {
				crex_use_new_element_for_string();

				UNDEF_RESULT();
			} else {
				dim = RT_CONSTANT(opline, opline->op2);
				value = RT_CONSTANT((opline+1), (opline+1)->op1);
				crex_assign_to_string_offset(object_ptr, dim, value OPLINE_CC EXECUTE_DATA_CC);

			}
		} else if (EXPECTED(C_TYPE_P(object_ptr) <= IS_FALSE)) {
			if (C_ISREF_P(orig_object_ptr)
			 && CREX_REF_HAS_TYPE_SOURCES(C_REF_P(orig_object_ptr))
			 && !crex_verify_ref_array_assignable(C_REF_P(orig_object_ptr))) {
				dim = RT_CONSTANT(opline, opline->op2);

				UNDEF_RESULT();
			} else {
				HashTable *ht = crex_new_array(8);
				uint8_t old_type = C_TYPE_P(object_ptr);

				ZVAL_ARR(object_ptr, ht);
				if (UNEXPECTED(old_type == IS_FALSE)) {
					GC_ADDREF(ht);
					crex_false_to_array_deprecated();
					if (UNEXPECTED(GC_DELREF(ht) == 0)) {
						crex_array_destroy(ht);
						goto assign_dim_error;
					}
				}
				goto try_assign_dim_array;
			}
		} else {
			crex_use_scalar_as_array();
			dim = RT_CONSTANT(opline, opline->op2);
assign_dim_error:

			if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
				ZVAL_NULL(EX_VAR(opline->result.var));
			}
		}
	}
	if (IS_CONST != IS_UNUSED) {

	}

	/* assign_dim has two opcodes! */
	CREX_VM_NEXT_OPCODE_EX(1, 2);
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ASSIGN_DIM_SPEC_CV_CONST_OP_DATA_TMP_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *object_ptr, *orig_object_ptr;
	zval *value;
	zval *variable_ptr;
	zval *dim;
	crex_refcounted *garbage = NULL;

	SAVE_OPLINE();
	orig_object_ptr = object_ptr = EX_VAR(opline->op1.var);

	if (EXPECTED(C_TYPE_P(object_ptr) == IS_ARRAY)) {
try_assign_dim_array:
		SEPARATE_ARRAY(object_ptr);
		if (IS_CONST == IS_UNUSED) {
			value = _get_zval_ptr_tmp((opline+1)->op1.var EXECUTE_DATA_CC);
			if (IS_TMP_VAR == IS_CV && UNEXPECTED(C_TYPE_P(value) == IS_UNDEF)) {
				HashTable *ht = C_ARRVAL_P(object_ptr);
				if (!(GC_FLAGS(ht) & IS_ARRAY_IMMUTABLE)) {
					GC_ADDREF(ht);
				}
				value = zval_undefined_cv((opline+1)->op1.var EXECUTE_DATA_CC);
				if (!(GC_FLAGS(ht) & IS_ARRAY_IMMUTABLE) && !GC_DELREF(ht)) {
					crex_array_destroy(ht);
					goto assign_dim_error;
				}
			}
			if (IS_TMP_VAR == IS_CV || IS_TMP_VAR == IS_VAR) {
				ZVAL_DEREF(value);
			}
			value = crex_hash_next_index_insert(C_ARRVAL_P(object_ptr), value);
			if (UNEXPECTED(value == NULL)) {
				crex_cannot_add_element();
				goto assign_dim_error;
			} else if (IS_TMP_VAR == IS_CV) {
				if (C_REFCOUNTED_P(value)) {
					C_ADDREF_P(value);
				}
			} else if (IS_TMP_VAR == IS_VAR) {
				zval *free_op_data = EX_VAR((opline+1)->op1.var);
				if (C_ISREF_P(free_op_data)) {
					if (C_REFCOUNTED_P(value)) {
						C_ADDREF_P(value);
					}
					zval_ptr_dtor_nogc(free_op_data);
				}
			} else if (IS_TMP_VAR == IS_CONST) {
				if (UNEXPECTED(C_REFCOUNTED_P(value))) {
					C_ADDREF_P(value);
				}
			}
		} else {
			dim = RT_CONSTANT(opline, opline->op2);
			if (IS_CONST == IS_CONST) {
				variable_ptr = crex_fetch_dimension_address_inner_W_CONST(C_ARRVAL_P(object_ptr), dim EXECUTE_DATA_CC);
			} else {
				variable_ptr = crex_fetch_dimension_address_inner_W(C_ARRVAL_P(object_ptr), dim EXECUTE_DATA_CC);
			}
			if (UNEXPECTED(variable_ptr == NULL)) {
				goto assign_dim_error;
			}
			value = _get_zval_ptr_tmp((opline+1)->op1.var EXECUTE_DATA_CC);
			value = crex_assign_to_variable_ex(variable_ptr, value, IS_TMP_VAR, EX_USES_STRICT_TYPES(), &garbage);
		}
		if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
			ZVAL_COPY(EX_VAR(opline->result.var), value);
		}
		if (garbage) {
			GC_DTOR_NO_REF(garbage);
		}
	} else {
		if (EXPECTED(C_ISREF_P(object_ptr))) {
			object_ptr = C_REFVAL_P(object_ptr);
			if (EXPECTED(C_TYPE_P(object_ptr) == IS_ARRAY)) {
				goto try_assign_dim_array;
			}
		}
		if (EXPECTED(C_TYPE_P(object_ptr) == IS_OBJECT)) {
			crex_object *obj = C_OBJ_P(object_ptr);

			GC_ADDREF(obj);
			dim = RT_CONSTANT(opline, opline->op2);
			if (IS_CONST == IS_CV && UNEXPECTED(C_ISUNDEF_P(dim))) {
				dim = ZVAL_UNDEFINED_OP2();
			} else if (IS_CONST == IS_CONST && C_EXTRA_P(dim) == CREX_EXTRA_VALUE) {
				dim++;
			}

			value = _get_zval_ptr_tmp((opline+1)->op1.var EXECUTE_DATA_CC);
			if (IS_TMP_VAR == IS_CV && UNEXPECTED(C_ISUNDEF_P(value))) {
				value = zval_undefined_cv((opline+1)->op1.var EXECUTE_DATA_CC);
			} else if (IS_TMP_VAR & (IS_CV|IS_VAR)) {
				ZVAL_DEREF(value);
			}

			crex_assign_to_object_dim(obj, dim, value OPLINE_CC EXECUTE_DATA_CC);

			zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
			if (UNEXPECTED(GC_DELREF(obj) == 0)) {
				crex_objects_store_del(obj);
			}
		} else if (EXPECTED(C_TYPE_P(object_ptr) == IS_STRING)) {
			if (IS_CONST == IS_UNUSED) {
				crex_use_new_element_for_string();
				zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
				UNDEF_RESULT();
			} else {
				dim = RT_CONSTANT(opline, opline->op2);
				value = _get_zval_ptr_tmp((opline+1)->op1.var EXECUTE_DATA_CC);
				crex_assign_to_string_offset(object_ptr, dim, value OPLINE_CC EXECUTE_DATA_CC);
				zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
			}
		} else if (EXPECTED(C_TYPE_P(object_ptr) <= IS_FALSE)) {
			if (C_ISREF_P(orig_object_ptr)
			 && CREX_REF_HAS_TYPE_SOURCES(C_REF_P(orig_object_ptr))
			 && !crex_verify_ref_array_assignable(C_REF_P(orig_object_ptr))) {
				dim = RT_CONSTANT(opline, opline->op2);
				zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
				UNDEF_RESULT();
			} else {
				HashTable *ht = crex_new_array(8);
				uint8_t old_type = C_TYPE_P(object_ptr);

				ZVAL_ARR(object_ptr, ht);
				if (UNEXPECTED(old_type == IS_FALSE)) {
					GC_ADDREF(ht);
					crex_false_to_array_deprecated();
					if (UNEXPECTED(GC_DELREF(ht) == 0)) {
						crex_array_destroy(ht);
						goto assign_dim_error;
					}
				}
				goto try_assign_dim_array;
			}
		} else {
			crex_use_scalar_as_array();
			dim = RT_CONSTANT(opline, opline->op2);
assign_dim_error:
			zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
			if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
				ZVAL_NULL(EX_VAR(opline->result.var));
			}
		}
	}
	if (IS_CONST != IS_UNUSED) {

	}

	/* assign_dim has two opcodes! */
	CREX_VM_NEXT_OPCODE_EX(1, 2);
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ASSIGN_DIM_SPEC_CV_CONST_OP_DATA_VAR_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *object_ptr, *orig_object_ptr;
	zval *value;
	zval *variable_ptr;
	zval *dim;
	crex_refcounted *garbage = NULL;

	SAVE_OPLINE();
	orig_object_ptr = object_ptr = EX_VAR(opline->op1.var);

	if (EXPECTED(C_TYPE_P(object_ptr) == IS_ARRAY)) {
try_assign_dim_array:
		SEPARATE_ARRAY(object_ptr);
		if (IS_CONST == IS_UNUSED) {
			value = _get_zval_ptr_var((opline+1)->op1.var EXECUTE_DATA_CC);
			if (IS_VAR == IS_CV && UNEXPECTED(C_TYPE_P(value) == IS_UNDEF)) {
				HashTable *ht = C_ARRVAL_P(object_ptr);
				if (!(GC_FLAGS(ht) & IS_ARRAY_IMMUTABLE)) {
					GC_ADDREF(ht);
				}
				value = zval_undefined_cv((opline+1)->op1.var EXECUTE_DATA_CC);
				if (!(GC_FLAGS(ht) & IS_ARRAY_IMMUTABLE) && !GC_DELREF(ht)) {
					crex_array_destroy(ht);
					goto assign_dim_error;
				}
			}
			if (IS_VAR == IS_CV || IS_VAR == IS_VAR) {
				ZVAL_DEREF(value);
			}
			value = crex_hash_next_index_insert(C_ARRVAL_P(object_ptr), value);
			if (UNEXPECTED(value == NULL)) {
				crex_cannot_add_element();
				goto assign_dim_error;
			} else if (IS_VAR == IS_CV) {
				if (C_REFCOUNTED_P(value)) {
					C_ADDREF_P(value);
				}
			} else if (IS_VAR == IS_VAR) {
				zval *free_op_data = EX_VAR((opline+1)->op1.var);
				if (C_ISREF_P(free_op_data)) {
					if (C_REFCOUNTED_P(value)) {
						C_ADDREF_P(value);
					}
					zval_ptr_dtor_nogc(free_op_data);
				}
			} else if (IS_VAR == IS_CONST) {
				if (UNEXPECTED(C_REFCOUNTED_P(value))) {
					C_ADDREF_P(value);
				}
			}
		} else {
			dim = RT_CONSTANT(opline, opline->op2);
			if (IS_CONST == IS_CONST) {
				variable_ptr = crex_fetch_dimension_address_inner_W_CONST(C_ARRVAL_P(object_ptr), dim EXECUTE_DATA_CC);
			} else {
				variable_ptr = crex_fetch_dimension_address_inner_W(C_ARRVAL_P(object_ptr), dim EXECUTE_DATA_CC);
			}
			if (UNEXPECTED(variable_ptr == NULL)) {
				goto assign_dim_error;
			}
			value = _get_zval_ptr_var((opline+1)->op1.var EXECUTE_DATA_CC);
			value = crex_assign_to_variable_ex(variable_ptr, value, IS_VAR, EX_USES_STRICT_TYPES(), &garbage);
		}
		if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
			ZVAL_COPY(EX_VAR(opline->result.var), value);
		}
		if (garbage) {
			GC_DTOR_NO_REF(garbage);
		}
	} else {
		if (EXPECTED(C_ISREF_P(object_ptr))) {
			object_ptr = C_REFVAL_P(object_ptr);
			if (EXPECTED(C_TYPE_P(object_ptr) == IS_ARRAY)) {
				goto try_assign_dim_array;
			}
		}
		if (EXPECTED(C_TYPE_P(object_ptr) == IS_OBJECT)) {
			crex_object *obj = C_OBJ_P(object_ptr);

			GC_ADDREF(obj);
			dim = RT_CONSTANT(opline, opline->op2);
			if (IS_CONST == IS_CV && UNEXPECTED(C_ISUNDEF_P(dim))) {
				dim = ZVAL_UNDEFINED_OP2();
			} else if (IS_CONST == IS_CONST && C_EXTRA_P(dim) == CREX_EXTRA_VALUE) {
				dim++;
			}

			value = _get_zval_ptr_var((opline+1)->op1.var EXECUTE_DATA_CC);
			if (IS_VAR == IS_CV && UNEXPECTED(C_ISUNDEF_P(value))) {
				value = zval_undefined_cv((opline+1)->op1.var EXECUTE_DATA_CC);
			} else if (IS_VAR & (IS_CV|IS_VAR)) {
				ZVAL_DEREF(value);
			}

			crex_assign_to_object_dim(obj, dim, value OPLINE_CC EXECUTE_DATA_CC);

			zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
			if (UNEXPECTED(GC_DELREF(obj) == 0)) {
				crex_objects_store_del(obj);
			}
		} else if (EXPECTED(C_TYPE_P(object_ptr) == IS_STRING)) {
			if (IS_CONST == IS_UNUSED) {
				crex_use_new_element_for_string();
				zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
				UNDEF_RESULT();
			} else {
				dim = RT_CONSTANT(opline, opline->op2);
				value = _get_zval_ptr_var((opline+1)->op1.var EXECUTE_DATA_CC);
				crex_assign_to_string_offset(object_ptr, dim, value OPLINE_CC EXECUTE_DATA_CC);
				zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
			}
		} else if (EXPECTED(C_TYPE_P(object_ptr) <= IS_FALSE)) {
			if (C_ISREF_P(orig_object_ptr)
			 && CREX_REF_HAS_TYPE_SOURCES(C_REF_P(orig_object_ptr))
			 && !crex_verify_ref_array_assignable(C_REF_P(orig_object_ptr))) {
				dim = RT_CONSTANT(opline, opline->op2);
				zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
				UNDEF_RESULT();
			} else {
				HashTable *ht = crex_new_array(8);
				uint8_t old_type = C_TYPE_P(object_ptr);

				ZVAL_ARR(object_ptr, ht);
				if (UNEXPECTED(old_type == IS_FALSE)) {
					GC_ADDREF(ht);
					crex_false_to_array_deprecated();
					if (UNEXPECTED(GC_DELREF(ht) == 0)) {
						crex_array_destroy(ht);
						goto assign_dim_error;
					}
				}
				goto try_assign_dim_array;
			}
		} else {
			crex_use_scalar_as_array();
			dim = RT_CONSTANT(opline, opline->op2);
assign_dim_error:
			zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
			if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
				ZVAL_NULL(EX_VAR(opline->result.var));
			}
		}
	}
	if (IS_CONST != IS_UNUSED) {

	}

	/* assign_dim has two opcodes! */
	CREX_VM_NEXT_OPCODE_EX(1, 2);
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ASSIGN_DIM_SPEC_CV_CONST_OP_DATA_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *object_ptr, *orig_object_ptr;
	zval *value;
	zval *variable_ptr;
	zval *dim;
	crex_refcounted *garbage = NULL;

	SAVE_OPLINE();
	orig_object_ptr = object_ptr = EX_VAR(opline->op1.var);

	if (EXPECTED(C_TYPE_P(object_ptr) == IS_ARRAY)) {
try_assign_dim_array:
		SEPARATE_ARRAY(object_ptr);
		if (IS_CONST == IS_UNUSED) {
			value = EX_VAR((opline+1)->op1.var);
			if (IS_CV == IS_CV && UNEXPECTED(C_TYPE_P(value) == IS_UNDEF)) {
				HashTable *ht = C_ARRVAL_P(object_ptr);
				if (!(GC_FLAGS(ht) & IS_ARRAY_IMMUTABLE)) {
					GC_ADDREF(ht);
				}
				value = zval_undefined_cv((opline+1)->op1.var EXECUTE_DATA_CC);
				if (!(GC_FLAGS(ht) & IS_ARRAY_IMMUTABLE) && !GC_DELREF(ht)) {
					crex_array_destroy(ht);
					goto assign_dim_error;
				}
			}
			if (IS_CV == IS_CV || IS_CV == IS_VAR) {
				ZVAL_DEREF(value);
			}
			value = crex_hash_next_index_insert(C_ARRVAL_P(object_ptr), value);
			if (UNEXPECTED(value == NULL)) {
				crex_cannot_add_element();
				goto assign_dim_error;
			} else if (IS_CV == IS_CV) {
				if (C_REFCOUNTED_P(value)) {
					C_ADDREF_P(value);
				}
			} else if (IS_CV == IS_VAR) {
				zval *free_op_data = EX_VAR((opline+1)->op1.var);
				if (C_ISREF_P(free_op_data)) {
					if (C_REFCOUNTED_P(value)) {
						C_ADDREF_P(value);
					}
					zval_ptr_dtor_nogc(free_op_data);
				}
			} else if (IS_CV == IS_CONST) {
				if (UNEXPECTED(C_REFCOUNTED_P(value))) {
					C_ADDREF_P(value);
				}
			}
		} else {
			dim = RT_CONSTANT(opline, opline->op2);
			if (IS_CONST == IS_CONST) {
				variable_ptr = crex_fetch_dimension_address_inner_W_CONST(C_ARRVAL_P(object_ptr), dim EXECUTE_DATA_CC);
			} else {
				variable_ptr = crex_fetch_dimension_address_inner_W(C_ARRVAL_P(object_ptr), dim EXECUTE_DATA_CC);
			}
			if (UNEXPECTED(variable_ptr == NULL)) {
				goto assign_dim_error;
			}
			value = _get_zval_ptr_cv_BP_VAR_R((opline+1)->op1.var EXECUTE_DATA_CC);
			value = crex_assign_to_variable_ex(variable_ptr, value, IS_CV, EX_USES_STRICT_TYPES(), &garbage);
		}
		if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
			ZVAL_COPY(EX_VAR(opline->result.var), value);
		}
		if (garbage) {
			GC_DTOR_NO_REF(garbage);
		}
	} else {
		if (EXPECTED(C_ISREF_P(object_ptr))) {
			object_ptr = C_REFVAL_P(object_ptr);
			if (EXPECTED(C_TYPE_P(object_ptr) == IS_ARRAY)) {
				goto try_assign_dim_array;
			}
		}
		if (EXPECTED(C_TYPE_P(object_ptr) == IS_OBJECT)) {
			crex_object *obj = C_OBJ_P(object_ptr);

			GC_ADDREF(obj);
			dim = RT_CONSTANT(opline, opline->op2);
			if (IS_CONST == IS_CV && UNEXPECTED(C_ISUNDEF_P(dim))) {
				dim = ZVAL_UNDEFINED_OP2();
			} else if (IS_CONST == IS_CONST && C_EXTRA_P(dim) == CREX_EXTRA_VALUE) {
				dim++;
			}

			value = EX_VAR((opline+1)->op1.var);
			if (IS_CV == IS_CV && UNEXPECTED(C_ISUNDEF_P(value))) {
				value = zval_undefined_cv((opline+1)->op1.var EXECUTE_DATA_CC);
			} else if (IS_CV & (IS_CV|IS_VAR)) {
				ZVAL_DEREF(value);
			}

			crex_assign_to_object_dim(obj, dim, value OPLINE_CC EXECUTE_DATA_CC);

			if (UNEXPECTED(GC_DELREF(obj) == 0)) {
				crex_objects_store_del(obj);
			}
		} else if (EXPECTED(C_TYPE_P(object_ptr) == IS_STRING)) {
			if (IS_CONST == IS_UNUSED) {
				crex_use_new_element_for_string();

				UNDEF_RESULT();
			} else {
				dim = RT_CONSTANT(opline, opline->op2);
				value = EX_VAR((opline+1)->op1.var);
				crex_assign_to_string_offset(object_ptr, dim, value OPLINE_CC EXECUTE_DATA_CC);

			}
		} else if (EXPECTED(C_TYPE_P(object_ptr) <= IS_FALSE)) {
			if (C_ISREF_P(orig_object_ptr)
			 && CREX_REF_HAS_TYPE_SOURCES(C_REF_P(orig_object_ptr))
			 && !crex_verify_ref_array_assignable(C_REF_P(orig_object_ptr))) {
				dim = RT_CONSTANT(opline, opline->op2);

				UNDEF_RESULT();
			} else {
				HashTable *ht = crex_new_array(8);
				uint8_t old_type = C_TYPE_P(object_ptr);

				ZVAL_ARR(object_ptr, ht);
				if (UNEXPECTED(old_type == IS_FALSE)) {
					GC_ADDREF(ht);
					crex_false_to_array_deprecated();
					if (UNEXPECTED(GC_DELREF(ht) == 0)) {
						crex_array_destroy(ht);
						goto assign_dim_error;
					}
				}
				goto try_assign_dim_array;
			}
		} else {
			crex_use_scalar_as_array();
			dim = RT_CONSTANT(opline, opline->op2);
assign_dim_error:

			if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
				ZVAL_NULL(EX_VAR(opline->result.var));
			}
		}
	}
	if (IS_CONST != IS_UNUSED) {

	}

	/* assign_dim has two opcodes! */
	CREX_VM_NEXT_OPCODE_EX(1, 2);
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ASSIGN_SPEC_CV_CONST_RETVAL_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *value;
	zval *variable_ptr;

	SAVE_OPLINE();
	value = RT_CONSTANT(opline, opline->op2);
	variable_ptr = EX_VAR(opline->op1.var);

	if (0 || UNEXPECTED(0)) {
		crex_refcounted *garbage = NULL;

		value = crex_assign_to_variable_ex(variable_ptr, value, IS_CONST, EX_USES_STRICT_TYPES(), &garbage);
		if (UNEXPECTED(0)) {
			ZVAL_COPY(EX_VAR(opline->result.var), value);
		}
		if (garbage) {
			GC_DTOR_NO_REF(garbage);
		}
	} else {
		value = crex_assign_to_variable(variable_ptr, value, IS_CONST, EX_USES_STRICT_TYPES());
	}

	/* crex_assign_to_variable() always takes care of op2, never free it! */

	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ASSIGN_SPEC_CV_CONST_RETVAL_USED_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *value;
	zval *variable_ptr;

	SAVE_OPLINE();
	value = RT_CONSTANT(opline, opline->op2);
	variable_ptr = EX_VAR(opline->op1.var);

	if (0 || UNEXPECTED(1)) {
		crex_refcounted *garbage = NULL;

		value = crex_assign_to_variable_ex(variable_ptr, value, IS_CONST, EX_USES_STRICT_TYPES(), &garbage);
		if (UNEXPECTED(1)) {
			ZVAL_COPY(EX_VAR(opline->result.var), value);
		}
		if (garbage) {
			GC_DTOR_NO_REF(garbage);
		}
	} else {
		value = crex_assign_to_variable(variable_ptr, value, IS_CONST, EX_USES_STRICT_TYPES());
	}

	/* crex_assign_to_variable() always takes care of op2, never free it! */

	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ASSIGN_OBJ_REF_SPEC_CV_CONST_OP_DATA_VAR_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *property, *container, *value_ptr;

	SAVE_OPLINE();

	container = EX_VAR(opline->op1.var);
	property = RT_CONSTANT(opline, opline->op2);

	value_ptr = _get_zval_ptr_ptr_var((opline+1)->op1.var EXECUTE_DATA_CC);

	if (1) {
		if (IS_CV == IS_UNUSED) {
			if (IS_CONST == IS_CONST) {
				crex_assign_to_property_reference_this_const(container, property, value_ptr OPLINE_CC EXECUTE_DATA_CC);
			} else {
				crex_assign_to_property_reference_this_var(container, property, value_ptr OPLINE_CC EXECUTE_DATA_CC);
			}
		} else {
			if (IS_CONST == IS_CONST) {
				crex_assign_to_property_reference_var_const(container, property, value_ptr OPLINE_CC EXECUTE_DATA_CC);
			} else {
				crex_assign_to_property_reference_var_var(container, property, value_ptr OPLINE_CC EXECUTE_DATA_CC);
			}
		}
	} else {
		crex_assign_to_property_reference(container, IS_CV, property, IS_CONST, value_ptr OPLINE_CC EXECUTE_DATA_CC);
	}


	zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
	CREX_VM_NEXT_OPCODE_EX(1, 2);
}

/* No specialization for op_types (CONST|TMPVAR|CV, UNUSED|CONST|VAR) */
static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ASSIGN_OBJ_REF_SPEC_CV_CONST_OP_DATA_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *property, *container, *value_ptr;

	SAVE_OPLINE();

	container = EX_VAR(opline->op1.var);
	property = RT_CONSTANT(opline, opline->op2);

	value_ptr = _get_zval_ptr_cv_BP_VAR_W((opline+1)->op1.var EXECUTE_DATA_CC);

	if (1) {
		if (IS_CV == IS_UNUSED) {
			if (IS_CONST == IS_CONST) {
				crex_assign_to_property_reference_this_const(container, property, value_ptr OPLINE_CC EXECUTE_DATA_CC);
			} else {
				crex_assign_to_property_reference_this_var(container, property, value_ptr OPLINE_CC EXECUTE_DATA_CC);
			}
		} else {
			if (IS_CONST == IS_CONST) {
				crex_assign_to_property_reference_var_const(container, property, value_ptr OPLINE_CC EXECUTE_DATA_CC);
			} else {
				crex_assign_to_property_reference_var_var(container, property, value_ptr OPLINE_CC EXECUTE_DATA_CC);
			}
		}
	} else {
		crex_assign_to_property_reference(container, IS_CV, property, IS_CONST, value_ptr OPLINE_CC EXECUTE_DATA_CC);
	}



	CREX_VM_NEXT_OPCODE_EX(1, 2);
}

/* No specialization for op_types (CONST|TMPVAR|CV, UNUSED|CONST|VAR) */
static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FAST_CONCAT_SPEC_CV_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	crex_string *op1_str, *op2_str, *str;


	op1 = EX_VAR(opline->op1.var);
	op2 = RT_CONSTANT(opline, opline->op2);
	if ((IS_CV == IS_CONST || EXPECTED(C_TYPE_P(op1) == IS_STRING)) &&
	    (IS_CONST == IS_CONST || EXPECTED(C_TYPE_P(op2) == IS_STRING))) {
		crex_string *op1_str = C_STR_P(op1);
		crex_string *op2_str = C_STR_P(op2);
		crex_string *str;
		uint32_t flags = ZSTR_GET_COPYABLE_CONCAT_PROPERTIES_BOTH(op1_str, op2_str);

		if (IS_CV != IS_CONST && UNEXPECTED(ZSTR_LEN(op1_str) == 0)) {
			if (IS_CONST == IS_CONST || IS_CONST == IS_CV) {
				ZVAL_STR_COPY(EX_VAR(opline->result.var), op2_str);
			} else {
				ZVAL_STR(EX_VAR(opline->result.var), op2_str);
			}
			if (IS_CV & (IS_TMP_VAR|IS_VAR)) {
				crex_string_release_ex(op1_str, 0);
			}
		} else if (IS_CONST != IS_CONST && UNEXPECTED(ZSTR_LEN(op2_str) == 0)) {
			if (IS_CV == IS_CONST || IS_CV == IS_CV) {
				ZVAL_STR_COPY(EX_VAR(opline->result.var), op1_str);
			} else {
				ZVAL_STR(EX_VAR(opline->result.var), op1_str);
			}
			if (IS_CONST & (IS_TMP_VAR|IS_VAR)) {
				crex_string_release_ex(op2_str, 0);
			}
		} else if (IS_CV != IS_CONST && IS_CV != IS_CV &&
		    !ZSTR_IS_INTERNED(op1_str) && GC_REFCOUNT(op1_str) == 1) {
			size_t len = ZSTR_LEN(op1_str);

			str = crex_string_extend(op1_str, len + ZSTR_LEN(op2_str), 0);
			memcpy(ZSTR_VAL(str) + len, ZSTR_VAL(op2_str), ZSTR_LEN(op2_str)+1);
			GC_ADD_FLAGS(str, flags);
			ZVAL_NEW_STR(EX_VAR(opline->result.var), str);
			if (IS_CONST & (IS_TMP_VAR|IS_VAR)) {
				crex_string_release_ex(op2_str, 0);
			}
		} else {
			str = crex_string_alloc(ZSTR_LEN(op1_str) + ZSTR_LEN(op2_str), 0);
			memcpy(ZSTR_VAL(str), ZSTR_VAL(op1_str), ZSTR_LEN(op1_str));
			memcpy(ZSTR_VAL(str) + ZSTR_LEN(op1_str), ZSTR_VAL(op2_str), ZSTR_LEN(op2_str)+1);
			GC_ADD_FLAGS(str, flags);
			ZVAL_NEW_STR(EX_VAR(opline->result.var), str);
			if (IS_CV & (IS_TMP_VAR|IS_VAR)) {
				crex_string_release_ex(op1_str, 0);
			}
			if (IS_CONST & (IS_TMP_VAR|IS_VAR)) {
				crex_string_release_ex(op2_str, 0);
			}
		}
		CREX_VM_NEXT_OPCODE();
	}

	SAVE_OPLINE();
	if (IS_CV == IS_CONST) {
		op1_str = C_STR_P(op1);
	} else if (EXPECTED(C_TYPE_P(op1) == IS_STRING)) {
		op1_str = crex_string_copy(C_STR_P(op1));
	} else {
		if (IS_CV == IS_CV && UNEXPECTED(C_TYPE_P(op1) == IS_UNDEF)) {
			ZVAL_UNDEFINED_OP1();
		}
		op1_str = zval_get_string_func(op1);
	}
	if (IS_CONST == IS_CONST) {
		op2_str = C_STR_P(op2);
	} else if (EXPECTED(C_TYPE_P(op2) == IS_STRING)) {
		op2_str = crex_string_copy(C_STR_P(op2));
	} else {
		if (IS_CONST == IS_CV && UNEXPECTED(C_TYPE_P(op2) == IS_UNDEF)) {
			ZVAL_UNDEFINED_OP2();
		}
		op2_str = zval_get_string_func(op2);
	}
	do {
		if (IS_CV != IS_CONST) {
			if (UNEXPECTED(ZSTR_LEN(op1_str) == 0)) {
				if (IS_CONST == IS_CONST) {
					if (UNEXPECTED(C_REFCOUNTED_P(op2))) {
						GC_ADDREF(op2_str);
					}
				}
				ZVAL_STR(EX_VAR(opline->result.var), op2_str);
				crex_string_release_ex(op1_str, 0);
				break;
			}
		}
		if (IS_CONST != IS_CONST) {
			if (UNEXPECTED(ZSTR_LEN(op2_str) == 0)) {
				if (IS_CV == IS_CONST) {
					if (UNEXPECTED(C_REFCOUNTED_P(op1))) {
						GC_ADDREF(op1_str);
					}
				}
				ZVAL_STR(EX_VAR(opline->result.var), op1_str);
				crex_string_release_ex(op2_str, 0);
				break;
			}
		}
		str = crex_string_alloc(ZSTR_LEN(op1_str) + ZSTR_LEN(op2_str), 0);
		memcpy(ZSTR_VAL(str), ZSTR_VAL(op1_str), ZSTR_LEN(op1_str));
		memcpy(ZSTR_VAL(str) + ZSTR_LEN(op1_str), ZSTR_VAL(op2_str), ZSTR_LEN(op2_str)+1);

		ZSTR_COPY_CONCAT_PROPERTIES_BOTH(str, op1_str, op2_str);
		ZVAL_NEW_STR(EX_VAR(opline->result.var), str);
		if (IS_CV != IS_CONST) {
			crex_string_release_ex(op1_str, 0);
		}
		if (IS_CONST != IS_CONST) {
			crex_string_release_ex(op2_str, 0);
		}
	} while (0);


	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_VM_HOT CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_INIT_METHOD_CALL_SPEC_CV_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *function_name;
	zval *object;
	crex_function *fbc;
	crex_class_entry *called_scope;
	crex_object *obj;
	crex_execute_data *call;
	uint32_t call_info;

	SAVE_OPLINE();

	object = EX_VAR(opline->op1.var);

	if (IS_CONST != IS_CONST) {
		function_name = RT_CONSTANT(opline, opline->op2);
	}

	if (IS_CONST != IS_CONST &&
	    UNEXPECTED(C_TYPE_P(function_name) != IS_STRING)) {
		do {
			if ((IS_CONST & (IS_VAR|IS_CV)) && C_ISREF_P(function_name)) {
				function_name = C_REFVAL_P(function_name);
				if (EXPECTED(C_TYPE_P(function_name) == IS_STRING)) {
					break;
				}
			} else if (IS_CONST == IS_CV && UNEXPECTED(C_TYPE_P(function_name) == IS_UNDEF)) {
				ZVAL_UNDEFINED_OP2();
				if (UNEXPECTED(EG(exception) != NULL)) {

					HANDLE_EXCEPTION();
				}
			}
			crex_throw_error(NULL, "Method name must be a string");


			HANDLE_EXCEPTION();
		} while (0);
	}

	if (IS_CV == IS_UNUSED) {
		obj = C_OBJ_P(object);
	} else {
		do {
			if (IS_CV != IS_CONST && EXPECTED(C_TYPE_P(object) == IS_OBJECT)) {
				obj = C_OBJ_P(object);
			} else {
				if ((IS_CV & (IS_VAR|IS_CV)) && EXPECTED(C_ISREF_P(object))) {
					crex_reference *ref = C_REF_P(object);

					object = &ref->val;
					if (EXPECTED(C_TYPE_P(object) == IS_OBJECT)) {
						obj = C_OBJ_P(object);
						if (IS_CV & IS_VAR) {
							if (UNEXPECTED(GC_DELREF(ref) == 0)) {
								efree_size(ref, sizeof(crex_reference));
							} else {
								C_ADDREF_P(object);
							}
						}
						break;
					}
				}
				if (IS_CV == IS_CV && UNEXPECTED(C_TYPE_P(object) == IS_UNDEF)) {
					object = ZVAL_UNDEFINED_OP1();
					if (UNEXPECTED(EG(exception) != NULL)) {
						if (IS_CONST != IS_CONST) {

						}
						HANDLE_EXCEPTION();
					}
				}
				if (IS_CONST == IS_CONST) {
					function_name = RT_CONSTANT(opline, opline->op2);
				}
				crex_invalid_method_call(object, function_name);


				HANDLE_EXCEPTION();
			}
		} while (0);
	}

	called_scope = obj->ce;

	if (IS_CONST == IS_CONST &&
	    EXPECTED(CACHED_PTR(opline->result.num) == called_scope)) {
		fbc = CACHED_PTR(opline->result.num + sizeof(void*));
	} else {
		crex_object *orig_obj = obj;

		if (IS_CONST == IS_CONST) {
			function_name = RT_CONSTANT(opline, opline->op2);
		}

		/* First, locate the function. */
		fbc = obj->handlers->get_method(&obj, C_STR_P(function_name), ((IS_CONST == IS_CONST) ? (RT_CONSTANT(opline, opline->op2) + 1) : NULL));
		if (UNEXPECTED(fbc == NULL)) {
			if (EXPECTED(!EG(exception))) {
				crex_undefined_method(obj->ce, C_STR_P(function_name));
			}

			if ((IS_CV & (IS_VAR|IS_TMP_VAR)) && GC_DELREF(orig_obj) == 0) {
				crex_objects_store_del(orig_obj);
			}
			HANDLE_EXCEPTION();
		}
		if (IS_CONST == IS_CONST &&
		    EXPECTED(!(fbc->common.fn_flags & (CREX_ACC_CALL_VIA_TRAMPOLINE|CREX_ACC_NEVER_CACHE))) &&
		    EXPECTED(obj == orig_obj)) {
			CACHE_POLYMORPHIC_PTR(opline->result.num, called_scope, fbc);
		}
		if ((IS_CV & (IS_VAR|IS_TMP_VAR)) && UNEXPECTED(obj != orig_obj)) {
			GC_ADDREF(obj); /* For $this pointer */
			if (GC_DELREF(orig_obj) == 0) {
				crex_objects_store_del(orig_obj);
			}
		}
		if (EXPECTED(fbc->type == CREX_USER_FUNCTION) && UNEXPECTED(!RUN_TIME_CACHE(&fbc->op_array))) {
			init_func_run_time_cache(&fbc->op_array);
		}
	}

	if (IS_CONST != IS_CONST) {

	}

	call_info = CREX_CALL_NESTED_FUNCTION | CREX_CALL_HAS_THIS;
	if (UNEXPECTED((fbc->common.fn_flags & CREX_ACC_STATIC) != 0)) {
		if ((IS_CV & (IS_VAR|IS_TMP_VAR)) && GC_DELREF(obj) == 0) {
			crex_objects_store_del(obj);
			if (UNEXPECTED(EG(exception))) {
				HANDLE_EXCEPTION();
			}
		}
		/* call static method */
		obj = (crex_object*)called_scope;
		call_info = CREX_CALL_NESTED_FUNCTION;
	} else if (IS_CV & (IS_VAR|IS_TMP_VAR|IS_CV)) {
		if (IS_CV == IS_CV) {
			GC_ADDREF(obj); /* For $this pointer */
		}
		/* CV may be changed indirectly (e.g. when it's a reference) */
		call_info = CREX_CALL_NESTED_FUNCTION | CREX_CALL_HAS_THIS | CREX_CALL_RELEASE_THIS;
	}

	call = crex_vm_stack_push_call_frame(call_info,
		fbc, opline->extended_value, obj);
	call->prev_execute_data = EX(call);
	EX(call) = call;

	CREX_VM_NEXT_OPCODE();
}

static CREX_VM_HOT CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_SEND_VAR_SPEC_CV_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *varptr, *arg;

	if (IS_CONST == IS_CONST) {
		SAVE_OPLINE();
		crex_string *arg_name = C_STR_P(RT_CONSTANT(opline, opline->op2));
		uint32_t arg_num;
		arg = crex_handle_named_arg(&EX(call), arg_name, &arg_num, CACHE_ADDR(opline->result.num));
		if (UNEXPECTED(!arg)) {

			HANDLE_EXCEPTION();
		}
	} else {
		arg = CREX_CALL_VAR(EX(call), opline->result.var);
	}

	varptr = EX_VAR(opline->op1.var);
	if (IS_CV == IS_CV && UNEXPECTED(C_TYPE_INFO_P(varptr) == IS_UNDEF)) {
		SAVE_OPLINE();
		ZVAL_UNDEFINED_OP1();
		ZVAL_NULL(arg);
		CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
	}

	if (IS_CV == IS_CV) {
		ZVAL_COPY_DEREF(arg, varptr);
	} else /* if (IS_CV == IS_VAR) */ {
		if (UNEXPECTED(C_ISREF_P(varptr))) {
			crex_refcounted *ref = C_COUNTED_P(varptr);

			varptr = C_REFVAL_P(varptr);
			ZVAL_COPY_VALUE(arg, varptr);
			if (UNEXPECTED(GC_DELREF(ref) == 0)) {
				efree_size(ref, sizeof(crex_reference));
			} else if (C_OPT_REFCOUNTED_P(arg)) {
				C_ADDREF_P(arg);
			}
		} else {
			ZVAL_COPY_VALUE(arg, varptr);
		}
	}

	CREX_VM_NEXT_OPCODE();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_SEND_REF_SPEC_CV_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *varptr, *arg;

	SAVE_OPLINE();
	if (IS_CONST == IS_CONST) {
		crex_string *arg_name = C_STR_P(RT_CONSTANT(opline, opline->op2));
		uint32_t arg_num;
		arg = crex_handle_named_arg(&EX(call), arg_name, &arg_num, CACHE_ADDR(opline->result.num));
		if (UNEXPECTED(!arg)) {

			HANDLE_EXCEPTION();
		}
	} else {
		arg = CREX_CALL_VAR(EX(call), opline->result.var);
	}

	varptr = _get_zval_ptr_cv_BP_VAR_W(opline->op1.var EXECUTE_DATA_CC);
	if (C_ISREF_P(varptr)) {
		C_ADDREF_P(varptr);
	} else {
		ZVAL_MAKE_REF_EX(varptr, 2);
	}
	ZVAL_REF(arg, C_REF_P(varptr));

	CREX_VM_NEXT_OPCODE();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_SEND_VAR_EX_SPEC_CV_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *varptr, *arg;
	uint32_t arg_num;

	if (IS_CONST == IS_CONST) {
		SAVE_OPLINE();
		crex_string *arg_name = C_STR_P(RT_CONSTANT(opline, opline->op2));
		arg = crex_handle_named_arg(&EX(call), arg_name, &arg_num, CACHE_ADDR(opline->result.num));
		if (UNEXPECTED(!arg)) {

			HANDLE_EXCEPTION();
		}
	} else {
		arg = CREX_CALL_VAR(EX(call), opline->result.var);
		arg_num = opline->op2.num;
	}

	if (EXPECTED(arg_num <= MAX_ARG_FLAG_NUM)) {
		if (QUICK_ARG_SHOULD_BE_SENT_BY_REF(EX(call)->func, arg_num)) {
			goto send_var_by_ref;
		}
	} else if (ARG_SHOULD_BE_SENT_BY_REF(EX(call)->func, arg_num)) {
send_var_by_ref:
		varptr = _get_zval_ptr_cv_BP_VAR_W(opline->op1.var EXECUTE_DATA_CC);
		if (C_ISREF_P(varptr)) {
			C_ADDREF_P(varptr);
		} else {
			ZVAL_MAKE_REF_EX(varptr, 2);
		}
		ZVAL_REF(arg, C_REF_P(varptr));

		CREX_VM_NEXT_OPCODE();
	}

	varptr = EX_VAR(opline->op1.var);
	if (IS_CV == IS_CV && UNEXPECTED(C_TYPE_INFO_P(varptr) == IS_UNDEF)) {
		SAVE_OPLINE();
		ZVAL_UNDEFINED_OP1();
		ZVAL_NULL(arg);
		CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
	}

	if (IS_CV == IS_CV) {
		ZVAL_COPY_DEREF(arg, varptr);
	} else /* if (IS_CV == IS_VAR) */ {
		if (UNEXPECTED(C_ISREF_P(varptr))) {
			crex_refcounted *ref = C_COUNTED_P(varptr);

			varptr = C_REFVAL_P(varptr);
			ZVAL_COPY_VALUE(arg, varptr);
			if (UNEXPECTED(GC_DELREF(ref) == 0)) {
				efree_size(ref, sizeof(crex_reference));
			} else if (C_OPT_REFCOUNTED_P(arg)) {
				C_ADDREF_P(arg);
			}
		} else {
			ZVAL_COPY_VALUE(arg, varptr);
		}
	}

	CREX_VM_NEXT_OPCODE();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ADD_ARRAY_ELEMENT_SPEC_CV_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *expr_ptr, new_expr;

	SAVE_OPLINE();
	if ((IS_CV == IS_VAR || IS_CV == IS_CV) &&
	    UNEXPECTED(opline->extended_value & CREX_ARRAY_ELEMENT_REF)) {
		expr_ptr = _get_zval_ptr_cv_BP_VAR_W(opline->op1.var EXECUTE_DATA_CC);
		if (C_ISREF_P(expr_ptr)) {
			C_ADDREF_P(expr_ptr);
		} else {
			ZVAL_MAKE_REF_EX(expr_ptr, 2);
		}

	} else {
		expr_ptr = _get_zval_ptr_cv_BP_VAR_R(opline->op1.var EXECUTE_DATA_CC);
		if (IS_CV == IS_TMP_VAR) {
			/* pass */
		} else if (IS_CV == IS_CONST) {
			C_TRY_ADDREF_P(expr_ptr);
		} else if (IS_CV == IS_CV) {
			ZVAL_DEREF(expr_ptr);
			C_TRY_ADDREF_P(expr_ptr);
		} else /* if (IS_CV == IS_VAR) */ {
			if (UNEXPECTED(C_ISREF_P(expr_ptr))) {
				crex_refcounted *ref = C_COUNTED_P(expr_ptr);

				expr_ptr = C_REFVAL_P(expr_ptr);
				if (UNEXPECTED(GC_DELREF(ref) == 0)) {
					ZVAL_COPY_VALUE(&new_expr, expr_ptr);
					expr_ptr = &new_expr;
					efree_size(ref, sizeof(crex_reference));
				} else if (C_OPT_REFCOUNTED_P(expr_ptr)) {
					C_ADDREF_P(expr_ptr);
				}
			}
		}
	}

	if (IS_CONST != IS_UNUSED) {
		zval *offset = RT_CONSTANT(opline, opline->op2);
		crex_string *str;
		crex_ulong hval;

add_again:
		if (EXPECTED(C_TYPE_P(offset) == IS_STRING)) {
			str = C_STR_P(offset);
			if (IS_CONST != IS_CONST) {
				if (CREX_HANDLE_NUMERIC(str, hval)) {
					goto num_index;
				}
			}
str_index:
			crex_hash_update(C_ARRVAL_P(EX_VAR(opline->result.var)), str, expr_ptr);
		} else if (EXPECTED(C_TYPE_P(offset) == IS_LONG)) {
			hval = C_LVAL_P(offset);
num_index:
			crex_hash_index_update(C_ARRVAL_P(EX_VAR(opline->result.var)), hval, expr_ptr);
		} else if ((IS_CONST & (IS_VAR|IS_CV)) && EXPECTED(C_TYPE_P(offset) == IS_REFERENCE)) {
			offset = C_REFVAL_P(offset);
			goto add_again;
		} else if (C_TYPE_P(offset) == IS_NULL) {
			str = ZSTR_EMPTY_ALLOC();
			goto str_index;
		} else if (C_TYPE_P(offset) == IS_DOUBLE) {
			hval = crex_dval_to_lval_safe(C_DVAL_P(offset));
			goto num_index;
		} else if (C_TYPE_P(offset) == IS_FALSE) {
			hval = 0;
			goto num_index;
		} else if (C_TYPE_P(offset) == IS_TRUE) {
			hval = 1;
			goto num_index;
		} else if (C_TYPE_P(offset) == IS_RESOURCE) {
			crex_use_resource_as_offset(offset);
			hval = C_RES_HANDLE_P(offset);
			goto num_index;
		} else if (IS_CONST == IS_CV && C_TYPE_P(offset) == IS_UNDEF) {
			ZVAL_UNDEFINED_OP2();
			str = ZSTR_EMPTY_ALLOC();
			goto str_index;
		} else {
			crex_illegal_array_offset_access(offset);
			zval_ptr_dtor_nogc(expr_ptr);
		}

	} else {
		if (!crex_hash_next_index_insert(C_ARRVAL_P(EX_VAR(opline->result.var)), expr_ptr)) {
			crex_cannot_add_element();
			zval_ptr_dtor_nogc(expr_ptr);
		}
	}
	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_INIT_ARRAY_SPEC_CV_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	zval *array;
	uint32_t size;
	USE_OPLINE

	array = EX_VAR(opline->result.var);
	if (IS_CV != IS_UNUSED) {
		size = opline->extended_value >> CREX_ARRAY_SIZE_SHIFT;
		ZVAL_ARR(array, crex_new_array(size));
		/* Explicitly initialize array as not-packed if flag is set */
		if (opline->extended_value & CREX_ARRAY_NOT_PACKED) {
			crex_hash_real_init_mixed(C_ARRVAL_P(array));
		}
		CREX_VM_TAIL_CALL(CREX_ADD_ARRAY_ELEMENT_SPEC_CV_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU));
	} else {
		ZVAL_ARR(array, crex_new_array(0));
		CREX_VM_NEXT_OPCODE();
	}
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_UNSET_DIM_SPEC_CV_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;
	zval *offset;
	crex_ulong hval;
	crex_string *key;

	SAVE_OPLINE();
	container = EX_VAR(opline->op1.var);
	offset = RT_CONSTANT(opline, opline->op2);

	do {
		if (EXPECTED(C_TYPE_P(container) == IS_ARRAY)) {
			HashTable *ht;

unset_dim_array:
			SEPARATE_ARRAY(container);
			ht = C_ARRVAL_P(container);
offset_again:
			if (EXPECTED(C_TYPE_P(offset) == IS_STRING)) {
				key = C_STR_P(offset);
				if (IS_CONST != IS_CONST) {
					if (CREX_HANDLE_NUMERIC(key, hval)) {
						goto num_index_dim;
					}
				}
str_index_dim:
				CREX_ASSERT(ht != &EG(symbol_table));
				crex_hash_del(ht, key);
			} else if (EXPECTED(C_TYPE_P(offset) == IS_LONG)) {
				hval = C_LVAL_P(offset);
num_index_dim:
				crex_hash_index_del(ht, hval);
			} else if ((IS_CONST & (IS_VAR|IS_CV)) && EXPECTED(C_TYPE_P(offset) == IS_REFERENCE)) {
				offset = C_REFVAL_P(offset);
				goto offset_again;
			} else if (C_TYPE_P(offset) == IS_DOUBLE) {
				hval = crex_dval_to_lval_safe(C_DVAL_P(offset));
				goto num_index_dim;
			} else if (C_TYPE_P(offset) == IS_NULL) {
				key = ZSTR_EMPTY_ALLOC();
				goto str_index_dim;
			} else if (C_TYPE_P(offset) == IS_FALSE) {
				hval = 0;
				goto num_index_dim;
			} else if (C_TYPE_P(offset) == IS_TRUE) {
				hval = 1;
				goto num_index_dim;
			} else if (C_TYPE_P(offset) == IS_RESOURCE) {
				crex_use_resource_as_offset(offset);
				hval = C_RES_HANDLE_P(offset);
				goto num_index_dim;
			} else if (IS_CONST == IS_CV && C_TYPE_P(offset) == IS_UNDEF) {
				ZVAL_UNDEFINED_OP2();
				key = ZSTR_EMPTY_ALLOC();
				goto str_index_dim;
			} else {
				crex_illegal_array_offset_unset(offset);
			}
			break;
		} else if (C_ISREF_P(container)) {
			container = C_REFVAL_P(container);
			if (EXPECTED(C_TYPE_P(container) == IS_ARRAY)) {
				goto unset_dim_array;
			}
		}
		if (IS_CV == IS_CV && UNEXPECTED(C_TYPE_P(container) == IS_UNDEF)) {
			container = ZVAL_UNDEFINED_OP1();
		}
		if (IS_CONST == IS_CV && UNEXPECTED(C_TYPE_P(offset) == IS_UNDEF)) {
			offset = ZVAL_UNDEFINED_OP2();
		}
		if (EXPECTED(C_TYPE_P(container) == IS_OBJECT)) {
			if (IS_CONST == IS_CONST && C_EXTRA_P(offset) == CREX_EXTRA_VALUE) {
				offset++;
			}
			C_OBJ_HT_P(container)->unset_dimension(C_OBJ_P(container), offset);
		} else if (UNEXPECTED(C_TYPE_P(container) == IS_STRING)) {
			crex_throw_error(NULL, "Cannot unset string offsets");
		} else if (UNEXPECTED(C_TYPE_P(container) > IS_FALSE)) {
			crex_throw_error(NULL, "Cannot unset offset in a non-array variable");
		} else if (UNEXPECTED(C_TYPE_P(container) == IS_FALSE)) {
			crex_false_to_array_deprecated();
		}
	} while (0);


	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_UNSET_OBJ_SPEC_CV_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;
	zval *offset;
	crex_string *name, *tmp_name;

	SAVE_OPLINE();
	container = EX_VAR(opline->op1.var);
	offset = RT_CONSTANT(opline, opline->op2);

	do {
		if (IS_CV != IS_UNUSED && UNEXPECTED(C_TYPE_P(container) != IS_OBJECT)) {
			if (C_ISREF_P(container)) {
				container = C_REFVAL_P(container);
				if (C_TYPE_P(container) != IS_OBJECT) {
					if (IS_CV == IS_CV
					 && UNEXPECTED(C_TYPE_P(container) == IS_UNDEF)) {
						ZVAL_UNDEFINED_OP1();
					}
					break;
				}
			} else {
				break;
			}
		}
		if (IS_CONST == IS_CONST) {
			name = C_STR_P(offset);
		} else {
			name = zval_try_get_tmp_string(offset, &tmp_name);
			if (UNEXPECTED(!name)) {
				break;
			}
		}
		C_OBJ_HT_P(container)->unset_property(C_OBJ_P(container), name, ((IS_CONST == IS_CONST) ? CACHE_ADDR(opline->extended_value) : NULL));
		if (IS_CONST != IS_CONST) {
			crex_tmp_string_release(tmp_name);
		}
	} while (0);


	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ISSET_ISEMPTY_DIM_OBJ_SPEC_CV_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;
	bool result;
	crex_ulong hval;
	zval *offset;

	SAVE_OPLINE();
	container = EX_VAR(opline->op1.var);
	offset = RT_CONSTANT(opline, opline->op2);

	if (EXPECTED(C_TYPE_P(container) == IS_ARRAY)) {
		HashTable *ht;
		zval *value;
		crex_string *str;

isset_dim_obj_array:
		ht = C_ARRVAL_P(container);
isset_again:
		if (EXPECTED(C_TYPE_P(offset) == IS_STRING)) {
			str = C_STR_P(offset);
			if (IS_CONST != IS_CONST) {
				if (CREX_HANDLE_NUMERIC(str, hval)) {
					goto num_index_prop;
				}
			}
			value = crex_hash_find_ex(ht, str, IS_CONST == IS_CONST);
		} else if (EXPECTED(C_TYPE_P(offset) == IS_LONG)) {
			hval = C_LVAL_P(offset);
num_index_prop:
			value = crex_hash_index_find(ht, hval);
		} else if ((IS_CONST & (IS_VAR|IS_CV)) && EXPECTED(C_ISREF_P(offset))) {
			offset = C_REFVAL_P(offset);
			goto isset_again;
		} else {
			value = crex_find_array_dim_slow(ht, offset EXECUTE_DATA_CC);
			if (UNEXPECTED(EG(exception))) {
				result = 0;
				goto isset_dim_obj_exit;
			}
		}

		if (!(opline->extended_value & CREX_ISEMPTY)) {
			/* > IS_NULL means not IS_UNDEF and not IS_NULL */
			result = value != NULL && C_TYPE_P(value) > IS_NULL &&
			    (!C_ISREF_P(value) || C_TYPE_P(C_REFVAL_P(value)) != IS_NULL);

			if (IS_CV & (IS_CONST|IS_CV)) {
				/* avoid exception check */

				CREX_VM_SMART_BRANCH(result, 0);
			}
		} else {
			result = (value == NULL || !i_crex_is_true(value));
		}
		goto isset_dim_obj_exit;
	} else if ((IS_CV & (IS_VAR|IS_CV)) && EXPECTED(C_ISREF_P(container))) {
		container = C_REFVAL_P(container);
		if (EXPECTED(C_TYPE_P(container) == IS_ARRAY)) {
			goto isset_dim_obj_array;
		}
	}

	if (IS_CONST == IS_CONST && C_EXTRA_P(offset) == CREX_EXTRA_VALUE) {
		offset++;
	}
	if (!(opline->extended_value & CREX_ISEMPTY)) {
		result = crex_isset_dim_slow(container, offset EXECUTE_DATA_CC);
	} else {
		result = crex_isempty_dim_slow(container, offset EXECUTE_DATA_CC);
	}

isset_dim_obj_exit:


	CREX_VM_SMART_BRANCH(result, 1);
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ISSET_ISEMPTY_PROP_OBJ_SPEC_CV_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;
	int result;
	zval *offset;
	crex_string *name, *tmp_name;

	SAVE_OPLINE();
	container = _get_zval_ptr_cv_BP_VAR_IS(opline->op1.var EXECUTE_DATA_CC);
	offset = RT_CONSTANT(opline, opline->op2);

	if (IS_CV == IS_CONST ||
	    (IS_CV != IS_UNUSED && UNEXPECTED(C_TYPE_P(container) != IS_OBJECT))) {
		if ((IS_CV & (IS_VAR|IS_CV)) && C_ISREF_P(container)) {
			container = C_REFVAL_P(container);
			if (UNEXPECTED(C_TYPE_P(container) != IS_OBJECT)) {
				result = (opline->extended_value & CREX_ISEMPTY);
				goto isset_object_finish;
			}
		} else {
			result = (opline->extended_value & CREX_ISEMPTY);
			goto isset_object_finish;
		}
	}

	if (IS_CONST == IS_CONST) {
		name = C_STR_P(offset);
	} else {
		name = zval_try_get_tmp_string(offset, &tmp_name);
		if (UNEXPECTED(!name)) {
			result = 0;
			goto isset_object_finish;
		}
	}

	result =
		(opline->extended_value & CREX_ISEMPTY) ^
		C_OBJ_HT_P(container)->has_property(C_OBJ_P(container), name, (opline->extended_value & CREX_ISEMPTY), ((IS_CONST == IS_CONST) ? CACHE_ADDR(opline->extended_value & ~CREX_ISEMPTY) : NULL));

	if (IS_CONST != IS_CONST) {
		crex_tmp_string_release(tmp_name);
	}

isset_object_finish:


	CREX_VM_SMART_BRANCH(result, 1);
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ARRAY_KEY_EXISTS_SPEC_CV_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *key, *subject;
	HashTable *ht;
	bool result;

	SAVE_OPLINE();

	key = EX_VAR(opline->op1.var);
	subject = RT_CONSTANT(opline, opline->op2);

	if (EXPECTED(C_TYPE_P(subject) == IS_ARRAY)) {
array_key_exists_array:
		ht = C_ARRVAL_P(subject);
		result = crex_array_key_exists_fast(ht, key OPLINE_CC EXECUTE_DATA_CC);
	} else {
		if ((IS_CONST & (IS_VAR|IS_CV)) && EXPECTED(C_ISREF_P(subject))) {
			subject = C_REFVAL_P(subject);
			if (EXPECTED(C_TYPE_P(subject) == IS_ARRAY)) {
				goto array_key_exists_array;
			}
		}
		crex_array_key_exists_error(subject, key OPLINE_CC EXECUTE_DATA_CC);
		result = 0;
	}


	CREX_VM_SMART_BRANCH(result, 1);
}

/* No specialization for op_types (CONST|TMPVAR|UNUSED|CV, ANY) */
static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_INSTANCEOF_SPEC_CV_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *expr;
	bool result;

	SAVE_OPLINE();
	expr = EX_VAR(opline->op1.var);

try_instanceof:
	if (C_TYPE_P(expr) == IS_OBJECT) {
		crex_class_entry *ce;

		if (IS_CONST == IS_CONST) {
			ce = CACHED_PTR(opline->extended_value);
			if (UNEXPECTED(ce == NULL)) {
				ce = crex_lookup_class_ex(C_STR_P(RT_CONSTANT(opline, opline->op2)), C_STR_P(RT_CONSTANT(opline, opline->op2) + 1), CREX_FETCH_CLASS_NO_AUTOLOAD);
				if (EXPECTED(ce)) {
					CACHE_PTR(opline->extended_value, ce);
				}
			}
		} else if (IS_CONST == IS_UNUSED) {
			ce = crex_fetch_class(NULL, opline->op2.num);
			if (UNEXPECTED(ce == NULL)) {

				ZVAL_UNDEF(EX_VAR(opline->result.var));
				HANDLE_EXCEPTION();
			}
		} else {
			ce = C_CE_P(EX_VAR(opline->op2.var));
		}
		result = ce && instanceof_function(C_OBJCE_P(expr), ce);
	} else if ((IS_CV & (IS_VAR|IS_CV)) && C_TYPE_P(expr) == IS_REFERENCE) {
		expr = C_REFVAL_P(expr);
		goto try_instanceof;
	} else {
		if (IS_CV == IS_CV && UNEXPECTED(C_TYPE_P(expr) == IS_UNDEF)) {
			ZVAL_UNDEFINED_OP1();
		}
		result = 0;
	}

	CREX_VM_SMART_BRANCH(result, 1);
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_YIELD_SPEC_CV_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	crex_generator *generator = crex_get_running_generator(EXECUTE_DATA_C);

	SAVE_OPLINE();
	if (UNEXPECTED(generator->flags & CREX_GENERATOR_FORCED_CLOSE)) {
		CREX_VM_TAIL_CALL(crex_yield_in_closed_generator_helper_SPEC(CREX_OPCODE_HANDLER_ARGS_PASSTHRU));
	}

	/* Destroy the previously yielded value */
	zval_ptr_dtor(&generator->value);

	/* Destroy the previously yielded key */
	zval_ptr_dtor(&generator->key);

	/* Set the new yielded value */
	if (IS_CV != IS_UNUSED) {
		if (UNEXPECTED(EX(func)->op_array.fn_flags & CREX_ACC_RETURN_REFERENCE)) {
			/* Constants and temporary variables aren't yieldable by reference,
			 * but we still allow them with a notice. */
			if (IS_CV & (IS_CONST|IS_TMP_VAR)) {
				zval *value;

				crex_error(E_NOTICE, "Only variable references should be yielded by reference");

				value = _get_zval_ptr_cv_BP_VAR_R(opline->op1.var EXECUTE_DATA_CC);
				ZVAL_COPY_VALUE(&generator->value, value);
				if (IS_CV == IS_CONST) {
					if (UNEXPECTED(C_OPT_REFCOUNTED(generator->value))) {
						C_ADDREF(generator->value);
					}
				}
			} else {
				zval *value_ptr = _get_zval_ptr_cv_BP_VAR_W(opline->op1.var EXECUTE_DATA_CC);

				/* If a function call result is yielded and the function did
				 * not return by reference we throw a notice. */
				do {
					if (IS_CV == IS_VAR) {
						CREX_ASSERT(value_ptr != &EG(uninitialized_zval));
						if (opline->extended_value == CREX_RETURNS_FUNCTION
						 && !C_ISREF_P(value_ptr)) {
							crex_error(E_NOTICE, "Only variable references should be yielded by reference");
							ZVAL_COPY(&generator->value, value_ptr);
							break;
						}
					}
					if (C_ISREF_P(value_ptr)) {
						C_ADDREF_P(value_ptr);
					} else {
						ZVAL_MAKE_REF_EX(value_ptr, 2);
					}
					ZVAL_REF(&generator->value, C_REF_P(value_ptr));
				} while (0);

			}
		} else {
			zval *value = _get_zval_ptr_cv_BP_VAR_R(opline->op1.var EXECUTE_DATA_CC);

			/* Consts, temporary variables and references need copying */
			if (IS_CV == IS_CONST) {
				ZVAL_COPY_VALUE(&generator->value, value);
				if (UNEXPECTED(C_OPT_REFCOUNTED(generator->value))) {
					C_ADDREF(generator->value);
				}
			} else if (IS_CV == IS_TMP_VAR) {
				ZVAL_COPY_VALUE(&generator->value, value);
			} else if ((IS_CV & (IS_VAR|IS_CV)) && C_ISREF_P(value)) {
				ZVAL_COPY(&generator->value, C_REFVAL_P(value));

			} else {
				ZVAL_COPY_VALUE(&generator->value, value);
				if (IS_CV == IS_CV) {
					if (C_OPT_REFCOUNTED_P(value)) C_ADDREF_P(value);
				}
			}
		}
	} else {
		/* If no value was specified yield null */
		ZVAL_NULL(&generator->value);
	}

	/* Set the new yielded key */
	if (IS_CONST != IS_UNUSED) {
		zval *key = RT_CONSTANT(opline, opline->op2);
		if ((IS_CONST & (IS_CV|IS_VAR)) && UNEXPECTED(C_TYPE_P(key) == IS_REFERENCE)) {
			key = C_REFVAL_P(key);
		}
		ZVAL_COPY(&generator->key, key);

		if (C_TYPE(generator->key) == IS_LONG
		    && C_LVAL(generator->key) > generator->largest_used_integer_key
		) {
			generator->largest_used_integer_key = C_LVAL(generator->key);
		}
	} else {
		/* If no key was specified we use auto-increment keys */
		generator->largest_used_integer_key++;
		ZVAL_LONG(&generator->key, generator->largest_used_integer_key);
	}

	if (RETURN_VALUE_USED(opline)) {
		/* If the return value of yield is used set the send
		 * target and initialize it to NULL */
		generator->send_target = EX_VAR(opline->result.var);
		ZVAL_NULL(generator->send_target);
	} else {
		generator->send_target = NULL;
	}

	/* We increment to the next op, so we are at the correct position when the
	 * generator is resumed. */
	CREX_VM_INC_OPCODE();

	/* The GOTO VM uses a local opline variable. We need to set the opline
	 * variable in execute_data so we don't resume at an old position. */
	SAVE_OPLINE();

	CREX_VM_RETURN();
}

static CREX_VM_HOT CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_BIND_GLOBAL_SPEC_CV_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	crex_string *varname;
	zval *value;
	zval *variable_ptr;
	uintptr_t idx;
	crex_reference *ref;

	CREX_VM_REPEATABLE_OPCODE

	varname = C_STR_P(RT_CONSTANT(opline, opline->op2));

	/* We store "hash slot index" + 1 (NULL is a mark of uninitialized cache slot) */
	idx = (uintptr_t)CACHED_PTR(opline->extended_value) - 1;
	if (EXPECTED(idx < EG(symbol_table).nNumUsed * sizeof(Bucket))) {
		Bucket *p = (Bucket*)((char*)EG(symbol_table).arData + idx);

		if (EXPECTED(p->key == varname) ||
		    (EXPECTED(p->h == ZSTR_H(varname)) &&
		     EXPECTED(p->key != NULL) &&
		     EXPECTED(crex_string_equal_content(p->key, varname)))) {

			value = (zval*)p; /* value = &p->val; */
			goto check_indirect;
		}
	}

	value = crex_hash_find_known_hash(&EG(symbol_table), varname);
	if (UNEXPECTED(value == NULL)) {
		value = crex_hash_add_new(&EG(symbol_table), varname, &EG(uninitialized_zval));
		idx = (char*)value - (char*)EG(symbol_table).arData;
		/* Store "hash slot index" + 1 (NULL is a mark of uninitialized cache slot) */
		CACHE_PTR(opline->extended_value, (void*)(idx + 1));
	} else {
		idx = (char*)value - (char*)EG(symbol_table).arData;
		/* Store "hash slot index" + 1 (NULL is a mark of uninitialized cache slot) */
		CACHE_PTR(opline->extended_value, (void*)(idx + 1));
check_indirect:
		/* GLOBAL variable may be an INDIRECT pointer to CV */
		if (UNEXPECTED(C_TYPE_P(value) == IS_INDIRECT)) {
			value = C_INDIRECT_P(value);
			if (UNEXPECTED(C_TYPE_P(value) == IS_UNDEF)) {
				ZVAL_NULL(value);
			}
		}
	}

	if (UNEXPECTED(!C_ISREF_P(value))) {
		ZVAL_MAKE_REF_EX(value, 2);
		ref = C_REF_P(value);
	} else {
		ref = C_REF_P(value);
		GC_ADDREF(ref);
	}

	variable_ptr = EX_VAR(opline->op1.var);

	if (UNEXPECTED(C_REFCOUNTED_P(variable_ptr))) {
		crex_refcounted *garbage = C_COUNTED_P(variable_ptr);

		ZVAL_REF(variable_ptr, ref);
		SAVE_OPLINE();
		if (GC_DELREF(garbage) == 0) {
			rc_dtor_func(garbage);
			if (UNEXPECTED(EG(exception))) {
				ZVAL_NULL(variable_ptr);
				HANDLE_EXCEPTION();
			}
		} else {
			gc_check_possible_root(garbage);
		}
	} else {
		ZVAL_REF(variable_ptr, ref);
	}

	CREX_VM_REPEAT_OPCODE(CREX_BIND_GLOBAL);
	CREX_VM_NEXT_OPCODE();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_IN_ARRAY_SPEC_CV_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1;
	HashTable *ht = C_ARRVAL_P(RT_CONSTANT(opline, opline->op2));
	zval *result;

	op1 = EX_VAR(opline->op1.var);
	if (EXPECTED(C_TYPE_P(op1) == IS_STRING)) {
		result = crex_hash_find_ex(ht, C_STR_P(op1), IS_CV == IS_CONST);
		if (IS_CV & (IS_TMP_VAR|IS_VAR)) {
			zval_ptr_dtor_str(op1);
		}
		CREX_VM_SMART_BRANCH(result, 0);
	}

	if (opline->extended_value) {
		if (EXPECTED(C_TYPE_P(op1) == IS_LONG)) {
			result = crex_hash_index_find(ht, C_LVAL_P(op1));
			CREX_VM_SMART_BRANCH(result, 0);
		}
		SAVE_OPLINE();
		if ((IS_CV & (IS_VAR|IS_CV)) && C_TYPE_P(op1) == IS_REFERENCE) {
			op1 = C_REFVAL_P(op1);
			if (EXPECTED(C_TYPE_P(op1) == IS_STRING)) {
				result = crex_hash_find(ht, C_STR_P(op1));

				CREX_VM_SMART_BRANCH(result, 0);
			} else if (EXPECTED(C_TYPE_P(op1) == IS_LONG)) {
				result = crex_hash_index_find(ht, C_LVAL_P(op1));

				CREX_VM_SMART_BRANCH(result, 0);
			}
		} else if (IS_CV == IS_CV && UNEXPECTED(C_TYPE_P(op1) == IS_UNDEF)) {
			ZVAL_UNDEFINED_OP1();
		}
	} else if (C_TYPE_P(op1) <= IS_FALSE) {
		if (IS_CV == IS_CV && UNEXPECTED(C_TYPE_P(op1) == IS_UNDEF)) {
			SAVE_OPLINE();
			ZVAL_UNDEFINED_OP1();
			if (UNEXPECTED(EG(exception) != NULL)) {
				HANDLE_EXCEPTION();
			}
		}
		result = crex_hash_find_known_hash(ht, ZSTR_EMPTY_ALLOC());
		CREX_VM_SMART_BRANCH(result, 0);
	} else {
		crex_string *key;
		zval key_tmp;

		if ((IS_CV & (IS_VAR|IS_CV)) && C_TYPE_P(op1) == IS_REFERENCE) {
			op1 = C_REFVAL_P(op1);
			if (EXPECTED(C_TYPE_P(op1) == IS_STRING)) {
				result = crex_hash_find(ht, C_STR_P(op1));

				CREX_VM_SMART_BRANCH(result, 0);
			}
		}

		SAVE_OPLINE();
		CREX_HASH_MAP_FOREACH_STR_KEY(ht, key) {
			ZVAL_STR(&key_tmp, key);
			if (crex_compare(op1, &key_tmp) == 0) {

				CREX_VM_SMART_BRANCH(1, 1);
			}
		} CREX_HASH_FOREACH_END();
	}

	CREX_VM_SMART_BRANCH(0, 1);
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_IS_IDENTICAL_NOTHROW_SPEC_CV_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	/* This is declared below the specializations for MAY_BE_LONG/MAY_BE_DOUBLE so those will be used instead if possible. */
	/* This optimizes $x === SOME_CONST_EXPR and $x === $y for non-refs and non-undef, which can't throw. */
	/* (Infinite recursion when comparing arrays is an uncatchable fatal error) */
	USE_OPLINE
	zval *op1, *op2;
	bool result;

	op1 = EX_VAR(opline->op1.var);
	op2 = RT_CONSTANT(opline, opline->op2);
	result = fast_is_identical_function(op1, op2);
	/* Free is a no-op for const/cv */
	CREX_VM_SMART_BRANCH(result, 0);
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_IS_NOT_IDENTICAL_NOTHROW_SPEC_CV_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	bool result;

	op1 = EX_VAR(opline->op1.var);
	op2 = RT_CONSTANT(opline, opline->op2);
	result = fast_is_identical_function(op1, op2);
	/* Free is a no-op for const/cv */
	CREX_VM_SMART_BRANCH(!result, 0);
}

static CREX_VM_HOT CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FETCH_DIM_R_INDEX_SPEC_CV_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container, *dim, *value;
	crex_long offset;
	HashTable *ht;

	container = EX_VAR(opline->op1.var);
	dim = RT_CONSTANT(opline, opline->op2);
	if (EXPECTED(C_TYPE_P(container) == IS_ARRAY)) {
fetch_dim_r_index_array:
		if (EXPECTED(C_TYPE_P(dim) == IS_LONG)) {
			offset = C_LVAL_P(dim);
		} else {
			SAVE_OPLINE();
			crex_fetch_dimension_address_read_R(container, dim, IS_CONST OPLINE_CC EXECUTE_DATA_CC);

			CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
		}
		ht = C_ARRVAL_P(container);
		CREX_HASH_INDEX_FIND(ht, offset, value, fetch_dim_r_index_undef);
		ZVAL_COPY_DEREF(EX_VAR(opline->result.var), value);
		if (IS_CV & (IS_TMP_VAR|IS_VAR)) {
			SAVE_OPLINE();

			CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
		} else {
			CREX_VM_NEXT_OPCODE();
		}
	} else if (IS_CV != IS_CONST && EXPECTED(C_TYPE_P(container) == IS_REFERENCE)) {
		container = C_REFVAL_P(container);
		if (EXPECTED(C_TYPE_P(container) == IS_ARRAY)) {
			goto fetch_dim_r_index_array;
		} else {
			goto fetch_dim_r_index_slow;
		}
	} else {
fetch_dim_r_index_slow:
		SAVE_OPLINE();
		if (IS_CONST == IS_CONST && C_EXTRA_P(dim) == CREX_EXTRA_VALUE) {
			dim++;
		}
		crex_fetch_dimension_address_read_R_slow(container, dim OPLINE_CC EXECUTE_DATA_CC);

		CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
	}

fetch_dim_r_index_undef:
	ZVAL_NULL(EX_VAR(opline->result.var));
	SAVE_OPLINE();
	crex_undefined_offset(offset);

	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_VM_HOT CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FETCH_DIM_R_INDEX_SPEC_CV_TMPVARCV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container, *dim, *value;
	crex_long offset;
	HashTable *ht;

	container = EX_VAR(opline->op1.var);
	dim = EX_VAR(opline->op2.var);
	if (EXPECTED(C_TYPE_P(container) == IS_ARRAY)) {
fetch_dim_r_index_array:
		if (EXPECTED(C_TYPE_P(dim) == IS_LONG)) {
			offset = C_LVAL_P(dim);
		} else {
			SAVE_OPLINE();
			crex_fetch_dimension_address_read_R(container, dim, (IS_TMP_VAR|IS_VAR|IS_CV) OPLINE_CC EXECUTE_DATA_CC);

			CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
		}
		ht = C_ARRVAL_P(container);
		CREX_HASH_INDEX_FIND(ht, offset, value, fetch_dim_r_index_undef);
		ZVAL_COPY_DEREF(EX_VAR(opline->result.var), value);
		if (IS_CV & (IS_TMP_VAR|IS_VAR)) {
			SAVE_OPLINE();

			CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
		} else {
			CREX_VM_NEXT_OPCODE();
		}
	} else if (IS_CV != IS_CONST && EXPECTED(C_TYPE_P(container) == IS_REFERENCE)) {
		container = C_REFVAL_P(container);
		if (EXPECTED(C_TYPE_P(container) == IS_ARRAY)) {
			goto fetch_dim_r_index_array;
		} else {
			goto fetch_dim_r_index_slow;
		}
	} else {
fetch_dim_r_index_slow:
		SAVE_OPLINE();
		if ((IS_TMP_VAR|IS_VAR|IS_CV) == IS_CONST && C_EXTRA_P(dim) == CREX_EXTRA_VALUE) {
			dim++;
		}
		crex_fetch_dimension_address_read_R_slow(container, dim OPLINE_CC EXECUTE_DATA_CC);

		CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
	}

fetch_dim_r_index_undef:
	ZVAL_NULL(EX_VAR(opline->result.var));
	SAVE_OPLINE();
	crex_undefined_offset(offset);

	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_DIV_SPEC_CV_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;

	SAVE_OPLINE();
	op1 = _get_zval_ptr_cv_BP_VAR_R(opline->op1.var EXECUTE_DATA_CC);
	op2 = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
	div_function(EX_VAR(opline->result.var), op1, op2);

	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_POW_SPEC_CV_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;

	SAVE_OPLINE();
	op1 = _get_zval_ptr_cv_BP_VAR_R(opline->op1.var EXECUTE_DATA_CC);
	op2 = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
	pow_function(EX_VAR(opline->result.var), op1, op2);

	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_CONCAT_SPEC_CV_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;

	op1 = EX_VAR(opline->op1.var);
	op2 = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);

	if ((IS_CV == IS_CONST || EXPECTED(C_TYPE_P(op1) == IS_STRING)) &&
	    ((IS_TMP_VAR|IS_VAR) == IS_CONST || EXPECTED(C_TYPE_P(op2) == IS_STRING))) {
		crex_string *op1_str = C_STR_P(op1);
		crex_string *op2_str = C_STR_P(op2);
		crex_string *str;
		uint32_t flags = ZSTR_GET_COPYABLE_CONCAT_PROPERTIES_BOTH(op1_str, op2_str);

		if (IS_CV != IS_CONST && UNEXPECTED(ZSTR_LEN(op1_str) == 0)) {
			if ((IS_TMP_VAR|IS_VAR) == IS_CONST || (IS_TMP_VAR|IS_VAR) == IS_CV) {
				ZVAL_STR_COPY(EX_VAR(opline->result.var), op2_str);
			} else {
				ZVAL_STR(EX_VAR(opline->result.var), op2_str);
			}
			if (IS_CV & (IS_TMP_VAR|IS_VAR)) {
				crex_string_release_ex(op1_str, 0);
			}
		} else if ((IS_TMP_VAR|IS_VAR) != IS_CONST && UNEXPECTED(ZSTR_LEN(op2_str) == 0)) {
			if (IS_CV == IS_CONST || IS_CV == IS_CV) {
				ZVAL_STR_COPY(EX_VAR(opline->result.var), op1_str);
			} else {
				ZVAL_STR(EX_VAR(opline->result.var), op1_str);
			}
			if ((IS_TMP_VAR|IS_VAR) & (IS_TMP_VAR|IS_VAR)) {
				crex_string_release_ex(op2_str, 0);
			}
		} else if (IS_CV != IS_CONST && IS_CV != IS_CV &&
		    !ZSTR_IS_INTERNED(op1_str) && GC_REFCOUNT(op1_str) == 1) {
			size_t len = ZSTR_LEN(op1_str);

			if (UNEXPECTED(len > ZSTR_MAX_LEN - ZSTR_LEN(op2_str))) {
				crex_error_noreturn(E_ERROR, "Integer overflow in memory allocation");
			}
			str = crex_string_extend(op1_str, len + ZSTR_LEN(op2_str), 0);
			memcpy(ZSTR_VAL(str) + len, ZSTR_VAL(op2_str), ZSTR_LEN(op2_str)+1);
			GC_ADD_FLAGS(str, flags);
			ZVAL_NEW_STR(EX_VAR(opline->result.var), str);
			if ((IS_TMP_VAR|IS_VAR) & (IS_TMP_VAR|IS_VAR)) {
				crex_string_release_ex(op2_str, 0);
			}
		} else {
			str = crex_string_alloc(ZSTR_LEN(op1_str) + ZSTR_LEN(op2_str), 0);
			memcpy(ZSTR_VAL(str), ZSTR_VAL(op1_str), ZSTR_LEN(op1_str));
			memcpy(ZSTR_VAL(str) + ZSTR_LEN(op1_str), ZSTR_VAL(op2_str), ZSTR_LEN(op2_str)+1);
			GC_ADD_FLAGS(str, flags);
			ZVAL_NEW_STR(EX_VAR(opline->result.var), str);
			if (IS_CV & (IS_TMP_VAR|IS_VAR)) {
				crex_string_release_ex(op1_str, 0);
			}
			if ((IS_TMP_VAR|IS_VAR) & (IS_TMP_VAR|IS_VAR)) {
				crex_string_release_ex(op2_str, 0);
			}
		}
		CREX_VM_NEXT_OPCODE();
	} else {
		SAVE_OPLINE();

		if (IS_CV == IS_CV && UNEXPECTED(C_TYPE_P(op1) == IS_UNDEF)) {
			op1 = ZVAL_UNDEFINED_OP1();
		}
		if ((IS_TMP_VAR|IS_VAR) == IS_CV && UNEXPECTED(C_TYPE_P(op2) == IS_UNDEF)) {
			op2 = ZVAL_UNDEFINED_OP2();
		}
		concat_function(EX_VAR(opline->result.var), op1, op2);

		zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
		CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
	}
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_IS_EQUAL_SPEC_CV_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	double d1, d2;

	op1 = EX_VAR(opline->op1.var);
	op2 = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
	if (1 && IS_CV == IS_CONST && (IS_TMP_VAR|IS_VAR) == IS_CONST) {
		/* pass */
	} else if (EXPECTED(C_TYPE_P(op1) == IS_LONG)) {
		if (EXPECTED(C_TYPE_P(op2) == IS_LONG)) {
			if (EXPECTED(C_LVAL_P(op1) == C_LVAL_P(op2))) {
is_equal_true:
				CREX_VM_SMART_BRANCH_TRUE_NONE();
			} else {
is_equal_false:
				CREX_VM_SMART_BRANCH_FALSE_NONE();
			}
		} else if (EXPECTED(C_TYPE_P(op2) == IS_DOUBLE)) {
			d1 = (double)C_LVAL_P(op1);
			d2 = C_DVAL_P(op2);
			goto is_equal_double;
		}
	} else if (EXPECTED(C_TYPE_P(op1) == IS_DOUBLE)) {
		if (EXPECTED(C_TYPE_P(op2) == IS_DOUBLE)) {
			d1 = C_DVAL_P(op1);
			d2 = C_DVAL_P(op2);
is_equal_double:
			if (d1 == d2) {
				goto is_equal_true;
			} else {
				goto is_equal_false;
			}
		} else if (EXPECTED(C_TYPE_P(op2) == IS_LONG)) {
			d1 = C_DVAL_P(op1);
			d2 = (double)C_LVAL_P(op2);
			goto is_equal_double;
		}
	} else if (EXPECTED(C_TYPE_P(op1) == IS_STRING)) {
		if (EXPECTED(C_TYPE_P(op2) == IS_STRING)) {
			bool result = crex_fast_equal_strings(C_STR_P(op1), C_STR_P(op2));
			if (IS_CV & (IS_TMP_VAR|IS_VAR)) {
				zval_ptr_dtor_str(op1);
			}
			if ((IS_TMP_VAR|IS_VAR) & (IS_TMP_VAR|IS_VAR)) {
				zval_ptr_dtor_str(op2);
			}
			if (result) {
				goto is_equal_true;
			} else {
				goto is_equal_false;
			}
		}
	}
	CREX_VM_TAIL_CALL(crex_is_equal_helper_SPEC(op1, op2 CREX_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_IS_EQUAL_SPEC_CV_TMPVAR_JMPC_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	double d1, d2;

	op1 = EX_VAR(opline->op1.var);
	op2 = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
	if (1 && IS_CV == IS_CONST && (IS_TMP_VAR|IS_VAR) == IS_CONST) {
		/* pass */
	} else if (EXPECTED(C_TYPE_P(op1) == IS_LONG)) {
		if (EXPECTED(C_TYPE_P(op2) == IS_LONG)) {
			if (EXPECTED(C_LVAL_P(op1) == C_LVAL_P(op2))) {
is_equal_true:
				CREX_VM_SMART_BRANCH_TRUE_JMPZ();
			} else {
is_equal_false:
				CREX_VM_SMART_BRANCH_FALSE_JMPZ();
			}
		} else if (EXPECTED(C_TYPE_P(op2) == IS_DOUBLE)) {
			d1 = (double)C_LVAL_P(op1);
			d2 = C_DVAL_P(op2);
			goto is_equal_double;
		}
	} else if (EXPECTED(C_TYPE_P(op1) == IS_DOUBLE)) {
		if (EXPECTED(C_TYPE_P(op2) == IS_DOUBLE)) {
			d1 = C_DVAL_P(op1);
			d2 = C_DVAL_P(op2);
is_equal_double:
			if (d1 == d2) {
				goto is_equal_true;
			} else {
				goto is_equal_false;
			}
		} else if (EXPECTED(C_TYPE_P(op2) == IS_LONG)) {
			d1 = C_DVAL_P(op1);
			d2 = (double)C_LVAL_P(op2);
			goto is_equal_double;
		}
	} else if (EXPECTED(C_TYPE_P(op1) == IS_STRING)) {
		if (EXPECTED(C_TYPE_P(op2) == IS_STRING)) {
			bool result = crex_fast_equal_strings(C_STR_P(op1), C_STR_P(op2));
			if (IS_CV & (IS_TMP_VAR|IS_VAR)) {
				zval_ptr_dtor_str(op1);
			}
			if ((IS_TMP_VAR|IS_VAR) & (IS_TMP_VAR|IS_VAR)) {
				zval_ptr_dtor_str(op2);
			}
			if (result) {
				goto is_equal_true;
			} else {
				goto is_equal_false;
			}
		}
	}
	CREX_VM_TAIL_CALL(crex_is_equal_helper_SPEC(op1, op2 CREX_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_IS_EQUAL_SPEC_CV_TMPVAR_JMPNC_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	double d1, d2;

	op1 = EX_VAR(opline->op1.var);
	op2 = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
	if (1 && IS_CV == IS_CONST && (IS_TMP_VAR|IS_VAR) == IS_CONST) {
		/* pass */
	} else if (EXPECTED(C_TYPE_P(op1) == IS_LONG)) {
		if (EXPECTED(C_TYPE_P(op2) == IS_LONG)) {
			if (EXPECTED(C_LVAL_P(op1) == C_LVAL_P(op2))) {
is_equal_true:
				CREX_VM_SMART_BRANCH_TRUE_JMPNZ();
			} else {
is_equal_false:
				CREX_VM_SMART_BRANCH_FALSE_JMPNZ();
			}
		} else if (EXPECTED(C_TYPE_P(op2) == IS_DOUBLE)) {
			d1 = (double)C_LVAL_P(op1);
			d2 = C_DVAL_P(op2);
			goto is_equal_double;
		}
	} else if (EXPECTED(C_TYPE_P(op1) == IS_DOUBLE)) {
		if (EXPECTED(C_TYPE_P(op2) == IS_DOUBLE)) {
			d1 = C_DVAL_P(op1);
			d2 = C_DVAL_P(op2);
is_equal_double:
			if (d1 == d2) {
				goto is_equal_true;
			} else {
				goto is_equal_false;
			}
		} else if (EXPECTED(C_TYPE_P(op2) == IS_LONG)) {
			d1 = C_DVAL_P(op1);
			d2 = (double)C_LVAL_P(op2);
			goto is_equal_double;
		}
	} else if (EXPECTED(C_TYPE_P(op1) == IS_STRING)) {
		if (EXPECTED(C_TYPE_P(op2) == IS_STRING)) {
			bool result = crex_fast_equal_strings(C_STR_P(op1), C_STR_P(op2));
			if (IS_CV & (IS_TMP_VAR|IS_VAR)) {
				zval_ptr_dtor_str(op1);
			}
			if ((IS_TMP_VAR|IS_VAR) & (IS_TMP_VAR|IS_VAR)) {
				zval_ptr_dtor_str(op2);
			}
			if (result) {
				goto is_equal_true;
			} else {
				goto is_equal_false;
			}
		}
	}
	CREX_VM_TAIL_CALL(crex_is_equal_helper_SPEC(op1, op2 CREX_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_IS_NOT_EQUAL_SPEC_CV_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	double d1, d2;

	op1 = EX_VAR(opline->op1.var);
	op2 = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
	if (1 && IS_CV == IS_CONST && (IS_TMP_VAR|IS_VAR) == IS_CONST) {
		/* pass */
	} else if (EXPECTED(C_TYPE_P(op1) == IS_LONG)) {
		if (EXPECTED(C_TYPE_P(op2) == IS_LONG)) {
			if (EXPECTED(C_LVAL_P(op1) != C_LVAL_P(op2))) {
is_not_equal_true:
				CREX_VM_SMART_BRANCH_TRUE_NONE();
			} else {
is_not_equal_false:
				CREX_VM_SMART_BRANCH_FALSE_NONE();
			}
		} else if (EXPECTED(C_TYPE_P(op2) == IS_DOUBLE)) {
			d1 = (double)C_LVAL_P(op1);
			d2 = C_DVAL_P(op2);
			goto is_not_equal_double;
		}
	} else if (EXPECTED(C_TYPE_P(op1) == IS_DOUBLE)) {
		if (EXPECTED(C_TYPE_P(op2) == IS_DOUBLE)) {
			d1 = C_DVAL_P(op1);
			d2 = C_DVAL_P(op2);
is_not_equal_double:
			if (d1 != d2) {
				goto is_not_equal_true;
			} else {
				goto is_not_equal_false;
			}
		} else if (EXPECTED(C_TYPE_P(op2) == IS_LONG)) {
			d1 = C_DVAL_P(op1);
			d2 = (double)C_LVAL_P(op2);
			goto is_not_equal_double;
		}
	} else if (EXPECTED(C_TYPE_P(op1) == IS_STRING)) {
		if (EXPECTED(C_TYPE_P(op2) == IS_STRING)) {
			bool result = crex_fast_equal_strings(C_STR_P(op1), C_STR_P(op2));
			if (IS_CV & (IS_TMP_VAR|IS_VAR)) {
				zval_ptr_dtor_str(op1);
			}
			if ((IS_TMP_VAR|IS_VAR) & (IS_TMP_VAR|IS_VAR)) {
				zval_ptr_dtor_str(op2);
			}
			if (!result) {
				goto is_not_equal_true;
			} else {
				goto is_not_equal_false;
			}
		}
	}
	CREX_VM_TAIL_CALL(crex_is_not_equal_helper_SPEC(op1, op2 CREX_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_IS_NOT_EQUAL_SPEC_CV_TMPVAR_JMPC_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	double d1, d2;

	op1 = EX_VAR(opline->op1.var);
	op2 = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
	if (1 && IS_CV == IS_CONST && (IS_TMP_VAR|IS_VAR) == IS_CONST) {
		/* pass */
	} else if (EXPECTED(C_TYPE_P(op1) == IS_LONG)) {
		if (EXPECTED(C_TYPE_P(op2) == IS_LONG)) {
			if (EXPECTED(C_LVAL_P(op1) != C_LVAL_P(op2))) {
is_not_equal_true:
				CREX_VM_SMART_BRANCH_TRUE_JMPZ();
			} else {
is_not_equal_false:
				CREX_VM_SMART_BRANCH_FALSE_JMPZ();
			}
		} else if (EXPECTED(C_TYPE_P(op2) == IS_DOUBLE)) {
			d1 = (double)C_LVAL_P(op1);
			d2 = C_DVAL_P(op2);
			goto is_not_equal_double;
		}
	} else if (EXPECTED(C_TYPE_P(op1) == IS_DOUBLE)) {
		if (EXPECTED(C_TYPE_P(op2) == IS_DOUBLE)) {
			d1 = C_DVAL_P(op1);
			d2 = C_DVAL_P(op2);
is_not_equal_double:
			if (d1 != d2) {
				goto is_not_equal_true;
			} else {
				goto is_not_equal_false;
			}
		} else if (EXPECTED(C_TYPE_P(op2) == IS_LONG)) {
			d1 = C_DVAL_P(op1);
			d2 = (double)C_LVAL_P(op2);
			goto is_not_equal_double;
		}
	} else if (EXPECTED(C_TYPE_P(op1) == IS_STRING)) {
		if (EXPECTED(C_TYPE_P(op2) == IS_STRING)) {
			bool result = crex_fast_equal_strings(C_STR_P(op1), C_STR_P(op2));
			if (IS_CV & (IS_TMP_VAR|IS_VAR)) {
				zval_ptr_dtor_str(op1);
			}
			if ((IS_TMP_VAR|IS_VAR) & (IS_TMP_VAR|IS_VAR)) {
				zval_ptr_dtor_str(op2);
			}
			if (!result) {
				goto is_not_equal_true;
			} else {
				goto is_not_equal_false;
			}
		}
	}
	CREX_VM_TAIL_CALL(crex_is_not_equal_helper_SPEC(op1, op2 CREX_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_IS_NOT_EQUAL_SPEC_CV_TMPVAR_JMPNC_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	double d1, d2;

	op1 = EX_VAR(opline->op1.var);
	op2 = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
	if (1 && IS_CV == IS_CONST && (IS_TMP_VAR|IS_VAR) == IS_CONST) {
		/* pass */
	} else if (EXPECTED(C_TYPE_P(op1) == IS_LONG)) {
		if (EXPECTED(C_TYPE_P(op2) == IS_LONG)) {
			if (EXPECTED(C_LVAL_P(op1) != C_LVAL_P(op2))) {
is_not_equal_true:
				CREX_VM_SMART_BRANCH_TRUE_JMPNZ();
			} else {
is_not_equal_false:
				CREX_VM_SMART_BRANCH_FALSE_JMPNZ();
			}
		} else if (EXPECTED(C_TYPE_P(op2) == IS_DOUBLE)) {
			d1 = (double)C_LVAL_P(op1);
			d2 = C_DVAL_P(op2);
			goto is_not_equal_double;
		}
	} else if (EXPECTED(C_TYPE_P(op1) == IS_DOUBLE)) {
		if (EXPECTED(C_TYPE_P(op2) == IS_DOUBLE)) {
			d1 = C_DVAL_P(op1);
			d2 = C_DVAL_P(op2);
is_not_equal_double:
			if (d1 != d2) {
				goto is_not_equal_true;
			} else {
				goto is_not_equal_false;
			}
		} else if (EXPECTED(C_TYPE_P(op2) == IS_LONG)) {
			d1 = C_DVAL_P(op1);
			d2 = (double)C_LVAL_P(op2);
			goto is_not_equal_double;
		}
	} else if (EXPECTED(C_TYPE_P(op1) == IS_STRING)) {
		if (EXPECTED(C_TYPE_P(op2) == IS_STRING)) {
			bool result = crex_fast_equal_strings(C_STR_P(op1), C_STR_P(op2));
			if (IS_CV & (IS_TMP_VAR|IS_VAR)) {
				zval_ptr_dtor_str(op1);
			}
			if ((IS_TMP_VAR|IS_VAR) & (IS_TMP_VAR|IS_VAR)) {
				zval_ptr_dtor_str(op2);
			}
			if (!result) {
				goto is_not_equal_true;
			} else {
				goto is_not_equal_false;
			}
		}
	}
	CREX_VM_TAIL_CALL(crex_is_not_equal_helper_SPEC(op1, op2 CREX_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_SPACESHIP_SPEC_CV_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;

	SAVE_OPLINE();
	op1 = _get_zval_ptr_cv_BP_VAR_R(opline->op1.var EXECUTE_DATA_CC);
	op2 = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
	compare_function(EX_VAR(opline->result.var), op1, op2);

	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_BOOL_XOR_SPEC_CV_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;

	SAVE_OPLINE();
	op1 = _get_zval_ptr_cv_BP_VAR_R(opline->op1.var EXECUTE_DATA_CC);
	op2 = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
	boolean_xor_function(EX_VAR(opline->result.var), op1, op2);

	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ASSIGN_OBJ_OP_SPEC_CV_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *object;
	zval *property;
	zval *value;
	zval *zptr;
	void **cache_slot;
	crex_property_info *prop_info;
	crex_object *zobj;
	crex_string *name, *tmp_name;

	SAVE_OPLINE();
	object = EX_VAR(opline->op1.var);
	property = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);

	do {
		value = get_op_data_zval_ptr_r((opline+1)->op1_type, (opline+1)->op1);

		if (IS_CV != IS_UNUSED && UNEXPECTED(C_TYPE_P(object) != IS_OBJECT)) {
			if (C_ISREF_P(object) && C_TYPE_P(C_REFVAL_P(object)) == IS_OBJECT) {
				object = C_REFVAL_P(object);
				goto assign_op_object;
			}
			if (IS_CV == IS_CV
			 && UNEXPECTED(C_TYPE_P(object) == IS_UNDEF)) {
				ZVAL_UNDEFINED_OP1();
			}
			crex_throw_non_object_error(object, property OPLINE_CC EXECUTE_DATA_CC);
			break;
		}

assign_op_object:
		/* here we are sure we are dealing with an object */
		zobj = C_OBJ_P(object);
		if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
			name = C_STR_P(property);
		} else {
			name = zval_try_get_tmp_string(property, &tmp_name);
			if (UNEXPECTED(!name)) {
				UNDEF_RESULT();
				break;
			}
		}
		cache_slot = ((IS_TMP_VAR|IS_VAR) == IS_CONST) ? CACHE_ADDR((opline+1)->extended_value) : NULL;
		if (EXPECTED((zptr = zobj->handlers->get_property_ptr_ptr(zobj, name, BP_VAR_RW, cache_slot)) != NULL)) {
			if (UNEXPECTED(C_ISERROR_P(zptr))) {
				if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
					ZVAL_NULL(EX_VAR(opline->result.var));
				}
			} else {
				zval *orig_zptr = zptr;
				crex_reference *ref;

				do {
					if (UNEXPECTED(C_ISREF_P(zptr))) {
						ref = C_REF_P(zptr);
						zptr = C_REFVAL_P(zptr);
						if (UNEXPECTED(CREX_REF_HAS_TYPE_SOURCES(ref))) {
							crex_binary_assign_op_typed_ref(ref, value OPLINE_CC EXECUTE_DATA_CC);
							break;
						}
					}

					if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
						prop_info = (crex_property_info*)CACHED_PTR_EX(cache_slot + 2);
					} else {
						prop_info = crex_object_fetch_property_type_info(C_OBJ_P(object), orig_zptr);
					}
					if (UNEXPECTED(prop_info)) {
						/* special case for typed properties */
						crex_binary_assign_op_typed_prop(prop_info, zptr, value OPLINE_CC EXECUTE_DATA_CC);
					} else {
						crex_binary_op(zptr, zptr, value OPLINE_CC);
					}
				} while (0);

				if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
					ZVAL_COPY(EX_VAR(opline->result.var), zptr);
				}
			}
		} else {
			crex_assign_op_overloaded_property(zobj, name, cache_slot, value OPLINE_CC EXECUTE_DATA_CC);
		}
		if ((IS_TMP_VAR|IS_VAR) != IS_CONST) {
			crex_tmp_string_release(tmp_name);
		}
	} while (0);

	FREE_OP((opline+1)->op1_type, (opline+1)->op1.var);
	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));

	/* assign_obj has two opcodes! */
	CREX_VM_NEXT_OPCODE_EX(1, 2);
}

/* No specialization for op_types (CONST|TMP|VAR|CV, UNUSED|CONST|TMPVAR) */
static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ASSIGN_DIM_OP_SPEC_CV_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *var_ptr;
	zval *value, *container, *dim;
	HashTable *ht;

	SAVE_OPLINE();
	container = EX_VAR(opline->op1.var);

	if (EXPECTED(C_TYPE_P(container) == IS_ARRAY)) {
assign_dim_op_array:
		SEPARATE_ARRAY(container);
		ht = C_ARRVAL_P(container);
assign_dim_op_new_array:
		dim = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
		if ((IS_TMP_VAR|IS_VAR) == IS_UNUSED) {
			var_ptr = crex_hash_next_index_insert(ht, &EG(uninitialized_zval));
			if (UNEXPECTED(!var_ptr)) {
				crex_cannot_add_element();
				goto assign_dim_op_ret_null;
			}
		} else {
			if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
				var_ptr = crex_fetch_dimension_address_inner_RW_CONST(ht, dim EXECUTE_DATA_CC);
			} else {
				var_ptr = crex_fetch_dimension_address_inner_RW(ht, dim EXECUTE_DATA_CC);
			}
			if (UNEXPECTED(!var_ptr)) {
				goto assign_dim_op_ret_null;
			}
		}

		value = get_op_data_zval_ptr_r((opline+1)->op1_type, (opline+1)->op1);

		do {
			if ((IS_TMP_VAR|IS_VAR) != IS_UNUSED && UNEXPECTED(C_ISREF_P(var_ptr))) {
				crex_reference *ref = C_REF_P(var_ptr);
				var_ptr = C_REFVAL_P(var_ptr);
				if (UNEXPECTED(CREX_REF_HAS_TYPE_SOURCES(ref))) {
					crex_binary_assign_op_typed_ref(ref, value OPLINE_CC EXECUTE_DATA_CC);
					break;
				}
			}
			crex_binary_op(var_ptr, var_ptr, value OPLINE_CC);
		} while (0);

		if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
			ZVAL_COPY(EX_VAR(opline->result.var), var_ptr);
		}
		FREE_OP((opline+1)->op1_type, (opline+1)->op1.var);
	} else {
		if (EXPECTED(C_ISREF_P(container))) {
			container = C_REFVAL_P(container);
			if (EXPECTED(C_TYPE_P(container) == IS_ARRAY)) {
				goto assign_dim_op_array;
			}
		}

		if (EXPECTED(C_TYPE_P(container) == IS_OBJECT)) {
			crex_object *obj = C_OBJ_P(container);

			dim = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
			if ((IS_TMP_VAR|IS_VAR) == IS_CONST && C_EXTRA_P(dim) == CREX_EXTRA_VALUE) {
				dim++;
			}
			crex_binary_assign_op_obj_dim(obj, dim OPLINE_CC EXECUTE_DATA_CC);
		} else if (EXPECTED(C_TYPE_P(container) <= IS_FALSE)) {
			uint8_t old_type;

			if (IS_CV == IS_CV && UNEXPECTED(C_TYPE_INFO_P(container) == IS_UNDEF)) {
				ZVAL_UNDEFINED_OP1();
			}
			ht = crex_new_array(8);
			old_type = C_TYPE_P(container);
			ZVAL_ARR(container, ht);
			if (UNEXPECTED(old_type == IS_FALSE)) {
				GC_ADDREF(ht);
				crex_false_to_array_deprecated();
				if (UNEXPECTED(GC_DELREF(ht) == 0)) {
					crex_array_destroy(ht);
					goto assign_dim_op_ret_null;
				}
			}
			goto assign_dim_op_new_array;
		} else {
			dim = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
			crex_binary_assign_op_dim_slow(container, dim OPLINE_CC EXECUTE_DATA_CC);
assign_dim_op_ret_null:
			FREE_OP((opline+1)->op1_type, (opline+1)->op1.var);
			if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
				ZVAL_NULL(EX_VAR(opline->result.var));
			}
		}
	}

	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));

	CREX_VM_NEXT_OPCODE_EX(1, 2);
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ASSIGN_OP_SPEC_CV_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *var_ptr;
	zval *value;

	SAVE_OPLINE();
	value = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
	var_ptr = _get_zval_ptr_cv_BP_VAR_RW(opline->op1.var EXECUTE_DATA_CC);

	do {
		if (UNEXPECTED(C_TYPE_P(var_ptr) == IS_REFERENCE)) {
			crex_reference *ref = C_REF_P(var_ptr);
			var_ptr = C_REFVAL_P(var_ptr);
			if (UNEXPECTED(CREX_REF_HAS_TYPE_SOURCES(ref))) {
				crex_binary_assign_op_typed_ref(ref, value OPLINE_CC EXECUTE_DATA_CC);
				break;
			}
		}
		crex_binary_op(var_ptr, var_ptr, value OPLINE_CC);
	} while (0);

	if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
		ZVAL_COPY(EX_VAR(opline->result.var), var_ptr);
	}

	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));

	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_PRE_INC_OBJ_SPEC_CV_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *object;
	zval *property;
	zval *zptr;
	void **cache_slot;
	crex_property_info *prop_info;
	crex_object *zobj;
	crex_string *name, *tmp_name;

	SAVE_OPLINE();
	object = EX_VAR(opline->op1.var);
	property = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);

	do {
		if (IS_CV != IS_UNUSED && UNEXPECTED(C_TYPE_P(object) != IS_OBJECT)) {
			if (C_ISREF_P(object) && C_TYPE_P(C_REFVAL_P(object)) == IS_OBJECT) {
				object = C_REFVAL_P(object);
				goto pre_incdec_object;
			}
			if (IS_CV == IS_CV
			 && UNEXPECTED(C_TYPE_P(object) == IS_UNDEF)) {
				ZVAL_UNDEFINED_OP1();
			}
			crex_throw_non_object_error(object, property OPLINE_CC EXECUTE_DATA_CC);
			break;
		}

pre_incdec_object:
		/* here we are sure we are dealing with an object */
		zobj = C_OBJ_P(object);
		if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
			name = C_STR_P(property);
		} else {
			name = zval_try_get_tmp_string(property, &tmp_name);
			if (UNEXPECTED(!name)) {
				UNDEF_RESULT();
				break;
			}
		}
		cache_slot = ((IS_TMP_VAR|IS_VAR) == IS_CONST) ? CACHE_ADDR(opline->extended_value) : NULL;
		if (EXPECTED((zptr = zobj->handlers->get_property_ptr_ptr(zobj, name, BP_VAR_RW, cache_slot)) != NULL)) {
			if (UNEXPECTED(C_ISERROR_P(zptr))) {
				if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
					ZVAL_NULL(EX_VAR(opline->result.var));
				}
			} else {
				if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
					prop_info = (crex_property_info *) CACHED_PTR_EX(cache_slot + 2);
				} else {
					prop_info = crex_object_fetch_property_type_info(C_OBJ_P(object), zptr);
				}
				crex_pre_incdec_property_zval(zptr, prop_info OPLINE_CC EXECUTE_DATA_CC);
			}
		} else {
			crex_pre_incdec_overloaded_property(zobj, name, cache_slot OPLINE_CC EXECUTE_DATA_CC);
		}
		if ((IS_TMP_VAR|IS_VAR) != IS_CONST) {
			crex_tmp_string_release(tmp_name);
		}
	} while (0);

	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));

	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_POST_INC_OBJ_SPEC_CV_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *object;
	zval *property;
	zval *zptr;
	void **cache_slot;
	crex_property_info *prop_info;
	crex_object *zobj;
	crex_string *name, *tmp_name;

	SAVE_OPLINE();
	object = EX_VAR(opline->op1.var);
	property = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);

	do {
		if (IS_CV != IS_UNUSED && UNEXPECTED(C_TYPE_P(object) != IS_OBJECT)) {
			if (C_ISREF_P(object) && C_TYPE_P(C_REFVAL_P(object)) == IS_OBJECT) {
				object = C_REFVAL_P(object);
				goto post_incdec_object;
			}
			if (IS_CV == IS_CV
			 && UNEXPECTED(C_TYPE_P(object) == IS_UNDEF)) {
				ZVAL_UNDEFINED_OP1();
			}
			crex_throw_non_object_error(object, property OPLINE_CC EXECUTE_DATA_CC);
			break;
		}

post_incdec_object:
		/* here we are sure we are dealing with an object */
		zobj = C_OBJ_P(object);
		if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
			name = C_STR_P(property);
		} else {
			name = zval_try_get_tmp_string(property, &tmp_name);
			if (UNEXPECTED(!name)) {
				ZVAL_UNDEF(EX_VAR(opline->result.var));
				break;
			}
		}
		cache_slot = ((IS_TMP_VAR|IS_VAR) == IS_CONST) ? CACHE_ADDR(opline->extended_value) : NULL;
		if (EXPECTED((zptr = zobj->handlers->get_property_ptr_ptr(zobj, name, BP_VAR_RW, cache_slot)) != NULL)) {
			if (UNEXPECTED(C_ISERROR_P(zptr))) {
				ZVAL_NULL(EX_VAR(opline->result.var));
			} else {
				if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
					prop_info = (crex_property_info*)CACHED_PTR_EX(cache_slot + 2);
				} else {
					prop_info = crex_object_fetch_property_type_info(C_OBJ_P(object), zptr);
				}

				crex_post_incdec_property_zval(zptr, prop_info OPLINE_CC EXECUTE_DATA_CC);
			}
		} else {
			crex_post_incdec_overloaded_property(zobj, name, cache_slot OPLINE_CC EXECUTE_DATA_CC);
		}
		if ((IS_TMP_VAR|IS_VAR) != IS_CONST) {
			crex_tmp_string_release(tmp_name);
		}
	} while (0);

	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));

	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FETCH_DIM_R_SPEC_CV_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container, *dim, *value;

	SAVE_OPLINE();
	container = EX_VAR(opline->op1.var);
	dim = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
	if (IS_CV != IS_CONST) {
		if (EXPECTED(C_TYPE_P(container) == IS_ARRAY)) {
fetch_dim_r_array:
			value = crex_fetch_dimension_address_inner(C_ARRVAL_P(container), dim, (IS_TMP_VAR|IS_VAR), BP_VAR_R EXECUTE_DATA_CC);
			ZVAL_COPY_DEREF(EX_VAR(opline->result.var), value);
		} else if (EXPECTED(C_TYPE_P(container) == IS_REFERENCE)) {
			container = C_REFVAL_P(container);
			if (EXPECTED(C_TYPE_P(container) == IS_ARRAY)) {
				goto fetch_dim_r_array;
			} else {
				goto fetch_dim_r_slow;
			}
		} else {
fetch_dim_r_slow:
			if ((IS_TMP_VAR|IS_VAR) == IS_CONST && C_EXTRA_P(dim) == CREX_EXTRA_VALUE) {
				dim++;
			}
			crex_fetch_dimension_address_read_R_slow(container, dim OPLINE_CC EXECUTE_DATA_CC);
		}
	} else {
		crex_fetch_dimension_address_read_R(container, dim, (IS_TMP_VAR|IS_VAR) OPLINE_CC EXECUTE_DATA_CC);
	}
	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));

	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FETCH_DIM_W_SPEC_CV_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;

	SAVE_OPLINE();
	container = EX_VAR(opline->op1.var);
	crex_fetch_dimension_address_W(container, _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC), (IS_TMP_VAR|IS_VAR) OPLINE_CC EXECUTE_DATA_CC);
	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
	if (IS_CV == IS_VAR) {
		FREE_VAR_PTR_AND_EXTRACT_RESULT_IF_NECESSARY(opline->op1.var);
	}
	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FETCH_DIM_RW_SPEC_CV_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;

	SAVE_OPLINE();
	container = EX_VAR(opline->op1.var);
	crex_fetch_dimension_address_RW(container, _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC), (IS_TMP_VAR|IS_VAR) OPLINE_CC EXECUTE_DATA_CC);
	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
	if (IS_CV == IS_VAR) {
		FREE_VAR_PTR_AND_EXTRACT_RESULT_IF_NECESSARY(opline->op1.var);
	}
	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FETCH_DIM_IS_SPEC_CV_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;

	SAVE_OPLINE();
	container = EX_VAR(opline->op1.var);
	crex_fetch_dimension_address_read_IS(container, _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC), (IS_TMP_VAR|IS_VAR) OPLINE_CC EXECUTE_DATA_CC);
	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));

	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FETCH_DIM_FUNC_ARG_SPEC_CV_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
#if 0
	USE_OPLINE
#endif

	if (UNEXPECTED(CREX_CALL_INFO(EX(call)) & CREX_CALL_SEND_ARG_BY_REF)) {
		if ((IS_CV & (IS_CONST|IS_TMP_VAR))) {
			CREX_VM_TAIL_CALL(crex_use_tmp_in_write_context_helper_SPEC(CREX_OPCODE_HANDLER_ARGS_PASSTHRU));
		}
		CREX_VM_TAIL_CALL(CREX_FETCH_DIM_W_SPEC_CV_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU));
	} else {
		if ((IS_TMP_VAR|IS_VAR) == IS_UNUSED) {
			CREX_VM_TAIL_CALL(crex_use_undef_in_read_context_helper_SPEC(CREX_OPCODE_HANDLER_ARGS_PASSTHRU));
		}
		CREX_VM_TAIL_CALL(CREX_FETCH_DIM_R_SPEC_CV_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU));
	}
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FETCH_DIM_UNSET_SPEC_CV_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;

	SAVE_OPLINE();
	container = EX_VAR(opline->op1.var);
	crex_fetch_dimension_address_UNSET(container, _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC), (IS_TMP_VAR|IS_VAR) OPLINE_CC EXECUTE_DATA_CC);
	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
	if (IS_CV == IS_VAR) {
		FREE_VAR_PTR_AND_EXTRACT_RESULT_IF_NECESSARY(opline->op1.var);
	}
	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FETCH_OBJ_R_SPEC_CV_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;
	void **cache_slot = NULL;

	SAVE_OPLINE();
	container = EX_VAR(opline->op1.var);

	if (IS_CV == IS_CONST ||
	    (IS_CV != IS_UNUSED && UNEXPECTED(C_TYPE_P(container) != IS_OBJECT))) {
		do {
			if ((IS_CV & (IS_VAR|IS_CV)) && C_ISREF_P(container)) {
				container = C_REFVAL_P(container);
				if (EXPECTED(C_TYPE_P(container) == IS_OBJECT)) {
					break;
				}
			}
			if (IS_CV == IS_CV && UNEXPECTED(C_TYPE_P(container) == IS_UNDEF)) {
				ZVAL_UNDEFINED_OP1();
			}
			crex_wrong_property_read(container, _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC));
			ZVAL_NULL(EX_VAR(opline->result.var));
			goto fetch_obj_r_finish;
		} while (0);
	}

	/* here we are sure we are dealing with an object */
	do {
		crex_object *zobj = C_OBJ_P(container);
		crex_string *name, *tmp_name;
		zval *retval;

		if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
			cache_slot = CACHE_ADDR(opline->extended_value & ~CREX_FETCH_REF /* FUNC_ARG fetch may contain it */);

			if (EXPECTED(zobj->ce == CACHED_PTR_EX(cache_slot))) {
				uintptr_t prop_offset = (uintptr_t)CACHED_PTR_EX(cache_slot + 1);

				if (EXPECTED(IS_VALID_PROPERTY_OFFSET(prop_offset))) {
					retval = OBJ_PROP(zobj, prop_offset);
					if (EXPECTED(C_TYPE_INFO_P(retval) != IS_UNDEF)) {
						if (0 || (IS_CV & (IS_TMP_VAR|IS_VAR)) != 0) {
							goto fetch_obj_r_copy;
						} else {
fetch_obj_r_fast_copy:
							ZVAL_COPY_DEREF(EX_VAR(opline->result.var), retval);
							CREX_VM_NEXT_OPCODE();
						}
					}
				} else if (EXPECTED(zobj->properties != NULL)) {
					name = C_STR_P(_get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC));
					if (!IS_UNKNOWN_DYNAMIC_PROPERTY_OFFSET(prop_offset)) {
						uintptr_t idx = CREX_DECODE_DYN_PROP_OFFSET(prop_offset);

						if (EXPECTED(idx < zobj->properties->nNumUsed * sizeof(Bucket))) {
							Bucket *p = (Bucket*)((char*)zobj->properties->arData + idx);

							if (EXPECTED(p->key == name) ||
							    (EXPECTED(p->h == ZSTR_H(name)) &&
							     EXPECTED(p->key != NULL) &&
							     EXPECTED(crex_string_equal_content(p->key, name)))) {
								retval = &p->val;
								if (0 || (IS_CV & (IS_TMP_VAR|IS_VAR)) != 0) {
									goto fetch_obj_r_copy;
								} else {
									goto fetch_obj_r_fast_copy;
								}
							}
						}
						CACHE_PTR_EX(cache_slot + 1, (void*)CREX_DYNAMIC_PROPERTY_OFFSET);
					}
					retval = crex_hash_find_known_hash(zobj->properties, name);
					if (EXPECTED(retval)) {
						uintptr_t idx = (char*)retval - (char*)zobj->properties->arData;
						CACHE_PTR_EX(cache_slot + 1, (void*)CREX_ENCODE_DYN_PROP_OFFSET(idx));
						if (0 || (IS_CV & (IS_TMP_VAR|IS_VAR)) != 0) {
							goto fetch_obj_r_copy;
						} else {
							goto fetch_obj_r_fast_copy;
						}
					}
				}
			}
			name = C_STR_P(_get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC));
		} else {
			name = zval_try_get_tmp_string(_get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC), &tmp_name);
			if (UNEXPECTED(!name)) {
				ZVAL_UNDEF(EX_VAR(opline->result.var));
				break;
			}
		}

#if CREX_DEBUG
		/* For non-standard object handlers, verify a declared property type in debug builds.
		 * Fetch prop_info before calling read_property(), as it may deallocate the object. */
		crex_property_info *prop_info = NULL;
		if (zobj->handlers->read_property != crex_std_read_property) {
			prop_info = crex_get_property_info(zobj->ce, name, /* silent */ true);
		}
#endif
		retval = zobj->handlers->read_property(zobj, name, BP_VAR_R, cache_slot, EX_VAR(opline->result.var));
#if CREX_DEBUG
		if (!EG(exception) && prop_info && prop_info != CREX_WRONG_PROPERTY_INFO
				&& CREX_TYPE_IS_SET(prop_info->type)) {
			ZVAL_OPT_DEREF(retval);
			crex_verify_property_type(prop_info, retval, /* strict */ true);
		}
#endif

		if ((IS_TMP_VAR|IS_VAR) != IS_CONST) {
			crex_tmp_string_release(tmp_name);
		}

		if (retval != EX_VAR(opline->result.var)) {
fetch_obj_r_copy:
			ZVAL_COPY_DEREF(EX_VAR(opline->result.var), retval);
		} else if (UNEXPECTED(C_ISREF_P(retval))) {
			crex_unwrap_reference(retval);
		}
	} while (0);

fetch_obj_r_finish:
	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));

	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FETCH_OBJ_W_SPEC_CV_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *property, *container, *result;

	SAVE_OPLINE();

	container = EX_VAR(opline->op1.var);
	property = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
	result = EX_VAR(opline->result.var);
	crex_fetch_property_address(
		result, container, IS_CV, property, (IS_TMP_VAR|IS_VAR),
		(((IS_TMP_VAR|IS_VAR) == IS_CONST) ? CACHE_ADDR(opline->extended_value & ~CREX_FETCH_OBJ_FLAGS) : NULL),
		BP_VAR_W, opline->extended_value OPLINE_CC EXECUTE_DATA_CC);
	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
	if (IS_CV == IS_VAR) {
		FREE_VAR_PTR_AND_EXTRACT_RESULT_IF_NECESSARY(opline->op1.var);
	}
	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FETCH_OBJ_RW_SPEC_CV_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *property, *container, *result;

	SAVE_OPLINE();
	container = EX_VAR(opline->op1.var);
	property = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
	result = EX_VAR(opline->result.var);
	crex_fetch_property_address(result, container, IS_CV, property, (IS_TMP_VAR|IS_VAR), (((IS_TMP_VAR|IS_VAR) == IS_CONST) ? CACHE_ADDR(opline->extended_value) : NULL), BP_VAR_RW, 0 OPLINE_CC EXECUTE_DATA_CC);
	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
	if (IS_CV == IS_VAR) {
		FREE_VAR_PTR_AND_EXTRACT_RESULT_IF_NECESSARY(opline->op1.var);
	}
	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FETCH_OBJ_IS_SPEC_CV_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;
	void **cache_slot = NULL;

	SAVE_OPLINE();
	container = _get_zval_ptr_cv_BP_VAR_IS(opline->op1.var EXECUTE_DATA_CC);

	if (IS_CV == IS_CONST ||
	    (IS_CV != IS_UNUSED && UNEXPECTED(C_TYPE_P(container) != IS_OBJECT))) {
		do {
			if ((IS_CV & (IS_VAR|IS_CV)) && C_ISREF_P(container)) {
				container = C_REFVAL_P(container);
				if (EXPECTED(C_TYPE_P(container) == IS_OBJECT)) {
					break;
				}
			}
			if ((IS_TMP_VAR|IS_VAR) == IS_CV && C_TYPE_P(EX_VAR(opline->op2.var)) == IS_UNDEF) {
				ZVAL_UNDEFINED_OP2();
			}
			ZVAL_NULL(EX_VAR(opline->result.var));
			goto fetch_obj_is_finish;
		} while (0);
	}

	/* here we are sure we are dealing with an object */
	do {
		crex_object *zobj = C_OBJ_P(container);
		crex_string *name, *tmp_name;
		zval *retval;

		if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
			cache_slot = CACHE_ADDR(opline->extended_value);

			if (EXPECTED(zobj->ce == CACHED_PTR_EX(cache_slot))) {
				uintptr_t prop_offset = (uintptr_t)CACHED_PTR_EX(cache_slot + 1);

				if (EXPECTED(IS_VALID_PROPERTY_OFFSET(prop_offset))) {
					retval = OBJ_PROP(zobj, prop_offset);
					if (EXPECTED(C_TYPE_P(retval) != IS_UNDEF)) {
						if (0 || (IS_CV & (IS_TMP_VAR|IS_VAR)) != 0) {
							goto fetch_obj_is_copy;
						} else {
fetch_obj_is_fast_copy:
							ZVAL_COPY_DEREF(EX_VAR(opline->result.var), retval);
							CREX_VM_NEXT_OPCODE();
						}
					}
				} else if (EXPECTED(zobj->properties != NULL)) {
					name = C_STR_P(_get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC));
					if (!IS_UNKNOWN_DYNAMIC_PROPERTY_OFFSET(prop_offset)) {
						uintptr_t idx = CREX_DECODE_DYN_PROP_OFFSET(prop_offset);

						if (EXPECTED(idx < zobj->properties->nNumUsed * sizeof(Bucket))) {
							Bucket *p = (Bucket*)((char*)zobj->properties->arData + idx);

							if (EXPECTED(p->key == name) ||
							    (EXPECTED(p->h == ZSTR_H(name)) &&
							     EXPECTED(p->key != NULL) &&
							     EXPECTED(crex_string_equal_content(p->key, name)))) {
								retval = &p->val;
								if (0 || (IS_CV & (IS_TMP_VAR|IS_VAR)) != 0) {
									goto fetch_obj_is_copy;
								} else {
									goto fetch_obj_is_fast_copy;
								}
							}
						}
						CACHE_PTR_EX(cache_slot + 1, (void*)CREX_DYNAMIC_PROPERTY_OFFSET);
					}
					retval = crex_hash_find_known_hash(zobj->properties, name);
					if (EXPECTED(retval)) {
						uintptr_t idx = (char*)retval - (char*)zobj->properties->arData;
						CACHE_PTR_EX(cache_slot + 1, (void*)CREX_ENCODE_DYN_PROP_OFFSET(idx));
						if (0 || (IS_CV & (IS_TMP_VAR|IS_VAR)) != 0) {
							goto fetch_obj_is_copy;
						} else {
							goto fetch_obj_is_fast_copy;
						}
					}
				}
			}
			name = C_STR_P(_get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC));
		} else {
			name = zval_try_get_tmp_string(_get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC), &tmp_name);
			if (UNEXPECTED(!name)) {
				ZVAL_UNDEF(EX_VAR(opline->result.var));
				break;
			}
		}

		retval = zobj->handlers->read_property(zobj, name, BP_VAR_IS, cache_slot, EX_VAR(opline->result.var));

		if ((IS_TMP_VAR|IS_VAR) != IS_CONST) {
			crex_tmp_string_release(tmp_name);
		}

		if (retval != EX_VAR(opline->result.var)) {
fetch_obj_is_copy:
			ZVAL_COPY_DEREF(EX_VAR(opline->result.var), retval);
		} else if (UNEXPECTED(C_ISREF_P(retval))) {
			crex_unwrap_reference(retval);
		}
	} while (0);

fetch_obj_is_finish:
	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));

	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FETCH_OBJ_FUNC_ARG_SPEC_CV_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
#if 0
	USE_OPLINE
#endif

	if (UNEXPECTED(CREX_CALL_INFO(EX(call)) & CREX_CALL_SEND_ARG_BY_REF)) {
		/* Behave like FETCH_OBJ_W */
		if ((IS_CV & (IS_CONST|IS_TMP_VAR))) {
			CREX_VM_TAIL_CALL(crex_use_tmp_in_write_context_helper_SPEC(CREX_OPCODE_HANDLER_ARGS_PASSTHRU));
		}
		CREX_VM_TAIL_CALL(CREX_FETCH_OBJ_W_SPEC_CV_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU));
	} else {
		CREX_VM_TAIL_CALL(CREX_FETCH_OBJ_R_SPEC_CV_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU));
	}
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FETCH_OBJ_UNSET_SPEC_CV_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container, *property, *result;

	SAVE_OPLINE();
	container = EX_VAR(opline->op1.var);
	property = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
	result = EX_VAR(opline->result.var);
	crex_fetch_property_address(result, container, IS_CV, property, (IS_TMP_VAR|IS_VAR), (((IS_TMP_VAR|IS_VAR) == IS_CONST) ? CACHE_ADDR(opline->extended_value) : NULL), BP_VAR_UNSET, 0 OPLINE_CC EXECUTE_DATA_CC);
	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
	if (IS_CV == IS_VAR) {
		FREE_VAR_PTR_AND_EXTRACT_RESULT_IF_NECESSARY(opline->op1.var);
	}
	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ASSIGN_OBJ_SPEC_CV_TMPVAR_OP_DATA_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *object, *value, tmp;
	crex_object *zobj;
	crex_string *name, *tmp_name;
	crex_refcounted *garbage = NULL;

	SAVE_OPLINE();
	object = EX_VAR(opline->op1.var);
	value = RT_CONSTANT((opline+1), (opline+1)->op1);

	if (IS_CV != IS_UNUSED && UNEXPECTED(C_TYPE_P(object) != IS_OBJECT)) {
		if (C_ISREF_P(object) && C_TYPE_P(C_REFVAL_P(object)) == IS_OBJECT) {
			object = C_REFVAL_P(object);
			goto assign_object;
		}
		crex_throw_non_object_error(object, _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC) OPLINE_CC EXECUTE_DATA_CC);
		value = &EG(uninitialized_zval);
		goto free_and_exit_assign_obj;
	}

assign_object:
	zobj = C_OBJ_P(object);
	if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
		if (EXPECTED(zobj->ce == CACHED_PTR(opline->extended_value))) {
			void **cache_slot = CACHE_ADDR(opline->extended_value);
			uintptr_t prop_offset = (uintptr_t)CACHED_PTR_EX(cache_slot + 1);
			zval *property_val;

			if (EXPECTED(IS_VALID_PROPERTY_OFFSET(prop_offset))) {
				property_val = OBJ_PROP(zobj, prop_offset);
				if (C_TYPE_P(property_val) != IS_UNDEF) {
					crex_property_info *prop_info = (crex_property_info*) CACHED_PTR_EX(cache_slot + 2);

					if (UNEXPECTED(prop_info != NULL)) {
						value = crex_assign_to_typed_prop(prop_info, property_val, value, &garbage EXECUTE_DATA_CC);
						goto free_and_exit_assign_obj;
					} else {
fast_assign_obj:
						value = crex_assign_to_variable_ex(property_val, value, IS_CONST, EX_USES_STRICT_TYPES(), &garbage);
						if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
							ZVAL_COPY(EX_VAR(opline->result.var), value);
						}
						goto exit_assign_obj;
					}
				}
			} else {
				name = C_STR_P(_get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC));
				if (EXPECTED(zobj->properties != NULL)) {
					if (UNEXPECTED(GC_REFCOUNT(zobj->properties) > 1)) {
						if (EXPECTED(!(GC_FLAGS(zobj->properties) & IS_ARRAY_IMMUTABLE))) {
							GC_DELREF(zobj->properties);
						}
						zobj->properties = crex_array_dup(zobj->properties);
					}
					property_val = crex_hash_find_known_hash(zobj->properties, name);
					if (property_val) {
						goto fast_assign_obj;
					}
				}

				if (!zobj->ce->__set && (zobj->ce->ce_flags & CREX_ACC_ALLOW_DYNAMIC_PROPERTIES)) {
					if (EXPECTED(zobj->properties == NULL)) {
						rebuild_object_properties(zobj);
					}
					if (IS_CONST == IS_CONST) {
						if (UNEXPECTED(C_OPT_REFCOUNTED_P(value))) {
							C_ADDREF_P(value);
						}
					} else if (IS_CONST != IS_TMP_VAR) {
						if (C_ISREF_P(value)) {
							if (IS_CONST == IS_VAR) {
								crex_reference *ref = C_REF_P(value);
								if (GC_DELREF(ref) == 0) {
									ZVAL_COPY_VALUE(&tmp, C_REFVAL_P(value));
									efree_size(ref, sizeof(crex_reference));
									value = &tmp;
								} else {
									value = C_REFVAL_P(value);
									C_TRY_ADDREF_P(value);
								}
							} else {
								value = C_REFVAL_P(value);
								C_TRY_ADDREF_P(value);
							}
						} else if (IS_CONST == IS_CV) {
							C_TRY_ADDREF_P(value);
						}
						}
					crex_hash_add_new(zobj->properties, name, value);
					if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
						ZVAL_COPY(EX_VAR(opline->result.var), value);
					}
					goto exit_assign_obj;
				}
			}
		}
		name = C_STR_P(_get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC));
	} else {
		name = zval_try_get_tmp_string(_get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC), &tmp_name);
		if (UNEXPECTED(!name)) {

			UNDEF_RESULT();
			goto exit_assign_obj;
		}
	}

	if (IS_CONST == IS_CV || IS_CONST == IS_VAR) {
		ZVAL_DEREF(value);
	}

	value = zobj->handlers->write_property(zobj, name, value, ((IS_TMP_VAR|IS_VAR) == IS_CONST) ? CACHE_ADDR(opline->extended_value) : NULL);

	if ((IS_TMP_VAR|IS_VAR) != IS_CONST) {
		crex_tmp_string_release(tmp_name);
	}

free_and_exit_assign_obj:
	if (UNEXPECTED(RETURN_VALUE_USED(opline)) && value) {
		ZVAL_COPY_DEREF(EX_VAR(opline->result.var), value);
	}

exit_assign_obj:
	if (garbage) {
		GC_DTOR_NO_REF(garbage);
	}
	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));

	/* assign_obj has two opcodes! */
	CREX_VM_NEXT_OPCODE_EX(1, 2);
}

/* No specialization for op_types (CONST|TMPVAR|CV, UNUSED|CONST|VAR) */
static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ASSIGN_OBJ_SPEC_CV_TMPVAR_OP_DATA_TMP_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *object, *value, tmp;
	crex_object *zobj;
	crex_string *name, *tmp_name;
	crex_refcounted *garbage = NULL;

	SAVE_OPLINE();
	object = EX_VAR(opline->op1.var);
	value = _get_zval_ptr_tmp((opline+1)->op1.var EXECUTE_DATA_CC);

	if (IS_CV != IS_UNUSED && UNEXPECTED(C_TYPE_P(object) != IS_OBJECT)) {
		if (C_ISREF_P(object) && C_TYPE_P(C_REFVAL_P(object)) == IS_OBJECT) {
			object = C_REFVAL_P(object);
			goto assign_object;
		}
		crex_throw_non_object_error(object, _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC) OPLINE_CC EXECUTE_DATA_CC);
		value = &EG(uninitialized_zval);
		goto free_and_exit_assign_obj;
	}

assign_object:
	zobj = C_OBJ_P(object);
	if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
		if (EXPECTED(zobj->ce == CACHED_PTR(opline->extended_value))) {
			void **cache_slot = CACHE_ADDR(opline->extended_value);
			uintptr_t prop_offset = (uintptr_t)CACHED_PTR_EX(cache_slot + 1);
			zval *property_val;

			if (EXPECTED(IS_VALID_PROPERTY_OFFSET(prop_offset))) {
				property_val = OBJ_PROP(zobj, prop_offset);
				if (C_TYPE_P(property_val) != IS_UNDEF) {
					crex_property_info *prop_info = (crex_property_info*) CACHED_PTR_EX(cache_slot + 2);

					if (UNEXPECTED(prop_info != NULL)) {
						value = crex_assign_to_typed_prop(prop_info, property_val, value, &garbage EXECUTE_DATA_CC);
						goto free_and_exit_assign_obj;
					} else {
fast_assign_obj:
						value = crex_assign_to_variable_ex(property_val, value, IS_TMP_VAR, EX_USES_STRICT_TYPES(), &garbage);
						if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
							ZVAL_COPY(EX_VAR(opline->result.var), value);
						}
						goto exit_assign_obj;
					}
				}
			} else {
				name = C_STR_P(_get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC));
				if (EXPECTED(zobj->properties != NULL)) {
					if (UNEXPECTED(GC_REFCOUNT(zobj->properties) > 1)) {
						if (EXPECTED(!(GC_FLAGS(zobj->properties) & IS_ARRAY_IMMUTABLE))) {
							GC_DELREF(zobj->properties);
						}
						zobj->properties = crex_array_dup(zobj->properties);
					}
					property_val = crex_hash_find_known_hash(zobj->properties, name);
					if (property_val) {
						goto fast_assign_obj;
					}
				}

				if (!zobj->ce->__set && (zobj->ce->ce_flags & CREX_ACC_ALLOW_DYNAMIC_PROPERTIES)) {
					if (EXPECTED(zobj->properties == NULL)) {
						rebuild_object_properties(zobj);
					}
					if (IS_TMP_VAR == IS_CONST) {
						if (UNEXPECTED(C_OPT_REFCOUNTED_P(value))) {
							C_ADDREF_P(value);
						}
					} else if (IS_TMP_VAR != IS_TMP_VAR) {
						if (C_ISREF_P(value)) {
							if (IS_TMP_VAR == IS_VAR) {
								crex_reference *ref = C_REF_P(value);
								if (GC_DELREF(ref) == 0) {
									ZVAL_COPY_VALUE(&tmp, C_REFVAL_P(value));
									efree_size(ref, sizeof(crex_reference));
									value = &tmp;
								} else {
									value = C_REFVAL_P(value);
									C_TRY_ADDREF_P(value);
								}
							} else {
								value = C_REFVAL_P(value);
								C_TRY_ADDREF_P(value);
							}
						} else if (IS_TMP_VAR == IS_CV) {
							C_TRY_ADDREF_P(value);
						}
						}
					crex_hash_add_new(zobj->properties, name, value);
					if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
						ZVAL_COPY(EX_VAR(opline->result.var), value);
					}
					goto exit_assign_obj;
				}
			}
		}
		name = C_STR_P(_get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC));
	} else {
		name = zval_try_get_tmp_string(_get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC), &tmp_name);
		if (UNEXPECTED(!name)) {
			zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
			UNDEF_RESULT();
			goto exit_assign_obj;
		}
	}

	if (IS_TMP_VAR == IS_CV || IS_TMP_VAR == IS_VAR) {
		ZVAL_DEREF(value);
	}

	value = zobj->handlers->write_property(zobj, name, value, ((IS_TMP_VAR|IS_VAR) == IS_CONST) ? CACHE_ADDR(opline->extended_value) : NULL);

	if ((IS_TMP_VAR|IS_VAR) != IS_CONST) {
		crex_tmp_string_release(tmp_name);
	}

free_and_exit_assign_obj:
	if (UNEXPECTED(RETURN_VALUE_USED(opline)) && value) {
		ZVAL_COPY_DEREF(EX_VAR(opline->result.var), value);
	}
	zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
exit_assign_obj:
	if (garbage) {
		GC_DTOR_NO_REF(garbage);
	}
	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));

	/* assign_obj has two opcodes! */
	CREX_VM_NEXT_OPCODE_EX(1, 2);
}

/* No specialization for op_types (CONST|TMPVAR|CV, UNUSED|CONST|VAR) */
static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ASSIGN_OBJ_SPEC_CV_TMPVAR_OP_DATA_VAR_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *object, *value, tmp;
	crex_object *zobj;
	crex_string *name, *tmp_name;
	crex_refcounted *garbage = NULL;

	SAVE_OPLINE();
	object = EX_VAR(opline->op1.var);
	value = _get_zval_ptr_var((opline+1)->op1.var EXECUTE_DATA_CC);

	if (IS_CV != IS_UNUSED && UNEXPECTED(C_TYPE_P(object) != IS_OBJECT)) {
		if (C_ISREF_P(object) && C_TYPE_P(C_REFVAL_P(object)) == IS_OBJECT) {
			object = C_REFVAL_P(object);
			goto assign_object;
		}
		crex_throw_non_object_error(object, _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC) OPLINE_CC EXECUTE_DATA_CC);
		value = &EG(uninitialized_zval);
		goto free_and_exit_assign_obj;
	}

assign_object:
	zobj = C_OBJ_P(object);
	if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
		if (EXPECTED(zobj->ce == CACHED_PTR(opline->extended_value))) {
			void **cache_slot = CACHE_ADDR(opline->extended_value);
			uintptr_t prop_offset = (uintptr_t)CACHED_PTR_EX(cache_slot + 1);
			zval *property_val;

			if (EXPECTED(IS_VALID_PROPERTY_OFFSET(prop_offset))) {
				property_val = OBJ_PROP(zobj, prop_offset);
				if (C_TYPE_P(property_val) != IS_UNDEF) {
					crex_property_info *prop_info = (crex_property_info*) CACHED_PTR_EX(cache_slot + 2);

					if (UNEXPECTED(prop_info != NULL)) {
						value = crex_assign_to_typed_prop(prop_info, property_val, value, &garbage EXECUTE_DATA_CC);
						goto free_and_exit_assign_obj;
					} else {
fast_assign_obj:
						value = crex_assign_to_variable_ex(property_val, value, IS_VAR, EX_USES_STRICT_TYPES(), &garbage);
						if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
							ZVAL_COPY(EX_VAR(opline->result.var), value);
						}
						goto exit_assign_obj;
					}
				}
			} else {
				name = C_STR_P(_get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC));
				if (EXPECTED(zobj->properties != NULL)) {
					if (UNEXPECTED(GC_REFCOUNT(zobj->properties) > 1)) {
						if (EXPECTED(!(GC_FLAGS(zobj->properties) & IS_ARRAY_IMMUTABLE))) {
							GC_DELREF(zobj->properties);
						}
						zobj->properties = crex_array_dup(zobj->properties);
					}
					property_val = crex_hash_find_known_hash(zobj->properties, name);
					if (property_val) {
						goto fast_assign_obj;
					}
				}

				if (!zobj->ce->__set && (zobj->ce->ce_flags & CREX_ACC_ALLOW_DYNAMIC_PROPERTIES)) {
					if (EXPECTED(zobj->properties == NULL)) {
						rebuild_object_properties(zobj);
					}
					if (IS_VAR == IS_CONST) {
						if (UNEXPECTED(C_OPT_REFCOUNTED_P(value))) {
							C_ADDREF_P(value);
						}
					} else if (IS_VAR != IS_TMP_VAR) {
						if (C_ISREF_P(value)) {
							if (IS_VAR == IS_VAR) {
								crex_reference *ref = C_REF_P(value);
								if (GC_DELREF(ref) == 0) {
									ZVAL_COPY_VALUE(&tmp, C_REFVAL_P(value));
									efree_size(ref, sizeof(crex_reference));
									value = &tmp;
								} else {
									value = C_REFVAL_P(value);
									C_TRY_ADDREF_P(value);
								}
							} else {
								value = C_REFVAL_P(value);
								C_TRY_ADDREF_P(value);
							}
						} else if (IS_VAR == IS_CV) {
							C_TRY_ADDREF_P(value);
						}
						}
					crex_hash_add_new(zobj->properties, name, value);
					if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
						ZVAL_COPY(EX_VAR(opline->result.var), value);
					}
					goto exit_assign_obj;
				}
			}
		}
		name = C_STR_P(_get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC));
	} else {
		name = zval_try_get_tmp_string(_get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC), &tmp_name);
		if (UNEXPECTED(!name)) {
			zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
			UNDEF_RESULT();
			goto exit_assign_obj;
		}
	}

	if (IS_VAR == IS_CV || IS_VAR == IS_VAR) {
		ZVAL_DEREF(value);
	}

	value = zobj->handlers->write_property(zobj, name, value, ((IS_TMP_VAR|IS_VAR) == IS_CONST) ? CACHE_ADDR(opline->extended_value) : NULL);

	if ((IS_TMP_VAR|IS_VAR) != IS_CONST) {
		crex_tmp_string_release(tmp_name);
	}

free_and_exit_assign_obj:
	if (UNEXPECTED(RETURN_VALUE_USED(opline)) && value) {
		ZVAL_COPY_DEREF(EX_VAR(opline->result.var), value);
	}
	zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
exit_assign_obj:
	if (garbage) {
		GC_DTOR_NO_REF(garbage);
	}
	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));

	/* assign_obj has two opcodes! */
	CREX_VM_NEXT_OPCODE_EX(1, 2);
}

/* No specialization for op_types (CONST|TMPVAR|CV, UNUSED|CONST|VAR) */
static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ASSIGN_OBJ_SPEC_CV_TMPVAR_OP_DATA_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *object, *value, tmp;
	crex_object *zobj;
	crex_string *name, *tmp_name;
	crex_refcounted *garbage = NULL;

	SAVE_OPLINE();
	object = EX_VAR(opline->op1.var);
	value = _get_zval_ptr_cv_BP_VAR_R((opline+1)->op1.var EXECUTE_DATA_CC);

	if (IS_CV != IS_UNUSED && UNEXPECTED(C_TYPE_P(object) != IS_OBJECT)) {
		if (C_ISREF_P(object) && C_TYPE_P(C_REFVAL_P(object)) == IS_OBJECT) {
			object = C_REFVAL_P(object);
			goto assign_object;
		}
		crex_throw_non_object_error(object, _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC) OPLINE_CC EXECUTE_DATA_CC);
		value = &EG(uninitialized_zval);
		goto free_and_exit_assign_obj;
	}

assign_object:
	zobj = C_OBJ_P(object);
	if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
		if (EXPECTED(zobj->ce == CACHED_PTR(opline->extended_value))) {
			void **cache_slot = CACHE_ADDR(opline->extended_value);
			uintptr_t prop_offset = (uintptr_t)CACHED_PTR_EX(cache_slot + 1);
			zval *property_val;

			if (EXPECTED(IS_VALID_PROPERTY_OFFSET(prop_offset))) {
				property_val = OBJ_PROP(zobj, prop_offset);
				if (C_TYPE_P(property_val) != IS_UNDEF) {
					crex_property_info *prop_info = (crex_property_info*) CACHED_PTR_EX(cache_slot + 2);

					if (UNEXPECTED(prop_info != NULL)) {
						value = crex_assign_to_typed_prop(prop_info, property_val, value, &garbage EXECUTE_DATA_CC);
						goto free_and_exit_assign_obj;
					} else {
fast_assign_obj:
						value = crex_assign_to_variable_ex(property_val, value, IS_CV, EX_USES_STRICT_TYPES(), &garbage);
						if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
							ZVAL_COPY(EX_VAR(opline->result.var), value);
						}
						goto exit_assign_obj;
					}
				}
			} else {
				name = C_STR_P(_get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC));
				if (EXPECTED(zobj->properties != NULL)) {
					if (UNEXPECTED(GC_REFCOUNT(zobj->properties) > 1)) {
						if (EXPECTED(!(GC_FLAGS(zobj->properties) & IS_ARRAY_IMMUTABLE))) {
							GC_DELREF(zobj->properties);
						}
						zobj->properties = crex_array_dup(zobj->properties);
					}
					property_val = crex_hash_find_known_hash(zobj->properties, name);
					if (property_val) {
						goto fast_assign_obj;
					}
				}

				if (!zobj->ce->__set && (zobj->ce->ce_flags & CREX_ACC_ALLOW_DYNAMIC_PROPERTIES)) {
					if (EXPECTED(zobj->properties == NULL)) {
						rebuild_object_properties(zobj);
					}
					if (IS_CV == IS_CONST) {
						if (UNEXPECTED(C_OPT_REFCOUNTED_P(value))) {
							C_ADDREF_P(value);
						}
					} else if (IS_CV != IS_TMP_VAR) {
						if (C_ISREF_P(value)) {
							if (IS_CV == IS_VAR) {
								crex_reference *ref = C_REF_P(value);
								if (GC_DELREF(ref) == 0) {
									ZVAL_COPY_VALUE(&tmp, C_REFVAL_P(value));
									efree_size(ref, sizeof(crex_reference));
									value = &tmp;
								} else {
									value = C_REFVAL_P(value);
									C_TRY_ADDREF_P(value);
								}
							} else {
								value = C_REFVAL_P(value);
								C_TRY_ADDREF_P(value);
							}
						} else if (IS_CV == IS_CV) {
							C_TRY_ADDREF_P(value);
						}
						}
					crex_hash_add_new(zobj->properties, name, value);
					if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
						ZVAL_COPY(EX_VAR(opline->result.var), value);
					}
					goto exit_assign_obj;
				}
			}
		}
		name = C_STR_P(_get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC));
	} else {
		name = zval_try_get_tmp_string(_get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC), &tmp_name);
		if (UNEXPECTED(!name)) {

			UNDEF_RESULT();
			goto exit_assign_obj;
		}
	}

	if (IS_CV == IS_CV || IS_CV == IS_VAR) {
		ZVAL_DEREF(value);
	}

	value = zobj->handlers->write_property(zobj, name, value, ((IS_TMP_VAR|IS_VAR) == IS_CONST) ? CACHE_ADDR(opline->extended_value) : NULL);

	if ((IS_TMP_VAR|IS_VAR) != IS_CONST) {
		crex_tmp_string_release(tmp_name);
	}

free_and_exit_assign_obj:
	if (UNEXPECTED(RETURN_VALUE_USED(opline)) && value) {
		ZVAL_COPY_DEREF(EX_VAR(opline->result.var), value);
	}

exit_assign_obj:
	if (garbage) {
		GC_DTOR_NO_REF(garbage);
	}
	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));

	/* assign_obj has two opcodes! */
	CREX_VM_NEXT_OPCODE_EX(1, 2);
}

/* No specialization for op_types (CONST|TMPVAR|CV, UNUSED|CONST|VAR) */
static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ASSIGN_DIM_SPEC_CV_TMPVAR_OP_DATA_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *object_ptr, *orig_object_ptr;
	zval *value;
	zval *variable_ptr;
	zval *dim;
	crex_refcounted *garbage = NULL;

	SAVE_OPLINE();
	orig_object_ptr = object_ptr = EX_VAR(opline->op1.var);

	if (EXPECTED(C_TYPE_P(object_ptr) == IS_ARRAY)) {
try_assign_dim_array:
		SEPARATE_ARRAY(object_ptr);
		if ((IS_TMP_VAR|IS_VAR) == IS_UNUSED) {
			value = RT_CONSTANT((opline+1), (opline+1)->op1);
			if (IS_CONST == IS_CV && UNEXPECTED(C_TYPE_P(value) == IS_UNDEF)) {
				HashTable *ht = C_ARRVAL_P(object_ptr);
				if (!(GC_FLAGS(ht) & IS_ARRAY_IMMUTABLE)) {
					GC_ADDREF(ht);
				}
				value = zval_undefined_cv((opline+1)->op1.var EXECUTE_DATA_CC);
				if (!(GC_FLAGS(ht) & IS_ARRAY_IMMUTABLE) && !GC_DELREF(ht)) {
					crex_array_destroy(ht);
					goto assign_dim_error;
				}
			}
			if (IS_CONST == IS_CV || IS_CONST == IS_VAR) {
				ZVAL_DEREF(value);
			}
			value = crex_hash_next_index_insert(C_ARRVAL_P(object_ptr), value);
			if (UNEXPECTED(value == NULL)) {
				crex_cannot_add_element();
				goto assign_dim_error;
			} else if (IS_CONST == IS_CV) {
				if (C_REFCOUNTED_P(value)) {
					C_ADDREF_P(value);
				}
			} else if (IS_CONST == IS_VAR) {
				zval *free_op_data = EX_VAR((opline+1)->op1.var);
				if (C_ISREF_P(free_op_data)) {
					if (C_REFCOUNTED_P(value)) {
						C_ADDREF_P(value);
					}
					zval_ptr_dtor_nogc(free_op_data);
				}
			} else if (IS_CONST == IS_CONST) {
				if (UNEXPECTED(C_REFCOUNTED_P(value))) {
					C_ADDREF_P(value);
				}
			}
		} else {
			dim = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
			if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
				variable_ptr = crex_fetch_dimension_address_inner_W_CONST(C_ARRVAL_P(object_ptr), dim EXECUTE_DATA_CC);
			} else {
				variable_ptr = crex_fetch_dimension_address_inner_W(C_ARRVAL_P(object_ptr), dim EXECUTE_DATA_CC);
			}
			if (UNEXPECTED(variable_ptr == NULL)) {
				goto assign_dim_error;
			}
			value = RT_CONSTANT((opline+1), (opline+1)->op1);
			value = crex_assign_to_variable_ex(variable_ptr, value, IS_CONST, EX_USES_STRICT_TYPES(), &garbage);
		}
		if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
			ZVAL_COPY(EX_VAR(opline->result.var), value);
		}
		if (garbage) {
			GC_DTOR_NO_REF(garbage);
		}
	} else {
		if (EXPECTED(C_ISREF_P(object_ptr))) {
			object_ptr = C_REFVAL_P(object_ptr);
			if (EXPECTED(C_TYPE_P(object_ptr) == IS_ARRAY)) {
				goto try_assign_dim_array;
			}
		}
		if (EXPECTED(C_TYPE_P(object_ptr) == IS_OBJECT)) {
			crex_object *obj = C_OBJ_P(object_ptr);

			GC_ADDREF(obj);
			dim = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
			if ((IS_TMP_VAR|IS_VAR) == IS_CV && UNEXPECTED(C_ISUNDEF_P(dim))) {
				dim = ZVAL_UNDEFINED_OP2();
			} else if ((IS_TMP_VAR|IS_VAR) == IS_CONST && C_EXTRA_P(dim) == CREX_EXTRA_VALUE) {
				dim++;
			}

			value = RT_CONSTANT((opline+1), (opline+1)->op1);
			if (IS_CONST == IS_CV && UNEXPECTED(C_ISUNDEF_P(value))) {
				value = zval_undefined_cv((opline+1)->op1.var EXECUTE_DATA_CC);
			} else if (IS_CONST & (IS_CV|IS_VAR)) {
				ZVAL_DEREF(value);
			}

			crex_assign_to_object_dim(obj, dim, value OPLINE_CC EXECUTE_DATA_CC);

			if (UNEXPECTED(GC_DELREF(obj) == 0)) {
				crex_objects_store_del(obj);
			}
		} else if (EXPECTED(C_TYPE_P(object_ptr) == IS_STRING)) {
			if ((IS_TMP_VAR|IS_VAR) == IS_UNUSED) {
				crex_use_new_element_for_string();

				UNDEF_RESULT();
			} else {
				dim = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
				value = RT_CONSTANT((opline+1), (opline+1)->op1);
				crex_assign_to_string_offset(object_ptr, dim, value OPLINE_CC EXECUTE_DATA_CC);

			}
		} else if (EXPECTED(C_TYPE_P(object_ptr) <= IS_FALSE)) {
			if (C_ISREF_P(orig_object_ptr)
			 && CREX_REF_HAS_TYPE_SOURCES(C_REF_P(orig_object_ptr))
			 && !crex_verify_ref_array_assignable(C_REF_P(orig_object_ptr))) {
				dim = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);

				UNDEF_RESULT();
			} else {
				HashTable *ht = crex_new_array(8);
				uint8_t old_type = C_TYPE_P(object_ptr);

				ZVAL_ARR(object_ptr, ht);
				if (UNEXPECTED(old_type == IS_FALSE)) {
					GC_ADDREF(ht);
					crex_false_to_array_deprecated();
					if (UNEXPECTED(GC_DELREF(ht) == 0)) {
						crex_array_destroy(ht);
						goto assign_dim_error;
					}
				}
				goto try_assign_dim_array;
			}
		} else {
			crex_use_scalar_as_array();
			dim = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
assign_dim_error:

			if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
				ZVAL_NULL(EX_VAR(opline->result.var));
			}
		}
	}
	if ((IS_TMP_VAR|IS_VAR) != IS_UNUSED) {
		zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
	}

	/* assign_dim has two opcodes! */
	CREX_VM_NEXT_OPCODE_EX(1, 2);
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ASSIGN_DIM_SPEC_CV_TMPVAR_OP_DATA_TMP_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *object_ptr, *orig_object_ptr;
	zval *value;
	zval *variable_ptr;
	zval *dim;
	crex_refcounted *garbage = NULL;

	SAVE_OPLINE();
	orig_object_ptr = object_ptr = EX_VAR(opline->op1.var);

	if (EXPECTED(C_TYPE_P(object_ptr) == IS_ARRAY)) {
try_assign_dim_array:
		SEPARATE_ARRAY(object_ptr);
		if ((IS_TMP_VAR|IS_VAR) == IS_UNUSED) {
			value = _get_zval_ptr_tmp((opline+1)->op1.var EXECUTE_DATA_CC);
			if (IS_TMP_VAR == IS_CV && UNEXPECTED(C_TYPE_P(value) == IS_UNDEF)) {
				HashTable *ht = C_ARRVAL_P(object_ptr);
				if (!(GC_FLAGS(ht) & IS_ARRAY_IMMUTABLE)) {
					GC_ADDREF(ht);
				}
				value = zval_undefined_cv((opline+1)->op1.var EXECUTE_DATA_CC);
				if (!(GC_FLAGS(ht) & IS_ARRAY_IMMUTABLE) && !GC_DELREF(ht)) {
					crex_array_destroy(ht);
					goto assign_dim_error;
				}
			}
			if (IS_TMP_VAR == IS_CV || IS_TMP_VAR == IS_VAR) {
				ZVAL_DEREF(value);
			}
			value = crex_hash_next_index_insert(C_ARRVAL_P(object_ptr), value);
			if (UNEXPECTED(value == NULL)) {
				crex_cannot_add_element();
				goto assign_dim_error;
			} else if (IS_TMP_VAR == IS_CV) {
				if (C_REFCOUNTED_P(value)) {
					C_ADDREF_P(value);
				}
			} else if (IS_TMP_VAR == IS_VAR) {
				zval *free_op_data = EX_VAR((opline+1)->op1.var);
				if (C_ISREF_P(free_op_data)) {
					if (C_REFCOUNTED_P(value)) {
						C_ADDREF_P(value);
					}
					zval_ptr_dtor_nogc(free_op_data);
				}
			} else if (IS_TMP_VAR == IS_CONST) {
				if (UNEXPECTED(C_REFCOUNTED_P(value))) {
					C_ADDREF_P(value);
				}
			}
		} else {
			dim = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
			if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
				variable_ptr = crex_fetch_dimension_address_inner_W_CONST(C_ARRVAL_P(object_ptr), dim EXECUTE_DATA_CC);
			} else {
				variable_ptr = crex_fetch_dimension_address_inner_W(C_ARRVAL_P(object_ptr), dim EXECUTE_DATA_CC);
			}
			if (UNEXPECTED(variable_ptr == NULL)) {
				goto assign_dim_error;
			}
			value = _get_zval_ptr_tmp((opline+1)->op1.var EXECUTE_DATA_CC);
			value = crex_assign_to_variable_ex(variable_ptr, value, IS_TMP_VAR, EX_USES_STRICT_TYPES(), &garbage);
		}
		if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
			ZVAL_COPY(EX_VAR(opline->result.var), value);
		}
		if (garbage) {
			GC_DTOR_NO_REF(garbage);
		}
	} else {
		if (EXPECTED(C_ISREF_P(object_ptr))) {
			object_ptr = C_REFVAL_P(object_ptr);
			if (EXPECTED(C_TYPE_P(object_ptr) == IS_ARRAY)) {
				goto try_assign_dim_array;
			}
		}
		if (EXPECTED(C_TYPE_P(object_ptr) == IS_OBJECT)) {
			crex_object *obj = C_OBJ_P(object_ptr);

			GC_ADDREF(obj);
			dim = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
			if ((IS_TMP_VAR|IS_VAR) == IS_CV && UNEXPECTED(C_ISUNDEF_P(dim))) {
				dim = ZVAL_UNDEFINED_OP2();
			} else if ((IS_TMP_VAR|IS_VAR) == IS_CONST && C_EXTRA_P(dim) == CREX_EXTRA_VALUE) {
				dim++;
			}

			value = _get_zval_ptr_tmp((opline+1)->op1.var EXECUTE_DATA_CC);
			if (IS_TMP_VAR == IS_CV && UNEXPECTED(C_ISUNDEF_P(value))) {
				value = zval_undefined_cv((opline+1)->op1.var EXECUTE_DATA_CC);
			} else if (IS_TMP_VAR & (IS_CV|IS_VAR)) {
				ZVAL_DEREF(value);
			}

			crex_assign_to_object_dim(obj, dim, value OPLINE_CC EXECUTE_DATA_CC);

			zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
			if (UNEXPECTED(GC_DELREF(obj) == 0)) {
				crex_objects_store_del(obj);
			}
		} else if (EXPECTED(C_TYPE_P(object_ptr) == IS_STRING)) {
			if ((IS_TMP_VAR|IS_VAR) == IS_UNUSED) {
				crex_use_new_element_for_string();
				zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
				UNDEF_RESULT();
			} else {
				dim = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
				value = _get_zval_ptr_tmp((opline+1)->op1.var EXECUTE_DATA_CC);
				crex_assign_to_string_offset(object_ptr, dim, value OPLINE_CC EXECUTE_DATA_CC);
				zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
			}
		} else if (EXPECTED(C_TYPE_P(object_ptr) <= IS_FALSE)) {
			if (C_ISREF_P(orig_object_ptr)
			 && CREX_REF_HAS_TYPE_SOURCES(C_REF_P(orig_object_ptr))
			 && !crex_verify_ref_array_assignable(C_REF_P(orig_object_ptr))) {
				dim = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
				zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
				UNDEF_RESULT();
			} else {
				HashTable *ht = crex_new_array(8);
				uint8_t old_type = C_TYPE_P(object_ptr);

				ZVAL_ARR(object_ptr, ht);
				if (UNEXPECTED(old_type == IS_FALSE)) {
					GC_ADDREF(ht);
					crex_false_to_array_deprecated();
					if (UNEXPECTED(GC_DELREF(ht) == 0)) {
						crex_array_destroy(ht);
						goto assign_dim_error;
					}
				}
				goto try_assign_dim_array;
			}
		} else {
			crex_use_scalar_as_array();
			dim = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
assign_dim_error:
			zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
			if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
				ZVAL_NULL(EX_VAR(opline->result.var));
			}
		}
	}
	if ((IS_TMP_VAR|IS_VAR) != IS_UNUSED) {
		zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
	}

	/* assign_dim has two opcodes! */
	CREX_VM_NEXT_OPCODE_EX(1, 2);
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ASSIGN_DIM_SPEC_CV_TMPVAR_OP_DATA_VAR_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *object_ptr, *orig_object_ptr;
	zval *value;
	zval *variable_ptr;
	zval *dim;
	crex_refcounted *garbage = NULL;

	SAVE_OPLINE();
	orig_object_ptr = object_ptr = EX_VAR(opline->op1.var);

	if (EXPECTED(C_TYPE_P(object_ptr) == IS_ARRAY)) {
try_assign_dim_array:
		SEPARATE_ARRAY(object_ptr);
		if ((IS_TMP_VAR|IS_VAR) == IS_UNUSED) {
			value = _get_zval_ptr_var((opline+1)->op1.var EXECUTE_DATA_CC);
			if (IS_VAR == IS_CV && UNEXPECTED(C_TYPE_P(value) == IS_UNDEF)) {
				HashTable *ht = C_ARRVAL_P(object_ptr);
				if (!(GC_FLAGS(ht) & IS_ARRAY_IMMUTABLE)) {
					GC_ADDREF(ht);
				}
				value = zval_undefined_cv((opline+1)->op1.var EXECUTE_DATA_CC);
				if (!(GC_FLAGS(ht) & IS_ARRAY_IMMUTABLE) && !GC_DELREF(ht)) {
					crex_array_destroy(ht);
					goto assign_dim_error;
				}
			}
			if (IS_VAR == IS_CV || IS_VAR == IS_VAR) {
				ZVAL_DEREF(value);
			}
			value = crex_hash_next_index_insert(C_ARRVAL_P(object_ptr), value);
			if (UNEXPECTED(value == NULL)) {
				crex_cannot_add_element();
				goto assign_dim_error;
			} else if (IS_VAR == IS_CV) {
				if (C_REFCOUNTED_P(value)) {
					C_ADDREF_P(value);
				}
			} else if (IS_VAR == IS_VAR) {
				zval *free_op_data = EX_VAR((opline+1)->op1.var);
				if (C_ISREF_P(free_op_data)) {
					if (C_REFCOUNTED_P(value)) {
						C_ADDREF_P(value);
					}
					zval_ptr_dtor_nogc(free_op_data);
				}
			} else if (IS_VAR == IS_CONST) {
				if (UNEXPECTED(C_REFCOUNTED_P(value))) {
					C_ADDREF_P(value);
				}
			}
		} else {
			dim = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
			if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
				variable_ptr = crex_fetch_dimension_address_inner_W_CONST(C_ARRVAL_P(object_ptr), dim EXECUTE_DATA_CC);
			} else {
				variable_ptr = crex_fetch_dimension_address_inner_W(C_ARRVAL_P(object_ptr), dim EXECUTE_DATA_CC);
			}
			if (UNEXPECTED(variable_ptr == NULL)) {
				goto assign_dim_error;
			}
			value = _get_zval_ptr_var((opline+1)->op1.var EXECUTE_DATA_CC);
			value = crex_assign_to_variable_ex(variable_ptr, value, IS_VAR, EX_USES_STRICT_TYPES(), &garbage);
		}
		if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
			ZVAL_COPY(EX_VAR(opline->result.var), value);
		}
		if (garbage) {
			GC_DTOR_NO_REF(garbage);
		}
	} else {
		if (EXPECTED(C_ISREF_P(object_ptr))) {
			object_ptr = C_REFVAL_P(object_ptr);
			if (EXPECTED(C_TYPE_P(object_ptr) == IS_ARRAY)) {
				goto try_assign_dim_array;
			}
		}
		if (EXPECTED(C_TYPE_P(object_ptr) == IS_OBJECT)) {
			crex_object *obj = C_OBJ_P(object_ptr);

			GC_ADDREF(obj);
			dim = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
			if ((IS_TMP_VAR|IS_VAR) == IS_CV && UNEXPECTED(C_ISUNDEF_P(dim))) {
				dim = ZVAL_UNDEFINED_OP2();
			} else if ((IS_TMP_VAR|IS_VAR) == IS_CONST && C_EXTRA_P(dim) == CREX_EXTRA_VALUE) {
				dim++;
			}

			value = _get_zval_ptr_var((opline+1)->op1.var EXECUTE_DATA_CC);
			if (IS_VAR == IS_CV && UNEXPECTED(C_ISUNDEF_P(value))) {
				value = zval_undefined_cv((opline+1)->op1.var EXECUTE_DATA_CC);
			} else if (IS_VAR & (IS_CV|IS_VAR)) {
				ZVAL_DEREF(value);
			}

			crex_assign_to_object_dim(obj, dim, value OPLINE_CC EXECUTE_DATA_CC);

			zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
			if (UNEXPECTED(GC_DELREF(obj) == 0)) {
				crex_objects_store_del(obj);
			}
		} else if (EXPECTED(C_TYPE_P(object_ptr) == IS_STRING)) {
			if ((IS_TMP_VAR|IS_VAR) == IS_UNUSED) {
				crex_use_new_element_for_string();
				zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
				UNDEF_RESULT();
			} else {
				dim = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
				value = _get_zval_ptr_var((opline+1)->op1.var EXECUTE_DATA_CC);
				crex_assign_to_string_offset(object_ptr, dim, value OPLINE_CC EXECUTE_DATA_CC);
				zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
			}
		} else if (EXPECTED(C_TYPE_P(object_ptr) <= IS_FALSE)) {
			if (C_ISREF_P(orig_object_ptr)
			 && CREX_REF_HAS_TYPE_SOURCES(C_REF_P(orig_object_ptr))
			 && !crex_verify_ref_array_assignable(C_REF_P(orig_object_ptr))) {
				dim = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
				zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
				UNDEF_RESULT();
			} else {
				HashTable *ht = crex_new_array(8);
				uint8_t old_type = C_TYPE_P(object_ptr);

				ZVAL_ARR(object_ptr, ht);
				if (UNEXPECTED(old_type == IS_FALSE)) {
					GC_ADDREF(ht);
					crex_false_to_array_deprecated();
					if (UNEXPECTED(GC_DELREF(ht) == 0)) {
						crex_array_destroy(ht);
						goto assign_dim_error;
					}
				}
				goto try_assign_dim_array;
			}
		} else {
			crex_use_scalar_as_array();
			dim = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
assign_dim_error:
			zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
			if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
				ZVAL_NULL(EX_VAR(opline->result.var));
			}
		}
	}
	if ((IS_TMP_VAR|IS_VAR) != IS_UNUSED) {
		zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
	}

	/* assign_dim has two opcodes! */
	CREX_VM_NEXT_OPCODE_EX(1, 2);
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ASSIGN_DIM_SPEC_CV_TMPVAR_OP_DATA_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *object_ptr, *orig_object_ptr;
	zval *value;
	zval *variable_ptr;
	zval *dim;
	crex_refcounted *garbage = NULL;

	SAVE_OPLINE();
	orig_object_ptr = object_ptr = EX_VAR(opline->op1.var);

	if (EXPECTED(C_TYPE_P(object_ptr) == IS_ARRAY)) {
try_assign_dim_array:
		SEPARATE_ARRAY(object_ptr);
		if ((IS_TMP_VAR|IS_VAR) == IS_UNUSED) {
			value = EX_VAR((opline+1)->op1.var);
			if (IS_CV == IS_CV && UNEXPECTED(C_TYPE_P(value) == IS_UNDEF)) {
				HashTable *ht = C_ARRVAL_P(object_ptr);
				if (!(GC_FLAGS(ht) & IS_ARRAY_IMMUTABLE)) {
					GC_ADDREF(ht);
				}
				value = zval_undefined_cv((opline+1)->op1.var EXECUTE_DATA_CC);
				if (!(GC_FLAGS(ht) & IS_ARRAY_IMMUTABLE) && !GC_DELREF(ht)) {
					crex_array_destroy(ht);
					goto assign_dim_error;
				}
			}
			if (IS_CV == IS_CV || IS_CV == IS_VAR) {
				ZVAL_DEREF(value);
			}
			value = crex_hash_next_index_insert(C_ARRVAL_P(object_ptr), value);
			if (UNEXPECTED(value == NULL)) {
				crex_cannot_add_element();
				goto assign_dim_error;
			} else if (IS_CV == IS_CV) {
				if (C_REFCOUNTED_P(value)) {
					C_ADDREF_P(value);
				}
			} else if (IS_CV == IS_VAR) {
				zval *free_op_data = EX_VAR((opline+1)->op1.var);
				if (C_ISREF_P(free_op_data)) {
					if (C_REFCOUNTED_P(value)) {
						C_ADDREF_P(value);
					}
					zval_ptr_dtor_nogc(free_op_data);
				}
			} else if (IS_CV == IS_CONST) {
				if (UNEXPECTED(C_REFCOUNTED_P(value))) {
					C_ADDREF_P(value);
				}
			}
		} else {
			dim = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
			if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
				variable_ptr = crex_fetch_dimension_address_inner_W_CONST(C_ARRVAL_P(object_ptr), dim EXECUTE_DATA_CC);
			} else {
				variable_ptr = crex_fetch_dimension_address_inner_W(C_ARRVAL_P(object_ptr), dim EXECUTE_DATA_CC);
			}
			if (UNEXPECTED(variable_ptr == NULL)) {
				goto assign_dim_error;
			}
			value = _get_zval_ptr_cv_BP_VAR_R((opline+1)->op1.var EXECUTE_DATA_CC);
			value = crex_assign_to_variable_ex(variable_ptr, value, IS_CV, EX_USES_STRICT_TYPES(), &garbage);
		}
		if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
			ZVAL_COPY(EX_VAR(opline->result.var), value);
		}
		if (garbage) {
			GC_DTOR_NO_REF(garbage);
		}
	} else {
		if (EXPECTED(C_ISREF_P(object_ptr))) {
			object_ptr = C_REFVAL_P(object_ptr);
			if (EXPECTED(C_TYPE_P(object_ptr) == IS_ARRAY)) {
				goto try_assign_dim_array;
			}
		}
		if (EXPECTED(C_TYPE_P(object_ptr) == IS_OBJECT)) {
			crex_object *obj = C_OBJ_P(object_ptr);

			GC_ADDREF(obj);
			dim = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
			if ((IS_TMP_VAR|IS_VAR) == IS_CV && UNEXPECTED(C_ISUNDEF_P(dim))) {
				dim = ZVAL_UNDEFINED_OP2();
			} else if ((IS_TMP_VAR|IS_VAR) == IS_CONST && C_EXTRA_P(dim) == CREX_EXTRA_VALUE) {
				dim++;
			}

			value = EX_VAR((opline+1)->op1.var);
			if (IS_CV == IS_CV && UNEXPECTED(C_ISUNDEF_P(value))) {
				value = zval_undefined_cv((opline+1)->op1.var EXECUTE_DATA_CC);
			} else if (IS_CV & (IS_CV|IS_VAR)) {
				ZVAL_DEREF(value);
			}

			crex_assign_to_object_dim(obj, dim, value OPLINE_CC EXECUTE_DATA_CC);

			if (UNEXPECTED(GC_DELREF(obj) == 0)) {
				crex_objects_store_del(obj);
			}
		} else if (EXPECTED(C_TYPE_P(object_ptr) == IS_STRING)) {
			if ((IS_TMP_VAR|IS_VAR) == IS_UNUSED) {
				crex_use_new_element_for_string();

				UNDEF_RESULT();
			} else {
				dim = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
				value = EX_VAR((opline+1)->op1.var);
				crex_assign_to_string_offset(object_ptr, dim, value OPLINE_CC EXECUTE_DATA_CC);

			}
		} else if (EXPECTED(C_TYPE_P(object_ptr) <= IS_FALSE)) {
			if (C_ISREF_P(orig_object_ptr)
			 && CREX_REF_HAS_TYPE_SOURCES(C_REF_P(orig_object_ptr))
			 && !crex_verify_ref_array_assignable(C_REF_P(orig_object_ptr))) {
				dim = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);

				UNDEF_RESULT();
			} else {
				HashTable *ht = crex_new_array(8);
				uint8_t old_type = C_TYPE_P(object_ptr);

				ZVAL_ARR(object_ptr, ht);
				if (UNEXPECTED(old_type == IS_FALSE)) {
					GC_ADDREF(ht);
					crex_false_to_array_deprecated();
					if (UNEXPECTED(GC_DELREF(ht) == 0)) {
						crex_array_destroy(ht);
						goto assign_dim_error;
					}
				}
				goto try_assign_dim_array;
			}
		} else {
			crex_use_scalar_as_array();
			dim = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
assign_dim_error:

			if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
				ZVAL_NULL(EX_VAR(opline->result.var));
			}
		}
	}
	if ((IS_TMP_VAR|IS_VAR) != IS_UNUSED) {
		zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
	}

	/* assign_dim has two opcodes! */
	CREX_VM_NEXT_OPCODE_EX(1, 2);
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ASSIGN_OBJ_REF_SPEC_CV_TMPVAR_OP_DATA_VAR_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *property, *container, *value_ptr;

	SAVE_OPLINE();

	container = EX_VAR(opline->op1.var);
	property = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);

	value_ptr = _get_zval_ptr_ptr_var((opline+1)->op1.var EXECUTE_DATA_CC);

	if (1) {
		if (IS_CV == IS_UNUSED) {
			if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
				crex_assign_to_property_reference_this_const(container, property, value_ptr OPLINE_CC EXECUTE_DATA_CC);
			} else {
				crex_assign_to_property_reference_this_var(container, property, value_ptr OPLINE_CC EXECUTE_DATA_CC);
			}
		} else {
			if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
				crex_assign_to_property_reference_var_const(container, property, value_ptr OPLINE_CC EXECUTE_DATA_CC);
			} else {
				crex_assign_to_property_reference_var_var(container, property, value_ptr OPLINE_CC EXECUTE_DATA_CC);
			}
		}
	} else {
		crex_assign_to_property_reference(container, IS_CV, property, (IS_TMP_VAR|IS_VAR), value_ptr OPLINE_CC EXECUTE_DATA_CC);
	}

	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
	zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
	CREX_VM_NEXT_OPCODE_EX(1, 2);
}

/* No specialization for op_types (CONST|TMPVAR|CV, UNUSED|CONST|VAR) */
static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ASSIGN_OBJ_REF_SPEC_CV_TMPVAR_OP_DATA_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *property, *container, *value_ptr;

	SAVE_OPLINE();

	container = EX_VAR(opline->op1.var);
	property = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);

	value_ptr = _get_zval_ptr_cv_BP_VAR_W((opline+1)->op1.var EXECUTE_DATA_CC);

	if (1) {
		if (IS_CV == IS_UNUSED) {
			if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
				crex_assign_to_property_reference_this_const(container, property, value_ptr OPLINE_CC EXECUTE_DATA_CC);
			} else {
				crex_assign_to_property_reference_this_var(container, property, value_ptr OPLINE_CC EXECUTE_DATA_CC);
			}
		} else {
			if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
				crex_assign_to_property_reference_var_const(container, property, value_ptr OPLINE_CC EXECUTE_DATA_CC);
			} else {
				crex_assign_to_property_reference_var_var(container, property, value_ptr OPLINE_CC EXECUTE_DATA_CC);
			}
		}
	} else {
		crex_assign_to_property_reference(container, IS_CV, property, (IS_TMP_VAR|IS_VAR), value_ptr OPLINE_CC EXECUTE_DATA_CC);
	}

	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));

	CREX_VM_NEXT_OPCODE_EX(1, 2);
}

/* No specialization for op_types (CONST|TMPVAR|CV, UNUSED|CONST|VAR) */
static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FAST_CONCAT_SPEC_CV_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	crex_string *op1_str, *op2_str, *str;


	op1 = EX_VAR(opline->op1.var);
	op2 = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
	if ((IS_CV == IS_CONST || EXPECTED(C_TYPE_P(op1) == IS_STRING)) &&
	    ((IS_TMP_VAR|IS_VAR) == IS_CONST || EXPECTED(C_TYPE_P(op2) == IS_STRING))) {
		crex_string *op1_str = C_STR_P(op1);
		crex_string *op2_str = C_STR_P(op2);
		crex_string *str;
		uint32_t flags = ZSTR_GET_COPYABLE_CONCAT_PROPERTIES_BOTH(op1_str, op2_str);

		if (IS_CV != IS_CONST && UNEXPECTED(ZSTR_LEN(op1_str) == 0)) {
			if ((IS_TMP_VAR|IS_VAR) == IS_CONST || (IS_TMP_VAR|IS_VAR) == IS_CV) {
				ZVAL_STR_COPY(EX_VAR(opline->result.var), op2_str);
			} else {
				ZVAL_STR(EX_VAR(opline->result.var), op2_str);
			}
			if (IS_CV & (IS_TMP_VAR|IS_VAR)) {
				crex_string_release_ex(op1_str, 0);
			}
		} else if ((IS_TMP_VAR|IS_VAR) != IS_CONST && UNEXPECTED(ZSTR_LEN(op2_str) == 0)) {
			if (IS_CV == IS_CONST || IS_CV == IS_CV) {
				ZVAL_STR_COPY(EX_VAR(opline->result.var), op1_str);
			} else {
				ZVAL_STR(EX_VAR(opline->result.var), op1_str);
			}
			if ((IS_TMP_VAR|IS_VAR) & (IS_TMP_VAR|IS_VAR)) {
				crex_string_release_ex(op2_str, 0);
			}
		} else if (IS_CV != IS_CONST && IS_CV != IS_CV &&
		    !ZSTR_IS_INTERNED(op1_str) && GC_REFCOUNT(op1_str) == 1) {
			size_t len = ZSTR_LEN(op1_str);

			str = crex_string_extend(op1_str, len + ZSTR_LEN(op2_str), 0);
			memcpy(ZSTR_VAL(str) + len, ZSTR_VAL(op2_str), ZSTR_LEN(op2_str)+1);
			GC_ADD_FLAGS(str, flags);
			ZVAL_NEW_STR(EX_VAR(opline->result.var), str);
			if ((IS_TMP_VAR|IS_VAR) & (IS_TMP_VAR|IS_VAR)) {
				crex_string_release_ex(op2_str, 0);
			}
		} else {
			str = crex_string_alloc(ZSTR_LEN(op1_str) + ZSTR_LEN(op2_str), 0);
			memcpy(ZSTR_VAL(str), ZSTR_VAL(op1_str), ZSTR_LEN(op1_str));
			memcpy(ZSTR_VAL(str) + ZSTR_LEN(op1_str), ZSTR_VAL(op2_str), ZSTR_LEN(op2_str)+1);
			GC_ADD_FLAGS(str, flags);
			ZVAL_NEW_STR(EX_VAR(opline->result.var), str);
			if (IS_CV & (IS_TMP_VAR|IS_VAR)) {
				crex_string_release_ex(op1_str, 0);
			}
			if ((IS_TMP_VAR|IS_VAR) & (IS_TMP_VAR|IS_VAR)) {
				crex_string_release_ex(op2_str, 0);
			}
		}
		CREX_VM_NEXT_OPCODE();
	}

	SAVE_OPLINE();
	if (IS_CV == IS_CONST) {
		op1_str = C_STR_P(op1);
	} else if (EXPECTED(C_TYPE_P(op1) == IS_STRING)) {
		op1_str = crex_string_copy(C_STR_P(op1));
	} else {
		if (IS_CV == IS_CV && UNEXPECTED(C_TYPE_P(op1) == IS_UNDEF)) {
			ZVAL_UNDEFINED_OP1();
		}
		op1_str = zval_get_string_func(op1);
	}
	if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
		op2_str = C_STR_P(op2);
	} else if (EXPECTED(C_TYPE_P(op2) == IS_STRING)) {
		op2_str = crex_string_copy(C_STR_P(op2));
	} else {
		if ((IS_TMP_VAR|IS_VAR) == IS_CV && UNEXPECTED(C_TYPE_P(op2) == IS_UNDEF)) {
			ZVAL_UNDEFINED_OP2();
		}
		op2_str = zval_get_string_func(op2);
	}
	do {
		if (IS_CV != IS_CONST) {
			if (UNEXPECTED(ZSTR_LEN(op1_str) == 0)) {
				if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
					if (UNEXPECTED(C_REFCOUNTED_P(op2))) {
						GC_ADDREF(op2_str);
					}
				}
				ZVAL_STR(EX_VAR(opline->result.var), op2_str);
				crex_string_release_ex(op1_str, 0);
				break;
			}
		}
		if ((IS_TMP_VAR|IS_VAR) != IS_CONST) {
			if (UNEXPECTED(ZSTR_LEN(op2_str) == 0)) {
				if (IS_CV == IS_CONST) {
					if (UNEXPECTED(C_REFCOUNTED_P(op1))) {
						GC_ADDREF(op1_str);
					}
				}
				ZVAL_STR(EX_VAR(opline->result.var), op1_str);
				crex_string_release_ex(op2_str, 0);
				break;
			}
		}
		str = crex_string_alloc(ZSTR_LEN(op1_str) + ZSTR_LEN(op2_str), 0);
		memcpy(ZSTR_VAL(str), ZSTR_VAL(op1_str), ZSTR_LEN(op1_str));
		memcpy(ZSTR_VAL(str) + ZSTR_LEN(op1_str), ZSTR_VAL(op2_str), ZSTR_LEN(op2_str)+1);

		ZSTR_COPY_CONCAT_PROPERTIES_BOTH(str, op1_str, op2_str);
		ZVAL_NEW_STR(EX_VAR(opline->result.var), str);
		if (IS_CV != IS_CONST) {
			crex_string_release_ex(op1_str, 0);
		}
		if ((IS_TMP_VAR|IS_VAR) != IS_CONST) {
			crex_string_release_ex(op2_str, 0);
		}
	} while (0);

	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_INIT_METHOD_CALL_SPEC_CV_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *function_name;
	zval *object;
	crex_function *fbc;
	crex_class_entry *called_scope;
	crex_object *obj;
	crex_execute_data *call;
	uint32_t call_info;

	SAVE_OPLINE();

	object = EX_VAR(opline->op1.var);

	if ((IS_TMP_VAR|IS_VAR) != IS_CONST) {
		function_name = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
	}

	if ((IS_TMP_VAR|IS_VAR) != IS_CONST &&
	    UNEXPECTED(C_TYPE_P(function_name) != IS_STRING)) {
		do {
			if (((IS_TMP_VAR|IS_VAR) & (IS_VAR|IS_CV)) && C_ISREF_P(function_name)) {
				function_name = C_REFVAL_P(function_name);
				if (EXPECTED(C_TYPE_P(function_name) == IS_STRING)) {
					break;
				}
			} else if ((IS_TMP_VAR|IS_VAR) == IS_CV && UNEXPECTED(C_TYPE_P(function_name) == IS_UNDEF)) {
				ZVAL_UNDEFINED_OP2();
				if (UNEXPECTED(EG(exception) != NULL)) {

					HANDLE_EXCEPTION();
				}
			}
			crex_throw_error(NULL, "Method name must be a string");
			zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));

			HANDLE_EXCEPTION();
		} while (0);
	}

	if (IS_CV == IS_UNUSED) {
		obj = C_OBJ_P(object);
	} else {
		do {
			if (IS_CV != IS_CONST && EXPECTED(C_TYPE_P(object) == IS_OBJECT)) {
				obj = C_OBJ_P(object);
			} else {
				if ((IS_CV & (IS_VAR|IS_CV)) && EXPECTED(C_ISREF_P(object))) {
					crex_reference *ref = C_REF_P(object);

					object = &ref->val;
					if (EXPECTED(C_TYPE_P(object) == IS_OBJECT)) {
						obj = C_OBJ_P(object);
						if (IS_CV & IS_VAR) {
							if (UNEXPECTED(GC_DELREF(ref) == 0)) {
								efree_size(ref, sizeof(crex_reference));
							} else {
								C_ADDREF_P(object);
							}
						}
						break;
					}
				}
				if (IS_CV == IS_CV && UNEXPECTED(C_TYPE_P(object) == IS_UNDEF)) {
					object = ZVAL_UNDEFINED_OP1();
					if (UNEXPECTED(EG(exception) != NULL)) {
						if ((IS_TMP_VAR|IS_VAR) != IS_CONST) {
							zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
						}
						HANDLE_EXCEPTION();
					}
				}
				if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
					function_name = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
				}
				crex_invalid_method_call(object, function_name);
				zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));

				HANDLE_EXCEPTION();
			}
		} while (0);
	}

	called_scope = obj->ce;

	if ((IS_TMP_VAR|IS_VAR) == IS_CONST &&
	    EXPECTED(CACHED_PTR(opline->result.num) == called_scope)) {
		fbc = CACHED_PTR(opline->result.num + sizeof(void*));
	} else {
		crex_object *orig_obj = obj;

		if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
			function_name = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
		}

		/* First, locate the function. */
		fbc = obj->handlers->get_method(&obj, C_STR_P(function_name), (((IS_TMP_VAR|IS_VAR) == IS_CONST) ? (RT_CONSTANT(opline, opline->op2) + 1) : NULL));
		if (UNEXPECTED(fbc == NULL)) {
			if (EXPECTED(!EG(exception))) {
				crex_undefined_method(obj->ce, C_STR_P(function_name));
			}
			zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
			if ((IS_CV & (IS_VAR|IS_TMP_VAR)) && GC_DELREF(orig_obj) == 0) {
				crex_objects_store_del(orig_obj);
			}
			HANDLE_EXCEPTION();
		}
		if ((IS_TMP_VAR|IS_VAR) == IS_CONST &&
		    EXPECTED(!(fbc->common.fn_flags & (CREX_ACC_CALL_VIA_TRAMPOLINE|CREX_ACC_NEVER_CACHE))) &&
		    EXPECTED(obj == orig_obj)) {
			CACHE_POLYMORPHIC_PTR(opline->result.num, called_scope, fbc);
		}
		if ((IS_CV & (IS_VAR|IS_TMP_VAR)) && UNEXPECTED(obj != orig_obj)) {
			GC_ADDREF(obj); /* For $this pointer */
			if (GC_DELREF(orig_obj) == 0) {
				crex_objects_store_del(orig_obj);
			}
		}
		if (EXPECTED(fbc->type == CREX_USER_FUNCTION) && UNEXPECTED(!RUN_TIME_CACHE(&fbc->op_array))) {
			init_func_run_time_cache(&fbc->op_array);
		}
	}

	if ((IS_TMP_VAR|IS_VAR) != IS_CONST) {
		zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
	}

	call_info = CREX_CALL_NESTED_FUNCTION | CREX_CALL_HAS_THIS;
	if (UNEXPECTED((fbc->common.fn_flags & CREX_ACC_STATIC) != 0)) {
		if ((IS_CV & (IS_VAR|IS_TMP_VAR)) && GC_DELREF(obj) == 0) {
			crex_objects_store_del(obj);
			if (UNEXPECTED(EG(exception))) {
				HANDLE_EXCEPTION();
			}
		}
		/* call static method */
		obj = (crex_object*)called_scope;
		call_info = CREX_CALL_NESTED_FUNCTION;
	} else if (IS_CV & (IS_VAR|IS_TMP_VAR|IS_CV)) {
		if (IS_CV == IS_CV) {
			GC_ADDREF(obj); /* For $this pointer */
		}
		/* CV may be changed indirectly (e.g. when it's a reference) */
		call_info = CREX_CALL_NESTED_FUNCTION | CREX_CALL_HAS_THIS | CREX_CALL_RELEASE_THIS;
	}

	call = crex_vm_stack_push_call_frame(call_info,
		fbc, opline->extended_value, obj);
	call->prev_execute_data = EX(call);
	EX(call) = call;

	CREX_VM_NEXT_OPCODE();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ADD_ARRAY_ELEMENT_SPEC_CV_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *expr_ptr, new_expr;

	SAVE_OPLINE();
	if ((IS_CV == IS_VAR || IS_CV == IS_CV) &&
	    UNEXPECTED(opline->extended_value & CREX_ARRAY_ELEMENT_REF)) {
		expr_ptr = _get_zval_ptr_cv_BP_VAR_W(opline->op1.var EXECUTE_DATA_CC);
		if (C_ISREF_P(expr_ptr)) {
			C_ADDREF_P(expr_ptr);
		} else {
			ZVAL_MAKE_REF_EX(expr_ptr, 2);
		}

	} else {
		expr_ptr = _get_zval_ptr_cv_BP_VAR_R(opline->op1.var EXECUTE_DATA_CC);
		if (IS_CV == IS_TMP_VAR) {
			/* pass */
		} else if (IS_CV == IS_CONST) {
			C_TRY_ADDREF_P(expr_ptr);
		} else if (IS_CV == IS_CV) {
			ZVAL_DEREF(expr_ptr);
			C_TRY_ADDREF_P(expr_ptr);
		} else /* if (IS_CV == IS_VAR) */ {
			if (UNEXPECTED(C_ISREF_P(expr_ptr))) {
				crex_refcounted *ref = C_COUNTED_P(expr_ptr);

				expr_ptr = C_REFVAL_P(expr_ptr);
				if (UNEXPECTED(GC_DELREF(ref) == 0)) {
					ZVAL_COPY_VALUE(&new_expr, expr_ptr);
					expr_ptr = &new_expr;
					efree_size(ref, sizeof(crex_reference));
				} else if (C_OPT_REFCOUNTED_P(expr_ptr)) {
					C_ADDREF_P(expr_ptr);
				}
			}
		}
	}

	if ((IS_TMP_VAR|IS_VAR) != IS_UNUSED) {
		zval *offset = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
		crex_string *str;
		crex_ulong hval;

add_again:
		if (EXPECTED(C_TYPE_P(offset) == IS_STRING)) {
			str = C_STR_P(offset);
			if ((IS_TMP_VAR|IS_VAR) != IS_CONST) {
				if (CREX_HANDLE_NUMERIC(str, hval)) {
					goto num_index;
				}
			}
str_index:
			crex_hash_update(C_ARRVAL_P(EX_VAR(opline->result.var)), str, expr_ptr);
		} else if (EXPECTED(C_TYPE_P(offset) == IS_LONG)) {
			hval = C_LVAL_P(offset);
num_index:
			crex_hash_index_update(C_ARRVAL_P(EX_VAR(opline->result.var)), hval, expr_ptr);
		} else if (((IS_TMP_VAR|IS_VAR) & (IS_VAR|IS_CV)) && EXPECTED(C_TYPE_P(offset) == IS_REFERENCE)) {
			offset = C_REFVAL_P(offset);
			goto add_again;
		} else if (C_TYPE_P(offset) == IS_NULL) {
			str = ZSTR_EMPTY_ALLOC();
			goto str_index;
		} else if (C_TYPE_P(offset) == IS_DOUBLE) {
			hval = crex_dval_to_lval_safe(C_DVAL_P(offset));
			goto num_index;
		} else if (C_TYPE_P(offset) == IS_FALSE) {
			hval = 0;
			goto num_index;
		} else if (C_TYPE_P(offset) == IS_TRUE) {
			hval = 1;
			goto num_index;
		} else if (C_TYPE_P(offset) == IS_RESOURCE) {
			crex_use_resource_as_offset(offset);
			hval = C_RES_HANDLE_P(offset);
			goto num_index;
		} else if ((IS_TMP_VAR|IS_VAR) == IS_CV && C_TYPE_P(offset) == IS_UNDEF) {
			ZVAL_UNDEFINED_OP2();
			str = ZSTR_EMPTY_ALLOC();
			goto str_index;
		} else {
			crex_illegal_array_offset_access(offset);
			zval_ptr_dtor_nogc(expr_ptr);
		}
		zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
	} else {
		if (!crex_hash_next_index_insert(C_ARRVAL_P(EX_VAR(opline->result.var)), expr_ptr)) {
			crex_cannot_add_element();
			zval_ptr_dtor_nogc(expr_ptr);
		}
	}
	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_INIT_ARRAY_SPEC_CV_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	zval *array;
	uint32_t size;
	USE_OPLINE

	array = EX_VAR(opline->result.var);
	if (IS_CV != IS_UNUSED) {
		size = opline->extended_value >> CREX_ARRAY_SIZE_SHIFT;
		ZVAL_ARR(array, crex_new_array(size));
		/* Explicitly initialize array as not-packed if flag is set */
		if (opline->extended_value & CREX_ARRAY_NOT_PACKED) {
			crex_hash_real_init_mixed(C_ARRVAL_P(array));
		}
		CREX_VM_TAIL_CALL(CREX_ADD_ARRAY_ELEMENT_SPEC_CV_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU));
	} else {
		ZVAL_ARR(array, crex_new_array(0));
		CREX_VM_NEXT_OPCODE();
	}
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_UNSET_DIM_SPEC_CV_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;
	zval *offset;
	crex_ulong hval;
	crex_string *key;

	SAVE_OPLINE();
	container = EX_VAR(opline->op1.var);
	offset = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);

	do {
		if (EXPECTED(C_TYPE_P(container) == IS_ARRAY)) {
			HashTable *ht;

unset_dim_array:
			SEPARATE_ARRAY(container);
			ht = C_ARRVAL_P(container);
offset_again:
			if (EXPECTED(C_TYPE_P(offset) == IS_STRING)) {
				key = C_STR_P(offset);
				if ((IS_TMP_VAR|IS_VAR) != IS_CONST) {
					if (CREX_HANDLE_NUMERIC(key, hval)) {
						goto num_index_dim;
					}
				}
str_index_dim:
				CREX_ASSERT(ht != &EG(symbol_table));
				crex_hash_del(ht, key);
			} else if (EXPECTED(C_TYPE_P(offset) == IS_LONG)) {
				hval = C_LVAL_P(offset);
num_index_dim:
				crex_hash_index_del(ht, hval);
			} else if (((IS_TMP_VAR|IS_VAR) & (IS_VAR|IS_CV)) && EXPECTED(C_TYPE_P(offset) == IS_REFERENCE)) {
				offset = C_REFVAL_P(offset);
				goto offset_again;
			} else if (C_TYPE_P(offset) == IS_DOUBLE) {
				hval = crex_dval_to_lval_safe(C_DVAL_P(offset));
				goto num_index_dim;
			} else if (C_TYPE_P(offset) == IS_NULL) {
				key = ZSTR_EMPTY_ALLOC();
				goto str_index_dim;
			} else if (C_TYPE_P(offset) == IS_FALSE) {
				hval = 0;
				goto num_index_dim;
			} else if (C_TYPE_P(offset) == IS_TRUE) {
				hval = 1;
				goto num_index_dim;
			} else if (C_TYPE_P(offset) == IS_RESOURCE) {
				crex_use_resource_as_offset(offset);
				hval = C_RES_HANDLE_P(offset);
				goto num_index_dim;
			} else if ((IS_TMP_VAR|IS_VAR) == IS_CV && C_TYPE_P(offset) == IS_UNDEF) {
				ZVAL_UNDEFINED_OP2();
				key = ZSTR_EMPTY_ALLOC();
				goto str_index_dim;
			} else {
				crex_illegal_array_offset_unset(offset);
			}
			break;
		} else if (C_ISREF_P(container)) {
			container = C_REFVAL_P(container);
			if (EXPECTED(C_TYPE_P(container) == IS_ARRAY)) {
				goto unset_dim_array;
			}
		}
		if (IS_CV == IS_CV && UNEXPECTED(C_TYPE_P(container) == IS_UNDEF)) {
			container = ZVAL_UNDEFINED_OP1();
		}
		if ((IS_TMP_VAR|IS_VAR) == IS_CV && UNEXPECTED(C_TYPE_P(offset) == IS_UNDEF)) {
			offset = ZVAL_UNDEFINED_OP2();
		}
		if (EXPECTED(C_TYPE_P(container) == IS_OBJECT)) {
			if ((IS_TMP_VAR|IS_VAR) == IS_CONST && C_EXTRA_P(offset) == CREX_EXTRA_VALUE) {
				offset++;
			}
			C_OBJ_HT_P(container)->unset_dimension(C_OBJ_P(container), offset);
		} else if (UNEXPECTED(C_TYPE_P(container) == IS_STRING)) {
			crex_throw_error(NULL, "Cannot unset string offsets");
		} else if (UNEXPECTED(C_TYPE_P(container) > IS_FALSE)) {
			crex_throw_error(NULL, "Cannot unset offset in a non-array variable");
		} else if (UNEXPECTED(C_TYPE_P(container) == IS_FALSE)) {
			crex_false_to_array_deprecated();
		}
	} while (0);

	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));

	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_UNSET_OBJ_SPEC_CV_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;
	zval *offset;
	crex_string *name, *tmp_name;

	SAVE_OPLINE();
	container = EX_VAR(opline->op1.var);
	offset = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);

	do {
		if (IS_CV != IS_UNUSED && UNEXPECTED(C_TYPE_P(container) != IS_OBJECT)) {
			if (C_ISREF_P(container)) {
				container = C_REFVAL_P(container);
				if (C_TYPE_P(container) != IS_OBJECT) {
					if (IS_CV == IS_CV
					 && UNEXPECTED(C_TYPE_P(container) == IS_UNDEF)) {
						ZVAL_UNDEFINED_OP1();
					}
					break;
				}
			} else {
				break;
			}
		}
		if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
			name = C_STR_P(offset);
		} else {
			name = zval_try_get_tmp_string(offset, &tmp_name);
			if (UNEXPECTED(!name)) {
				break;
			}
		}
		C_OBJ_HT_P(container)->unset_property(C_OBJ_P(container), name, (((IS_TMP_VAR|IS_VAR) == IS_CONST) ? CACHE_ADDR(opline->extended_value) : NULL));
		if ((IS_TMP_VAR|IS_VAR) != IS_CONST) {
			crex_tmp_string_release(tmp_name);
		}
	} while (0);

	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));

	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ISSET_ISEMPTY_DIM_OBJ_SPEC_CV_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;
	bool result;
	crex_ulong hval;
	zval *offset;

	SAVE_OPLINE();
	container = EX_VAR(opline->op1.var);
	offset = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);

	if (EXPECTED(C_TYPE_P(container) == IS_ARRAY)) {
		HashTable *ht;
		zval *value;
		crex_string *str;

isset_dim_obj_array:
		ht = C_ARRVAL_P(container);
isset_again:
		if (EXPECTED(C_TYPE_P(offset) == IS_STRING)) {
			str = C_STR_P(offset);
			if ((IS_TMP_VAR|IS_VAR) != IS_CONST) {
				if (CREX_HANDLE_NUMERIC(str, hval)) {
					goto num_index_prop;
				}
			}
			value = crex_hash_find_ex(ht, str, (IS_TMP_VAR|IS_VAR) == IS_CONST);
		} else if (EXPECTED(C_TYPE_P(offset) == IS_LONG)) {
			hval = C_LVAL_P(offset);
num_index_prop:
			value = crex_hash_index_find(ht, hval);
		} else if (((IS_TMP_VAR|IS_VAR) & (IS_VAR|IS_CV)) && EXPECTED(C_ISREF_P(offset))) {
			offset = C_REFVAL_P(offset);
			goto isset_again;
		} else {
			value = crex_find_array_dim_slow(ht, offset EXECUTE_DATA_CC);
			if (UNEXPECTED(EG(exception))) {
				result = 0;
				goto isset_dim_obj_exit;
			}
		}

		if (!(opline->extended_value & CREX_ISEMPTY)) {
			/* > IS_NULL means not IS_UNDEF and not IS_NULL */
			result = value != NULL && C_TYPE_P(value) > IS_NULL &&
			    (!C_ISREF_P(value) || C_TYPE_P(C_REFVAL_P(value)) != IS_NULL);

			if (IS_CV & (IS_CONST|IS_CV)) {
				/* avoid exception check */
				zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
				CREX_VM_SMART_BRANCH(result, 0);
			}
		} else {
			result = (value == NULL || !i_crex_is_true(value));
		}
		goto isset_dim_obj_exit;
	} else if ((IS_CV & (IS_VAR|IS_CV)) && EXPECTED(C_ISREF_P(container))) {
		container = C_REFVAL_P(container);
		if (EXPECTED(C_TYPE_P(container) == IS_ARRAY)) {
			goto isset_dim_obj_array;
		}
	}

	if ((IS_TMP_VAR|IS_VAR) == IS_CONST && C_EXTRA_P(offset) == CREX_EXTRA_VALUE) {
		offset++;
	}
	if (!(opline->extended_value & CREX_ISEMPTY)) {
		result = crex_isset_dim_slow(container, offset EXECUTE_DATA_CC);
	} else {
		result = crex_isempty_dim_slow(container, offset EXECUTE_DATA_CC);
	}

isset_dim_obj_exit:
	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));

	CREX_VM_SMART_BRANCH(result, 1);
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ISSET_ISEMPTY_PROP_OBJ_SPEC_CV_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;
	int result;
	zval *offset;
	crex_string *name, *tmp_name;

	SAVE_OPLINE();
	container = _get_zval_ptr_cv_BP_VAR_IS(opline->op1.var EXECUTE_DATA_CC);
	offset = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);

	if (IS_CV == IS_CONST ||
	    (IS_CV != IS_UNUSED && UNEXPECTED(C_TYPE_P(container) != IS_OBJECT))) {
		if ((IS_CV & (IS_VAR|IS_CV)) && C_ISREF_P(container)) {
			container = C_REFVAL_P(container);
			if (UNEXPECTED(C_TYPE_P(container) != IS_OBJECT)) {
				result = (opline->extended_value & CREX_ISEMPTY);
				goto isset_object_finish;
			}
		} else {
			result = (opline->extended_value & CREX_ISEMPTY);
			goto isset_object_finish;
		}
	}

	if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
		name = C_STR_P(offset);
	} else {
		name = zval_try_get_tmp_string(offset, &tmp_name);
		if (UNEXPECTED(!name)) {
			result = 0;
			goto isset_object_finish;
		}
	}

	result =
		(opline->extended_value & CREX_ISEMPTY) ^
		C_OBJ_HT_P(container)->has_property(C_OBJ_P(container), name, (opline->extended_value & CREX_ISEMPTY), (((IS_TMP_VAR|IS_VAR) == IS_CONST) ? CACHE_ADDR(opline->extended_value & ~CREX_ISEMPTY) : NULL));

	if ((IS_TMP_VAR|IS_VAR) != IS_CONST) {
		crex_tmp_string_release(tmp_name);
	}

isset_object_finish:
	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));

	CREX_VM_SMART_BRANCH(result, 1);
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ARRAY_KEY_EXISTS_SPEC_CV_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *key, *subject;
	HashTable *ht;
	bool result;

	SAVE_OPLINE();

	key = EX_VAR(opline->op1.var);
	subject = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);

	if (EXPECTED(C_TYPE_P(subject) == IS_ARRAY)) {
array_key_exists_array:
		ht = C_ARRVAL_P(subject);
		result = crex_array_key_exists_fast(ht, key OPLINE_CC EXECUTE_DATA_CC);
	} else {
		if (((IS_TMP_VAR|IS_VAR) & (IS_VAR|IS_CV)) && EXPECTED(C_ISREF_P(subject))) {
			subject = C_REFVAL_P(subject);
			if (EXPECTED(C_TYPE_P(subject) == IS_ARRAY)) {
				goto array_key_exists_array;
			}
		}
		crex_array_key_exists_error(subject, key OPLINE_CC EXECUTE_DATA_CC);
		result = 0;
	}

	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));

	CREX_VM_SMART_BRANCH(result, 1);
}

/* No specialization for op_types (CONST|TMPVAR|UNUSED|CV, ANY) */
static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_YIELD_SPEC_CV_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	crex_generator *generator = crex_get_running_generator(EXECUTE_DATA_C);

	SAVE_OPLINE();
	if (UNEXPECTED(generator->flags & CREX_GENERATOR_FORCED_CLOSE)) {
		CREX_VM_TAIL_CALL(crex_yield_in_closed_generator_helper_SPEC(CREX_OPCODE_HANDLER_ARGS_PASSTHRU));
	}

	/* Destroy the previously yielded value */
	zval_ptr_dtor(&generator->value);

	/* Destroy the previously yielded key */
	zval_ptr_dtor(&generator->key);

	/* Set the new yielded value */
	if (IS_CV != IS_UNUSED) {
		if (UNEXPECTED(EX(func)->op_array.fn_flags & CREX_ACC_RETURN_REFERENCE)) {
			/* Constants and temporary variables aren't yieldable by reference,
			 * but we still allow them with a notice. */
			if (IS_CV & (IS_CONST|IS_TMP_VAR)) {
				zval *value;

				crex_error(E_NOTICE, "Only variable references should be yielded by reference");

				value = _get_zval_ptr_cv_BP_VAR_R(opline->op1.var EXECUTE_DATA_CC);
				ZVAL_COPY_VALUE(&generator->value, value);
				if (IS_CV == IS_CONST) {
					if (UNEXPECTED(C_OPT_REFCOUNTED(generator->value))) {
						C_ADDREF(generator->value);
					}
				}
			} else {
				zval *value_ptr = _get_zval_ptr_cv_BP_VAR_W(opline->op1.var EXECUTE_DATA_CC);

				/* If a function call result is yielded and the function did
				 * not return by reference we throw a notice. */
				do {
					if (IS_CV == IS_VAR) {
						CREX_ASSERT(value_ptr != &EG(uninitialized_zval));
						if (opline->extended_value == CREX_RETURNS_FUNCTION
						 && !C_ISREF_P(value_ptr)) {
							crex_error(E_NOTICE, "Only variable references should be yielded by reference");
							ZVAL_COPY(&generator->value, value_ptr);
							break;
						}
					}
					if (C_ISREF_P(value_ptr)) {
						C_ADDREF_P(value_ptr);
					} else {
						ZVAL_MAKE_REF_EX(value_ptr, 2);
					}
					ZVAL_REF(&generator->value, C_REF_P(value_ptr));
				} while (0);

			}
		} else {
			zval *value = _get_zval_ptr_cv_BP_VAR_R(opline->op1.var EXECUTE_DATA_CC);

			/* Consts, temporary variables and references need copying */
			if (IS_CV == IS_CONST) {
				ZVAL_COPY_VALUE(&generator->value, value);
				if (UNEXPECTED(C_OPT_REFCOUNTED(generator->value))) {
					C_ADDREF(generator->value);
				}
			} else if (IS_CV == IS_TMP_VAR) {
				ZVAL_COPY_VALUE(&generator->value, value);
			} else if ((IS_CV & (IS_VAR|IS_CV)) && C_ISREF_P(value)) {
				ZVAL_COPY(&generator->value, C_REFVAL_P(value));

			} else {
				ZVAL_COPY_VALUE(&generator->value, value);
				if (IS_CV == IS_CV) {
					if (C_OPT_REFCOUNTED_P(value)) C_ADDREF_P(value);
				}
			}
		}
	} else {
		/* If no value was specified yield null */
		ZVAL_NULL(&generator->value);
	}

	/* Set the new yielded key */
	if ((IS_TMP_VAR|IS_VAR) != IS_UNUSED) {
		zval *key = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
		if (((IS_TMP_VAR|IS_VAR) & (IS_CV|IS_VAR)) && UNEXPECTED(C_TYPE_P(key) == IS_REFERENCE)) {
			key = C_REFVAL_P(key);
		}
		ZVAL_COPY(&generator->key, key);
		zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));

		if (C_TYPE(generator->key) == IS_LONG
		    && C_LVAL(generator->key) > generator->largest_used_integer_key
		) {
			generator->largest_used_integer_key = C_LVAL(generator->key);
		}
	} else {
		/* If no key was specified we use auto-increment keys */
		generator->largest_used_integer_key++;
		ZVAL_LONG(&generator->key, generator->largest_used_integer_key);
	}

	if (RETURN_VALUE_USED(opline)) {
		/* If the return value of yield is used set the send
		 * target and initialize it to NULL */
		generator->send_target = EX_VAR(opline->result.var);
		ZVAL_NULL(generator->send_target);
	} else {
		generator->send_target = NULL;
	}

	/* We increment to the next op, so we are at the correct position when the
	 * generator is resumed. */
	CREX_VM_INC_OPCODE();

	/* The GOTO VM uses a local opline variable. We need to set the opline
	 * variable in execute_data so we don't resume at an old position. */
	SAVE_OPLINE();

	CREX_VM_RETURN();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_IS_IDENTICAL_SPEC_CV_TMP_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	bool result;

	SAVE_OPLINE();
	op1 = _get_zval_ptr_cv_deref_BP_VAR_R(opline->op1.var EXECUTE_DATA_CC);
	op2 = _get_zval_ptr_tmp(opline->op2.var EXECUTE_DATA_CC);
	result = fast_is_identical_function(op1, op2);

	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
	CREX_VM_SMART_BRANCH(result, 1);
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_IS_NOT_IDENTICAL_SPEC_CV_TMP_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	bool result;

	SAVE_OPLINE();
	op1 = _get_zval_ptr_cv_deref_BP_VAR_R(opline->op1.var EXECUTE_DATA_CC);
	op2 = _get_zval_ptr_tmp(opline->op2.var EXECUTE_DATA_CC);
	result = fast_is_not_identical_function(op1, op2);

	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
	CREX_VM_SMART_BRANCH(result, 1);
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ASSIGN_SPEC_CV_TMP_RETVAL_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *value;
	zval *variable_ptr;

	SAVE_OPLINE();
	value = _get_zval_ptr_tmp(opline->op2.var EXECUTE_DATA_CC);
	variable_ptr = EX_VAR(opline->op1.var);

	if (0 || UNEXPECTED(0)) {
		crex_refcounted *garbage = NULL;

		value = crex_assign_to_variable_ex(variable_ptr, value, IS_TMP_VAR, EX_USES_STRICT_TYPES(), &garbage);
		if (UNEXPECTED(0)) {
			ZVAL_COPY(EX_VAR(opline->result.var), value);
		}
		if (garbage) {
			GC_DTOR_NO_REF(garbage);
		}
	} else {
		value = crex_assign_to_variable(variable_ptr, value, IS_TMP_VAR, EX_USES_STRICT_TYPES());
	}

	/* crex_assign_to_variable() always takes care of op2, never free it! */

	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ASSIGN_SPEC_CV_TMP_RETVAL_USED_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *value;
	zval *variable_ptr;

	SAVE_OPLINE();
	value = _get_zval_ptr_tmp(opline->op2.var EXECUTE_DATA_CC);
	variable_ptr = EX_VAR(opline->op1.var);

	if (0 || UNEXPECTED(1)) {
		crex_refcounted *garbage = NULL;

		value = crex_assign_to_variable_ex(variable_ptr, value, IS_TMP_VAR, EX_USES_STRICT_TYPES(), &garbage);
		if (UNEXPECTED(1)) {
			ZVAL_COPY(EX_VAR(opline->result.var), value);
		}
		if (garbage) {
			GC_DTOR_NO_REF(garbage);
		}
	} else {
		value = crex_assign_to_variable(variable_ptr, value, IS_TMP_VAR, EX_USES_STRICT_TYPES());
	}

	/* crex_assign_to_variable() always takes care of op2, never free it! */

	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_IS_IDENTICAL_SPEC_CV_VAR_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	bool result;

	SAVE_OPLINE();
	op1 = _get_zval_ptr_cv_deref_BP_VAR_R(opline->op1.var EXECUTE_DATA_CC);
	op2 = _get_zval_ptr_var_deref(opline->op2.var EXECUTE_DATA_CC);
	result = fast_is_identical_function(op1, op2);

	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
	CREX_VM_SMART_BRANCH(result, 1);
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_IS_NOT_IDENTICAL_SPEC_CV_VAR_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	bool result;

	SAVE_OPLINE();
	op1 = _get_zval_ptr_cv_deref_BP_VAR_R(opline->op1.var EXECUTE_DATA_CC);
	op2 = _get_zval_ptr_var_deref(opline->op2.var EXECUTE_DATA_CC);
	result = fast_is_not_identical_function(op1, op2);

	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
	CREX_VM_SMART_BRANCH(result, 1);
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ASSIGN_SPEC_CV_VAR_RETVAL_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *value;
	zval *variable_ptr;

	SAVE_OPLINE();
	value = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
	variable_ptr = EX_VAR(opline->op1.var);

	if (0 || UNEXPECTED(0)) {
		crex_refcounted *garbage = NULL;

		value = crex_assign_to_variable_ex(variable_ptr, value, IS_VAR, EX_USES_STRICT_TYPES(), &garbage);
		if (UNEXPECTED(0)) {
			ZVAL_COPY(EX_VAR(opline->result.var), value);
		}
		if (garbage) {
			GC_DTOR_NO_REF(garbage);
		}
	} else {
		value = crex_assign_to_variable(variable_ptr, value, IS_VAR, EX_USES_STRICT_TYPES());
	}

	/* crex_assign_to_variable() always takes care of op2, never free it! */

	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ASSIGN_SPEC_CV_VAR_RETVAL_USED_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *value;
	zval *variable_ptr;

	SAVE_OPLINE();
	value = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
	variable_ptr = EX_VAR(opline->op1.var);

	if (0 || UNEXPECTED(1)) {
		crex_refcounted *garbage = NULL;

		value = crex_assign_to_variable_ex(variable_ptr, value, IS_VAR, EX_USES_STRICT_TYPES(), &garbage);
		if (UNEXPECTED(1)) {
			ZVAL_COPY(EX_VAR(opline->result.var), value);
		}
		if (garbage) {
			GC_DTOR_NO_REF(garbage);
		}
	} else {
		value = crex_assign_to_variable(variable_ptr, value, IS_VAR, EX_USES_STRICT_TYPES());
	}

	/* crex_assign_to_variable() always takes care of op2, never free it! */

	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ASSIGN_REF_SPEC_CV_VAR_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *variable_ptr;
	zval *value_ptr;
	crex_refcounted *garbage = NULL;

	SAVE_OPLINE();
	value_ptr = _get_zval_ptr_ptr_var(opline->op2.var EXECUTE_DATA_CC);
	variable_ptr = EX_VAR(opline->op1.var);

	if (IS_CV == IS_VAR &&
	           UNEXPECTED(C_TYPE_P(EX_VAR(opline->op1.var)) != IS_INDIRECT)) {

		crex_throw_error(NULL, "Cannot assign by reference to an array dimension of an object");
		variable_ptr = &EG(uninitialized_zval);
	} else if (IS_VAR == IS_VAR &&
	           opline->extended_value == CREX_RETURNS_FUNCTION &&
			   UNEXPECTED(!C_ISREF_P(value_ptr))) {

		variable_ptr = crex_wrong_assign_to_variable_reference(
			variable_ptr, value_ptr, &garbage OPLINE_CC EXECUTE_DATA_CC);
	} else {
		crex_assign_to_variable_reference(variable_ptr, value_ptr, &garbage);
	}

	if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
		ZVAL_COPY(EX_VAR(opline->result.var), variable_ptr);
	}

	if (garbage) {
		GC_DTOR(garbage);
	}

	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));

	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_INSTANCEOF_SPEC_CV_VAR_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *expr;
	bool result;

	SAVE_OPLINE();
	expr = EX_VAR(opline->op1.var);

try_instanceof:
	if (C_TYPE_P(expr) == IS_OBJECT) {
		crex_class_entry *ce;

		if (IS_VAR == IS_CONST) {
			ce = CACHED_PTR(opline->extended_value);
			if (UNEXPECTED(ce == NULL)) {
				ce = crex_lookup_class_ex(C_STR_P(RT_CONSTANT(opline, opline->op2)), C_STR_P(RT_CONSTANT(opline, opline->op2) + 1), CREX_FETCH_CLASS_NO_AUTOLOAD);
				if (EXPECTED(ce)) {
					CACHE_PTR(opline->extended_value, ce);
				}
			}
		} else if (IS_VAR == IS_UNUSED) {
			ce = crex_fetch_class(NULL, opline->op2.num);
			if (UNEXPECTED(ce == NULL)) {

				ZVAL_UNDEF(EX_VAR(opline->result.var));
				HANDLE_EXCEPTION();
			}
		} else {
			ce = C_CE_P(EX_VAR(opline->op2.var));
		}
		result = ce && instanceof_function(C_OBJCE_P(expr), ce);
	} else if ((IS_CV & (IS_VAR|IS_CV)) && C_TYPE_P(expr) == IS_REFERENCE) {
		expr = C_REFVAL_P(expr);
		goto try_instanceof;
	} else {
		if (IS_CV == IS_CV && UNEXPECTED(C_TYPE_P(expr) == IS_UNDEF)) {
			ZVAL_UNDEFINED_OP1();
		}
		result = 0;
	}

	CREX_VM_SMART_BRANCH(result, 1);
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ASSIGN_DIM_OP_SPEC_CV_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *var_ptr;
	zval *value, *container, *dim;
	HashTable *ht;

	SAVE_OPLINE();
	container = EX_VAR(opline->op1.var);

	if (EXPECTED(C_TYPE_P(container) == IS_ARRAY)) {
assign_dim_op_array:
		SEPARATE_ARRAY(container);
		ht = C_ARRVAL_P(container);
assign_dim_op_new_array:
		dim = NULL;
		if (IS_UNUSED == IS_UNUSED) {
			var_ptr = crex_hash_next_index_insert(ht, &EG(uninitialized_zval));
			if (UNEXPECTED(!var_ptr)) {
				crex_cannot_add_element();
				goto assign_dim_op_ret_null;
			}
		} else {
			if (IS_UNUSED == IS_CONST) {
				var_ptr = crex_fetch_dimension_address_inner_RW_CONST(ht, dim EXECUTE_DATA_CC);
			} else {
				var_ptr = crex_fetch_dimension_address_inner_RW(ht, dim EXECUTE_DATA_CC);
			}
			if (UNEXPECTED(!var_ptr)) {
				goto assign_dim_op_ret_null;
			}
		}

		value = get_op_data_zval_ptr_r((opline+1)->op1_type, (opline+1)->op1);

		do {
			if (IS_UNUSED != IS_UNUSED && UNEXPECTED(C_ISREF_P(var_ptr))) {
				crex_reference *ref = C_REF_P(var_ptr);
				var_ptr = C_REFVAL_P(var_ptr);
				if (UNEXPECTED(CREX_REF_HAS_TYPE_SOURCES(ref))) {
					crex_binary_assign_op_typed_ref(ref, value OPLINE_CC EXECUTE_DATA_CC);
					break;
				}
			}
			crex_binary_op(var_ptr, var_ptr, value OPLINE_CC);
		} while (0);

		if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
			ZVAL_COPY(EX_VAR(opline->result.var), var_ptr);
		}
		FREE_OP((opline+1)->op1_type, (opline+1)->op1.var);
	} else {
		if (EXPECTED(C_ISREF_P(container))) {
			container = C_REFVAL_P(container);
			if (EXPECTED(C_TYPE_P(container) == IS_ARRAY)) {
				goto assign_dim_op_array;
			}
		}

		if (EXPECTED(C_TYPE_P(container) == IS_OBJECT)) {
			crex_object *obj = C_OBJ_P(container);

			dim = NULL;
			if (IS_UNUSED == IS_CONST && C_EXTRA_P(dim) == CREX_EXTRA_VALUE) {
				dim++;
			}
			crex_binary_assign_op_obj_dim(obj, dim OPLINE_CC EXECUTE_DATA_CC);
		} else if (EXPECTED(C_TYPE_P(container) <= IS_FALSE)) {
			uint8_t old_type;

			if (IS_CV == IS_CV && UNEXPECTED(C_TYPE_INFO_P(container) == IS_UNDEF)) {
				ZVAL_UNDEFINED_OP1();
			}
			ht = crex_new_array(8);
			old_type = C_TYPE_P(container);
			ZVAL_ARR(container, ht);
			if (UNEXPECTED(old_type == IS_FALSE)) {
				GC_ADDREF(ht);
				crex_false_to_array_deprecated();
				if (UNEXPECTED(GC_DELREF(ht) == 0)) {
					crex_array_destroy(ht);
					goto assign_dim_op_ret_null;
				}
			}
			goto assign_dim_op_new_array;
		} else {
			dim = NULL;
			crex_binary_assign_op_dim_slow(container, dim OPLINE_CC EXECUTE_DATA_CC);
assign_dim_op_ret_null:
			FREE_OP((opline+1)->op1_type, (opline+1)->op1.var);
			if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
				ZVAL_NULL(EX_VAR(opline->result.var));
			}
		}
	}


	CREX_VM_NEXT_OPCODE_EX(1, 2);
}

static crex_never_inline CREX_OPCODE_HANDLER_RET CREX_FASTCALL crex_fetch_var_address_helper_SPEC_CV_UNUSED(int type CREX_OPCODE_HANDLER_ARGS_DC)
{
	USE_OPLINE
	zval *varname;
	zval *retval;
	crex_string *name, *tmp_name;
	HashTable *target_symbol_table;

	SAVE_OPLINE();
	varname = EX_VAR(opline->op1.var);

	if (IS_CV == IS_CONST) {
		name = C_STR_P(varname);
	} else if (EXPECTED(C_TYPE_P(varname) == IS_STRING)) {
		name = C_STR_P(varname);
		tmp_name = NULL;
	} else {
		if (IS_CV == IS_CV && UNEXPECTED(C_TYPE_P(varname) == IS_UNDEF)) {
			ZVAL_UNDEFINED_OP1();
		}
		name = zval_try_get_tmp_string(varname, &tmp_name);
		if (UNEXPECTED(!name)) {
			if (!(opline->extended_value & CREX_FETCH_GLOBAL_LOCK)) {

			}
			ZVAL_UNDEF(EX_VAR(opline->result.var));
			HANDLE_EXCEPTION();
		}
	}

	target_symbol_table = crex_get_target_symbol_table(opline->extended_value EXECUTE_DATA_CC);
	retval = crex_hash_find_ex(target_symbol_table, name, IS_CV == IS_CONST);
	if (retval == NULL) {
		if (UNEXPECTED(crex_string_equals(name, ZSTR_KNOWN(CREX_STR_THIS)))) {
fetch_this:
			crex_fetch_this_var(type OPLINE_CC EXECUTE_DATA_CC);
			if (IS_CV != IS_CONST) {
				crex_tmp_string_release(tmp_name);
			}
			CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
		}
		if (type == BP_VAR_W) {
			retval = crex_hash_add_new(target_symbol_table, name, &EG(uninitialized_zval));
		} else if (type == BP_VAR_IS || type == BP_VAR_UNSET) {
			retval = &EG(uninitialized_zval);
		} else {
			if (IS_CV == IS_CV) {
				/* Keep name alive in case an error handler tries to free it. */
				crex_string_addref(name);
			}
			crex_error(E_WARNING, "Undefined %svariable $%s",
				(opline->extended_value & CREX_FETCH_GLOBAL ? "global " : ""), ZSTR_VAL(name));
			if (type == BP_VAR_RW && !EG(exception)) {
				retval = crex_hash_update(target_symbol_table, name, &EG(uninitialized_zval));
			} else {
				retval = &EG(uninitialized_zval);
			}
			if (IS_CV == IS_CV) {
				crex_string_release(name);
			}
		}
	/* GLOBAL or $$name variable may be an INDIRECT pointer to CV */
	} else if (C_TYPE_P(retval) == IS_INDIRECT) {
		retval = C_INDIRECT_P(retval);
		if (C_TYPE_P(retval) == IS_UNDEF) {
			if (UNEXPECTED(crex_string_equals(name, ZSTR_KNOWN(CREX_STR_THIS)))) {
				goto fetch_this;
			}
			if (type == BP_VAR_W) {
				ZVAL_NULL(retval);
			} else if (type == BP_VAR_IS || type == BP_VAR_UNSET) {
				retval = &EG(uninitialized_zval);
			} else {
				crex_error(E_WARNING, "Undefined %svariable $%s",
					(opline->extended_value & CREX_FETCH_GLOBAL ? "global " : ""), ZSTR_VAL(name));
				if (type == BP_VAR_RW && !EG(exception)) {
					ZVAL_NULL(retval);
				} else {
					retval = &EG(uninitialized_zval);
				}
			}
		}
	}

	if (!(opline->extended_value & CREX_FETCH_GLOBAL_LOCK)) {

	}

	if (IS_CV != IS_CONST) {
		crex_tmp_string_release(tmp_name);
	}

	CREX_ASSERT(retval != NULL);
	if (type == BP_VAR_R || type == BP_VAR_IS) {
		ZVAL_COPY_DEREF(EX_VAR(opline->result.var), retval);
	} else {
		ZVAL_INDIRECT(EX_VAR(opline->result.var), retval);
	}
	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FETCH_R_SPEC_CV_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	CREX_VM_TAIL_CALL(crex_fetch_var_address_helper_SPEC_CV_UNUSED(BP_VAR_R CREX_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FETCH_W_SPEC_CV_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	CREX_VM_TAIL_CALL(crex_fetch_var_address_helper_SPEC_CV_UNUSED(BP_VAR_W CREX_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FETCH_RW_SPEC_CV_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	CREX_VM_TAIL_CALL(crex_fetch_var_address_helper_SPEC_CV_UNUSED(BP_VAR_RW CREX_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FETCH_FUNC_ARG_SPEC_CV_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	int fetch_type =
		(UNEXPECTED(CREX_CALL_INFO(EX(call)) & CREX_CALL_SEND_ARG_BY_REF)) ?
			BP_VAR_W : BP_VAR_R;
	CREX_VM_TAIL_CALL(crex_fetch_var_address_helper_SPEC_CV_UNUSED(fetch_type CREX_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FETCH_UNSET_SPEC_CV_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	CREX_VM_TAIL_CALL(crex_fetch_var_address_helper_SPEC_CV_UNUSED(BP_VAR_UNSET CREX_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FETCH_IS_SPEC_CV_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	CREX_VM_TAIL_CALL(crex_fetch_var_address_helper_SPEC_CV_UNUSED(BP_VAR_IS CREX_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

/* No specialization for op_types (CONST|TMPVAR|CV, UNUSED|CONST|VAR) */
static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FETCH_DIM_W_SPEC_CV_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;

	SAVE_OPLINE();
	container = EX_VAR(opline->op1.var);
	crex_fetch_dimension_address_W(container, NULL, IS_UNUSED OPLINE_CC EXECUTE_DATA_CC);

	if (IS_CV == IS_VAR) {
		FREE_VAR_PTR_AND_EXTRACT_RESULT_IF_NECESSARY(opline->op1.var);
	}
	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FETCH_DIM_RW_SPEC_CV_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;

	SAVE_OPLINE();
	container = EX_VAR(opline->op1.var);
	crex_fetch_dimension_address_RW(container, NULL, IS_UNUSED OPLINE_CC EXECUTE_DATA_CC);

	if (IS_CV == IS_VAR) {
		FREE_VAR_PTR_AND_EXTRACT_RESULT_IF_NECESSARY(opline->op1.var);
	}
	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FETCH_DIM_FUNC_ARG_SPEC_CV_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
#if 0
	USE_OPLINE
#endif

	if (UNEXPECTED(CREX_CALL_INFO(EX(call)) & CREX_CALL_SEND_ARG_BY_REF)) {
		if ((IS_CV & (IS_CONST|IS_TMP_VAR))) {
			CREX_VM_TAIL_CALL(crex_use_tmp_in_write_context_helper_SPEC(CREX_OPCODE_HANDLER_ARGS_PASSTHRU));
		}
		CREX_VM_TAIL_CALL(CREX_FETCH_DIM_W_SPEC_CV_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU));
	} else {
		if (IS_UNUSED == IS_UNUSED) {
			CREX_VM_TAIL_CALL(crex_use_undef_in_read_context_helper_SPEC(CREX_OPCODE_HANDLER_ARGS_PASSTHRU));
		}
		CREX_VM_TAIL_CALL(CREX_NULL_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU));
	}
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ASSIGN_DIM_SPEC_CV_UNUSED_OP_DATA_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *object_ptr, *orig_object_ptr;
	zval *value;
	zval *variable_ptr;
	zval *dim;
	crex_refcounted *garbage = NULL;

	SAVE_OPLINE();
	orig_object_ptr = object_ptr = EX_VAR(opline->op1.var);

	if (EXPECTED(C_TYPE_P(object_ptr) == IS_ARRAY)) {
try_assign_dim_array:
		SEPARATE_ARRAY(object_ptr);
		if (IS_UNUSED == IS_UNUSED) {
			value = RT_CONSTANT((opline+1), (opline+1)->op1);
			if (IS_CONST == IS_CV && UNEXPECTED(C_TYPE_P(value) == IS_UNDEF)) {
				HashTable *ht = C_ARRVAL_P(object_ptr);
				if (!(GC_FLAGS(ht) & IS_ARRAY_IMMUTABLE)) {
					GC_ADDREF(ht);
				}
				value = zval_undefined_cv((opline+1)->op1.var EXECUTE_DATA_CC);
				if (!(GC_FLAGS(ht) & IS_ARRAY_IMMUTABLE) && !GC_DELREF(ht)) {
					crex_array_destroy(ht);
					goto assign_dim_error;
				}
			}
			if (IS_CONST == IS_CV || IS_CONST == IS_VAR) {
				ZVAL_DEREF(value);
			}
			value = crex_hash_next_index_insert(C_ARRVAL_P(object_ptr), value);
			if (UNEXPECTED(value == NULL)) {
				crex_cannot_add_element();
				goto assign_dim_error;
			} else if (IS_CONST == IS_CV) {
				if (C_REFCOUNTED_P(value)) {
					C_ADDREF_P(value);
				}
			} else if (IS_CONST == IS_VAR) {
				zval *free_op_data = EX_VAR((opline+1)->op1.var);
				if (C_ISREF_P(free_op_data)) {
					if (C_REFCOUNTED_P(value)) {
						C_ADDREF_P(value);
					}
					zval_ptr_dtor_nogc(free_op_data);
				}
			} else if (IS_CONST == IS_CONST) {
				if (UNEXPECTED(C_REFCOUNTED_P(value))) {
					C_ADDREF_P(value);
				}
			}
		} else {
			dim = NULL;
			if (IS_UNUSED == IS_CONST) {
				variable_ptr = crex_fetch_dimension_address_inner_W_CONST(C_ARRVAL_P(object_ptr), dim EXECUTE_DATA_CC);
			} else {
				variable_ptr = crex_fetch_dimension_address_inner_W(C_ARRVAL_P(object_ptr), dim EXECUTE_DATA_CC);
			}
			if (UNEXPECTED(variable_ptr == NULL)) {
				goto assign_dim_error;
			}
			value = RT_CONSTANT((opline+1), (opline+1)->op1);
			value = crex_assign_to_variable_ex(variable_ptr, value, IS_CONST, EX_USES_STRICT_TYPES(), &garbage);
		}
		if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
			ZVAL_COPY(EX_VAR(opline->result.var), value);
		}
		if (garbage) {
			GC_DTOR_NO_REF(garbage);
		}
	} else {
		if (EXPECTED(C_ISREF_P(object_ptr))) {
			object_ptr = C_REFVAL_P(object_ptr);
			if (EXPECTED(C_TYPE_P(object_ptr) == IS_ARRAY)) {
				goto try_assign_dim_array;
			}
		}
		if (EXPECTED(C_TYPE_P(object_ptr) == IS_OBJECT)) {
			crex_object *obj = C_OBJ_P(object_ptr);

			GC_ADDREF(obj);
			dim = NULL;
			if (IS_UNUSED == IS_CV && UNEXPECTED(C_ISUNDEF_P(dim))) {
				dim = ZVAL_UNDEFINED_OP2();
			} else if (IS_UNUSED == IS_CONST && C_EXTRA_P(dim) == CREX_EXTRA_VALUE) {
				dim++;
			}

			value = RT_CONSTANT((opline+1), (opline+1)->op1);
			if (IS_CONST == IS_CV && UNEXPECTED(C_ISUNDEF_P(value))) {
				value = zval_undefined_cv((opline+1)->op1.var EXECUTE_DATA_CC);
			} else if (IS_CONST & (IS_CV|IS_VAR)) {
				ZVAL_DEREF(value);
			}

			crex_assign_to_object_dim(obj, dim, value OPLINE_CC EXECUTE_DATA_CC);

			if (UNEXPECTED(GC_DELREF(obj) == 0)) {
				crex_objects_store_del(obj);
			}
		} else if (EXPECTED(C_TYPE_P(object_ptr) == IS_STRING)) {
			if (IS_UNUSED == IS_UNUSED) {
				crex_use_new_element_for_string();

				UNDEF_RESULT();
			} else {
				dim = NULL;
				value = RT_CONSTANT((opline+1), (opline+1)->op1);
				crex_assign_to_string_offset(object_ptr, dim, value OPLINE_CC EXECUTE_DATA_CC);

			}
		} else if (EXPECTED(C_TYPE_P(object_ptr) <= IS_FALSE)) {
			if (C_ISREF_P(orig_object_ptr)
			 && CREX_REF_HAS_TYPE_SOURCES(C_REF_P(orig_object_ptr))
			 && !crex_verify_ref_array_assignable(C_REF_P(orig_object_ptr))) {
				dim = NULL;

				UNDEF_RESULT();
			} else {
				HashTable *ht = crex_new_array(8);
				uint8_t old_type = C_TYPE_P(object_ptr);

				ZVAL_ARR(object_ptr, ht);
				if (UNEXPECTED(old_type == IS_FALSE)) {
					GC_ADDREF(ht);
					crex_false_to_array_deprecated();
					if (UNEXPECTED(GC_DELREF(ht) == 0)) {
						crex_array_destroy(ht);
						goto assign_dim_error;
					}
				}
				goto try_assign_dim_array;
			}
		} else {
			crex_use_scalar_as_array();
			dim = NULL;
assign_dim_error:

			if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
				ZVAL_NULL(EX_VAR(opline->result.var));
			}
		}
	}
	if (IS_UNUSED != IS_UNUSED) {

	}

	/* assign_dim has two opcodes! */
	CREX_VM_NEXT_OPCODE_EX(1, 2);
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ASSIGN_DIM_SPEC_CV_UNUSED_OP_DATA_TMP_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *object_ptr, *orig_object_ptr;
	zval *value;
	zval *variable_ptr;
	zval *dim;
	crex_refcounted *garbage = NULL;

	SAVE_OPLINE();
	orig_object_ptr = object_ptr = EX_VAR(opline->op1.var);

	if (EXPECTED(C_TYPE_P(object_ptr) == IS_ARRAY)) {
try_assign_dim_array:
		SEPARATE_ARRAY(object_ptr);
		if (IS_UNUSED == IS_UNUSED) {
			value = _get_zval_ptr_tmp((opline+1)->op1.var EXECUTE_DATA_CC);
			if (IS_TMP_VAR == IS_CV && UNEXPECTED(C_TYPE_P(value) == IS_UNDEF)) {
				HashTable *ht = C_ARRVAL_P(object_ptr);
				if (!(GC_FLAGS(ht) & IS_ARRAY_IMMUTABLE)) {
					GC_ADDREF(ht);
				}
				value = zval_undefined_cv((opline+1)->op1.var EXECUTE_DATA_CC);
				if (!(GC_FLAGS(ht) & IS_ARRAY_IMMUTABLE) && !GC_DELREF(ht)) {
					crex_array_destroy(ht);
					goto assign_dim_error;
				}
			}
			if (IS_TMP_VAR == IS_CV || IS_TMP_VAR == IS_VAR) {
				ZVAL_DEREF(value);
			}
			value = crex_hash_next_index_insert(C_ARRVAL_P(object_ptr), value);
			if (UNEXPECTED(value == NULL)) {
				crex_cannot_add_element();
				goto assign_dim_error;
			} else if (IS_TMP_VAR == IS_CV) {
				if (C_REFCOUNTED_P(value)) {
					C_ADDREF_P(value);
				}
			} else if (IS_TMP_VAR == IS_VAR) {
				zval *free_op_data = EX_VAR((opline+1)->op1.var);
				if (C_ISREF_P(free_op_data)) {
					if (C_REFCOUNTED_P(value)) {
						C_ADDREF_P(value);
					}
					zval_ptr_dtor_nogc(free_op_data);
				}
			} else if (IS_TMP_VAR == IS_CONST) {
				if (UNEXPECTED(C_REFCOUNTED_P(value))) {
					C_ADDREF_P(value);
				}
			}
		} else {
			dim = NULL;
			if (IS_UNUSED == IS_CONST) {
				variable_ptr = crex_fetch_dimension_address_inner_W_CONST(C_ARRVAL_P(object_ptr), dim EXECUTE_DATA_CC);
			} else {
				variable_ptr = crex_fetch_dimension_address_inner_W(C_ARRVAL_P(object_ptr), dim EXECUTE_DATA_CC);
			}
			if (UNEXPECTED(variable_ptr == NULL)) {
				goto assign_dim_error;
			}
			value = _get_zval_ptr_tmp((opline+1)->op1.var EXECUTE_DATA_CC);
			value = crex_assign_to_variable_ex(variable_ptr, value, IS_TMP_VAR, EX_USES_STRICT_TYPES(), &garbage);
		}
		if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
			ZVAL_COPY(EX_VAR(opline->result.var), value);
		}
		if (garbage) {
			GC_DTOR_NO_REF(garbage);
		}
	} else {
		if (EXPECTED(C_ISREF_P(object_ptr))) {
			object_ptr = C_REFVAL_P(object_ptr);
			if (EXPECTED(C_TYPE_P(object_ptr) == IS_ARRAY)) {
				goto try_assign_dim_array;
			}
		}
		if (EXPECTED(C_TYPE_P(object_ptr) == IS_OBJECT)) {
			crex_object *obj = C_OBJ_P(object_ptr);

			GC_ADDREF(obj);
			dim = NULL;
			if (IS_UNUSED == IS_CV && UNEXPECTED(C_ISUNDEF_P(dim))) {
				dim = ZVAL_UNDEFINED_OP2();
			} else if (IS_UNUSED == IS_CONST && C_EXTRA_P(dim) == CREX_EXTRA_VALUE) {
				dim++;
			}

			value = _get_zval_ptr_tmp((opline+1)->op1.var EXECUTE_DATA_CC);
			if (IS_TMP_VAR == IS_CV && UNEXPECTED(C_ISUNDEF_P(value))) {
				value = zval_undefined_cv((opline+1)->op1.var EXECUTE_DATA_CC);
			} else if (IS_TMP_VAR & (IS_CV|IS_VAR)) {
				ZVAL_DEREF(value);
			}

			crex_assign_to_object_dim(obj, dim, value OPLINE_CC EXECUTE_DATA_CC);

			zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
			if (UNEXPECTED(GC_DELREF(obj) == 0)) {
				crex_objects_store_del(obj);
			}
		} else if (EXPECTED(C_TYPE_P(object_ptr) == IS_STRING)) {
			if (IS_UNUSED == IS_UNUSED) {
				crex_use_new_element_for_string();
				zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
				UNDEF_RESULT();
			} else {
				dim = NULL;
				value = _get_zval_ptr_tmp((opline+1)->op1.var EXECUTE_DATA_CC);
				crex_assign_to_string_offset(object_ptr, dim, value OPLINE_CC EXECUTE_DATA_CC);
				zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
			}
		} else if (EXPECTED(C_TYPE_P(object_ptr) <= IS_FALSE)) {
			if (C_ISREF_P(orig_object_ptr)
			 && CREX_REF_HAS_TYPE_SOURCES(C_REF_P(orig_object_ptr))
			 && !crex_verify_ref_array_assignable(C_REF_P(orig_object_ptr))) {
				dim = NULL;
				zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
				UNDEF_RESULT();
			} else {
				HashTable *ht = crex_new_array(8);
				uint8_t old_type = C_TYPE_P(object_ptr);

				ZVAL_ARR(object_ptr, ht);
				if (UNEXPECTED(old_type == IS_FALSE)) {
					GC_ADDREF(ht);
					crex_false_to_array_deprecated();
					if (UNEXPECTED(GC_DELREF(ht) == 0)) {
						crex_array_destroy(ht);
						goto assign_dim_error;
					}
				}
				goto try_assign_dim_array;
			}
		} else {
			crex_use_scalar_as_array();
			dim = NULL;
assign_dim_error:
			zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
			if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
				ZVAL_NULL(EX_VAR(opline->result.var));
			}
		}
	}
	if (IS_UNUSED != IS_UNUSED) {

	}

	/* assign_dim has two opcodes! */
	CREX_VM_NEXT_OPCODE_EX(1, 2);
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ASSIGN_DIM_SPEC_CV_UNUSED_OP_DATA_VAR_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *object_ptr, *orig_object_ptr;
	zval *value;
	zval *variable_ptr;
	zval *dim;
	crex_refcounted *garbage = NULL;

	SAVE_OPLINE();
	orig_object_ptr = object_ptr = EX_VAR(opline->op1.var);

	if (EXPECTED(C_TYPE_P(object_ptr) == IS_ARRAY)) {
try_assign_dim_array:
		SEPARATE_ARRAY(object_ptr);
		if (IS_UNUSED == IS_UNUSED) {
			value = _get_zval_ptr_var((opline+1)->op1.var EXECUTE_DATA_CC);
			if (IS_VAR == IS_CV && UNEXPECTED(C_TYPE_P(value) == IS_UNDEF)) {
				HashTable *ht = C_ARRVAL_P(object_ptr);
				if (!(GC_FLAGS(ht) & IS_ARRAY_IMMUTABLE)) {
					GC_ADDREF(ht);
				}
				value = zval_undefined_cv((opline+1)->op1.var EXECUTE_DATA_CC);
				if (!(GC_FLAGS(ht) & IS_ARRAY_IMMUTABLE) && !GC_DELREF(ht)) {
					crex_array_destroy(ht);
					goto assign_dim_error;
				}
			}
			if (IS_VAR == IS_CV || IS_VAR == IS_VAR) {
				ZVAL_DEREF(value);
			}
			value = crex_hash_next_index_insert(C_ARRVAL_P(object_ptr), value);
			if (UNEXPECTED(value == NULL)) {
				crex_cannot_add_element();
				goto assign_dim_error;
			} else if (IS_VAR == IS_CV) {
				if (C_REFCOUNTED_P(value)) {
					C_ADDREF_P(value);
				}
			} else if (IS_VAR == IS_VAR) {
				zval *free_op_data = EX_VAR((opline+1)->op1.var);
				if (C_ISREF_P(free_op_data)) {
					if (C_REFCOUNTED_P(value)) {
						C_ADDREF_P(value);
					}
					zval_ptr_dtor_nogc(free_op_data);
				}
			} else if (IS_VAR == IS_CONST) {
				if (UNEXPECTED(C_REFCOUNTED_P(value))) {
					C_ADDREF_P(value);
				}
			}
		} else {
			dim = NULL;
			if (IS_UNUSED == IS_CONST) {
				variable_ptr = crex_fetch_dimension_address_inner_W_CONST(C_ARRVAL_P(object_ptr), dim EXECUTE_DATA_CC);
			} else {
				variable_ptr = crex_fetch_dimension_address_inner_W(C_ARRVAL_P(object_ptr), dim EXECUTE_DATA_CC);
			}
			if (UNEXPECTED(variable_ptr == NULL)) {
				goto assign_dim_error;
			}
			value = _get_zval_ptr_var((opline+1)->op1.var EXECUTE_DATA_CC);
			value = crex_assign_to_variable_ex(variable_ptr, value, IS_VAR, EX_USES_STRICT_TYPES(), &garbage);
		}
		if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
			ZVAL_COPY(EX_VAR(opline->result.var), value);
		}
		if (garbage) {
			GC_DTOR_NO_REF(garbage);
		}
	} else {
		if (EXPECTED(C_ISREF_P(object_ptr))) {
			object_ptr = C_REFVAL_P(object_ptr);
			if (EXPECTED(C_TYPE_P(object_ptr) == IS_ARRAY)) {
				goto try_assign_dim_array;
			}
		}
		if (EXPECTED(C_TYPE_P(object_ptr) == IS_OBJECT)) {
			crex_object *obj = C_OBJ_P(object_ptr);

			GC_ADDREF(obj);
			dim = NULL;
			if (IS_UNUSED == IS_CV && UNEXPECTED(C_ISUNDEF_P(dim))) {
				dim = ZVAL_UNDEFINED_OP2();
			} else if (IS_UNUSED == IS_CONST && C_EXTRA_P(dim) == CREX_EXTRA_VALUE) {
				dim++;
			}

			value = _get_zval_ptr_var((opline+1)->op1.var EXECUTE_DATA_CC);
			if (IS_VAR == IS_CV && UNEXPECTED(C_ISUNDEF_P(value))) {
				value = zval_undefined_cv((opline+1)->op1.var EXECUTE_DATA_CC);
			} else if (IS_VAR & (IS_CV|IS_VAR)) {
				ZVAL_DEREF(value);
			}

			crex_assign_to_object_dim(obj, dim, value OPLINE_CC EXECUTE_DATA_CC);

			zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
			if (UNEXPECTED(GC_DELREF(obj) == 0)) {
				crex_objects_store_del(obj);
			}
		} else if (EXPECTED(C_TYPE_P(object_ptr) == IS_STRING)) {
			if (IS_UNUSED == IS_UNUSED) {
				crex_use_new_element_for_string();
				zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
				UNDEF_RESULT();
			} else {
				dim = NULL;
				value = _get_zval_ptr_var((opline+1)->op1.var EXECUTE_DATA_CC);
				crex_assign_to_string_offset(object_ptr, dim, value OPLINE_CC EXECUTE_DATA_CC);
				zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
			}
		} else if (EXPECTED(C_TYPE_P(object_ptr) <= IS_FALSE)) {
			if (C_ISREF_P(orig_object_ptr)
			 && CREX_REF_HAS_TYPE_SOURCES(C_REF_P(orig_object_ptr))
			 && !crex_verify_ref_array_assignable(C_REF_P(orig_object_ptr))) {
				dim = NULL;
				zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
				UNDEF_RESULT();
			} else {
				HashTable *ht = crex_new_array(8);
				uint8_t old_type = C_TYPE_P(object_ptr);

				ZVAL_ARR(object_ptr, ht);
				if (UNEXPECTED(old_type == IS_FALSE)) {
					GC_ADDREF(ht);
					crex_false_to_array_deprecated();
					if (UNEXPECTED(GC_DELREF(ht) == 0)) {
						crex_array_destroy(ht);
						goto assign_dim_error;
					}
				}
				goto try_assign_dim_array;
			}
		} else {
			crex_use_scalar_as_array();
			dim = NULL;
assign_dim_error:
			zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
			if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
				ZVAL_NULL(EX_VAR(opline->result.var));
			}
		}
	}
	if (IS_UNUSED != IS_UNUSED) {

	}

	/* assign_dim has two opcodes! */
	CREX_VM_NEXT_OPCODE_EX(1, 2);
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ASSIGN_DIM_SPEC_CV_UNUSED_OP_DATA_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *object_ptr, *orig_object_ptr;
	zval *value;
	zval *variable_ptr;
	zval *dim;
	crex_refcounted *garbage = NULL;

	SAVE_OPLINE();
	orig_object_ptr = object_ptr = EX_VAR(opline->op1.var);

	if (EXPECTED(C_TYPE_P(object_ptr) == IS_ARRAY)) {
try_assign_dim_array:
		SEPARATE_ARRAY(object_ptr);
		if (IS_UNUSED == IS_UNUSED) {
			value = EX_VAR((opline+1)->op1.var);
			if (IS_CV == IS_CV && UNEXPECTED(C_TYPE_P(value) == IS_UNDEF)) {
				HashTable *ht = C_ARRVAL_P(object_ptr);
				if (!(GC_FLAGS(ht) & IS_ARRAY_IMMUTABLE)) {
					GC_ADDREF(ht);
				}
				value = zval_undefined_cv((opline+1)->op1.var EXECUTE_DATA_CC);
				if (!(GC_FLAGS(ht) & IS_ARRAY_IMMUTABLE) && !GC_DELREF(ht)) {
					crex_array_destroy(ht);
					goto assign_dim_error;
				}
			}
			if (IS_CV == IS_CV || IS_CV == IS_VAR) {
				ZVAL_DEREF(value);
			}
			value = crex_hash_next_index_insert(C_ARRVAL_P(object_ptr), value);
			if (UNEXPECTED(value == NULL)) {
				crex_cannot_add_element();
				goto assign_dim_error;
			} else if (IS_CV == IS_CV) {
				if (C_REFCOUNTED_P(value)) {
					C_ADDREF_P(value);
				}
			} else if (IS_CV == IS_VAR) {
				zval *free_op_data = EX_VAR((opline+1)->op1.var);
				if (C_ISREF_P(free_op_data)) {
					if (C_REFCOUNTED_P(value)) {
						C_ADDREF_P(value);
					}
					zval_ptr_dtor_nogc(free_op_data);
				}
			} else if (IS_CV == IS_CONST) {
				if (UNEXPECTED(C_REFCOUNTED_P(value))) {
					C_ADDREF_P(value);
				}
			}
		} else {
			dim = NULL;
			if (IS_UNUSED == IS_CONST) {
				variable_ptr = crex_fetch_dimension_address_inner_W_CONST(C_ARRVAL_P(object_ptr), dim EXECUTE_DATA_CC);
			} else {
				variable_ptr = crex_fetch_dimension_address_inner_W(C_ARRVAL_P(object_ptr), dim EXECUTE_DATA_CC);
			}
			if (UNEXPECTED(variable_ptr == NULL)) {
				goto assign_dim_error;
			}
			value = _get_zval_ptr_cv_BP_VAR_R((opline+1)->op1.var EXECUTE_DATA_CC);
			value = crex_assign_to_variable_ex(variable_ptr, value, IS_CV, EX_USES_STRICT_TYPES(), &garbage);
		}
		if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
			ZVAL_COPY(EX_VAR(opline->result.var), value);
		}
		if (garbage) {
			GC_DTOR_NO_REF(garbage);
		}
	} else {
		if (EXPECTED(C_ISREF_P(object_ptr))) {
			object_ptr = C_REFVAL_P(object_ptr);
			if (EXPECTED(C_TYPE_P(object_ptr) == IS_ARRAY)) {
				goto try_assign_dim_array;
			}
		}
		if (EXPECTED(C_TYPE_P(object_ptr) == IS_OBJECT)) {
			crex_object *obj = C_OBJ_P(object_ptr);

			GC_ADDREF(obj);
			dim = NULL;
			if (IS_UNUSED == IS_CV && UNEXPECTED(C_ISUNDEF_P(dim))) {
				dim = ZVAL_UNDEFINED_OP2();
			} else if (IS_UNUSED == IS_CONST && C_EXTRA_P(dim) == CREX_EXTRA_VALUE) {
				dim++;
			}

			value = EX_VAR((opline+1)->op1.var);
			if (IS_CV == IS_CV && UNEXPECTED(C_ISUNDEF_P(value))) {
				value = zval_undefined_cv((opline+1)->op1.var EXECUTE_DATA_CC);
			} else if (IS_CV & (IS_CV|IS_VAR)) {
				ZVAL_DEREF(value);
			}

			crex_assign_to_object_dim(obj, dim, value OPLINE_CC EXECUTE_DATA_CC);

			if (UNEXPECTED(GC_DELREF(obj) == 0)) {
				crex_objects_store_del(obj);
			}
		} else if (EXPECTED(C_TYPE_P(object_ptr) == IS_STRING)) {
			if (IS_UNUSED == IS_UNUSED) {
				crex_use_new_element_for_string();

				UNDEF_RESULT();
			} else {
				dim = NULL;
				value = EX_VAR((opline+1)->op1.var);
				crex_assign_to_string_offset(object_ptr, dim, value OPLINE_CC EXECUTE_DATA_CC);

			}
		} else if (EXPECTED(C_TYPE_P(object_ptr) <= IS_FALSE)) {
			if (C_ISREF_P(orig_object_ptr)
			 && CREX_REF_HAS_TYPE_SOURCES(C_REF_P(orig_object_ptr))
			 && !crex_verify_ref_array_assignable(C_REF_P(orig_object_ptr))) {
				dim = NULL;

				UNDEF_RESULT();
			} else {
				HashTable *ht = crex_new_array(8);
				uint8_t old_type = C_TYPE_P(object_ptr);

				ZVAL_ARR(object_ptr, ht);
				if (UNEXPECTED(old_type == IS_FALSE)) {
					GC_ADDREF(ht);
					crex_false_to_array_deprecated();
					if (UNEXPECTED(GC_DELREF(ht) == 0)) {
						crex_array_destroy(ht);
						goto assign_dim_error;
					}
				}
				goto try_assign_dim_array;
			}
		} else {
			crex_use_scalar_as_array();
			dim = NULL;
assign_dim_error:

			if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
				ZVAL_NULL(EX_VAR(opline->result.var));
			}
		}
	}
	if (IS_UNUSED != IS_UNUSED) {

	}

	/* assign_dim has two opcodes! */
	CREX_VM_NEXT_OPCODE_EX(1, 2);
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_VERIFY_RETURN_TYPE_SPEC_CV_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	if (IS_CV == IS_UNUSED) {
		SAVE_OPLINE();
		crex_verify_missing_return_type(EX(func));
		HANDLE_EXCEPTION();
	} else {
/* prevents "undefined variable opline" errors */
#if 0 || (IS_CV != IS_UNUSED)
		USE_OPLINE
		zval *retval_ref, *retval_ptr;
		crex_arg_info *ret_info = EX(func)->common.arg_info - 1;
		retval_ref = retval_ptr = EX_VAR(opline->op1.var);

		if (IS_CV == IS_CONST) {
			ZVAL_COPY(EX_VAR(opline->result.var), retval_ptr);
			retval_ref = retval_ptr = EX_VAR(opline->result.var);
		} else if (IS_CV == IS_VAR) {
			if (UNEXPECTED(C_TYPE_P(retval_ptr) == IS_INDIRECT)) {
				retval_ref = retval_ptr = C_INDIRECT_P(retval_ptr);
			}
			ZVAL_DEREF(retval_ptr);
		} else if (IS_CV == IS_CV) {
			ZVAL_DEREF(retval_ptr);
		}

		if (EXPECTED(CREX_TYPE_CONTAINS_CODE(ret_info->type, C_TYPE_P(retval_ptr)))) {
			CREX_VM_NEXT_OPCODE();
		}

		if (IS_CV == IS_CV && UNEXPECTED(C_ISUNDEF_P(retval_ptr))) {
			SAVE_OPLINE();
			retval_ref = retval_ptr = ZVAL_UNDEFINED_OP1();
			if (UNEXPECTED(EG(exception))) {
				HANDLE_EXCEPTION();
			}
			if (CREX_TYPE_FULL_MASK(ret_info->type) & MAY_BE_NULL) {
				CREX_VM_NEXT_OPCODE();
			}
		}

		crex_reference *ref = NULL;
		void *cache_slot = CACHE_ADDR(opline->op2.num);
		if (UNEXPECTED(retval_ref != retval_ptr)) {
			if (UNEXPECTED(EX(func)->op_array.fn_flags & CREX_ACC_RETURN_REFERENCE)) {
				ref = C_REF_P(retval_ref);
			} else {
				/* A cast might happen - unwrap the reference if this is a by-value return */
				if (C_REFCOUNT_P(retval_ref) == 1) {
					ZVAL_UNREF(retval_ref);
				} else {
					C_DELREF_P(retval_ref);
					ZVAL_COPY(retval_ref, retval_ptr);
				}
				retval_ptr = retval_ref;
			}
		}

		SAVE_OPLINE();
		if (UNEXPECTED(!crex_check_type_slow(&ret_info->type, retval_ptr, ref, cache_slot, 1, 0))) {
			crex_verify_return_error(EX(func), retval_ptr);
			HANDLE_EXCEPTION();
		}
		CREX_VM_NEXT_OPCODE();
#endif
	}
}

static CREX_VM_HOT CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_SEND_VAR_SPEC_CV_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *varptr, *arg;

	if (IS_UNUSED == IS_CONST) {
		SAVE_OPLINE();
		crex_string *arg_name = C_STR_P(RT_CONSTANT(opline, opline->op2));
		uint32_t arg_num;
		arg = crex_handle_named_arg(&EX(call), arg_name, &arg_num, CACHE_ADDR(opline->result.num));
		if (UNEXPECTED(!arg)) {

			HANDLE_EXCEPTION();
		}
	} else {
		arg = CREX_CALL_VAR(EX(call), opline->result.var);
	}

	varptr = EX_VAR(opline->op1.var);
	if (IS_CV == IS_CV && UNEXPECTED(C_TYPE_INFO_P(varptr) == IS_UNDEF)) {
		SAVE_OPLINE();
		ZVAL_UNDEFINED_OP1();
		ZVAL_NULL(arg);
		CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
	}

	if (IS_CV == IS_CV) {
		ZVAL_COPY_DEREF(arg, varptr);
	} else /* if (IS_CV == IS_VAR) */ {
		if (UNEXPECTED(C_ISREF_P(varptr))) {
			crex_refcounted *ref = C_COUNTED_P(varptr);

			varptr = C_REFVAL_P(varptr);
			ZVAL_COPY_VALUE(arg, varptr);
			if (UNEXPECTED(GC_DELREF(ref) == 0)) {
				efree_size(ref, sizeof(crex_reference));
			} else if (C_OPT_REFCOUNTED_P(arg)) {
				C_ADDREF_P(arg);
			}
		} else {
			ZVAL_COPY_VALUE(arg, varptr);
		}
	}

	CREX_VM_NEXT_OPCODE();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_SEND_REF_SPEC_CV_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *varptr, *arg;

	SAVE_OPLINE();
	if (IS_UNUSED == IS_CONST) {
		crex_string *arg_name = C_STR_P(RT_CONSTANT(opline, opline->op2));
		uint32_t arg_num;
		arg = crex_handle_named_arg(&EX(call), arg_name, &arg_num, CACHE_ADDR(opline->result.num));
		if (UNEXPECTED(!arg)) {

			HANDLE_EXCEPTION();
		}
	} else {
		arg = CREX_CALL_VAR(EX(call), opline->result.var);
	}

	varptr = _get_zval_ptr_cv_BP_VAR_W(opline->op1.var EXECUTE_DATA_CC);
	if (C_ISREF_P(varptr)) {
		C_ADDREF_P(varptr);
	} else {
		ZVAL_MAKE_REF_EX(varptr, 2);
	}
	ZVAL_REF(arg, C_REF_P(varptr));

	CREX_VM_NEXT_OPCODE();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_SEND_VAR_EX_SPEC_CV_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *varptr, *arg;
	uint32_t arg_num;

	if (IS_UNUSED == IS_CONST) {
		SAVE_OPLINE();
		crex_string *arg_name = C_STR_P(RT_CONSTANT(opline, opline->op2));
		arg = crex_handle_named_arg(&EX(call), arg_name, &arg_num, CACHE_ADDR(opline->result.num));
		if (UNEXPECTED(!arg)) {

			HANDLE_EXCEPTION();
		}
	} else {
		arg = CREX_CALL_VAR(EX(call), opline->result.var);
		arg_num = opline->op2.num;
	}

	if (EXPECTED(0)) {
		if (QUICK_ARG_SHOULD_BE_SENT_BY_REF(EX(call)->func, arg_num)) {
			goto send_var_by_ref;
		}
	} else if (ARG_SHOULD_BE_SENT_BY_REF(EX(call)->func, arg_num)) {
send_var_by_ref:
		varptr = _get_zval_ptr_cv_BP_VAR_W(opline->op1.var EXECUTE_DATA_CC);
		if (C_ISREF_P(varptr)) {
			C_ADDREF_P(varptr);
		} else {
			ZVAL_MAKE_REF_EX(varptr, 2);
		}
		ZVAL_REF(arg, C_REF_P(varptr));

		CREX_VM_NEXT_OPCODE();
	}

	varptr = EX_VAR(opline->op1.var);
	if (IS_CV == IS_CV && UNEXPECTED(C_TYPE_INFO_P(varptr) == IS_UNDEF)) {
		SAVE_OPLINE();
		ZVAL_UNDEFINED_OP1();
		ZVAL_NULL(arg);
		CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
	}

	if (IS_CV == IS_CV) {
		ZVAL_COPY_DEREF(arg, varptr);
	} else /* if (IS_CV == IS_VAR) */ {
		if (UNEXPECTED(C_ISREF_P(varptr))) {
			crex_refcounted *ref = C_COUNTED_P(varptr);

			varptr = C_REFVAL_P(varptr);
			ZVAL_COPY_VALUE(arg, varptr);
			if (UNEXPECTED(GC_DELREF(ref) == 0)) {
				efree_size(ref, sizeof(crex_reference));
			} else if (C_OPT_REFCOUNTED_P(arg)) {
				C_ADDREF_P(arg);
			}
		} else {
			ZVAL_COPY_VALUE(arg, varptr);
		}
	}

	CREX_VM_NEXT_OPCODE();
}

static CREX_VM_HOT CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_SEND_VAR_EX_SPEC_CV_UNUSED_QUICK_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *varptr, *arg;
	uint32_t arg_num;

	if (IS_UNUSED == IS_CONST) {
		SAVE_OPLINE();
		crex_string *arg_name = C_STR_P(RT_CONSTANT(opline, opline->op2));
		arg = crex_handle_named_arg(&EX(call), arg_name, &arg_num, CACHE_ADDR(opline->result.num));
		if (UNEXPECTED(!arg)) {

			HANDLE_EXCEPTION();
		}
	} else {
		arg = CREX_CALL_VAR(EX(call), opline->result.var);
		arg_num = opline->op2.num;
	}

	if (EXPECTED(1)) {
		if (QUICK_ARG_SHOULD_BE_SENT_BY_REF(EX(call)->func, arg_num)) {
			goto send_var_by_ref;
		}
	} else if (ARG_SHOULD_BE_SENT_BY_REF(EX(call)->func, arg_num)) {
send_var_by_ref:
		varptr = _get_zval_ptr_cv_BP_VAR_W(opline->op1.var EXECUTE_DATA_CC);
		if (C_ISREF_P(varptr)) {
			C_ADDREF_P(varptr);
		} else {
			ZVAL_MAKE_REF_EX(varptr, 2);
		}
		ZVAL_REF(arg, C_REF_P(varptr));

		CREX_VM_NEXT_OPCODE();
	}

	varptr = EX_VAR(opline->op1.var);
	if (IS_CV == IS_CV && UNEXPECTED(C_TYPE_INFO_P(varptr) == IS_UNDEF)) {
		SAVE_OPLINE();
		ZVAL_UNDEFINED_OP1();
		ZVAL_NULL(arg);
		CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
	}

	if (IS_CV == IS_CV) {
		ZVAL_COPY_DEREF(arg, varptr);
	} else /* if (IS_CV == IS_VAR) */ {
		if (UNEXPECTED(C_ISREF_P(varptr))) {
			crex_refcounted *ref = C_COUNTED_P(varptr);

			varptr = C_REFVAL_P(varptr);
			ZVAL_COPY_VALUE(arg, varptr);
			if (UNEXPECTED(GC_DELREF(ref) == 0)) {
				efree_size(ref, sizeof(crex_reference));
			} else if (C_OPT_REFCOUNTED_P(arg)) {
				C_ADDREF_P(arg);
			}
		} else {
			ZVAL_COPY_VALUE(arg, varptr);
		}
	}

	CREX_VM_NEXT_OPCODE();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ADD_ARRAY_ELEMENT_SPEC_CV_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *expr_ptr, new_expr;

	SAVE_OPLINE();
	if ((IS_CV == IS_VAR || IS_CV == IS_CV) &&
	    UNEXPECTED(opline->extended_value & CREX_ARRAY_ELEMENT_REF)) {
		expr_ptr = _get_zval_ptr_cv_BP_VAR_W(opline->op1.var EXECUTE_DATA_CC);
		if (C_ISREF_P(expr_ptr)) {
			C_ADDREF_P(expr_ptr);
		} else {
			ZVAL_MAKE_REF_EX(expr_ptr, 2);
		}

	} else {
		expr_ptr = _get_zval_ptr_cv_BP_VAR_R(opline->op1.var EXECUTE_DATA_CC);
		if (IS_CV == IS_TMP_VAR) {
			/* pass */
		} else if (IS_CV == IS_CONST) {
			C_TRY_ADDREF_P(expr_ptr);
		} else if (IS_CV == IS_CV) {
			ZVAL_DEREF(expr_ptr);
			C_TRY_ADDREF_P(expr_ptr);
		} else /* if (IS_CV == IS_VAR) */ {
			if (UNEXPECTED(C_ISREF_P(expr_ptr))) {
				crex_refcounted *ref = C_COUNTED_P(expr_ptr);

				expr_ptr = C_REFVAL_P(expr_ptr);
				if (UNEXPECTED(GC_DELREF(ref) == 0)) {
					ZVAL_COPY_VALUE(&new_expr, expr_ptr);
					expr_ptr = &new_expr;
					efree_size(ref, sizeof(crex_reference));
				} else if (C_OPT_REFCOUNTED_P(expr_ptr)) {
					C_ADDREF_P(expr_ptr);
				}
			}
		}
	}

	if (IS_UNUSED != IS_UNUSED) {
		zval *offset = NULL;
		crex_string *str;
		crex_ulong hval;

add_again:
		if (EXPECTED(C_TYPE_P(offset) == IS_STRING)) {
			str = C_STR_P(offset);
			if (IS_UNUSED != IS_CONST) {
				if (CREX_HANDLE_NUMERIC(str, hval)) {
					goto num_index;
				}
			}
str_index:
			crex_hash_update(C_ARRVAL_P(EX_VAR(opline->result.var)), str, expr_ptr);
		} else if (EXPECTED(C_TYPE_P(offset) == IS_LONG)) {
			hval = C_LVAL_P(offset);
num_index:
			crex_hash_index_update(C_ARRVAL_P(EX_VAR(opline->result.var)), hval, expr_ptr);
		} else if ((IS_UNUSED & (IS_VAR|IS_CV)) && EXPECTED(C_TYPE_P(offset) == IS_REFERENCE)) {
			offset = C_REFVAL_P(offset);
			goto add_again;
		} else if (C_TYPE_P(offset) == IS_NULL) {
			str = ZSTR_EMPTY_ALLOC();
			goto str_index;
		} else if (C_TYPE_P(offset) == IS_DOUBLE) {
			hval = crex_dval_to_lval_safe(C_DVAL_P(offset));
			goto num_index;
		} else if (C_TYPE_P(offset) == IS_FALSE) {
			hval = 0;
			goto num_index;
		} else if (C_TYPE_P(offset) == IS_TRUE) {
			hval = 1;
			goto num_index;
		} else if (C_TYPE_P(offset) == IS_RESOURCE) {
			crex_use_resource_as_offset(offset);
			hval = C_RES_HANDLE_P(offset);
			goto num_index;
		} else if (IS_UNUSED == IS_CV && C_TYPE_P(offset) == IS_UNDEF) {
			ZVAL_UNDEFINED_OP2();
			str = ZSTR_EMPTY_ALLOC();
			goto str_index;
		} else {
			crex_illegal_array_offset_access(offset);
			zval_ptr_dtor_nogc(expr_ptr);
		}

	} else {
		if (!crex_hash_next_index_insert(C_ARRVAL_P(EX_VAR(opline->result.var)), expr_ptr)) {
			crex_cannot_add_element();
			zval_ptr_dtor_nogc(expr_ptr);
		}
	}
	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_INIT_ARRAY_SPEC_CV_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	zval *array;
	uint32_t size;
	USE_OPLINE

	array = EX_VAR(opline->result.var);
	if (IS_CV != IS_UNUSED) {
		size = opline->extended_value >> CREX_ARRAY_SIZE_SHIFT;
		ZVAL_ARR(array, crex_new_array(size));
		/* Explicitly initialize array as not-packed if flag is set */
		if (opline->extended_value & CREX_ARRAY_NOT_PACKED) {
			crex_hash_real_init_mixed(C_ARRVAL_P(array));
		}
		CREX_VM_TAIL_CALL(CREX_ADD_ARRAY_ELEMENT_SPEC_CV_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU));
	} else {
		ZVAL_ARR(array, crex_new_array(0));
		CREX_VM_NEXT_OPCODE();
	}
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_UNSET_CV_SPEC_CV_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *var = EX_VAR(opline->op1.var);

	if (C_REFCOUNTED_P(var)) {
		crex_refcounted *garbage = C_COUNTED_P(var);

		ZVAL_UNDEF(var);
		SAVE_OPLINE();
		GC_DTOR(garbage);
		CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
	} else {
		ZVAL_UNDEF(var);
	}
	CREX_VM_NEXT_OPCODE();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_UNSET_VAR_SPEC_CV_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *varname;
	crex_string *name, *tmp_name;
	HashTable *target_symbol_table;

	SAVE_OPLINE();

	varname = EX_VAR(opline->op1.var);

	if (IS_CV == IS_CONST) {
		name = C_STR_P(varname);
	} else if (EXPECTED(C_TYPE_P(varname) == IS_STRING)) {
		name = C_STR_P(varname);
		tmp_name = NULL;
	} else {
		if (IS_CV == IS_CV && UNEXPECTED(C_TYPE_P(varname) == IS_UNDEF)) {
			varname = ZVAL_UNDEFINED_OP1();
		}
		name = zval_try_get_tmp_string(varname, &tmp_name);
		if (UNEXPECTED(!name)) {

			HANDLE_EXCEPTION();
		}
	}

	target_symbol_table = crex_get_target_symbol_table(opline->extended_value EXECUTE_DATA_CC);
	crex_hash_del_ind(target_symbol_table, name);

	if (IS_CV != IS_CONST) {
		crex_tmp_string_release(tmp_name);
	}

	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

/* No specialization for op_types (CONST|TMPVAR|CV, UNUSED|CLASS_FETCH|CONST|VAR) */
static CREX_VM_HOT CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ISSET_ISEMPTY_CV_SPEC_CV_UNUSED_SET_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *value;

	value = EX_VAR(opline->op1.var);
	if (!(0)) {
		if (C_TYPE_P(value) > IS_NULL &&
		    (!C_ISREF_P(value) || C_TYPE_P(C_REFVAL_P(value)) != IS_NULL)) {
			CREX_VM_SMART_BRANCH_TRUE();
		} else {
			CREX_VM_SMART_BRANCH_FALSE();
		}
	} else {
		bool result;

		SAVE_OPLINE();
		result = !i_crex_is_true(value);
		CREX_VM_SMART_BRANCH(result, 1);
	}
}

static CREX_VM_HOT CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ISSET_ISEMPTY_CV_SPEC_CV_UNUSED_EMPTY_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *value;

	value = EX_VAR(opline->op1.var);
	if (!(1)) {
		if (C_TYPE_P(value) > IS_NULL &&
		    (!C_ISREF_P(value) || C_TYPE_P(C_REFVAL_P(value)) != IS_NULL)) {
			CREX_VM_SMART_BRANCH_TRUE();
		} else {
			CREX_VM_SMART_BRANCH_FALSE();
		}
	} else {
		bool result;

		SAVE_OPLINE();
		result = !i_crex_is_true(value);
		CREX_VM_SMART_BRANCH(result, 1);
	}
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ISSET_ISEMPTY_VAR_SPEC_CV_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *value;
	/* Should be bool result? as below got: result = (opline->extended_value & CREX_ISEMPTY) */
	int result;
	zval *varname;
	crex_string *name, *tmp_name;
	HashTable *target_symbol_table;

	SAVE_OPLINE();
	varname = _get_zval_ptr_cv_BP_VAR_IS(opline->op1.var EXECUTE_DATA_CC);
	if (IS_CV == IS_CONST) {
		name = C_STR_P(varname);
	} else {
		name = zval_get_tmp_string(varname, &tmp_name);
	}

	target_symbol_table = crex_get_target_symbol_table(opline->extended_value EXECUTE_DATA_CC);
	value = crex_hash_find_ex(target_symbol_table, name, IS_CV == IS_CONST);

	if (IS_CV != IS_CONST) {
		crex_tmp_string_release(tmp_name);
	}

	if (!value) {
		result = (opline->extended_value & CREX_ISEMPTY);
	} else {
		if (C_TYPE_P(value) == IS_INDIRECT) {
			value = C_INDIRECT_P(value);
		}
		if (!(opline->extended_value & CREX_ISEMPTY)) {
			if (C_ISREF_P(value)) {
				value = C_REFVAL_P(value);
			}
			result = C_TYPE_P(value) > IS_NULL;
		} else {
			result = !i_crex_is_true(value);
		}
	}

	CREX_VM_SMART_BRANCH(result, 1);
}

/* No specialization for op_types (CONST|TMPVAR|CV, UNUSED|CLASS_FETCH|CONST|VAR) */
static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_INSTANCEOF_SPEC_CV_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *expr;
	bool result;

	SAVE_OPLINE();
	expr = EX_VAR(opline->op1.var);

try_instanceof:
	if (C_TYPE_P(expr) == IS_OBJECT) {
		crex_class_entry *ce;

		if (IS_UNUSED == IS_CONST) {
			ce = CACHED_PTR(opline->extended_value);
			if (UNEXPECTED(ce == NULL)) {
				ce = crex_lookup_class_ex(C_STR_P(RT_CONSTANT(opline, opline->op2)), C_STR_P(RT_CONSTANT(opline, opline->op2) + 1), CREX_FETCH_CLASS_NO_AUTOLOAD);
				if (EXPECTED(ce)) {
					CACHE_PTR(opline->extended_value, ce);
				}
			}
		} else if (IS_UNUSED == IS_UNUSED) {
			ce = crex_fetch_class(NULL, opline->op2.num);
			if (UNEXPECTED(ce == NULL)) {

				ZVAL_UNDEF(EX_VAR(opline->result.var));
				HANDLE_EXCEPTION();
			}
		} else {
			ce = C_CE_P(EX_VAR(opline->op2.var));
		}
		result = ce && instanceof_function(C_OBJCE_P(expr), ce);
	} else if ((IS_CV & (IS_VAR|IS_CV)) && C_TYPE_P(expr) == IS_REFERENCE) {
		expr = C_REFVAL_P(expr);
		goto try_instanceof;
	} else {
		if (IS_CV == IS_CV && UNEXPECTED(C_TYPE_P(expr) == IS_UNDEF)) {
			ZVAL_UNDEFINED_OP1();
		}
		result = 0;
	}

	CREX_VM_SMART_BRANCH(result, 1);
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_YIELD_SPEC_CV_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	crex_generator *generator = crex_get_running_generator(EXECUTE_DATA_C);

	SAVE_OPLINE();
	if (UNEXPECTED(generator->flags & CREX_GENERATOR_FORCED_CLOSE)) {
		CREX_VM_TAIL_CALL(crex_yield_in_closed_generator_helper_SPEC(CREX_OPCODE_HANDLER_ARGS_PASSTHRU));
	}

	/* Destroy the previously yielded value */
	zval_ptr_dtor(&generator->value);

	/* Destroy the previously yielded key */
	zval_ptr_dtor(&generator->key);

	/* Set the new yielded value */
	if (IS_CV != IS_UNUSED) {
		if (UNEXPECTED(EX(func)->op_array.fn_flags & CREX_ACC_RETURN_REFERENCE)) {
			/* Constants and temporary variables aren't yieldable by reference,
			 * but we still allow them with a notice. */
			if (IS_CV & (IS_CONST|IS_TMP_VAR)) {
				zval *value;

				crex_error(E_NOTICE, "Only variable references should be yielded by reference");

				value = _get_zval_ptr_cv_BP_VAR_R(opline->op1.var EXECUTE_DATA_CC);
				ZVAL_COPY_VALUE(&generator->value, value);
				if (IS_CV == IS_CONST) {
					if (UNEXPECTED(C_OPT_REFCOUNTED(generator->value))) {
						C_ADDREF(generator->value);
					}
				}
			} else {
				zval *value_ptr = _get_zval_ptr_cv_BP_VAR_W(opline->op1.var EXECUTE_DATA_CC);

				/* If a function call result is yielded and the function did
				 * not return by reference we throw a notice. */
				do {
					if (IS_CV == IS_VAR) {
						CREX_ASSERT(value_ptr != &EG(uninitialized_zval));
						if (opline->extended_value == CREX_RETURNS_FUNCTION
						 && !C_ISREF_P(value_ptr)) {
							crex_error(E_NOTICE, "Only variable references should be yielded by reference");
							ZVAL_COPY(&generator->value, value_ptr);
							break;
						}
					}
					if (C_ISREF_P(value_ptr)) {
						C_ADDREF_P(value_ptr);
					} else {
						ZVAL_MAKE_REF_EX(value_ptr, 2);
					}
					ZVAL_REF(&generator->value, C_REF_P(value_ptr));
				} while (0);

			}
		} else {
			zval *value = _get_zval_ptr_cv_BP_VAR_R(opline->op1.var EXECUTE_DATA_CC);

			/* Consts, temporary variables and references need copying */
			if (IS_CV == IS_CONST) {
				ZVAL_COPY_VALUE(&generator->value, value);
				if (UNEXPECTED(C_OPT_REFCOUNTED(generator->value))) {
					C_ADDREF(generator->value);
				}
			} else if (IS_CV == IS_TMP_VAR) {
				ZVAL_COPY_VALUE(&generator->value, value);
			} else if ((IS_CV & (IS_VAR|IS_CV)) && C_ISREF_P(value)) {
				ZVAL_COPY(&generator->value, C_REFVAL_P(value));

			} else {
				ZVAL_COPY_VALUE(&generator->value, value);
				if (IS_CV == IS_CV) {
					if (C_OPT_REFCOUNTED_P(value)) C_ADDREF_P(value);
				}
			}
		}
	} else {
		/* If no value was specified yield null */
		ZVAL_NULL(&generator->value);
	}

	/* Set the new yielded key */
	if (IS_UNUSED != IS_UNUSED) {
		zval *key = NULL;
		if ((IS_UNUSED & (IS_CV|IS_VAR)) && UNEXPECTED(C_TYPE_P(key) == IS_REFERENCE)) {
			key = C_REFVAL_P(key);
		}
		ZVAL_COPY(&generator->key, key);

		if (C_TYPE(generator->key) == IS_LONG
		    && C_LVAL(generator->key) > generator->largest_used_integer_key
		) {
			generator->largest_used_integer_key = C_LVAL(generator->key);
		}
	} else {
		/* If no key was specified we use auto-increment keys */
		generator->largest_used_integer_key++;
		ZVAL_LONG(&generator->key, generator->largest_used_integer_key);
	}

	if (RETURN_VALUE_USED(opline)) {
		/* If the return value of yield is used set the send
		 * target and initialize it to NULL */
		generator->send_target = EX_VAR(opline->result.var);
		ZVAL_NULL(generator->send_target);
	} else {
		generator->send_target = NULL;
	}

	/* We increment to the next op, so we are at the correct position when the
	 * generator is resumed. */
	CREX_VM_INC_OPCODE();

	/* The GOTO VM uses a local opline variable. We need to set the opline
	 * variable in execute_data so we don't resume at an old position. */
	SAVE_OPLINE();

	CREX_VM_RETURN();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_CHECK_VAR_SPEC_CV_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1 = EX_VAR(opline->op1.var);

	if (UNEXPECTED(C_TYPE_INFO_P(op1) == IS_UNDEF)) {
		SAVE_OPLINE();
		ZVAL_UNDEFINED_OP1();
		CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
	}
	CREX_VM_NEXT_OPCODE();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_MAKE_REF_SPEC_CV_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1 = EX_VAR(opline->op1.var);

	if (IS_CV == IS_CV) {
		if (UNEXPECTED(C_TYPE_P(op1) == IS_UNDEF)) {
			ZVAL_NEW_EMPTY_REF(op1);
			C_SET_REFCOUNT_P(op1, 2);
			ZVAL_NULL(C_REFVAL_P(op1));
			ZVAL_REF(EX_VAR(opline->result.var), C_REF_P(op1));
		} else {
			if (C_ISREF_P(op1)) {
				C_ADDREF_P(op1);
			} else {
				ZVAL_MAKE_REF_EX(op1, 2);
			}
			ZVAL_REF(EX_VAR(opline->result.var), C_REF_P(op1));
		}
	} else if (EXPECTED(C_TYPE_P(op1) == IS_INDIRECT)) {
		op1 = C_INDIRECT_P(op1);
		if (EXPECTED(!C_ISREF_P(op1))) {
			ZVAL_MAKE_REF_EX(op1, 2);
		} else {
			GC_ADDREF(C_REF_P(op1));
		}
		ZVAL_REF(EX_VAR(opline->result.var), C_REF_P(op1));
	} else {
		ZVAL_COPY_VALUE(EX_VAR(opline->result.var), op1);
	}
	CREX_VM_NEXT_OPCODE();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_COUNT_SPEC_CV_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1;
	crex_long count;

	SAVE_OPLINE();
	op1 = EX_VAR(opline->op1.var);

	while (1) {
		if (C_TYPE_P(op1) == IS_ARRAY) {
			count = crex_hash_num_elements(C_ARRVAL_P(op1));
			break;
		} else if (C_TYPE_P(op1) == IS_OBJECT) {
			crex_object *zobj = C_OBJ_P(op1);

			/* first, we check if the handler is defined */
			if (zobj->handlers->count_elements) {
				if (SUCCESS == zobj->handlers->count_elements(zobj, &count)) {
					break;
				}
				if (UNEXPECTED(EG(exception))) {
					count = 0;
					break;
				}
			}

			/* if not and the object implements Countable we call its count() method */
			if (crex_class_implements_interface(zobj->ce, crex_ce_countable)) {
				zval retval;

				crex_function *count_fn = crex_hash_find_ptr(&zobj->ce->function_table, ZSTR_KNOWN(CREX_STR_COUNT));
				crex_call_known_instance_method_with_0_params(count_fn, zobj, &retval);
				count = zval_get_long(&retval);
				zval_ptr_dtor(&retval);
				break;
			}

			/* If There's no handler and it doesn't implement Countable then emit a TypeError */
		} else if ((IS_CV & (IS_VAR|IS_CV)) != 0 && C_TYPE_P(op1) == IS_REFERENCE) {
			op1 = C_REFVAL_P(op1);
			continue;
		} else if (IS_CV == IS_CV && UNEXPECTED(C_TYPE_P(op1) == IS_UNDEF)) {
			ZVAL_UNDEFINED_OP1();
		}
		count = 0;
		crex_type_error("%s(): Argument #1 ($value) must be of type Countable|array, %s given", opline->extended_value ? "sizeof" : "count", crex_zval_value_name(op1));
		break;
	}

	ZVAL_LONG(EX_VAR(opline->result.var), count);

	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_COUNT_ARRAY_SPEC_CV_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	crex_array *ht = C_ARRVAL_P(EX_VAR(opline->op1.var));
	ZVAL_LONG(EX_VAR(opline->result.var), crex_hash_num_elements(ht));
	if (IS_CV & (IS_TMP_VAR|IS_VAR) && !(GC_FLAGS(ht) & IS_ARRAY_IMMUTABLE) && !GC_DELREF(ht)) {
		SAVE_OPLINE();
		crex_array_destroy(ht);
		if (EG(exception)) {
			HANDLE_EXCEPTION();
		}
	}
	CREX_VM_NEXT_OPCODE();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_GET_CLASS_SPEC_CV_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (IS_CV == IS_UNUSED) {
		SAVE_OPLINE();
		if (UNEXPECTED(!EX(func)->common.scope)) {
			crex_throw_error(NULL, "get_class() without arguments must be called from within a class");
			ZVAL_UNDEF(EX_VAR(opline->result.var));
			HANDLE_EXCEPTION();
		} else {
			crex_error(E_DEPRECATED, "Calling get_class() without arguments is deprecated");
			ZVAL_STR_COPY(EX_VAR(opline->result.var), EX(func)->common.scope->name);
			if (UNEXPECTED(EG(exception))) {
				HANDLE_EXCEPTION();
			}
			CREX_VM_NEXT_OPCODE();
		}
	} else {
		zval *op1;

		SAVE_OPLINE();
		op1 = EX_VAR(opline->op1.var);
		while (1) {
			if (C_TYPE_P(op1) == IS_OBJECT) {
				ZVAL_STR_COPY(EX_VAR(opline->result.var), C_OBJCE_P(op1)->name);
			} else if ((IS_CV & (IS_VAR|IS_CV)) != 0 && C_TYPE_P(op1) == IS_REFERENCE) {
				op1 = C_REFVAL_P(op1);
				continue;
			} else {
				if (IS_CV == IS_CV && UNEXPECTED(C_TYPE_P(op1) == IS_UNDEF)) {
					ZVAL_UNDEFINED_OP1();
				}
				crex_type_error("get_class(): Argument #1 ($object) must be of type object, %s given", crex_zval_value_name(op1));
				ZVAL_UNDEF(EX_VAR(opline->result.var));
			}
			break;
		}

		CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
	}
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_GET_TYPE_SPEC_CV_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1;
	crex_string *type;

	SAVE_OPLINE();
	op1 = _get_zval_ptr_cv_deref_BP_VAR_R(opline->op1.var EXECUTE_DATA_CC);
	type = crex_zval_get_legacy_type(op1);
	if (EXPECTED(type)) {
		ZVAL_INTERNED_STR(EX_VAR(opline->result.var), type);
	} else {
		ZVAL_STRING(EX_VAR(opline->result.var), "unknown type");
	}

	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_VM_HOT CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_SEND_VAR_EX_SIMPLE_SPEC_CV_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *varptr, *arg;
	uint32_t arg_num = opline->op2.num;

	if (QUICK_ARG_SHOULD_BE_SENT_BY_REF(EX(call)->func, arg_num)) {
		CREX_VM_TAIL_CALL(CREX_SEND_REF_SPEC_CV_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU));
	}

	varptr = EX_VAR(opline->op1.var);
	arg = CREX_CALL_VAR(EX(call), opline->result.var);

	if (IS_CV == IS_CV) {
		ZVAL_COPY(arg, varptr);
	} else /* if (IS_CV == IS_VAR) */ {
		ZVAL_COPY_VALUE(arg, varptr);
	}

	CREX_VM_NEXT_OPCODE();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_DIV_SPEC_CV_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;

	SAVE_OPLINE();
	op1 = _get_zval_ptr_cv_BP_VAR_R(opline->op1.var EXECUTE_DATA_CC);
	op2 = _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC);
	div_function(EX_VAR(opline->result.var), op1, op2);


	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_POW_SPEC_CV_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;

	SAVE_OPLINE();
	op1 = _get_zval_ptr_cv_BP_VAR_R(opline->op1.var EXECUTE_DATA_CC);
	op2 = _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC);
	pow_function(EX_VAR(opline->result.var), op1, op2);


	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_CONCAT_SPEC_CV_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;

	op1 = EX_VAR(opline->op1.var);
	op2 = EX_VAR(opline->op2.var);

	if ((IS_CV == IS_CONST || EXPECTED(C_TYPE_P(op1) == IS_STRING)) &&
	    (IS_CV == IS_CONST || EXPECTED(C_TYPE_P(op2) == IS_STRING))) {
		crex_string *op1_str = C_STR_P(op1);
		crex_string *op2_str = C_STR_P(op2);
		crex_string *str;
		uint32_t flags = ZSTR_GET_COPYABLE_CONCAT_PROPERTIES_BOTH(op1_str, op2_str);

		if (IS_CV != IS_CONST && UNEXPECTED(ZSTR_LEN(op1_str) == 0)) {
			if (IS_CV == IS_CONST || IS_CV == IS_CV) {
				ZVAL_STR_COPY(EX_VAR(opline->result.var), op2_str);
			} else {
				ZVAL_STR(EX_VAR(opline->result.var), op2_str);
			}
			if (IS_CV & (IS_TMP_VAR|IS_VAR)) {
				crex_string_release_ex(op1_str, 0);
			}
		} else if (IS_CV != IS_CONST && UNEXPECTED(ZSTR_LEN(op2_str) == 0)) {
			if (IS_CV == IS_CONST || IS_CV == IS_CV) {
				ZVAL_STR_COPY(EX_VAR(opline->result.var), op1_str);
			} else {
				ZVAL_STR(EX_VAR(opline->result.var), op1_str);
			}
			if (IS_CV & (IS_TMP_VAR|IS_VAR)) {
				crex_string_release_ex(op2_str, 0);
			}
		} else if (IS_CV != IS_CONST && IS_CV != IS_CV &&
		    !ZSTR_IS_INTERNED(op1_str) && GC_REFCOUNT(op1_str) == 1) {
			size_t len = ZSTR_LEN(op1_str);

			if (UNEXPECTED(len > ZSTR_MAX_LEN - ZSTR_LEN(op2_str))) {
				crex_error_noreturn(E_ERROR, "Integer overflow in memory allocation");
			}
			str = crex_string_extend(op1_str, len + ZSTR_LEN(op2_str), 0);
			memcpy(ZSTR_VAL(str) + len, ZSTR_VAL(op2_str), ZSTR_LEN(op2_str)+1);
			GC_ADD_FLAGS(str, flags);
			ZVAL_NEW_STR(EX_VAR(opline->result.var), str);
			if (IS_CV & (IS_TMP_VAR|IS_VAR)) {
				crex_string_release_ex(op2_str, 0);
			}
		} else {
			str = crex_string_alloc(ZSTR_LEN(op1_str) + ZSTR_LEN(op2_str), 0);
			memcpy(ZSTR_VAL(str), ZSTR_VAL(op1_str), ZSTR_LEN(op1_str));
			memcpy(ZSTR_VAL(str) + ZSTR_LEN(op1_str), ZSTR_VAL(op2_str), ZSTR_LEN(op2_str)+1);
			GC_ADD_FLAGS(str, flags);
			ZVAL_NEW_STR(EX_VAR(opline->result.var), str);
			if (IS_CV & (IS_TMP_VAR|IS_VAR)) {
				crex_string_release_ex(op1_str, 0);
			}
			if (IS_CV & (IS_TMP_VAR|IS_VAR)) {
				crex_string_release_ex(op2_str, 0);
			}
		}
		CREX_VM_NEXT_OPCODE();
	} else {
		SAVE_OPLINE();

		if (IS_CV == IS_CV && UNEXPECTED(C_TYPE_P(op1) == IS_UNDEF)) {
			op1 = ZVAL_UNDEFINED_OP1();
		}
		if (IS_CV == IS_CV && UNEXPECTED(C_TYPE_P(op2) == IS_UNDEF)) {
			op2 = ZVAL_UNDEFINED_OP2();
		}
		concat_function(EX_VAR(opline->result.var), op1, op2);


		CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
	}
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_IS_IDENTICAL_SPEC_CV_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	bool result;

	SAVE_OPLINE();
	op1 = _get_zval_ptr_cv_deref_BP_VAR_R(opline->op1.var EXECUTE_DATA_CC);
	op2 = _get_zval_ptr_cv_deref_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC);
	result = fast_is_identical_function(op1, op2);


	CREX_VM_SMART_BRANCH(result, 1);
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_IS_NOT_IDENTICAL_SPEC_CV_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	bool result;

	SAVE_OPLINE();
	op1 = _get_zval_ptr_cv_deref_BP_VAR_R(opline->op1.var EXECUTE_DATA_CC);
	op2 = _get_zval_ptr_cv_deref_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC);
	result = fast_is_not_identical_function(op1, op2);


	CREX_VM_SMART_BRANCH(result, 1);
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_IS_EQUAL_SPEC_CV_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	double d1, d2;

	op1 = EX_VAR(opline->op1.var);
	op2 = EX_VAR(opline->op2.var);
	if (1 && IS_CV == IS_CONST && IS_CV == IS_CONST) {
		/* pass */
	} else if (EXPECTED(C_TYPE_P(op1) == IS_LONG)) {
		if (EXPECTED(C_TYPE_P(op2) == IS_LONG)) {
			if (EXPECTED(C_LVAL_P(op1) == C_LVAL_P(op2))) {
is_equal_true:
				CREX_VM_SMART_BRANCH_TRUE_NONE();
			} else {
is_equal_false:
				CREX_VM_SMART_BRANCH_FALSE_NONE();
			}
		} else if (EXPECTED(C_TYPE_P(op2) == IS_DOUBLE)) {
			d1 = (double)C_LVAL_P(op1);
			d2 = C_DVAL_P(op2);
			goto is_equal_double;
		}
	} else if (EXPECTED(C_TYPE_P(op1) == IS_DOUBLE)) {
		if (EXPECTED(C_TYPE_P(op2) == IS_DOUBLE)) {
			d1 = C_DVAL_P(op1);
			d2 = C_DVAL_P(op2);
is_equal_double:
			if (d1 == d2) {
				goto is_equal_true;
			} else {
				goto is_equal_false;
			}
		} else if (EXPECTED(C_TYPE_P(op2) == IS_LONG)) {
			d1 = C_DVAL_P(op1);
			d2 = (double)C_LVAL_P(op2);
			goto is_equal_double;
		}
	} else if (EXPECTED(C_TYPE_P(op1) == IS_STRING)) {
		if (EXPECTED(C_TYPE_P(op2) == IS_STRING)) {
			bool result = crex_fast_equal_strings(C_STR_P(op1), C_STR_P(op2));
			if (IS_CV & (IS_TMP_VAR|IS_VAR)) {
				zval_ptr_dtor_str(op1);
			}
			if (IS_CV & (IS_TMP_VAR|IS_VAR)) {
				zval_ptr_dtor_str(op2);
			}
			if (result) {
				goto is_equal_true;
			} else {
				goto is_equal_false;
			}
		}
	}
	CREX_VM_TAIL_CALL(crex_is_equal_helper_SPEC(op1, op2 CREX_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_IS_EQUAL_SPEC_CV_CV_JMPC_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	double d1, d2;

	op1 = EX_VAR(opline->op1.var);
	op2 = EX_VAR(opline->op2.var);
	if (1 && IS_CV == IS_CONST && IS_CV == IS_CONST) {
		/* pass */
	} else if (EXPECTED(C_TYPE_P(op1) == IS_LONG)) {
		if (EXPECTED(C_TYPE_P(op2) == IS_LONG)) {
			if (EXPECTED(C_LVAL_P(op1) == C_LVAL_P(op2))) {
is_equal_true:
				CREX_VM_SMART_BRANCH_TRUE_JMPZ();
			} else {
is_equal_false:
				CREX_VM_SMART_BRANCH_FALSE_JMPZ();
			}
		} else if (EXPECTED(C_TYPE_P(op2) == IS_DOUBLE)) {
			d1 = (double)C_LVAL_P(op1);
			d2 = C_DVAL_P(op2);
			goto is_equal_double;
		}
	} else if (EXPECTED(C_TYPE_P(op1) == IS_DOUBLE)) {
		if (EXPECTED(C_TYPE_P(op2) == IS_DOUBLE)) {
			d1 = C_DVAL_P(op1);
			d2 = C_DVAL_P(op2);
is_equal_double:
			if (d1 == d2) {
				goto is_equal_true;
			} else {
				goto is_equal_false;
			}
		} else if (EXPECTED(C_TYPE_P(op2) == IS_LONG)) {
			d1 = C_DVAL_P(op1);
			d2 = (double)C_LVAL_P(op2);
			goto is_equal_double;
		}
	} else if (EXPECTED(C_TYPE_P(op1) == IS_STRING)) {
		if (EXPECTED(C_TYPE_P(op2) == IS_STRING)) {
			bool result = crex_fast_equal_strings(C_STR_P(op1), C_STR_P(op2));
			if (IS_CV & (IS_TMP_VAR|IS_VAR)) {
				zval_ptr_dtor_str(op1);
			}
			if (IS_CV & (IS_TMP_VAR|IS_VAR)) {
				zval_ptr_dtor_str(op2);
			}
			if (result) {
				goto is_equal_true;
			} else {
				goto is_equal_false;
			}
		}
	}
	CREX_VM_TAIL_CALL(crex_is_equal_helper_SPEC(op1, op2 CREX_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_IS_EQUAL_SPEC_CV_CV_JMPNC_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	double d1, d2;

	op1 = EX_VAR(opline->op1.var);
	op2 = EX_VAR(opline->op2.var);
	if (1 && IS_CV == IS_CONST && IS_CV == IS_CONST) {
		/* pass */
	} else if (EXPECTED(C_TYPE_P(op1) == IS_LONG)) {
		if (EXPECTED(C_TYPE_P(op2) == IS_LONG)) {
			if (EXPECTED(C_LVAL_P(op1) == C_LVAL_P(op2))) {
is_equal_true:
				CREX_VM_SMART_BRANCH_TRUE_JMPNZ();
			} else {
is_equal_false:
				CREX_VM_SMART_BRANCH_FALSE_JMPNZ();
			}
		} else if (EXPECTED(C_TYPE_P(op2) == IS_DOUBLE)) {
			d1 = (double)C_LVAL_P(op1);
			d2 = C_DVAL_P(op2);
			goto is_equal_double;
		}
	} else if (EXPECTED(C_TYPE_P(op1) == IS_DOUBLE)) {
		if (EXPECTED(C_TYPE_P(op2) == IS_DOUBLE)) {
			d1 = C_DVAL_P(op1);
			d2 = C_DVAL_P(op2);
is_equal_double:
			if (d1 == d2) {
				goto is_equal_true;
			} else {
				goto is_equal_false;
			}
		} else if (EXPECTED(C_TYPE_P(op2) == IS_LONG)) {
			d1 = C_DVAL_P(op1);
			d2 = (double)C_LVAL_P(op2);
			goto is_equal_double;
		}
	} else if (EXPECTED(C_TYPE_P(op1) == IS_STRING)) {
		if (EXPECTED(C_TYPE_P(op2) == IS_STRING)) {
			bool result = crex_fast_equal_strings(C_STR_P(op1), C_STR_P(op2));
			if (IS_CV & (IS_TMP_VAR|IS_VAR)) {
				zval_ptr_dtor_str(op1);
			}
			if (IS_CV & (IS_TMP_VAR|IS_VAR)) {
				zval_ptr_dtor_str(op2);
			}
			if (result) {
				goto is_equal_true;
			} else {
				goto is_equal_false;
			}
		}
	}
	CREX_VM_TAIL_CALL(crex_is_equal_helper_SPEC(op1, op2 CREX_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_IS_NOT_EQUAL_SPEC_CV_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	double d1, d2;

	op1 = EX_VAR(opline->op1.var);
	op2 = EX_VAR(opline->op2.var);
	if (1 && IS_CV == IS_CONST && IS_CV == IS_CONST) {
		/* pass */
	} else if (EXPECTED(C_TYPE_P(op1) == IS_LONG)) {
		if (EXPECTED(C_TYPE_P(op2) == IS_LONG)) {
			if (EXPECTED(C_LVAL_P(op1) != C_LVAL_P(op2))) {
is_not_equal_true:
				CREX_VM_SMART_BRANCH_TRUE_NONE();
			} else {
is_not_equal_false:
				CREX_VM_SMART_BRANCH_FALSE_NONE();
			}
		} else if (EXPECTED(C_TYPE_P(op2) == IS_DOUBLE)) {
			d1 = (double)C_LVAL_P(op1);
			d2 = C_DVAL_P(op2);
			goto is_not_equal_double;
		}
	} else if (EXPECTED(C_TYPE_P(op1) == IS_DOUBLE)) {
		if (EXPECTED(C_TYPE_P(op2) == IS_DOUBLE)) {
			d1 = C_DVAL_P(op1);
			d2 = C_DVAL_P(op2);
is_not_equal_double:
			if (d1 != d2) {
				goto is_not_equal_true;
			} else {
				goto is_not_equal_false;
			}
		} else if (EXPECTED(C_TYPE_P(op2) == IS_LONG)) {
			d1 = C_DVAL_P(op1);
			d2 = (double)C_LVAL_P(op2);
			goto is_not_equal_double;
		}
	} else if (EXPECTED(C_TYPE_P(op1) == IS_STRING)) {
		if (EXPECTED(C_TYPE_P(op2) == IS_STRING)) {
			bool result = crex_fast_equal_strings(C_STR_P(op1), C_STR_P(op2));
			if (IS_CV & (IS_TMP_VAR|IS_VAR)) {
				zval_ptr_dtor_str(op1);
			}
			if (IS_CV & (IS_TMP_VAR|IS_VAR)) {
				zval_ptr_dtor_str(op2);
			}
			if (!result) {
				goto is_not_equal_true;
			} else {
				goto is_not_equal_false;
			}
		}
	}
	CREX_VM_TAIL_CALL(crex_is_not_equal_helper_SPEC(op1, op2 CREX_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_IS_NOT_EQUAL_SPEC_CV_CV_JMPC_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	double d1, d2;

	op1 = EX_VAR(opline->op1.var);
	op2 = EX_VAR(opline->op2.var);
	if (1 && IS_CV == IS_CONST && IS_CV == IS_CONST) {
		/* pass */
	} else if (EXPECTED(C_TYPE_P(op1) == IS_LONG)) {
		if (EXPECTED(C_TYPE_P(op2) == IS_LONG)) {
			if (EXPECTED(C_LVAL_P(op1) != C_LVAL_P(op2))) {
is_not_equal_true:
				CREX_VM_SMART_BRANCH_TRUE_JMPZ();
			} else {
is_not_equal_false:
				CREX_VM_SMART_BRANCH_FALSE_JMPZ();
			}
		} else if (EXPECTED(C_TYPE_P(op2) == IS_DOUBLE)) {
			d1 = (double)C_LVAL_P(op1);
			d2 = C_DVAL_P(op2);
			goto is_not_equal_double;
		}
	} else if (EXPECTED(C_TYPE_P(op1) == IS_DOUBLE)) {
		if (EXPECTED(C_TYPE_P(op2) == IS_DOUBLE)) {
			d1 = C_DVAL_P(op1);
			d2 = C_DVAL_P(op2);
is_not_equal_double:
			if (d1 != d2) {
				goto is_not_equal_true;
			} else {
				goto is_not_equal_false;
			}
		} else if (EXPECTED(C_TYPE_P(op2) == IS_LONG)) {
			d1 = C_DVAL_P(op1);
			d2 = (double)C_LVAL_P(op2);
			goto is_not_equal_double;
		}
	} else if (EXPECTED(C_TYPE_P(op1) == IS_STRING)) {
		if (EXPECTED(C_TYPE_P(op2) == IS_STRING)) {
			bool result = crex_fast_equal_strings(C_STR_P(op1), C_STR_P(op2));
			if (IS_CV & (IS_TMP_VAR|IS_VAR)) {
				zval_ptr_dtor_str(op1);
			}
			if (IS_CV & (IS_TMP_VAR|IS_VAR)) {
				zval_ptr_dtor_str(op2);
			}
			if (!result) {
				goto is_not_equal_true;
			} else {
				goto is_not_equal_false;
			}
		}
	}
	CREX_VM_TAIL_CALL(crex_is_not_equal_helper_SPEC(op1, op2 CREX_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_IS_NOT_EQUAL_SPEC_CV_CV_JMPNC_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	double d1, d2;

	op1 = EX_VAR(opline->op1.var);
	op2 = EX_VAR(opline->op2.var);
	if (1 && IS_CV == IS_CONST && IS_CV == IS_CONST) {
		/* pass */
	} else if (EXPECTED(C_TYPE_P(op1) == IS_LONG)) {
		if (EXPECTED(C_TYPE_P(op2) == IS_LONG)) {
			if (EXPECTED(C_LVAL_P(op1) != C_LVAL_P(op2))) {
is_not_equal_true:
				CREX_VM_SMART_BRANCH_TRUE_JMPNZ();
			} else {
is_not_equal_false:
				CREX_VM_SMART_BRANCH_FALSE_JMPNZ();
			}
		} else if (EXPECTED(C_TYPE_P(op2) == IS_DOUBLE)) {
			d1 = (double)C_LVAL_P(op1);
			d2 = C_DVAL_P(op2);
			goto is_not_equal_double;
		}
	} else if (EXPECTED(C_TYPE_P(op1) == IS_DOUBLE)) {
		if (EXPECTED(C_TYPE_P(op2) == IS_DOUBLE)) {
			d1 = C_DVAL_P(op1);
			d2 = C_DVAL_P(op2);
is_not_equal_double:
			if (d1 != d2) {
				goto is_not_equal_true;
			} else {
				goto is_not_equal_false;
			}
		} else if (EXPECTED(C_TYPE_P(op2) == IS_LONG)) {
			d1 = C_DVAL_P(op1);
			d2 = (double)C_LVAL_P(op2);
			goto is_not_equal_double;
		}
	} else if (EXPECTED(C_TYPE_P(op1) == IS_STRING)) {
		if (EXPECTED(C_TYPE_P(op2) == IS_STRING)) {
			bool result = crex_fast_equal_strings(C_STR_P(op1), C_STR_P(op2));
			if (IS_CV & (IS_TMP_VAR|IS_VAR)) {
				zval_ptr_dtor_str(op1);
			}
			if (IS_CV & (IS_TMP_VAR|IS_VAR)) {
				zval_ptr_dtor_str(op2);
			}
			if (!result) {
				goto is_not_equal_true;
			} else {
				goto is_not_equal_false;
			}
		}
	}
	CREX_VM_TAIL_CALL(crex_is_not_equal_helper_SPEC(op1, op2 CREX_OPCODE_HANDLER_ARGS_PASSTHRU_CC));
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_SPACESHIP_SPEC_CV_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;

	SAVE_OPLINE();
	op1 = _get_zval_ptr_cv_BP_VAR_R(opline->op1.var EXECUTE_DATA_CC);
	op2 = _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC);
	compare_function(EX_VAR(opline->result.var), op1, op2);


	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_BOOL_XOR_SPEC_CV_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;

	SAVE_OPLINE();
	op1 = _get_zval_ptr_cv_BP_VAR_R(opline->op1.var EXECUTE_DATA_CC);
	op2 = _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC);
	boolean_xor_function(EX_VAR(opline->result.var), op1, op2);


	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ASSIGN_OBJ_OP_SPEC_CV_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *object;
	zval *property;
	zval *value;
	zval *zptr;
	void **cache_slot;
	crex_property_info *prop_info;
	crex_object *zobj;
	crex_string *name, *tmp_name;

	SAVE_OPLINE();
	object = EX_VAR(opline->op1.var);
	property = _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC);

	do {
		value = get_op_data_zval_ptr_r((opline+1)->op1_type, (opline+1)->op1);

		if (IS_CV != IS_UNUSED && UNEXPECTED(C_TYPE_P(object) != IS_OBJECT)) {
			if (C_ISREF_P(object) && C_TYPE_P(C_REFVAL_P(object)) == IS_OBJECT) {
				object = C_REFVAL_P(object);
				goto assign_op_object;
			}
			if (IS_CV == IS_CV
			 && UNEXPECTED(C_TYPE_P(object) == IS_UNDEF)) {
				ZVAL_UNDEFINED_OP1();
			}
			crex_throw_non_object_error(object, property OPLINE_CC EXECUTE_DATA_CC);
			break;
		}

assign_op_object:
		/* here we are sure we are dealing with an object */
		zobj = C_OBJ_P(object);
		if (IS_CV == IS_CONST) {
			name = C_STR_P(property);
		} else {
			name = zval_try_get_tmp_string(property, &tmp_name);
			if (UNEXPECTED(!name)) {
				UNDEF_RESULT();
				break;
			}
		}
		cache_slot = (IS_CV == IS_CONST) ? CACHE_ADDR((opline+1)->extended_value) : NULL;
		if (EXPECTED((zptr = zobj->handlers->get_property_ptr_ptr(zobj, name, BP_VAR_RW, cache_slot)) != NULL)) {
			if (UNEXPECTED(C_ISERROR_P(zptr))) {
				if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
					ZVAL_NULL(EX_VAR(opline->result.var));
				}
			} else {
				zval *orig_zptr = zptr;
				crex_reference *ref;

				do {
					if (UNEXPECTED(C_ISREF_P(zptr))) {
						ref = C_REF_P(zptr);
						zptr = C_REFVAL_P(zptr);
						if (UNEXPECTED(CREX_REF_HAS_TYPE_SOURCES(ref))) {
							crex_binary_assign_op_typed_ref(ref, value OPLINE_CC EXECUTE_DATA_CC);
							break;
						}
					}

					if (IS_CV == IS_CONST) {
						prop_info = (crex_property_info*)CACHED_PTR_EX(cache_slot + 2);
					} else {
						prop_info = crex_object_fetch_property_type_info(C_OBJ_P(object), orig_zptr);
					}
					if (UNEXPECTED(prop_info)) {
						/* special case for typed properties */
						crex_binary_assign_op_typed_prop(prop_info, zptr, value OPLINE_CC EXECUTE_DATA_CC);
					} else {
						crex_binary_op(zptr, zptr, value OPLINE_CC);
					}
				} while (0);

				if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
					ZVAL_COPY(EX_VAR(opline->result.var), zptr);
				}
			}
		} else {
			crex_assign_op_overloaded_property(zobj, name, cache_slot, value OPLINE_CC EXECUTE_DATA_CC);
		}
		if (IS_CV != IS_CONST) {
			crex_tmp_string_release(tmp_name);
		}
	} while (0);

	FREE_OP((opline+1)->op1_type, (opline+1)->op1.var);


	/* assign_obj has two opcodes! */
	CREX_VM_NEXT_OPCODE_EX(1, 2);
}

/* No specialization for op_types (CONST|TMP|VAR|CV, UNUSED|CONST|TMPVAR) */
static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ASSIGN_DIM_OP_SPEC_CV_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *var_ptr;
	zval *value, *container, *dim;
	HashTable *ht;

	SAVE_OPLINE();
	container = EX_VAR(opline->op1.var);

	if (EXPECTED(C_TYPE_P(container) == IS_ARRAY)) {
assign_dim_op_array:
		SEPARATE_ARRAY(container);
		ht = C_ARRVAL_P(container);
assign_dim_op_new_array:
		dim = EX_VAR(opline->op2.var);
		if (IS_CV == IS_UNUSED) {
			var_ptr = crex_hash_next_index_insert(ht, &EG(uninitialized_zval));
			if (UNEXPECTED(!var_ptr)) {
				crex_cannot_add_element();
				goto assign_dim_op_ret_null;
			}
		} else {
			if (IS_CV == IS_CONST) {
				var_ptr = crex_fetch_dimension_address_inner_RW_CONST(ht, dim EXECUTE_DATA_CC);
			} else {
				var_ptr = crex_fetch_dimension_address_inner_RW(ht, dim EXECUTE_DATA_CC);
			}
			if (UNEXPECTED(!var_ptr)) {
				goto assign_dim_op_ret_null;
			}
		}

		value = get_op_data_zval_ptr_r((opline+1)->op1_type, (opline+1)->op1);

		do {
			if (IS_CV != IS_UNUSED && UNEXPECTED(C_ISREF_P(var_ptr))) {
				crex_reference *ref = C_REF_P(var_ptr);
				var_ptr = C_REFVAL_P(var_ptr);
				if (UNEXPECTED(CREX_REF_HAS_TYPE_SOURCES(ref))) {
					crex_binary_assign_op_typed_ref(ref, value OPLINE_CC EXECUTE_DATA_CC);
					break;
				}
			}
			crex_binary_op(var_ptr, var_ptr, value OPLINE_CC);
		} while (0);

		if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
			ZVAL_COPY(EX_VAR(opline->result.var), var_ptr);
		}
		FREE_OP((opline+1)->op1_type, (opline+1)->op1.var);
	} else {
		if (EXPECTED(C_ISREF_P(container))) {
			container = C_REFVAL_P(container);
			if (EXPECTED(C_TYPE_P(container) == IS_ARRAY)) {
				goto assign_dim_op_array;
			}
		}

		if (EXPECTED(C_TYPE_P(container) == IS_OBJECT)) {
			crex_object *obj = C_OBJ_P(container);

			dim = EX_VAR(opline->op2.var);
			if (IS_CV == IS_CONST && C_EXTRA_P(dim) == CREX_EXTRA_VALUE) {
				dim++;
			}
			crex_binary_assign_op_obj_dim(obj, dim OPLINE_CC EXECUTE_DATA_CC);
		} else if (EXPECTED(C_TYPE_P(container) <= IS_FALSE)) {
			uint8_t old_type;

			if (IS_CV == IS_CV && UNEXPECTED(C_TYPE_INFO_P(container) == IS_UNDEF)) {
				ZVAL_UNDEFINED_OP1();
			}
			ht = crex_new_array(8);
			old_type = C_TYPE_P(container);
			ZVAL_ARR(container, ht);
			if (UNEXPECTED(old_type == IS_FALSE)) {
				GC_ADDREF(ht);
				crex_false_to_array_deprecated();
				if (UNEXPECTED(GC_DELREF(ht) == 0)) {
					crex_array_destroy(ht);
					goto assign_dim_op_ret_null;
				}
			}
			goto assign_dim_op_new_array;
		} else {
			dim = _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC);
			crex_binary_assign_op_dim_slow(container, dim OPLINE_CC EXECUTE_DATA_CC);
assign_dim_op_ret_null:
			FREE_OP((opline+1)->op1_type, (opline+1)->op1.var);
			if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
				ZVAL_NULL(EX_VAR(opline->result.var));
			}
		}
	}


	CREX_VM_NEXT_OPCODE_EX(1, 2);
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ASSIGN_OP_SPEC_CV_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *var_ptr;
	zval *value;

	SAVE_OPLINE();
	value = _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC);
	var_ptr = _get_zval_ptr_cv_BP_VAR_RW(opline->op1.var EXECUTE_DATA_CC);

	do {
		if (UNEXPECTED(C_TYPE_P(var_ptr) == IS_REFERENCE)) {
			crex_reference *ref = C_REF_P(var_ptr);
			var_ptr = C_REFVAL_P(var_ptr);
			if (UNEXPECTED(CREX_REF_HAS_TYPE_SOURCES(ref))) {
				crex_binary_assign_op_typed_ref(ref, value OPLINE_CC EXECUTE_DATA_CC);
				break;
			}
		}
		crex_binary_op(var_ptr, var_ptr, value OPLINE_CC);
	} while (0);

	if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
		ZVAL_COPY(EX_VAR(opline->result.var), var_ptr);
	}


	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_PRE_INC_OBJ_SPEC_CV_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *object;
	zval *property;
	zval *zptr;
	void **cache_slot;
	crex_property_info *prop_info;
	crex_object *zobj;
	crex_string *name, *tmp_name;

	SAVE_OPLINE();
	object = EX_VAR(opline->op1.var);
	property = _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC);

	do {
		if (IS_CV != IS_UNUSED && UNEXPECTED(C_TYPE_P(object) != IS_OBJECT)) {
			if (C_ISREF_P(object) && C_TYPE_P(C_REFVAL_P(object)) == IS_OBJECT) {
				object = C_REFVAL_P(object);
				goto pre_incdec_object;
			}
			if (IS_CV == IS_CV
			 && UNEXPECTED(C_TYPE_P(object) == IS_UNDEF)) {
				ZVAL_UNDEFINED_OP1();
			}
			crex_throw_non_object_error(object, property OPLINE_CC EXECUTE_DATA_CC);
			break;
		}

pre_incdec_object:
		/* here we are sure we are dealing with an object */
		zobj = C_OBJ_P(object);
		if (IS_CV == IS_CONST) {
			name = C_STR_P(property);
		} else {
			name = zval_try_get_tmp_string(property, &tmp_name);
			if (UNEXPECTED(!name)) {
				UNDEF_RESULT();
				break;
			}
		}
		cache_slot = (IS_CV == IS_CONST) ? CACHE_ADDR(opline->extended_value) : NULL;
		if (EXPECTED((zptr = zobj->handlers->get_property_ptr_ptr(zobj, name, BP_VAR_RW, cache_slot)) != NULL)) {
			if (UNEXPECTED(C_ISERROR_P(zptr))) {
				if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
					ZVAL_NULL(EX_VAR(opline->result.var));
				}
			} else {
				if (IS_CV == IS_CONST) {
					prop_info = (crex_property_info *) CACHED_PTR_EX(cache_slot + 2);
				} else {
					prop_info = crex_object_fetch_property_type_info(C_OBJ_P(object), zptr);
				}
				crex_pre_incdec_property_zval(zptr, prop_info OPLINE_CC EXECUTE_DATA_CC);
			}
		} else {
			crex_pre_incdec_overloaded_property(zobj, name, cache_slot OPLINE_CC EXECUTE_DATA_CC);
		}
		if (IS_CV != IS_CONST) {
			crex_tmp_string_release(tmp_name);
		}
	} while (0);


	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_POST_INC_OBJ_SPEC_CV_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *object;
	zval *property;
	zval *zptr;
	void **cache_slot;
	crex_property_info *prop_info;
	crex_object *zobj;
	crex_string *name, *tmp_name;

	SAVE_OPLINE();
	object = EX_VAR(opline->op1.var);
	property = _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC);

	do {
		if (IS_CV != IS_UNUSED && UNEXPECTED(C_TYPE_P(object) != IS_OBJECT)) {
			if (C_ISREF_P(object) && C_TYPE_P(C_REFVAL_P(object)) == IS_OBJECT) {
				object = C_REFVAL_P(object);
				goto post_incdec_object;
			}
			if (IS_CV == IS_CV
			 && UNEXPECTED(C_TYPE_P(object) == IS_UNDEF)) {
				ZVAL_UNDEFINED_OP1();
			}
			crex_throw_non_object_error(object, property OPLINE_CC EXECUTE_DATA_CC);
			break;
		}

post_incdec_object:
		/* here we are sure we are dealing with an object */
		zobj = C_OBJ_P(object);
		if (IS_CV == IS_CONST) {
			name = C_STR_P(property);
		} else {
			name = zval_try_get_tmp_string(property, &tmp_name);
			if (UNEXPECTED(!name)) {
				ZVAL_UNDEF(EX_VAR(opline->result.var));
				break;
			}
		}
		cache_slot = (IS_CV == IS_CONST) ? CACHE_ADDR(opline->extended_value) : NULL;
		if (EXPECTED((zptr = zobj->handlers->get_property_ptr_ptr(zobj, name, BP_VAR_RW, cache_slot)) != NULL)) {
			if (UNEXPECTED(C_ISERROR_P(zptr))) {
				ZVAL_NULL(EX_VAR(opline->result.var));
			} else {
				if (IS_CV == IS_CONST) {
					prop_info = (crex_property_info*)CACHED_PTR_EX(cache_slot + 2);
				} else {
					prop_info = crex_object_fetch_property_type_info(C_OBJ_P(object), zptr);
				}

				crex_post_incdec_property_zval(zptr, prop_info OPLINE_CC EXECUTE_DATA_CC);
			}
		} else {
			crex_post_incdec_overloaded_property(zobj, name, cache_slot OPLINE_CC EXECUTE_DATA_CC);
		}
		if (IS_CV != IS_CONST) {
			crex_tmp_string_release(tmp_name);
		}
	} while (0);


	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FETCH_DIM_R_SPEC_CV_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container, *dim, *value;

	SAVE_OPLINE();
	container = EX_VAR(opline->op1.var);
	dim = EX_VAR(opline->op2.var);
	if (IS_CV != IS_CONST) {
		if (EXPECTED(C_TYPE_P(container) == IS_ARRAY)) {
fetch_dim_r_array:
			value = crex_fetch_dimension_address_inner(C_ARRVAL_P(container), dim, IS_CV, BP_VAR_R EXECUTE_DATA_CC);
			ZVAL_COPY_DEREF(EX_VAR(opline->result.var), value);
		} else if (EXPECTED(C_TYPE_P(container) == IS_REFERENCE)) {
			container = C_REFVAL_P(container);
			if (EXPECTED(C_TYPE_P(container) == IS_ARRAY)) {
				goto fetch_dim_r_array;
			} else {
				goto fetch_dim_r_slow;
			}
		} else {
fetch_dim_r_slow:
			if (IS_CV == IS_CONST && C_EXTRA_P(dim) == CREX_EXTRA_VALUE) {
				dim++;
			}
			crex_fetch_dimension_address_read_R_slow(container, dim OPLINE_CC EXECUTE_DATA_CC);
		}
	} else {
		crex_fetch_dimension_address_read_R(container, dim, IS_CV OPLINE_CC EXECUTE_DATA_CC);
	}


	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FETCH_DIM_W_SPEC_CV_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;

	SAVE_OPLINE();
	container = EX_VAR(opline->op1.var);
	crex_fetch_dimension_address_W(container, EX_VAR(opline->op2.var), IS_CV OPLINE_CC EXECUTE_DATA_CC);

	if (IS_CV == IS_VAR) {
		FREE_VAR_PTR_AND_EXTRACT_RESULT_IF_NECESSARY(opline->op1.var);
	}
	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FETCH_DIM_RW_SPEC_CV_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;

	SAVE_OPLINE();
	container = EX_VAR(opline->op1.var);
	crex_fetch_dimension_address_RW(container, EX_VAR(opline->op2.var), IS_CV OPLINE_CC EXECUTE_DATA_CC);

	if (IS_CV == IS_VAR) {
		FREE_VAR_PTR_AND_EXTRACT_RESULT_IF_NECESSARY(opline->op1.var);
	}
	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FETCH_DIM_IS_SPEC_CV_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;

	SAVE_OPLINE();
	container = EX_VAR(opline->op1.var);
	crex_fetch_dimension_address_read_IS(container, EX_VAR(opline->op2.var), IS_CV OPLINE_CC EXECUTE_DATA_CC);


	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FETCH_DIM_FUNC_ARG_SPEC_CV_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
#if 0
	USE_OPLINE
#endif

	if (UNEXPECTED(CREX_CALL_INFO(EX(call)) & CREX_CALL_SEND_ARG_BY_REF)) {
		if ((IS_CV & (IS_CONST|IS_TMP_VAR))) {
			CREX_VM_TAIL_CALL(crex_use_tmp_in_write_context_helper_SPEC(CREX_OPCODE_HANDLER_ARGS_PASSTHRU));
		}
		CREX_VM_TAIL_CALL(CREX_FETCH_DIM_W_SPEC_CV_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU));
	} else {
		if (IS_CV == IS_UNUSED) {
			CREX_VM_TAIL_CALL(crex_use_undef_in_read_context_helper_SPEC(CREX_OPCODE_HANDLER_ARGS_PASSTHRU));
		}
		CREX_VM_TAIL_CALL(CREX_FETCH_DIM_R_SPEC_CV_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU));
	}
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FETCH_DIM_UNSET_SPEC_CV_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;

	SAVE_OPLINE();
	container = EX_VAR(opline->op1.var);
	crex_fetch_dimension_address_UNSET(container, EX_VAR(opline->op2.var), IS_CV OPLINE_CC EXECUTE_DATA_CC);

	if (IS_CV == IS_VAR) {
		FREE_VAR_PTR_AND_EXTRACT_RESULT_IF_NECESSARY(opline->op1.var);
	}
	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FETCH_OBJ_R_SPEC_CV_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;
	void **cache_slot = NULL;

	SAVE_OPLINE();
	container = EX_VAR(opline->op1.var);

	if (IS_CV == IS_CONST ||
	    (IS_CV != IS_UNUSED && UNEXPECTED(C_TYPE_P(container) != IS_OBJECT))) {
		do {
			if ((IS_CV & (IS_VAR|IS_CV)) && C_ISREF_P(container)) {
				container = C_REFVAL_P(container);
				if (EXPECTED(C_TYPE_P(container) == IS_OBJECT)) {
					break;
				}
			}
			if (IS_CV == IS_CV && UNEXPECTED(C_TYPE_P(container) == IS_UNDEF)) {
				ZVAL_UNDEFINED_OP1();
			}
			crex_wrong_property_read(container, _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC));
			ZVAL_NULL(EX_VAR(opline->result.var));
			goto fetch_obj_r_finish;
		} while (0);
	}

	/* here we are sure we are dealing with an object */
	do {
		crex_object *zobj = C_OBJ_P(container);
		crex_string *name, *tmp_name;
		zval *retval;

		if (IS_CV == IS_CONST) {
			cache_slot = CACHE_ADDR(opline->extended_value & ~CREX_FETCH_REF /* FUNC_ARG fetch may contain it */);

			if (EXPECTED(zobj->ce == CACHED_PTR_EX(cache_slot))) {
				uintptr_t prop_offset = (uintptr_t)CACHED_PTR_EX(cache_slot + 1);

				if (EXPECTED(IS_VALID_PROPERTY_OFFSET(prop_offset))) {
					retval = OBJ_PROP(zobj, prop_offset);
					if (EXPECTED(C_TYPE_INFO_P(retval) != IS_UNDEF)) {
						if (0 || (IS_CV & (IS_TMP_VAR|IS_VAR)) != 0) {
							goto fetch_obj_r_copy;
						} else {
fetch_obj_r_fast_copy:
							ZVAL_COPY_DEREF(EX_VAR(opline->result.var), retval);
							CREX_VM_NEXT_OPCODE();
						}
					}
				} else if (EXPECTED(zobj->properties != NULL)) {
					name = C_STR_P(_get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC));
					if (!IS_UNKNOWN_DYNAMIC_PROPERTY_OFFSET(prop_offset)) {
						uintptr_t idx = CREX_DECODE_DYN_PROP_OFFSET(prop_offset);

						if (EXPECTED(idx < zobj->properties->nNumUsed * sizeof(Bucket))) {
							Bucket *p = (Bucket*)((char*)zobj->properties->arData + idx);

							if (EXPECTED(p->key == name) ||
							    (EXPECTED(p->h == ZSTR_H(name)) &&
							     EXPECTED(p->key != NULL) &&
							     EXPECTED(crex_string_equal_content(p->key, name)))) {
								retval = &p->val;
								if (0 || (IS_CV & (IS_TMP_VAR|IS_VAR)) != 0) {
									goto fetch_obj_r_copy;
								} else {
									goto fetch_obj_r_fast_copy;
								}
							}
						}
						CACHE_PTR_EX(cache_slot + 1, (void*)CREX_DYNAMIC_PROPERTY_OFFSET);
					}
					retval = crex_hash_find_known_hash(zobj->properties, name);
					if (EXPECTED(retval)) {
						uintptr_t idx = (char*)retval - (char*)zobj->properties->arData;
						CACHE_PTR_EX(cache_slot + 1, (void*)CREX_ENCODE_DYN_PROP_OFFSET(idx));
						if (0 || (IS_CV & (IS_TMP_VAR|IS_VAR)) != 0) {
							goto fetch_obj_r_copy;
						} else {
							goto fetch_obj_r_fast_copy;
						}
					}
				}
			}
			name = C_STR_P(_get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC));
		} else {
			name = zval_try_get_tmp_string(_get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC), &tmp_name);
			if (UNEXPECTED(!name)) {
				ZVAL_UNDEF(EX_VAR(opline->result.var));
				break;
			}
		}

#if CREX_DEBUG
		/* For non-standard object handlers, verify a declared property type in debug builds.
		 * Fetch prop_info before calling read_property(), as it may deallocate the object. */
		crex_property_info *prop_info = NULL;
		if (zobj->handlers->read_property != crex_std_read_property) {
			prop_info = crex_get_property_info(zobj->ce, name, /* silent */ true);
		}
#endif
		retval = zobj->handlers->read_property(zobj, name, BP_VAR_R, cache_slot, EX_VAR(opline->result.var));
#if CREX_DEBUG
		if (!EG(exception) && prop_info && prop_info != CREX_WRONG_PROPERTY_INFO
				&& CREX_TYPE_IS_SET(prop_info->type)) {
			ZVAL_OPT_DEREF(retval);
			crex_verify_property_type(prop_info, retval, /* strict */ true);
		}
#endif

		if (IS_CV != IS_CONST) {
			crex_tmp_string_release(tmp_name);
		}

		if (retval != EX_VAR(opline->result.var)) {
fetch_obj_r_copy:
			ZVAL_COPY_DEREF(EX_VAR(opline->result.var), retval);
		} else if (UNEXPECTED(C_ISREF_P(retval))) {
			crex_unwrap_reference(retval);
		}
	} while (0);

fetch_obj_r_finish:


	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FETCH_OBJ_W_SPEC_CV_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *property, *container, *result;

	SAVE_OPLINE();

	container = EX_VAR(opline->op1.var);
	property = _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC);
	result = EX_VAR(opline->result.var);
	crex_fetch_property_address(
		result, container, IS_CV, property, IS_CV,
		((IS_CV == IS_CONST) ? CACHE_ADDR(opline->extended_value & ~CREX_FETCH_OBJ_FLAGS) : NULL),
		BP_VAR_W, opline->extended_value OPLINE_CC EXECUTE_DATA_CC);

	if (IS_CV == IS_VAR) {
		FREE_VAR_PTR_AND_EXTRACT_RESULT_IF_NECESSARY(opline->op1.var);
	}
	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FETCH_OBJ_RW_SPEC_CV_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *property, *container, *result;

	SAVE_OPLINE();
	container = EX_VAR(opline->op1.var);
	property = _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC);
	result = EX_VAR(opline->result.var);
	crex_fetch_property_address(result, container, IS_CV, property, IS_CV, ((IS_CV == IS_CONST) ? CACHE_ADDR(opline->extended_value) : NULL), BP_VAR_RW, 0 OPLINE_CC EXECUTE_DATA_CC);

	if (IS_CV == IS_VAR) {
		FREE_VAR_PTR_AND_EXTRACT_RESULT_IF_NECESSARY(opline->op1.var);
	}
	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FETCH_OBJ_IS_SPEC_CV_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;
	void **cache_slot = NULL;

	SAVE_OPLINE();
	container = _get_zval_ptr_cv_BP_VAR_IS(opline->op1.var EXECUTE_DATA_CC);

	if (IS_CV == IS_CONST ||
	    (IS_CV != IS_UNUSED && UNEXPECTED(C_TYPE_P(container) != IS_OBJECT))) {
		do {
			if ((IS_CV & (IS_VAR|IS_CV)) && C_ISREF_P(container)) {
				container = C_REFVAL_P(container);
				if (EXPECTED(C_TYPE_P(container) == IS_OBJECT)) {
					break;
				}
			}
			if (IS_CV == IS_CV && C_TYPE_P(EX_VAR(opline->op2.var)) == IS_UNDEF) {
				ZVAL_UNDEFINED_OP2();
			}
			ZVAL_NULL(EX_VAR(opline->result.var));
			goto fetch_obj_is_finish;
		} while (0);
	}

	/* here we are sure we are dealing with an object */
	do {
		crex_object *zobj = C_OBJ_P(container);
		crex_string *name, *tmp_name;
		zval *retval;

		if (IS_CV == IS_CONST) {
			cache_slot = CACHE_ADDR(opline->extended_value);

			if (EXPECTED(zobj->ce == CACHED_PTR_EX(cache_slot))) {
				uintptr_t prop_offset = (uintptr_t)CACHED_PTR_EX(cache_slot + 1);

				if (EXPECTED(IS_VALID_PROPERTY_OFFSET(prop_offset))) {
					retval = OBJ_PROP(zobj, prop_offset);
					if (EXPECTED(C_TYPE_P(retval) != IS_UNDEF)) {
						if (0 || (IS_CV & (IS_TMP_VAR|IS_VAR)) != 0) {
							goto fetch_obj_is_copy;
						} else {
fetch_obj_is_fast_copy:
							ZVAL_COPY_DEREF(EX_VAR(opline->result.var), retval);
							CREX_VM_NEXT_OPCODE();
						}
					}
				} else if (EXPECTED(zobj->properties != NULL)) {
					name = C_STR_P(_get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC));
					if (!IS_UNKNOWN_DYNAMIC_PROPERTY_OFFSET(prop_offset)) {
						uintptr_t idx = CREX_DECODE_DYN_PROP_OFFSET(prop_offset);

						if (EXPECTED(idx < zobj->properties->nNumUsed * sizeof(Bucket))) {
							Bucket *p = (Bucket*)((char*)zobj->properties->arData + idx);

							if (EXPECTED(p->key == name) ||
							    (EXPECTED(p->h == ZSTR_H(name)) &&
							     EXPECTED(p->key != NULL) &&
							     EXPECTED(crex_string_equal_content(p->key, name)))) {
								retval = &p->val;
								if (0 || (IS_CV & (IS_TMP_VAR|IS_VAR)) != 0) {
									goto fetch_obj_is_copy;
								} else {
									goto fetch_obj_is_fast_copy;
								}
							}
						}
						CACHE_PTR_EX(cache_slot + 1, (void*)CREX_DYNAMIC_PROPERTY_OFFSET);
					}
					retval = crex_hash_find_known_hash(zobj->properties, name);
					if (EXPECTED(retval)) {
						uintptr_t idx = (char*)retval - (char*)zobj->properties->arData;
						CACHE_PTR_EX(cache_slot + 1, (void*)CREX_ENCODE_DYN_PROP_OFFSET(idx));
						if (0 || (IS_CV & (IS_TMP_VAR|IS_VAR)) != 0) {
							goto fetch_obj_is_copy;
						} else {
							goto fetch_obj_is_fast_copy;
						}
					}
				}
			}
			name = C_STR_P(_get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC));
		} else {
			name = zval_try_get_tmp_string(_get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC), &tmp_name);
			if (UNEXPECTED(!name)) {
				ZVAL_UNDEF(EX_VAR(opline->result.var));
				break;
			}
		}

		retval = zobj->handlers->read_property(zobj, name, BP_VAR_IS, cache_slot, EX_VAR(opline->result.var));

		if (IS_CV != IS_CONST) {
			crex_tmp_string_release(tmp_name);
		}

		if (retval != EX_VAR(opline->result.var)) {
fetch_obj_is_copy:
			ZVAL_COPY_DEREF(EX_VAR(opline->result.var), retval);
		} else if (UNEXPECTED(C_ISREF_P(retval))) {
			crex_unwrap_reference(retval);
		}
	} while (0);

fetch_obj_is_finish:


	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FETCH_OBJ_FUNC_ARG_SPEC_CV_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
#if 0
	USE_OPLINE
#endif

	if (UNEXPECTED(CREX_CALL_INFO(EX(call)) & CREX_CALL_SEND_ARG_BY_REF)) {
		/* Behave like FETCH_OBJ_W */
		if ((IS_CV & (IS_CONST|IS_TMP_VAR))) {
			CREX_VM_TAIL_CALL(crex_use_tmp_in_write_context_helper_SPEC(CREX_OPCODE_HANDLER_ARGS_PASSTHRU));
		}
		CREX_VM_TAIL_CALL(CREX_FETCH_OBJ_W_SPEC_CV_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU));
	} else {
		CREX_VM_TAIL_CALL(CREX_FETCH_OBJ_R_SPEC_CV_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU));
	}
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FETCH_OBJ_UNSET_SPEC_CV_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container, *property, *result;

	SAVE_OPLINE();
	container = EX_VAR(opline->op1.var);
	property = _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC);
	result = EX_VAR(opline->result.var);
	crex_fetch_property_address(result, container, IS_CV, property, IS_CV, ((IS_CV == IS_CONST) ? CACHE_ADDR(opline->extended_value) : NULL), BP_VAR_UNSET, 0 OPLINE_CC EXECUTE_DATA_CC);

	if (IS_CV == IS_VAR) {
		FREE_VAR_PTR_AND_EXTRACT_RESULT_IF_NECESSARY(opline->op1.var);
	}
	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ASSIGN_OBJ_SPEC_CV_CV_OP_DATA_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *object, *value, tmp;
	crex_object *zobj;
	crex_string *name, *tmp_name;
	crex_refcounted *garbage = NULL;

	SAVE_OPLINE();
	object = EX_VAR(opline->op1.var);
	value = RT_CONSTANT((opline+1), (opline+1)->op1);

	if (IS_CV != IS_UNUSED && UNEXPECTED(C_TYPE_P(object) != IS_OBJECT)) {
		if (C_ISREF_P(object) && C_TYPE_P(C_REFVAL_P(object)) == IS_OBJECT) {
			object = C_REFVAL_P(object);
			goto assign_object;
		}
		crex_throw_non_object_error(object, _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC) OPLINE_CC EXECUTE_DATA_CC);
		value = &EG(uninitialized_zval);
		goto free_and_exit_assign_obj;
	}

assign_object:
	zobj = C_OBJ_P(object);
	if (IS_CV == IS_CONST) {
		if (EXPECTED(zobj->ce == CACHED_PTR(opline->extended_value))) {
			void **cache_slot = CACHE_ADDR(opline->extended_value);
			uintptr_t prop_offset = (uintptr_t)CACHED_PTR_EX(cache_slot + 1);
			zval *property_val;

			if (EXPECTED(IS_VALID_PROPERTY_OFFSET(prop_offset))) {
				property_val = OBJ_PROP(zobj, prop_offset);
				if (C_TYPE_P(property_val) != IS_UNDEF) {
					crex_property_info *prop_info = (crex_property_info*) CACHED_PTR_EX(cache_slot + 2);

					if (UNEXPECTED(prop_info != NULL)) {
						value = crex_assign_to_typed_prop(prop_info, property_val, value, &garbage EXECUTE_DATA_CC);
						goto free_and_exit_assign_obj;
					} else {
fast_assign_obj:
						value = crex_assign_to_variable_ex(property_val, value, IS_CONST, EX_USES_STRICT_TYPES(), &garbage);
						if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
							ZVAL_COPY(EX_VAR(opline->result.var), value);
						}
						goto exit_assign_obj;
					}
				}
			} else {
				name = C_STR_P(_get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC));
				if (EXPECTED(zobj->properties != NULL)) {
					if (UNEXPECTED(GC_REFCOUNT(zobj->properties) > 1)) {
						if (EXPECTED(!(GC_FLAGS(zobj->properties) & IS_ARRAY_IMMUTABLE))) {
							GC_DELREF(zobj->properties);
						}
						zobj->properties = crex_array_dup(zobj->properties);
					}
					property_val = crex_hash_find_known_hash(zobj->properties, name);
					if (property_val) {
						goto fast_assign_obj;
					}
				}

				if (!zobj->ce->__set && (zobj->ce->ce_flags & CREX_ACC_ALLOW_DYNAMIC_PROPERTIES)) {
					if (EXPECTED(zobj->properties == NULL)) {
						rebuild_object_properties(zobj);
					}
					if (IS_CONST == IS_CONST) {
						if (UNEXPECTED(C_OPT_REFCOUNTED_P(value))) {
							C_ADDREF_P(value);
						}
					} else if (IS_CONST != IS_TMP_VAR) {
						if (C_ISREF_P(value)) {
							if (IS_CONST == IS_VAR) {
								crex_reference *ref = C_REF_P(value);
								if (GC_DELREF(ref) == 0) {
									ZVAL_COPY_VALUE(&tmp, C_REFVAL_P(value));
									efree_size(ref, sizeof(crex_reference));
									value = &tmp;
								} else {
									value = C_REFVAL_P(value);
									C_TRY_ADDREF_P(value);
								}
							} else {
								value = C_REFVAL_P(value);
								C_TRY_ADDREF_P(value);
							}
						} else if (IS_CONST == IS_CV) {
							C_TRY_ADDREF_P(value);
						}
						}
					crex_hash_add_new(zobj->properties, name, value);
					if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
						ZVAL_COPY(EX_VAR(opline->result.var), value);
					}
					goto exit_assign_obj;
				}
			}
		}
		name = C_STR_P(_get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC));
	} else {
		name = zval_try_get_tmp_string(_get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC), &tmp_name);
		if (UNEXPECTED(!name)) {

			UNDEF_RESULT();
			goto exit_assign_obj;
		}
	}

	if (IS_CONST == IS_CV || IS_CONST == IS_VAR) {
		ZVAL_DEREF(value);
	}

	value = zobj->handlers->write_property(zobj, name, value, (IS_CV == IS_CONST) ? CACHE_ADDR(opline->extended_value) : NULL);

	if (IS_CV != IS_CONST) {
		crex_tmp_string_release(tmp_name);
	}

free_and_exit_assign_obj:
	if (UNEXPECTED(RETURN_VALUE_USED(opline)) && value) {
		ZVAL_COPY_DEREF(EX_VAR(opline->result.var), value);
	}

exit_assign_obj:
	if (garbage) {
		GC_DTOR_NO_REF(garbage);
	}


	/* assign_obj has two opcodes! */
	CREX_VM_NEXT_OPCODE_EX(1, 2);
}

/* No specialization for op_types (CONST|TMPVAR|CV, UNUSED|CONST|VAR) */
static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ASSIGN_OBJ_SPEC_CV_CV_OP_DATA_TMP_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *object, *value, tmp;
	crex_object *zobj;
	crex_string *name, *tmp_name;
	crex_refcounted *garbage = NULL;

	SAVE_OPLINE();
	object = EX_VAR(opline->op1.var);
	value = _get_zval_ptr_tmp((opline+1)->op1.var EXECUTE_DATA_CC);

	if (IS_CV != IS_UNUSED && UNEXPECTED(C_TYPE_P(object) != IS_OBJECT)) {
		if (C_ISREF_P(object) && C_TYPE_P(C_REFVAL_P(object)) == IS_OBJECT) {
			object = C_REFVAL_P(object);
			goto assign_object;
		}
		crex_throw_non_object_error(object, _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC) OPLINE_CC EXECUTE_DATA_CC);
		value = &EG(uninitialized_zval);
		goto free_and_exit_assign_obj;
	}

assign_object:
	zobj = C_OBJ_P(object);
	if (IS_CV == IS_CONST) {
		if (EXPECTED(zobj->ce == CACHED_PTR(opline->extended_value))) {
			void **cache_slot = CACHE_ADDR(opline->extended_value);
			uintptr_t prop_offset = (uintptr_t)CACHED_PTR_EX(cache_slot + 1);
			zval *property_val;

			if (EXPECTED(IS_VALID_PROPERTY_OFFSET(prop_offset))) {
				property_val = OBJ_PROP(zobj, prop_offset);
				if (C_TYPE_P(property_val) != IS_UNDEF) {
					crex_property_info *prop_info = (crex_property_info*) CACHED_PTR_EX(cache_slot + 2);

					if (UNEXPECTED(prop_info != NULL)) {
						value = crex_assign_to_typed_prop(prop_info, property_val, value, &garbage EXECUTE_DATA_CC);
						goto free_and_exit_assign_obj;
					} else {
fast_assign_obj:
						value = crex_assign_to_variable_ex(property_val, value, IS_TMP_VAR, EX_USES_STRICT_TYPES(), &garbage);
						if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
							ZVAL_COPY(EX_VAR(opline->result.var), value);
						}
						goto exit_assign_obj;
					}
				}
			} else {
				name = C_STR_P(_get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC));
				if (EXPECTED(zobj->properties != NULL)) {
					if (UNEXPECTED(GC_REFCOUNT(zobj->properties) > 1)) {
						if (EXPECTED(!(GC_FLAGS(zobj->properties) & IS_ARRAY_IMMUTABLE))) {
							GC_DELREF(zobj->properties);
						}
						zobj->properties = crex_array_dup(zobj->properties);
					}
					property_val = crex_hash_find_known_hash(zobj->properties, name);
					if (property_val) {
						goto fast_assign_obj;
					}
				}

				if (!zobj->ce->__set && (zobj->ce->ce_flags & CREX_ACC_ALLOW_DYNAMIC_PROPERTIES)) {
					if (EXPECTED(zobj->properties == NULL)) {
						rebuild_object_properties(zobj);
					}
					if (IS_TMP_VAR == IS_CONST) {
						if (UNEXPECTED(C_OPT_REFCOUNTED_P(value))) {
							C_ADDREF_P(value);
						}
					} else if (IS_TMP_VAR != IS_TMP_VAR) {
						if (C_ISREF_P(value)) {
							if (IS_TMP_VAR == IS_VAR) {
								crex_reference *ref = C_REF_P(value);
								if (GC_DELREF(ref) == 0) {
									ZVAL_COPY_VALUE(&tmp, C_REFVAL_P(value));
									efree_size(ref, sizeof(crex_reference));
									value = &tmp;
								} else {
									value = C_REFVAL_P(value);
									C_TRY_ADDREF_P(value);
								}
							} else {
								value = C_REFVAL_P(value);
								C_TRY_ADDREF_P(value);
							}
						} else if (IS_TMP_VAR == IS_CV) {
							C_TRY_ADDREF_P(value);
						}
						}
					crex_hash_add_new(zobj->properties, name, value);
					if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
						ZVAL_COPY(EX_VAR(opline->result.var), value);
					}
					goto exit_assign_obj;
				}
			}
		}
		name = C_STR_P(_get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC));
	} else {
		name = zval_try_get_tmp_string(_get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC), &tmp_name);
		if (UNEXPECTED(!name)) {
			zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
			UNDEF_RESULT();
			goto exit_assign_obj;
		}
	}

	if (IS_TMP_VAR == IS_CV || IS_TMP_VAR == IS_VAR) {
		ZVAL_DEREF(value);
	}

	value = zobj->handlers->write_property(zobj, name, value, (IS_CV == IS_CONST) ? CACHE_ADDR(opline->extended_value) : NULL);

	if (IS_CV != IS_CONST) {
		crex_tmp_string_release(tmp_name);
	}

free_and_exit_assign_obj:
	if (UNEXPECTED(RETURN_VALUE_USED(opline)) && value) {
		ZVAL_COPY_DEREF(EX_VAR(opline->result.var), value);
	}
	zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
exit_assign_obj:
	if (garbage) {
		GC_DTOR_NO_REF(garbage);
	}


	/* assign_obj has two opcodes! */
	CREX_VM_NEXT_OPCODE_EX(1, 2);
}

/* No specialization for op_types (CONST|TMPVAR|CV, UNUSED|CONST|VAR) */
static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ASSIGN_OBJ_SPEC_CV_CV_OP_DATA_VAR_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *object, *value, tmp;
	crex_object *zobj;
	crex_string *name, *tmp_name;
	crex_refcounted *garbage = NULL;

	SAVE_OPLINE();
	object = EX_VAR(opline->op1.var);
	value = _get_zval_ptr_var((opline+1)->op1.var EXECUTE_DATA_CC);

	if (IS_CV != IS_UNUSED && UNEXPECTED(C_TYPE_P(object) != IS_OBJECT)) {
		if (C_ISREF_P(object) && C_TYPE_P(C_REFVAL_P(object)) == IS_OBJECT) {
			object = C_REFVAL_P(object);
			goto assign_object;
		}
		crex_throw_non_object_error(object, _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC) OPLINE_CC EXECUTE_DATA_CC);
		value = &EG(uninitialized_zval);
		goto free_and_exit_assign_obj;
	}

assign_object:
	zobj = C_OBJ_P(object);
	if (IS_CV == IS_CONST) {
		if (EXPECTED(zobj->ce == CACHED_PTR(opline->extended_value))) {
			void **cache_slot = CACHE_ADDR(opline->extended_value);
			uintptr_t prop_offset = (uintptr_t)CACHED_PTR_EX(cache_slot + 1);
			zval *property_val;

			if (EXPECTED(IS_VALID_PROPERTY_OFFSET(prop_offset))) {
				property_val = OBJ_PROP(zobj, prop_offset);
				if (C_TYPE_P(property_val) != IS_UNDEF) {
					crex_property_info *prop_info = (crex_property_info*) CACHED_PTR_EX(cache_slot + 2);

					if (UNEXPECTED(prop_info != NULL)) {
						value = crex_assign_to_typed_prop(prop_info, property_val, value, &garbage EXECUTE_DATA_CC);
						goto free_and_exit_assign_obj;
					} else {
fast_assign_obj:
						value = crex_assign_to_variable_ex(property_val, value, IS_VAR, EX_USES_STRICT_TYPES(), &garbage);
						if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
							ZVAL_COPY(EX_VAR(opline->result.var), value);
						}
						goto exit_assign_obj;
					}
				}
			} else {
				name = C_STR_P(_get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC));
				if (EXPECTED(zobj->properties != NULL)) {
					if (UNEXPECTED(GC_REFCOUNT(zobj->properties) > 1)) {
						if (EXPECTED(!(GC_FLAGS(zobj->properties) & IS_ARRAY_IMMUTABLE))) {
							GC_DELREF(zobj->properties);
						}
						zobj->properties = crex_array_dup(zobj->properties);
					}
					property_val = crex_hash_find_known_hash(zobj->properties, name);
					if (property_val) {
						goto fast_assign_obj;
					}
				}

				if (!zobj->ce->__set && (zobj->ce->ce_flags & CREX_ACC_ALLOW_DYNAMIC_PROPERTIES)) {
					if (EXPECTED(zobj->properties == NULL)) {
						rebuild_object_properties(zobj);
					}
					if (IS_VAR == IS_CONST) {
						if (UNEXPECTED(C_OPT_REFCOUNTED_P(value))) {
							C_ADDREF_P(value);
						}
					} else if (IS_VAR != IS_TMP_VAR) {
						if (C_ISREF_P(value)) {
							if (IS_VAR == IS_VAR) {
								crex_reference *ref = C_REF_P(value);
								if (GC_DELREF(ref) == 0) {
									ZVAL_COPY_VALUE(&tmp, C_REFVAL_P(value));
									efree_size(ref, sizeof(crex_reference));
									value = &tmp;
								} else {
									value = C_REFVAL_P(value);
									C_TRY_ADDREF_P(value);
								}
							} else {
								value = C_REFVAL_P(value);
								C_TRY_ADDREF_P(value);
							}
						} else if (IS_VAR == IS_CV) {
							C_TRY_ADDREF_P(value);
						}
						}
					crex_hash_add_new(zobj->properties, name, value);
					if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
						ZVAL_COPY(EX_VAR(opline->result.var), value);
					}
					goto exit_assign_obj;
				}
			}
		}
		name = C_STR_P(_get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC));
	} else {
		name = zval_try_get_tmp_string(_get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC), &tmp_name);
		if (UNEXPECTED(!name)) {
			zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
			UNDEF_RESULT();
			goto exit_assign_obj;
		}
	}

	if (IS_VAR == IS_CV || IS_VAR == IS_VAR) {
		ZVAL_DEREF(value);
	}

	value = zobj->handlers->write_property(zobj, name, value, (IS_CV == IS_CONST) ? CACHE_ADDR(opline->extended_value) : NULL);

	if (IS_CV != IS_CONST) {
		crex_tmp_string_release(tmp_name);
	}

free_and_exit_assign_obj:
	if (UNEXPECTED(RETURN_VALUE_USED(opline)) && value) {
		ZVAL_COPY_DEREF(EX_VAR(opline->result.var), value);
	}
	zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
exit_assign_obj:
	if (garbage) {
		GC_DTOR_NO_REF(garbage);
	}


	/* assign_obj has two opcodes! */
	CREX_VM_NEXT_OPCODE_EX(1, 2);
}

/* No specialization for op_types (CONST|TMPVAR|CV, UNUSED|CONST|VAR) */
static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ASSIGN_OBJ_SPEC_CV_CV_OP_DATA_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *object, *value, tmp;
	crex_object *zobj;
	crex_string *name, *tmp_name;
	crex_refcounted *garbage = NULL;

	SAVE_OPLINE();
	object = EX_VAR(opline->op1.var);
	value = _get_zval_ptr_cv_BP_VAR_R((opline+1)->op1.var EXECUTE_DATA_CC);

	if (IS_CV != IS_UNUSED && UNEXPECTED(C_TYPE_P(object) != IS_OBJECT)) {
		if (C_ISREF_P(object) && C_TYPE_P(C_REFVAL_P(object)) == IS_OBJECT) {
			object = C_REFVAL_P(object);
			goto assign_object;
		}
		crex_throw_non_object_error(object, _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC) OPLINE_CC EXECUTE_DATA_CC);
		value = &EG(uninitialized_zval);
		goto free_and_exit_assign_obj;
	}

assign_object:
	zobj = C_OBJ_P(object);
	if (IS_CV == IS_CONST) {
		if (EXPECTED(zobj->ce == CACHED_PTR(opline->extended_value))) {
			void **cache_slot = CACHE_ADDR(opline->extended_value);
			uintptr_t prop_offset = (uintptr_t)CACHED_PTR_EX(cache_slot + 1);
			zval *property_val;

			if (EXPECTED(IS_VALID_PROPERTY_OFFSET(prop_offset))) {
				property_val = OBJ_PROP(zobj, prop_offset);
				if (C_TYPE_P(property_val) != IS_UNDEF) {
					crex_property_info *prop_info = (crex_property_info*) CACHED_PTR_EX(cache_slot + 2);

					if (UNEXPECTED(prop_info != NULL)) {
						value = crex_assign_to_typed_prop(prop_info, property_val, value, &garbage EXECUTE_DATA_CC);
						goto free_and_exit_assign_obj;
					} else {
fast_assign_obj:
						value = crex_assign_to_variable_ex(property_val, value, IS_CV, EX_USES_STRICT_TYPES(), &garbage);
						if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
							ZVAL_COPY(EX_VAR(opline->result.var), value);
						}
						goto exit_assign_obj;
					}
				}
			} else {
				name = C_STR_P(_get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC));
				if (EXPECTED(zobj->properties != NULL)) {
					if (UNEXPECTED(GC_REFCOUNT(zobj->properties) > 1)) {
						if (EXPECTED(!(GC_FLAGS(zobj->properties) & IS_ARRAY_IMMUTABLE))) {
							GC_DELREF(zobj->properties);
						}
						zobj->properties = crex_array_dup(zobj->properties);
					}
					property_val = crex_hash_find_known_hash(zobj->properties, name);
					if (property_val) {
						goto fast_assign_obj;
					}
				}

				if (!zobj->ce->__set && (zobj->ce->ce_flags & CREX_ACC_ALLOW_DYNAMIC_PROPERTIES)) {
					if (EXPECTED(zobj->properties == NULL)) {
						rebuild_object_properties(zobj);
					}
					if (IS_CV == IS_CONST) {
						if (UNEXPECTED(C_OPT_REFCOUNTED_P(value))) {
							C_ADDREF_P(value);
						}
					} else if (IS_CV != IS_TMP_VAR) {
						if (C_ISREF_P(value)) {
							if (IS_CV == IS_VAR) {
								crex_reference *ref = C_REF_P(value);
								if (GC_DELREF(ref) == 0) {
									ZVAL_COPY_VALUE(&tmp, C_REFVAL_P(value));
									efree_size(ref, sizeof(crex_reference));
									value = &tmp;
								} else {
									value = C_REFVAL_P(value);
									C_TRY_ADDREF_P(value);
								}
							} else {
								value = C_REFVAL_P(value);
								C_TRY_ADDREF_P(value);
							}
						} else if (IS_CV == IS_CV) {
							C_TRY_ADDREF_P(value);
						}
						}
					crex_hash_add_new(zobj->properties, name, value);
					if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
						ZVAL_COPY(EX_VAR(opline->result.var), value);
					}
					goto exit_assign_obj;
				}
			}
		}
		name = C_STR_P(_get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC));
	} else {
		name = zval_try_get_tmp_string(_get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC), &tmp_name);
		if (UNEXPECTED(!name)) {

			UNDEF_RESULT();
			goto exit_assign_obj;
		}
	}

	if (IS_CV == IS_CV || IS_CV == IS_VAR) {
		ZVAL_DEREF(value);
	}

	value = zobj->handlers->write_property(zobj, name, value, (IS_CV == IS_CONST) ? CACHE_ADDR(opline->extended_value) : NULL);

	if (IS_CV != IS_CONST) {
		crex_tmp_string_release(tmp_name);
	}

free_and_exit_assign_obj:
	if (UNEXPECTED(RETURN_VALUE_USED(opline)) && value) {
		ZVAL_COPY_DEREF(EX_VAR(opline->result.var), value);
	}

exit_assign_obj:
	if (garbage) {
		GC_DTOR_NO_REF(garbage);
	}


	/* assign_obj has two opcodes! */
	CREX_VM_NEXT_OPCODE_EX(1, 2);
}

/* No specialization for op_types (CONST|TMPVAR|CV, UNUSED|CONST|VAR) */
static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ASSIGN_DIM_SPEC_CV_CV_OP_DATA_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *object_ptr, *orig_object_ptr;
	zval *value;
	zval *variable_ptr;
	zval *dim;
	crex_refcounted *garbage = NULL;

	SAVE_OPLINE();
	orig_object_ptr = object_ptr = EX_VAR(opline->op1.var);

	if (EXPECTED(C_TYPE_P(object_ptr) == IS_ARRAY)) {
try_assign_dim_array:
		SEPARATE_ARRAY(object_ptr);
		if (IS_CV == IS_UNUSED) {
			value = RT_CONSTANT((opline+1), (opline+1)->op1);
			if (IS_CONST == IS_CV && UNEXPECTED(C_TYPE_P(value) == IS_UNDEF)) {
				HashTable *ht = C_ARRVAL_P(object_ptr);
				if (!(GC_FLAGS(ht) & IS_ARRAY_IMMUTABLE)) {
					GC_ADDREF(ht);
				}
				value = zval_undefined_cv((opline+1)->op1.var EXECUTE_DATA_CC);
				if (!(GC_FLAGS(ht) & IS_ARRAY_IMMUTABLE) && !GC_DELREF(ht)) {
					crex_array_destroy(ht);
					goto assign_dim_error;
				}
			}
			if (IS_CONST == IS_CV || IS_CONST == IS_VAR) {
				ZVAL_DEREF(value);
			}
			value = crex_hash_next_index_insert(C_ARRVAL_P(object_ptr), value);
			if (UNEXPECTED(value == NULL)) {
				crex_cannot_add_element();
				goto assign_dim_error;
			} else if (IS_CONST == IS_CV) {
				if (C_REFCOUNTED_P(value)) {
					C_ADDREF_P(value);
				}
			} else if (IS_CONST == IS_VAR) {
				zval *free_op_data = EX_VAR((opline+1)->op1.var);
				if (C_ISREF_P(free_op_data)) {
					if (C_REFCOUNTED_P(value)) {
						C_ADDREF_P(value);
					}
					zval_ptr_dtor_nogc(free_op_data);
				}
			} else if (IS_CONST == IS_CONST) {
				if (UNEXPECTED(C_REFCOUNTED_P(value))) {
					C_ADDREF_P(value);
				}
			}
		} else {
			dim = EX_VAR(opline->op2.var);
			if (IS_CV == IS_CONST) {
				variable_ptr = crex_fetch_dimension_address_inner_W_CONST(C_ARRVAL_P(object_ptr), dim EXECUTE_DATA_CC);
			} else {
				variable_ptr = crex_fetch_dimension_address_inner_W(C_ARRVAL_P(object_ptr), dim EXECUTE_DATA_CC);
			}
			if (UNEXPECTED(variable_ptr == NULL)) {
				goto assign_dim_error;
			}
			value = RT_CONSTANT((opline+1), (opline+1)->op1);
			value = crex_assign_to_variable_ex(variable_ptr, value, IS_CONST, EX_USES_STRICT_TYPES(), &garbage);
		}
		if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
			ZVAL_COPY(EX_VAR(opline->result.var), value);
		}
		if (garbage) {
			GC_DTOR_NO_REF(garbage);
		}
	} else {
		if (EXPECTED(C_ISREF_P(object_ptr))) {
			object_ptr = C_REFVAL_P(object_ptr);
			if (EXPECTED(C_TYPE_P(object_ptr) == IS_ARRAY)) {
				goto try_assign_dim_array;
			}
		}
		if (EXPECTED(C_TYPE_P(object_ptr) == IS_OBJECT)) {
			crex_object *obj = C_OBJ_P(object_ptr);

			GC_ADDREF(obj);
			dim = EX_VAR(opline->op2.var);
			if (IS_CV == IS_CV && UNEXPECTED(C_ISUNDEF_P(dim))) {
				dim = ZVAL_UNDEFINED_OP2();
			} else if (IS_CV == IS_CONST && C_EXTRA_P(dim) == CREX_EXTRA_VALUE) {
				dim++;
			}

			value = RT_CONSTANT((opline+1), (opline+1)->op1);
			if (IS_CONST == IS_CV && UNEXPECTED(C_ISUNDEF_P(value))) {
				value = zval_undefined_cv((opline+1)->op1.var EXECUTE_DATA_CC);
			} else if (IS_CONST & (IS_CV|IS_VAR)) {
				ZVAL_DEREF(value);
			}

			crex_assign_to_object_dim(obj, dim, value OPLINE_CC EXECUTE_DATA_CC);

			if (UNEXPECTED(GC_DELREF(obj) == 0)) {
				crex_objects_store_del(obj);
			}
		} else if (EXPECTED(C_TYPE_P(object_ptr) == IS_STRING)) {
			if (IS_CV == IS_UNUSED) {
				crex_use_new_element_for_string();

				UNDEF_RESULT();
			} else {
				dim = EX_VAR(opline->op2.var);
				value = RT_CONSTANT((opline+1), (opline+1)->op1);
				crex_assign_to_string_offset(object_ptr, dim, value OPLINE_CC EXECUTE_DATA_CC);

			}
		} else if (EXPECTED(C_TYPE_P(object_ptr) <= IS_FALSE)) {
			if (C_ISREF_P(orig_object_ptr)
			 && CREX_REF_HAS_TYPE_SOURCES(C_REF_P(orig_object_ptr))
			 && !crex_verify_ref_array_assignable(C_REF_P(orig_object_ptr))) {
				dim = _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC);

				UNDEF_RESULT();
			} else {
				HashTable *ht = crex_new_array(8);
				uint8_t old_type = C_TYPE_P(object_ptr);

				ZVAL_ARR(object_ptr, ht);
				if (UNEXPECTED(old_type == IS_FALSE)) {
					GC_ADDREF(ht);
					crex_false_to_array_deprecated();
					if (UNEXPECTED(GC_DELREF(ht) == 0)) {
						crex_array_destroy(ht);
						goto assign_dim_error;
					}
				}
				goto try_assign_dim_array;
			}
		} else {
			crex_use_scalar_as_array();
			dim = _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC);
assign_dim_error:

			if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
				ZVAL_NULL(EX_VAR(opline->result.var));
			}
		}
	}
	if (IS_CV != IS_UNUSED) {

	}

	/* assign_dim has two opcodes! */
	CREX_VM_NEXT_OPCODE_EX(1, 2);
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ASSIGN_DIM_SPEC_CV_CV_OP_DATA_TMP_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *object_ptr, *orig_object_ptr;
	zval *value;
	zval *variable_ptr;
	zval *dim;
	crex_refcounted *garbage = NULL;

	SAVE_OPLINE();
	orig_object_ptr = object_ptr = EX_VAR(opline->op1.var);

	if (EXPECTED(C_TYPE_P(object_ptr) == IS_ARRAY)) {
try_assign_dim_array:
		SEPARATE_ARRAY(object_ptr);
		if (IS_CV == IS_UNUSED) {
			value = _get_zval_ptr_tmp((opline+1)->op1.var EXECUTE_DATA_CC);
			if (IS_TMP_VAR == IS_CV && UNEXPECTED(C_TYPE_P(value) == IS_UNDEF)) {
				HashTable *ht = C_ARRVAL_P(object_ptr);
				if (!(GC_FLAGS(ht) & IS_ARRAY_IMMUTABLE)) {
					GC_ADDREF(ht);
				}
				value = zval_undefined_cv((opline+1)->op1.var EXECUTE_DATA_CC);
				if (!(GC_FLAGS(ht) & IS_ARRAY_IMMUTABLE) && !GC_DELREF(ht)) {
					crex_array_destroy(ht);
					goto assign_dim_error;
				}
			}
			if (IS_TMP_VAR == IS_CV || IS_TMP_VAR == IS_VAR) {
				ZVAL_DEREF(value);
			}
			value = crex_hash_next_index_insert(C_ARRVAL_P(object_ptr), value);
			if (UNEXPECTED(value == NULL)) {
				crex_cannot_add_element();
				goto assign_dim_error;
			} else if (IS_TMP_VAR == IS_CV) {
				if (C_REFCOUNTED_P(value)) {
					C_ADDREF_P(value);
				}
			} else if (IS_TMP_VAR == IS_VAR) {
				zval *free_op_data = EX_VAR((opline+1)->op1.var);
				if (C_ISREF_P(free_op_data)) {
					if (C_REFCOUNTED_P(value)) {
						C_ADDREF_P(value);
					}
					zval_ptr_dtor_nogc(free_op_data);
				}
			} else if (IS_TMP_VAR == IS_CONST) {
				if (UNEXPECTED(C_REFCOUNTED_P(value))) {
					C_ADDREF_P(value);
				}
			}
		} else {
			dim = EX_VAR(opline->op2.var);
			if (IS_CV == IS_CONST) {
				variable_ptr = crex_fetch_dimension_address_inner_W_CONST(C_ARRVAL_P(object_ptr), dim EXECUTE_DATA_CC);
			} else {
				variable_ptr = crex_fetch_dimension_address_inner_W(C_ARRVAL_P(object_ptr), dim EXECUTE_DATA_CC);
			}
			if (UNEXPECTED(variable_ptr == NULL)) {
				goto assign_dim_error;
			}
			value = _get_zval_ptr_tmp((opline+1)->op1.var EXECUTE_DATA_CC);
			value = crex_assign_to_variable_ex(variable_ptr, value, IS_TMP_VAR, EX_USES_STRICT_TYPES(), &garbage);
		}
		if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
			ZVAL_COPY(EX_VAR(opline->result.var), value);
		}
		if (garbage) {
			GC_DTOR_NO_REF(garbage);
		}
	} else {
		if (EXPECTED(C_ISREF_P(object_ptr))) {
			object_ptr = C_REFVAL_P(object_ptr);
			if (EXPECTED(C_TYPE_P(object_ptr) == IS_ARRAY)) {
				goto try_assign_dim_array;
			}
		}
		if (EXPECTED(C_TYPE_P(object_ptr) == IS_OBJECT)) {
			crex_object *obj = C_OBJ_P(object_ptr);

			GC_ADDREF(obj);
			dim = EX_VAR(opline->op2.var);
			if (IS_CV == IS_CV && UNEXPECTED(C_ISUNDEF_P(dim))) {
				dim = ZVAL_UNDEFINED_OP2();
			} else if (IS_CV == IS_CONST && C_EXTRA_P(dim) == CREX_EXTRA_VALUE) {
				dim++;
			}

			value = _get_zval_ptr_tmp((opline+1)->op1.var EXECUTE_DATA_CC);
			if (IS_TMP_VAR == IS_CV && UNEXPECTED(C_ISUNDEF_P(value))) {
				value = zval_undefined_cv((opline+1)->op1.var EXECUTE_DATA_CC);
			} else if (IS_TMP_VAR & (IS_CV|IS_VAR)) {
				ZVAL_DEREF(value);
			}

			crex_assign_to_object_dim(obj, dim, value OPLINE_CC EXECUTE_DATA_CC);

			zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
			if (UNEXPECTED(GC_DELREF(obj) == 0)) {
				crex_objects_store_del(obj);
			}
		} else if (EXPECTED(C_TYPE_P(object_ptr) == IS_STRING)) {
			if (IS_CV == IS_UNUSED) {
				crex_use_new_element_for_string();
				zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
				UNDEF_RESULT();
			} else {
				dim = EX_VAR(opline->op2.var);
				value = _get_zval_ptr_tmp((opline+1)->op1.var EXECUTE_DATA_CC);
				crex_assign_to_string_offset(object_ptr, dim, value OPLINE_CC EXECUTE_DATA_CC);
				zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
			}
		} else if (EXPECTED(C_TYPE_P(object_ptr) <= IS_FALSE)) {
			if (C_ISREF_P(orig_object_ptr)
			 && CREX_REF_HAS_TYPE_SOURCES(C_REF_P(orig_object_ptr))
			 && !crex_verify_ref_array_assignable(C_REF_P(orig_object_ptr))) {
				dim = _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC);
				zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
				UNDEF_RESULT();
			} else {
				HashTable *ht = crex_new_array(8);
				uint8_t old_type = C_TYPE_P(object_ptr);

				ZVAL_ARR(object_ptr, ht);
				if (UNEXPECTED(old_type == IS_FALSE)) {
					GC_ADDREF(ht);
					crex_false_to_array_deprecated();
					if (UNEXPECTED(GC_DELREF(ht) == 0)) {
						crex_array_destroy(ht);
						goto assign_dim_error;
					}
				}
				goto try_assign_dim_array;
			}
		} else {
			crex_use_scalar_as_array();
			dim = _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC);
assign_dim_error:
			zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
			if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
				ZVAL_NULL(EX_VAR(opline->result.var));
			}
		}
	}
	if (IS_CV != IS_UNUSED) {

	}

	/* assign_dim has two opcodes! */
	CREX_VM_NEXT_OPCODE_EX(1, 2);
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ASSIGN_DIM_SPEC_CV_CV_OP_DATA_VAR_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *object_ptr, *orig_object_ptr;
	zval *value;
	zval *variable_ptr;
	zval *dim;
	crex_refcounted *garbage = NULL;

	SAVE_OPLINE();
	orig_object_ptr = object_ptr = EX_VAR(opline->op1.var);

	if (EXPECTED(C_TYPE_P(object_ptr) == IS_ARRAY)) {
try_assign_dim_array:
		SEPARATE_ARRAY(object_ptr);
		if (IS_CV == IS_UNUSED) {
			value = _get_zval_ptr_var((opline+1)->op1.var EXECUTE_DATA_CC);
			if (IS_VAR == IS_CV && UNEXPECTED(C_TYPE_P(value) == IS_UNDEF)) {
				HashTable *ht = C_ARRVAL_P(object_ptr);
				if (!(GC_FLAGS(ht) & IS_ARRAY_IMMUTABLE)) {
					GC_ADDREF(ht);
				}
				value = zval_undefined_cv((opline+1)->op1.var EXECUTE_DATA_CC);
				if (!(GC_FLAGS(ht) & IS_ARRAY_IMMUTABLE) && !GC_DELREF(ht)) {
					crex_array_destroy(ht);
					goto assign_dim_error;
				}
			}
			if (IS_VAR == IS_CV || IS_VAR == IS_VAR) {
				ZVAL_DEREF(value);
			}
			value = crex_hash_next_index_insert(C_ARRVAL_P(object_ptr), value);
			if (UNEXPECTED(value == NULL)) {
				crex_cannot_add_element();
				goto assign_dim_error;
			} else if (IS_VAR == IS_CV) {
				if (C_REFCOUNTED_P(value)) {
					C_ADDREF_P(value);
				}
			} else if (IS_VAR == IS_VAR) {
				zval *free_op_data = EX_VAR((opline+1)->op1.var);
				if (C_ISREF_P(free_op_data)) {
					if (C_REFCOUNTED_P(value)) {
						C_ADDREF_P(value);
					}
					zval_ptr_dtor_nogc(free_op_data);
				}
			} else if (IS_VAR == IS_CONST) {
				if (UNEXPECTED(C_REFCOUNTED_P(value))) {
					C_ADDREF_P(value);
				}
			}
		} else {
			dim = EX_VAR(opline->op2.var);
			if (IS_CV == IS_CONST) {
				variable_ptr = crex_fetch_dimension_address_inner_W_CONST(C_ARRVAL_P(object_ptr), dim EXECUTE_DATA_CC);
			} else {
				variable_ptr = crex_fetch_dimension_address_inner_W(C_ARRVAL_P(object_ptr), dim EXECUTE_DATA_CC);
			}
			if (UNEXPECTED(variable_ptr == NULL)) {
				goto assign_dim_error;
			}
			value = _get_zval_ptr_var((opline+1)->op1.var EXECUTE_DATA_CC);
			value = crex_assign_to_variable_ex(variable_ptr, value, IS_VAR, EX_USES_STRICT_TYPES(), &garbage);
		}
		if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
			ZVAL_COPY(EX_VAR(opline->result.var), value);
		}
		if (garbage) {
			GC_DTOR_NO_REF(garbage);
		}
	} else {
		if (EXPECTED(C_ISREF_P(object_ptr))) {
			object_ptr = C_REFVAL_P(object_ptr);
			if (EXPECTED(C_TYPE_P(object_ptr) == IS_ARRAY)) {
				goto try_assign_dim_array;
			}
		}
		if (EXPECTED(C_TYPE_P(object_ptr) == IS_OBJECT)) {
			crex_object *obj = C_OBJ_P(object_ptr);

			GC_ADDREF(obj);
			dim = EX_VAR(opline->op2.var);
			if (IS_CV == IS_CV && UNEXPECTED(C_ISUNDEF_P(dim))) {
				dim = ZVAL_UNDEFINED_OP2();
			} else if (IS_CV == IS_CONST && C_EXTRA_P(dim) == CREX_EXTRA_VALUE) {
				dim++;
			}

			value = _get_zval_ptr_var((opline+1)->op1.var EXECUTE_DATA_CC);
			if (IS_VAR == IS_CV && UNEXPECTED(C_ISUNDEF_P(value))) {
				value = zval_undefined_cv((opline+1)->op1.var EXECUTE_DATA_CC);
			} else if (IS_VAR & (IS_CV|IS_VAR)) {
				ZVAL_DEREF(value);
			}

			crex_assign_to_object_dim(obj, dim, value OPLINE_CC EXECUTE_DATA_CC);

			zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
			if (UNEXPECTED(GC_DELREF(obj) == 0)) {
				crex_objects_store_del(obj);
			}
		} else if (EXPECTED(C_TYPE_P(object_ptr) == IS_STRING)) {
			if (IS_CV == IS_UNUSED) {
				crex_use_new_element_for_string();
				zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
				UNDEF_RESULT();
			} else {
				dim = EX_VAR(opline->op2.var);
				value = _get_zval_ptr_var((opline+1)->op1.var EXECUTE_DATA_CC);
				crex_assign_to_string_offset(object_ptr, dim, value OPLINE_CC EXECUTE_DATA_CC);
				zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
			}
		} else if (EXPECTED(C_TYPE_P(object_ptr) <= IS_FALSE)) {
			if (C_ISREF_P(orig_object_ptr)
			 && CREX_REF_HAS_TYPE_SOURCES(C_REF_P(orig_object_ptr))
			 && !crex_verify_ref_array_assignable(C_REF_P(orig_object_ptr))) {
				dim = _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC);
				zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
				UNDEF_RESULT();
			} else {
				HashTable *ht = crex_new_array(8);
				uint8_t old_type = C_TYPE_P(object_ptr);

				ZVAL_ARR(object_ptr, ht);
				if (UNEXPECTED(old_type == IS_FALSE)) {
					GC_ADDREF(ht);
					crex_false_to_array_deprecated();
					if (UNEXPECTED(GC_DELREF(ht) == 0)) {
						crex_array_destroy(ht);
						goto assign_dim_error;
					}
				}
				goto try_assign_dim_array;
			}
		} else {
			crex_use_scalar_as_array();
			dim = _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC);
assign_dim_error:
			zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
			if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
				ZVAL_NULL(EX_VAR(opline->result.var));
			}
		}
	}
	if (IS_CV != IS_UNUSED) {

	}

	/* assign_dim has two opcodes! */
	CREX_VM_NEXT_OPCODE_EX(1, 2);
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ASSIGN_DIM_SPEC_CV_CV_OP_DATA_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *object_ptr, *orig_object_ptr;
	zval *value;
	zval *variable_ptr;
	zval *dim;
	crex_refcounted *garbage = NULL;

	SAVE_OPLINE();
	orig_object_ptr = object_ptr = EX_VAR(opline->op1.var);

	if (EXPECTED(C_TYPE_P(object_ptr) == IS_ARRAY)) {
try_assign_dim_array:
		SEPARATE_ARRAY(object_ptr);
		if (IS_CV == IS_UNUSED) {
			value = EX_VAR((opline+1)->op1.var);
			if (IS_CV == IS_CV && UNEXPECTED(C_TYPE_P(value) == IS_UNDEF)) {
				HashTable *ht = C_ARRVAL_P(object_ptr);
				if (!(GC_FLAGS(ht) & IS_ARRAY_IMMUTABLE)) {
					GC_ADDREF(ht);
				}
				value = zval_undefined_cv((opline+1)->op1.var EXECUTE_DATA_CC);
				if (!(GC_FLAGS(ht) & IS_ARRAY_IMMUTABLE) && !GC_DELREF(ht)) {
					crex_array_destroy(ht);
					goto assign_dim_error;
				}
			}
			if (IS_CV == IS_CV || IS_CV == IS_VAR) {
				ZVAL_DEREF(value);
			}
			value = crex_hash_next_index_insert(C_ARRVAL_P(object_ptr), value);
			if (UNEXPECTED(value == NULL)) {
				crex_cannot_add_element();
				goto assign_dim_error;
			} else if (IS_CV == IS_CV) {
				if (C_REFCOUNTED_P(value)) {
					C_ADDREF_P(value);
				}
			} else if (IS_CV == IS_VAR) {
				zval *free_op_data = EX_VAR((opline+1)->op1.var);
				if (C_ISREF_P(free_op_data)) {
					if (C_REFCOUNTED_P(value)) {
						C_ADDREF_P(value);
					}
					zval_ptr_dtor_nogc(free_op_data);
				}
			} else if (IS_CV == IS_CONST) {
				if (UNEXPECTED(C_REFCOUNTED_P(value))) {
					C_ADDREF_P(value);
				}
			}
		} else {
			dim = EX_VAR(opline->op2.var);
			if (IS_CV == IS_CONST) {
				variable_ptr = crex_fetch_dimension_address_inner_W_CONST(C_ARRVAL_P(object_ptr), dim EXECUTE_DATA_CC);
			} else {
				variable_ptr = crex_fetch_dimension_address_inner_W(C_ARRVAL_P(object_ptr), dim EXECUTE_DATA_CC);
			}
			if (UNEXPECTED(variable_ptr == NULL)) {
				goto assign_dim_error;
			}
			value = _get_zval_ptr_cv_BP_VAR_R((opline+1)->op1.var EXECUTE_DATA_CC);
			value = crex_assign_to_variable_ex(variable_ptr, value, IS_CV, EX_USES_STRICT_TYPES(), &garbage);
		}
		if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
			ZVAL_COPY(EX_VAR(opline->result.var), value);
		}
		if (garbage) {
			GC_DTOR_NO_REF(garbage);
		}
	} else {
		if (EXPECTED(C_ISREF_P(object_ptr))) {
			object_ptr = C_REFVAL_P(object_ptr);
			if (EXPECTED(C_TYPE_P(object_ptr) == IS_ARRAY)) {
				goto try_assign_dim_array;
			}
		}
		if (EXPECTED(C_TYPE_P(object_ptr) == IS_OBJECT)) {
			crex_object *obj = C_OBJ_P(object_ptr);

			GC_ADDREF(obj);
			dim = EX_VAR(opline->op2.var);
			if (IS_CV == IS_CV && UNEXPECTED(C_ISUNDEF_P(dim))) {
				dim = ZVAL_UNDEFINED_OP2();
			} else if (IS_CV == IS_CONST && C_EXTRA_P(dim) == CREX_EXTRA_VALUE) {
				dim++;
			}

			value = EX_VAR((opline+1)->op1.var);
			if (IS_CV == IS_CV && UNEXPECTED(C_ISUNDEF_P(value))) {
				value = zval_undefined_cv((opline+1)->op1.var EXECUTE_DATA_CC);
			} else if (IS_CV & (IS_CV|IS_VAR)) {
				ZVAL_DEREF(value);
			}

			crex_assign_to_object_dim(obj, dim, value OPLINE_CC EXECUTE_DATA_CC);

			if (UNEXPECTED(GC_DELREF(obj) == 0)) {
				crex_objects_store_del(obj);
			}
		} else if (EXPECTED(C_TYPE_P(object_ptr) == IS_STRING)) {
			if (IS_CV == IS_UNUSED) {
				crex_use_new_element_for_string();

				UNDEF_RESULT();
			} else {
				dim = EX_VAR(opline->op2.var);
				value = EX_VAR((opline+1)->op1.var);
				crex_assign_to_string_offset(object_ptr, dim, value OPLINE_CC EXECUTE_DATA_CC);

			}
		} else if (EXPECTED(C_TYPE_P(object_ptr) <= IS_FALSE)) {
			if (C_ISREF_P(orig_object_ptr)
			 && CREX_REF_HAS_TYPE_SOURCES(C_REF_P(orig_object_ptr))
			 && !crex_verify_ref_array_assignable(C_REF_P(orig_object_ptr))) {
				dim = _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC);

				UNDEF_RESULT();
			} else {
				HashTable *ht = crex_new_array(8);
				uint8_t old_type = C_TYPE_P(object_ptr);

				ZVAL_ARR(object_ptr, ht);
				if (UNEXPECTED(old_type == IS_FALSE)) {
					GC_ADDREF(ht);
					crex_false_to_array_deprecated();
					if (UNEXPECTED(GC_DELREF(ht) == 0)) {
						crex_array_destroy(ht);
						goto assign_dim_error;
					}
				}
				goto try_assign_dim_array;
			}
		} else {
			crex_use_scalar_as_array();
			dim = _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC);
assign_dim_error:

			if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
				ZVAL_NULL(EX_VAR(opline->result.var));
			}
		}
	}
	if (IS_CV != IS_UNUSED) {

	}

	/* assign_dim has two opcodes! */
	CREX_VM_NEXT_OPCODE_EX(1, 2);
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ASSIGN_SPEC_CV_CV_RETVAL_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *value;
	zval *variable_ptr;

	SAVE_OPLINE();
	value = _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC);
	variable_ptr = EX_VAR(opline->op1.var);

	if (0 || UNEXPECTED(0)) {
		crex_refcounted *garbage = NULL;

		value = crex_assign_to_variable_ex(variable_ptr, value, IS_CV, EX_USES_STRICT_TYPES(), &garbage);
		if (UNEXPECTED(0)) {
			ZVAL_COPY(EX_VAR(opline->result.var), value);
		}
		if (garbage) {
			GC_DTOR_NO_REF(garbage);
		}
	} else {
		value = crex_assign_to_variable(variable_ptr, value, IS_CV, EX_USES_STRICT_TYPES());
	}

	/* crex_assign_to_variable() always takes care of op2, never free it! */

	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ASSIGN_SPEC_CV_CV_RETVAL_USED_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *value;
	zval *variable_ptr;

	SAVE_OPLINE();
	value = _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC);
	variable_ptr = EX_VAR(opline->op1.var);

	if (0 || UNEXPECTED(1)) {
		crex_refcounted *garbage = NULL;

		value = crex_assign_to_variable_ex(variable_ptr, value, IS_CV, EX_USES_STRICT_TYPES(), &garbage);
		if (UNEXPECTED(1)) {
			ZVAL_COPY(EX_VAR(opline->result.var), value);
		}
		if (garbage) {
			GC_DTOR_NO_REF(garbage);
		}
	} else {
		value = crex_assign_to_variable(variable_ptr, value, IS_CV, EX_USES_STRICT_TYPES());
	}

	/* crex_assign_to_variable() always takes care of op2, never free it! */

	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ASSIGN_REF_SPEC_CV_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *variable_ptr;
	zval *value_ptr;
	crex_refcounted *garbage = NULL;

	SAVE_OPLINE();
	value_ptr = _get_zval_ptr_cv_BP_VAR_W(opline->op2.var EXECUTE_DATA_CC);
	variable_ptr = EX_VAR(opline->op1.var);

	if (IS_CV == IS_VAR &&
	           UNEXPECTED(C_TYPE_P(EX_VAR(opline->op1.var)) != IS_INDIRECT)) {

		crex_throw_error(NULL, "Cannot assign by reference to an array dimension of an object");
		variable_ptr = &EG(uninitialized_zval);
	} else if (IS_CV == IS_VAR &&
	           opline->extended_value == CREX_RETURNS_FUNCTION &&
			   UNEXPECTED(!C_ISREF_P(value_ptr))) {

		variable_ptr = crex_wrong_assign_to_variable_reference(
			variable_ptr, value_ptr, &garbage OPLINE_CC EXECUTE_DATA_CC);
	} else {
		crex_assign_to_variable_reference(variable_ptr, value_ptr, &garbage);
	}

	if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
		ZVAL_COPY(EX_VAR(opline->result.var), variable_ptr);
	}

	if (garbage) {
		GC_DTOR(garbage);
	}


	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ASSIGN_OBJ_REF_SPEC_CV_CV_OP_DATA_VAR_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *property, *container, *value_ptr;

	SAVE_OPLINE();

	container = EX_VAR(opline->op1.var);
	property = _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC);

	value_ptr = _get_zval_ptr_ptr_var((opline+1)->op1.var EXECUTE_DATA_CC);

	if (1) {
		if (IS_CV == IS_UNUSED) {
			if (IS_CV == IS_CONST) {
				crex_assign_to_property_reference_this_const(container, property, value_ptr OPLINE_CC EXECUTE_DATA_CC);
			} else {
				crex_assign_to_property_reference_this_var(container, property, value_ptr OPLINE_CC EXECUTE_DATA_CC);
			}
		} else {
			if (IS_CV == IS_CONST) {
				crex_assign_to_property_reference_var_const(container, property, value_ptr OPLINE_CC EXECUTE_DATA_CC);
			} else {
				crex_assign_to_property_reference_var_var(container, property, value_ptr OPLINE_CC EXECUTE_DATA_CC);
			}
		}
	} else {
		crex_assign_to_property_reference(container, IS_CV, property, IS_CV, value_ptr OPLINE_CC EXECUTE_DATA_CC);
	}


	zval_ptr_dtor_nogc(EX_VAR((opline+1)->op1.var));
	CREX_VM_NEXT_OPCODE_EX(1, 2);
}

/* No specialization for op_types (CONST|TMPVAR|CV, UNUSED|CONST|VAR) */
static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ASSIGN_OBJ_REF_SPEC_CV_CV_OP_DATA_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *property, *container, *value_ptr;

	SAVE_OPLINE();

	container = EX_VAR(opline->op1.var);
	property = _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC);

	value_ptr = _get_zval_ptr_cv_BP_VAR_W((opline+1)->op1.var EXECUTE_DATA_CC);

	if (1) {
		if (IS_CV == IS_UNUSED) {
			if (IS_CV == IS_CONST) {
				crex_assign_to_property_reference_this_const(container, property, value_ptr OPLINE_CC EXECUTE_DATA_CC);
			} else {
				crex_assign_to_property_reference_this_var(container, property, value_ptr OPLINE_CC EXECUTE_DATA_CC);
			}
		} else {
			if (IS_CV == IS_CONST) {
				crex_assign_to_property_reference_var_const(container, property, value_ptr OPLINE_CC EXECUTE_DATA_CC);
			} else {
				crex_assign_to_property_reference_var_var(container, property, value_ptr OPLINE_CC EXECUTE_DATA_CC);
			}
		}
	} else {
		crex_assign_to_property_reference(container, IS_CV, property, IS_CV, value_ptr OPLINE_CC EXECUTE_DATA_CC);
	}



	CREX_VM_NEXT_OPCODE_EX(1, 2);
}

/* No specialization for op_types (CONST|TMPVAR|CV, UNUSED|CONST|VAR) */
static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_FAST_CONCAT_SPEC_CV_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	crex_string *op1_str, *op2_str, *str;


	op1 = EX_VAR(opline->op1.var);
	op2 = EX_VAR(opline->op2.var);
	if ((IS_CV == IS_CONST || EXPECTED(C_TYPE_P(op1) == IS_STRING)) &&
	    (IS_CV == IS_CONST || EXPECTED(C_TYPE_P(op2) == IS_STRING))) {
		crex_string *op1_str = C_STR_P(op1);
		crex_string *op2_str = C_STR_P(op2);
		crex_string *str;
		uint32_t flags = ZSTR_GET_COPYABLE_CONCAT_PROPERTIES_BOTH(op1_str, op2_str);

		if (IS_CV != IS_CONST && UNEXPECTED(ZSTR_LEN(op1_str) == 0)) {
			if (IS_CV == IS_CONST || IS_CV == IS_CV) {
				ZVAL_STR_COPY(EX_VAR(opline->result.var), op2_str);
			} else {
				ZVAL_STR(EX_VAR(opline->result.var), op2_str);
			}
			if (IS_CV & (IS_TMP_VAR|IS_VAR)) {
				crex_string_release_ex(op1_str, 0);
			}
		} else if (IS_CV != IS_CONST && UNEXPECTED(ZSTR_LEN(op2_str) == 0)) {
			if (IS_CV == IS_CONST || IS_CV == IS_CV) {
				ZVAL_STR_COPY(EX_VAR(opline->result.var), op1_str);
			} else {
				ZVAL_STR(EX_VAR(opline->result.var), op1_str);
			}
			if (IS_CV & (IS_TMP_VAR|IS_VAR)) {
				crex_string_release_ex(op2_str, 0);
			}
		} else if (IS_CV != IS_CONST && IS_CV != IS_CV &&
		    !ZSTR_IS_INTERNED(op1_str) && GC_REFCOUNT(op1_str) == 1) {
			size_t len = ZSTR_LEN(op1_str);

			str = crex_string_extend(op1_str, len + ZSTR_LEN(op2_str), 0);
			memcpy(ZSTR_VAL(str) + len, ZSTR_VAL(op2_str), ZSTR_LEN(op2_str)+1);
			GC_ADD_FLAGS(str, flags);
			ZVAL_NEW_STR(EX_VAR(opline->result.var), str);
			if (IS_CV & (IS_TMP_VAR|IS_VAR)) {
				crex_string_release_ex(op2_str, 0);
			}
		} else {
			str = crex_string_alloc(ZSTR_LEN(op1_str) + ZSTR_LEN(op2_str), 0);
			memcpy(ZSTR_VAL(str), ZSTR_VAL(op1_str), ZSTR_LEN(op1_str));
			memcpy(ZSTR_VAL(str) + ZSTR_LEN(op1_str), ZSTR_VAL(op2_str), ZSTR_LEN(op2_str)+1);
			GC_ADD_FLAGS(str, flags);
			ZVAL_NEW_STR(EX_VAR(opline->result.var), str);
			if (IS_CV & (IS_TMP_VAR|IS_VAR)) {
				crex_string_release_ex(op1_str, 0);
			}
			if (IS_CV & (IS_TMP_VAR|IS_VAR)) {
				crex_string_release_ex(op2_str, 0);
			}
		}
		CREX_VM_NEXT_OPCODE();
	}

	SAVE_OPLINE();
	if (IS_CV == IS_CONST) {
		op1_str = C_STR_P(op1);
	} else if (EXPECTED(C_TYPE_P(op1) == IS_STRING)) {
		op1_str = crex_string_copy(C_STR_P(op1));
	} else {
		if (IS_CV == IS_CV && UNEXPECTED(C_TYPE_P(op1) == IS_UNDEF)) {
			ZVAL_UNDEFINED_OP1();
		}
		op1_str = zval_get_string_func(op1);
	}
	if (IS_CV == IS_CONST) {
		op2_str = C_STR_P(op2);
	} else if (EXPECTED(C_TYPE_P(op2) == IS_STRING)) {
		op2_str = crex_string_copy(C_STR_P(op2));
	} else {
		if (IS_CV == IS_CV && UNEXPECTED(C_TYPE_P(op2) == IS_UNDEF)) {
			ZVAL_UNDEFINED_OP2();
		}
		op2_str = zval_get_string_func(op2);
	}
	do {
		if (IS_CV != IS_CONST) {
			if (UNEXPECTED(ZSTR_LEN(op1_str) == 0)) {
				if (IS_CV == IS_CONST) {
					if (UNEXPECTED(C_REFCOUNTED_P(op2))) {
						GC_ADDREF(op2_str);
					}
				}
				ZVAL_STR(EX_VAR(opline->result.var), op2_str);
				crex_string_release_ex(op1_str, 0);
				break;
			}
		}
		if (IS_CV != IS_CONST) {
			if (UNEXPECTED(ZSTR_LEN(op2_str) == 0)) {
				if (IS_CV == IS_CONST) {
					if (UNEXPECTED(C_REFCOUNTED_P(op1))) {
						GC_ADDREF(op1_str);
					}
				}
				ZVAL_STR(EX_VAR(opline->result.var), op1_str);
				crex_string_release_ex(op2_str, 0);
				break;
			}
		}
		str = crex_string_alloc(ZSTR_LEN(op1_str) + ZSTR_LEN(op2_str), 0);
		memcpy(ZSTR_VAL(str), ZSTR_VAL(op1_str), ZSTR_LEN(op1_str));
		memcpy(ZSTR_VAL(str) + ZSTR_LEN(op1_str), ZSTR_VAL(op2_str), ZSTR_LEN(op2_str)+1);

		ZSTR_COPY_CONCAT_PROPERTIES_BOTH(str, op1_str, op2_str);
		ZVAL_NEW_STR(EX_VAR(opline->result.var), str);
		if (IS_CV != IS_CONST) {
			crex_string_release_ex(op1_str, 0);
		}
		if (IS_CV != IS_CONST) {
			crex_string_release_ex(op2_str, 0);
		}
	} while (0);


	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_INIT_METHOD_CALL_SPEC_CV_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *function_name;
	zval *object;
	crex_function *fbc;
	crex_class_entry *called_scope;
	crex_object *obj;
	crex_execute_data *call;
	uint32_t call_info;

	SAVE_OPLINE();

	object = EX_VAR(opline->op1.var);

	if (IS_CV != IS_CONST) {
		function_name = EX_VAR(opline->op2.var);
	}

	if (IS_CV != IS_CONST &&
	    UNEXPECTED(C_TYPE_P(function_name) != IS_STRING)) {
		do {
			if ((IS_CV & (IS_VAR|IS_CV)) && C_ISREF_P(function_name)) {
				function_name = C_REFVAL_P(function_name);
				if (EXPECTED(C_TYPE_P(function_name) == IS_STRING)) {
					break;
				}
			} else if (IS_CV == IS_CV && UNEXPECTED(C_TYPE_P(function_name) == IS_UNDEF)) {
				ZVAL_UNDEFINED_OP2();
				if (UNEXPECTED(EG(exception) != NULL)) {

					HANDLE_EXCEPTION();
				}
			}
			crex_throw_error(NULL, "Method name must be a string");


			HANDLE_EXCEPTION();
		} while (0);
	}

	if (IS_CV == IS_UNUSED) {
		obj = C_OBJ_P(object);
	} else {
		do {
			if (IS_CV != IS_CONST && EXPECTED(C_TYPE_P(object) == IS_OBJECT)) {
				obj = C_OBJ_P(object);
			} else {
				if ((IS_CV & (IS_VAR|IS_CV)) && EXPECTED(C_ISREF_P(object))) {
					crex_reference *ref = C_REF_P(object);

					object = &ref->val;
					if (EXPECTED(C_TYPE_P(object) == IS_OBJECT)) {
						obj = C_OBJ_P(object);
						if (IS_CV & IS_VAR) {
							if (UNEXPECTED(GC_DELREF(ref) == 0)) {
								efree_size(ref, sizeof(crex_reference));
							} else {
								C_ADDREF_P(object);
							}
						}
						break;
					}
				}
				if (IS_CV == IS_CV && UNEXPECTED(C_TYPE_P(object) == IS_UNDEF)) {
					object = ZVAL_UNDEFINED_OP1();
					if (UNEXPECTED(EG(exception) != NULL)) {
						if (IS_CV != IS_CONST) {

						}
						HANDLE_EXCEPTION();
					}
				}
				if (IS_CV == IS_CONST) {
					function_name = EX_VAR(opline->op2.var);
				}
				crex_invalid_method_call(object, function_name);


				HANDLE_EXCEPTION();
			}
		} while (0);
	}

	called_scope = obj->ce;

	if (IS_CV == IS_CONST &&
	    EXPECTED(CACHED_PTR(opline->result.num) == called_scope)) {
		fbc = CACHED_PTR(opline->result.num + sizeof(void*));
	} else {
		crex_object *orig_obj = obj;

		if (IS_CV == IS_CONST) {
			function_name = EX_VAR(opline->op2.var);
		}

		/* First, locate the function. */
		fbc = obj->handlers->get_method(&obj, C_STR_P(function_name), ((IS_CV == IS_CONST) ? (RT_CONSTANT(opline, opline->op2) + 1) : NULL));
		if (UNEXPECTED(fbc == NULL)) {
			if (EXPECTED(!EG(exception))) {
				crex_undefined_method(obj->ce, C_STR_P(function_name));
			}

			if ((IS_CV & (IS_VAR|IS_TMP_VAR)) && GC_DELREF(orig_obj) == 0) {
				crex_objects_store_del(orig_obj);
			}
			HANDLE_EXCEPTION();
		}
		if (IS_CV == IS_CONST &&
		    EXPECTED(!(fbc->common.fn_flags & (CREX_ACC_CALL_VIA_TRAMPOLINE|CREX_ACC_NEVER_CACHE))) &&
		    EXPECTED(obj == orig_obj)) {
			CACHE_POLYMORPHIC_PTR(opline->result.num, called_scope, fbc);
		}
		if ((IS_CV & (IS_VAR|IS_TMP_VAR)) && UNEXPECTED(obj != orig_obj)) {
			GC_ADDREF(obj); /* For $this pointer */
			if (GC_DELREF(orig_obj) == 0) {
				crex_objects_store_del(orig_obj);
			}
		}
		if (EXPECTED(fbc->type == CREX_USER_FUNCTION) && UNEXPECTED(!RUN_TIME_CACHE(&fbc->op_array))) {
			init_func_run_time_cache(&fbc->op_array);
		}
	}

	if (IS_CV != IS_CONST) {

	}

	call_info = CREX_CALL_NESTED_FUNCTION | CREX_CALL_HAS_THIS;
	if (UNEXPECTED((fbc->common.fn_flags & CREX_ACC_STATIC) != 0)) {
		if ((IS_CV & (IS_VAR|IS_TMP_VAR)) && GC_DELREF(obj) == 0) {
			crex_objects_store_del(obj);
			if (UNEXPECTED(EG(exception))) {
				HANDLE_EXCEPTION();
			}
		}
		/* call static method */
		obj = (crex_object*)called_scope;
		call_info = CREX_CALL_NESTED_FUNCTION;
	} else if (IS_CV & (IS_VAR|IS_TMP_VAR|IS_CV)) {
		if (IS_CV == IS_CV) {
			GC_ADDREF(obj); /* For $this pointer */
		}
		/* CV may be changed indirectly (e.g. when it's a reference) */
		call_info = CREX_CALL_NESTED_FUNCTION | CREX_CALL_HAS_THIS | CREX_CALL_RELEASE_THIS;
	}

	call = crex_vm_stack_push_call_frame(call_info,
		fbc, opline->extended_value, obj);
	call->prev_execute_data = EX(call);
	EX(call) = call;

	CREX_VM_NEXT_OPCODE();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ADD_ARRAY_ELEMENT_SPEC_CV_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *expr_ptr, new_expr;

	SAVE_OPLINE();
	if ((IS_CV == IS_VAR || IS_CV == IS_CV) &&
	    UNEXPECTED(opline->extended_value & CREX_ARRAY_ELEMENT_REF)) {
		expr_ptr = _get_zval_ptr_cv_BP_VAR_W(opline->op1.var EXECUTE_DATA_CC);
		if (C_ISREF_P(expr_ptr)) {
			C_ADDREF_P(expr_ptr);
		} else {
			ZVAL_MAKE_REF_EX(expr_ptr, 2);
		}

	} else {
		expr_ptr = _get_zval_ptr_cv_BP_VAR_R(opline->op1.var EXECUTE_DATA_CC);
		if (IS_CV == IS_TMP_VAR) {
			/* pass */
		} else if (IS_CV == IS_CONST) {
			C_TRY_ADDREF_P(expr_ptr);
		} else if (IS_CV == IS_CV) {
			ZVAL_DEREF(expr_ptr);
			C_TRY_ADDREF_P(expr_ptr);
		} else /* if (IS_CV == IS_VAR) */ {
			if (UNEXPECTED(C_ISREF_P(expr_ptr))) {
				crex_refcounted *ref = C_COUNTED_P(expr_ptr);

				expr_ptr = C_REFVAL_P(expr_ptr);
				if (UNEXPECTED(GC_DELREF(ref) == 0)) {
					ZVAL_COPY_VALUE(&new_expr, expr_ptr);
					expr_ptr = &new_expr;
					efree_size(ref, sizeof(crex_reference));
				} else if (C_OPT_REFCOUNTED_P(expr_ptr)) {
					C_ADDREF_P(expr_ptr);
				}
			}
		}
	}

	if (IS_CV != IS_UNUSED) {
		zval *offset = EX_VAR(opline->op2.var);
		crex_string *str;
		crex_ulong hval;

add_again:
		if (EXPECTED(C_TYPE_P(offset) == IS_STRING)) {
			str = C_STR_P(offset);
			if (IS_CV != IS_CONST) {
				if (CREX_HANDLE_NUMERIC(str, hval)) {
					goto num_index;
				}
			}
str_index:
			crex_hash_update(C_ARRVAL_P(EX_VAR(opline->result.var)), str, expr_ptr);
		} else if (EXPECTED(C_TYPE_P(offset) == IS_LONG)) {
			hval = C_LVAL_P(offset);
num_index:
			crex_hash_index_update(C_ARRVAL_P(EX_VAR(opline->result.var)), hval, expr_ptr);
		} else if ((IS_CV & (IS_VAR|IS_CV)) && EXPECTED(C_TYPE_P(offset) == IS_REFERENCE)) {
			offset = C_REFVAL_P(offset);
			goto add_again;
		} else if (C_TYPE_P(offset) == IS_NULL) {
			str = ZSTR_EMPTY_ALLOC();
			goto str_index;
		} else if (C_TYPE_P(offset) == IS_DOUBLE) {
			hval = crex_dval_to_lval_safe(C_DVAL_P(offset));
			goto num_index;
		} else if (C_TYPE_P(offset) == IS_FALSE) {
			hval = 0;
			goto num_index;
		} else if (C_TYPE_P(offset) == IS_TRUE) {
			hval = 1;
			goto num_index;
		} else if (C_TYPE_P(offset) == IS_RESOURCE) {
			crex_use_resource_as_offset(offset);
			hval = C_RES_HANDLE_P(offset);
			goto num_index;
		} else if (IS_CV == IS_CV && C_TYPE_P(offset) == IS_UNDEF) {
			ZVAL_UNDEFINED_OP2();
			str = ZSTR_EMPTY_ALLOC();
			goto str_index;
		} else {
			crex_illegal_array_offset_access(offset);
			zval_ptr_dtor_nogc(expr_ptr);
		}

	} else {
		if (!crex_hash_next_index_insert(C_ARRVAL_P(EX_VAR(opline->result.var)), expr_ptr)) {
			crex_cannot_add_element();
			zval_ptr_dtor_nogc(expr_ptr);
		}
	}
	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_INIT_ARRAY_SPEC_CV_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	zval *array;
	uint32_t size;
	USE_OPLINE

	array = EX_VAR(opline->result.var);
	if (IS_CV != IS_UNUSED) {
		size = opline->extended_value >> CREX_ARRAY_SIZE_SHIFT;
		ZVAL_ARR(array, crex_new_array(size));
		/* Explicitly initialize array as not-packed if flag is set */
		if (opline->extended_value & CREX_ARRAY_NOT_PACKED) {
			crex_hash_real_init_mixed(C_ARRVAL_P(array));
		}
		CREX_VM_TAIL_CALL(CREX_ADD_ARRAY_ELEMENT_SPEC_CV_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU));
	} else {
		ZVAL_ARR(array, crex_new_array(0));
		CREX_VM_NEXT_OPCODE();
	}
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_UNSET_DIM_SPEC_CV_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;
	zval *offset;
	crex_ulong hval;
	crex_string *key;

	SAVE_OPLINE();
	container = EX_VAR(opline->op1.var);
	offset = EX_VAR(opline->op2.var);

	do {
		if (EXPECTED(C_TYPE_P(container) == IS_ARRAY)) {
			HashTable *ht;

unset_dim_array:
			SEPARATE_ARRAY(container);
			ht = C_ARRVAL_P(container);
offset_again:
			if (EXPECTED(C_TYPE_P(offset) == IS_STRING)) {
				key = C_STR_P(offset);
				if (IS_CV != IS_CONST) {
					if (CREX_HANDLE_NUMERIC(key, hval)) {
						goto num_index_dim;
					}
				}
str_index_dim:
				CREX_ASSERT(ht != &EG(symbol_table));
				crex_hash_del(ht, key);
			} else if (EXPECTED(C_TYPE_P(offset) == IS_LONG)) {
				hval = C_LVAL_P(offset);
num_index_dim:
				crex_hash_index_del(ht, hval);
			} else if ((IS_CV & (IS_VAR|IS_CV)) && EXPECTED(C_TYPE_P(offset) == IS_REFERENCE)) {
				offset = C_REFVAL_P(offset);
				goto offset_again;
			} else if (C_TYPE_P(offset) == IS_DOUBLE) {
				hval = crex_dval_to_lval_safe(C_DVAL_P(offset));
				goto num_index_dim;
			} else if (C_TYPE_P(offset) == IS_NULL) {
				key = ZSTR_EMPTY_ALLOC();
				goto str_index_dim;
			} else if (C_TYPE_P(offset) == IS_FALSE) {
				hval = 0;
				goto num_index_dim;
			} else if (C_TYPE_P(offset) == IS_TRUE) {
				hval = 1;
				goto num_index_dim;
			} else if (C_TYPE_P(offset) == IS_RESOURCE) {
				crex_use_resource_as_offset(offset);
				hval = C_RES_HANDLE_P(offset);
				goto num_index_dim;
			} else if (IS_CV == IS_CV && C_TYPE_P(offset) == IS_UNDEF) {
				ZVAL_UNDEFINED_OP2();
				key = ZSTR_EMPTY_ALLOC();
				goto str_index_dim;
			} else {
				crex_illegal_array_offset_unset(offset);
			}
			break;
		} else if (C_ISREF_P(container)) {
			container = C_REFVAL_P(container);
			if (EXPECTED(C_TYPE_P(container) == IS_ARRAY)) {
				goto unset_dim_array;
			}
		}
		if (IS_CV == IS_CV && UNEXPECTED(C_TYPE_P(container) == IS_UNDEF)) {
			container = ZVAL_UNDEFINED_OP1();
		}
		if (IS_CV == IS_CV && UNEXPECTED(C_TYPE_P(offset) == IS_UNDEF)) {
			offset = ZVAL_UNDEFINED_OP2();
		}
		if (EXPECTED(C_TYPE_P(container) == IS_OBJECT)) {
			if (IS_CV == IS_CONST && C_EXTRA_P(offset) == CREX_EXTRA_VALUE) {
				offset++;
			}
			C_OBJ_HT_P(container)->unset_dimension(C_OBJ_P(container), offset);
		} else if (UNEXPECTED(C_TYPE_P(container) == IS_STRING)) {
			crex_throw_error(NULL, "Cannot unset string offsets");
		} else if (UNEXPECTED(C_TYPE_P(container) > IS_FALSE)) {
			crex_throw_error(NULL, "Cannot unset offset in a non-array variable");
		} else if (UNEXPECTED(C_TYPE_P(container) == IS_FALSE)) {
			crex_false_to_array_deprecated();
		}
	} while (0);


	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_UNSET_OBJ_SPEC_CV_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;
	zval *offset;
	crex_string *name, *tmp_name;

	SAVE_OPLINE();
	container = EX_VAR(opline->op1.var);
	offset = _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC);

	do {
		if (IS_CV != IS_UNUSED && UNEXPECTED(C_TYPE_P(container) != IS_OBJECT)) {
			if (C_ISREF_P(container)) {
				container = C_REFVAL_P(container);
				if (C_TYPE_P(container) != IS_OBJECT) {
					if (IS_CV == IS_CV
					 && UNEXPECTED(C_TYPE_P(container) == IS_UNDEF)) {
						ZVAL_UNDEFINED_OP1();
					}
					break;
				}
			} else {
				break;
			}
		}
		if (IS_CV == IS_CONST) {
			name = C_STR_P(offset);
		} else {
			name = zval_try_get_tmp_string(offset, &tmp_name);
			if (UNEXPECTED(!name)) {
				break;
			}
		}
		C_OBJ_HT_P(container)->unset_property(C_OBJ_P(container), name, ((IS_CV == IS_CONST) ? CACHE_ADDR(opline->extended_value) : NULL));
		if (IS_CV != IS_CONST) {
			crex_tmp_string_release(tmp_name);
		}
	} while (0);


	CREX_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ISSET_ISEMPTY_DIM_OBJ_SPEC_CV_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;
	bool result;
	crex_ulong hval;
	zval *offset;

	SAVE_OPLINE();
	container = EX_VAR(opline->op1.var);
	offset = EX_VAR(opline->op2.var);

	if (EXPECTED(C_TYPE_P(container) == IS_ARRAY)) {
		HashTable *ht;
		zval *value;
		crex_string *str;

isset_dim_obj_array:
		ht = C_ARRVAL_P(container);
isset_again:
		if (EXPECTED(C_TYPE_P(offset) == IS_STRING)) {
			str = C_STR_P(offset);
			if (IS_CV != IS_CONST) {
				if (CREX_HANDLE_NUMERIC(str, hval)) {
					goto num_index_prop;
				}
			}
			value = crex_hash_find_ex(ht, str, IS_CV == IS_CONST);
		} else if (EXPECTED(C_TYPE_P(offset) == IS_LONG)) {
			hval = C_LVAL_P(offset);
num_index_prop:
			value = crex_hash_index_find(ht, hval);
		} else if ((IS_CV & (IS_VAR|IS_CV)) && EXPECTED(C_ISREF_P(offset))) {
			offset = C_REFVAL_P(offset);
			goto isset_again;
		} else {
			value = crex_find_array_dim_slow(ht, offset EXECUTE_DATA_CC);
			if (UNEXPECTED(EG(exception))) {
				result = 0;
				goto isset_dim_obj_exit;
			}
		}

		if (!(opline->extended_value & CREX_ISEMPTY)) {
			/* > IS_NULL means not IS_UNDEF and not IS_NULL */
			result = value != NULL && C_TYPE_P(value) > IS_NULL &&
			    (!C_ISREF_P(value) || C_TYPE_P(C_REFVAL_P(value)) != IS_NULL);

			if (IS_CV & (IS_CONST|IS_CV)) {
				/* avoid exception check */

				CREX_VM_SMART_BRANCH(result, 0);
			}
		} else {
			result = (value == NULL || !i_crex_is_true(value));
		}
		goto isset_dim_obj_exit;
	} else if ((IS_CV & (IS_VAR|IS_CV)) && EXPECTED(C_ISREF_P(container))) {
		container = C_REFVAL_P(container);
		if (EXPECTED(C_TYPE_P(container) == IS_ARRAY)) {
			goto isset_dim_obj_array;
		}
	}

	if (IS_CV == IS_CONST && C_EXTRA_P(offset) == CREX_EXTRA_VALUE) {
		offset++;
	}
	if (!(opline->extended_value & CREX_ISEMPTY)) {
		result = crex_isset_dim_slow(container, offset EXECUTE_DATA_CC);
	} else {
		result = crex_isempty_dim_slow(container, offset EXECUTE_DATA_CC);
	}

isset_dim_obj_exit:


	CREX_VM_SMART_BRANCH(result, 1);
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ISSET_ISEMPTY_PROP_OBJ_SPEC_CV_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;
	int result;
	zval *offset;
	crex_string *name, *tmp_name;

	SAVE_OPLINE();
	container = _get_zval_ptr_cv_BP_VAR_IS(opline->op1.var EXECUTE_DATA_CC);
	offset = _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC);

	if (IS_CV == IS_CONST ||
	    (IS_CV != IS_UNUSED && UNEXPECTED(C_TYPE_P(container) != IS_OBJECT))) {
		if ((IS_CV & (IS_VAR|IS_CV)) && C_ISREF_P(container)) {
			container = C_REFVAL_P(container);
			if (UNEXPECTED(C_TYPE_P(container) != IS_OBJECT)) {
				result = (opline->extended_value & CREX_ISEMPTY);
				goto isset_object_finish;
			}
		} else {
			result = (opline->extended_value & CREX_ISEMPTY);
			goto isset_object_finish;
		}
	}

	if (IS_CV == IS_CONST) {
		name = C_STR_P(offset);
	} else {
		name = zval_try_get_tmp_string(offset, &tmp_name);
		if (UNEXPECTED(!name)) {
			result = 0;
			goto isset_object_finish;
		}
	}

	result =
		(opline->extended_value & CREX_ISEMPTY) ^
		C_OBJ_HT_P(container)->has_property(C_OBJ_P(container), name, (opline->extended_value & CREX_ISEMPTY), ((IS_CV == IS_CONST) ? CACHE_ADDR(opline->extended_value & ~CREX_ISEMPTY) : NULL));

	if (IS_CV != IS_CONST) {
		crex_tmp_string_release(tmp_name);
	}

isset_object_finish:


	CREX_VM_SMART_BRANCH(result, 1);
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_ARRAY_KEY_EXISTS_SPEC_CV_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *key, *subject;
	HashTable *ht;
	bool result;

	SAVE_OPLINE();

	key = EX_VAR(opline->op1.var);
	subject = EX_VAR(opline->op2.var);

	if (EXPECTED(C_TYPE_P(subject) == IS_ARRAY)) {
array_key_exists_array:
		ht = C_ARRVAL_P(subject);
		result = crex_array_key_exists_fast(ht, key OPLINE_CC EXECUTE_DATA_CC);
	} else {
		if ((IS_CV & (IS_VAR|IS_CV)) && EXPECTED(C_ISREF_P(subject))) {
			subject = C_REFVAL_P(subject);
			if (EXPECTED(C_TYPE_P(subject) == IS_ARRAY)) {
				goto array_key_exists_array;
			}
		}
		crex_array_key_exists_error(subject, key OPLINE_CC EXECUTE_DATA_CC);
		result = 0;
	}


	CREX_VM_SMART_BRANCH(result, 1);
}

/* No specialization for op_types (CONST|TMPVAR|UNUSED|CV, ANY) */
static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_YIELD_SPEC_CV_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	crex_generator *generator = crex_get_running_generator(EXECUTE_DATA_C);

	SAVE_OPLINE();
	if (UNEXPECTED(generator->flags & CREX_GENERATOR_FORCED_CLOSE)) {
		CREX_VM_TAIL_CALL(crex_yield_in_closed_generator_helper_SPEC(CREX_OPCODE_HANDLER_ARGS_PASSTHRU));
	}

	/* Destroy the previously yielded value */
	zval_ptr_dtor(&generator->value);

	/* Destroy the previously yielded key */
	zval_ptr_dtor(&generator->key);

	/* Set the new yielded value */
	if (IS_CV != IS_UNUSED) {
		if (UNEXPECTED(EX(func)->op_array.fn_flags & CREX_ACC_RETURN_REFERENCE)) {
			/* Constants and temporary variables aren't yieldable by reference,
			 * but we still allow them with a notice. */
			if (IS_CV & (IS_CONST|IS_TMP_VAR)) {
				zval *value;

				crex_error(E_NOTICE, "Only variable references should be yielded by reference");

				value = _get_zval_ptr_cv_BP_VAR_R(opline->op1.var EXECUTE_DATA_CC);
				ZVAL_COPY_VALUE(&generator->value, value);
				if (IS_CV == IS_CONST) {
					if (UNEXPECTED(C_OPT_REFCOUNTED(generator->value))) {
						C_ADDREF(generator->value);
					}
				}
			} else {
				zval *value_ptr = _get_zval_ptr_cv_BP_VAR_W(opline->op1.var EXECUTE_DATA_CC);

				/* If a function call result is yielded and the function did
				 * not return by reference we throw a notice. */
				do {
					if (IS_CV == IS_VAR) {
						CREX_ASSERT(value_ptr != &EG(uninitialized_zval));
						if (opline->extended_value == CREX_RETURNS_FUNCTION
						 && !C_ISREF_P(value_ptr)) {
							crex_error(E_NOTICE, "Only variable references should be yielded by reference");
							ZVAL_COPY(&generator->value, value_ptr);
							break;
						}
					}
					if (C_ISREF_P(value_ptr)) {
						C_ADDREF_P(value_ptr);
					} else {
						ZVAL_MAKE_REF_EX(value_ptr, 2);
					}
					ZVAL_REF(&generator->value, C_REF_P(value_ptr));
				} while (0);

			}
		} else {
			zval *value = _get_zval_ptr_cv_BP_VAR_R(opline->op1.var EXECUTE_DATA_CC);

			/* Consts, temporary variables and references need copying */
			if (IS_CV == IS_CONST) {
				ZVAL_COPY_VALUE(&generator->value, value);
				if (UNEXPECTED(C_OPT_REFCOUNTED(generator->value))) {
					C_ADDREF(generator->value);
				}
			} else if (IS_CV == IS_TMP_VAR) {
				ZVAL_COPY_VALUE(&generator->value, value);
			} else if ((IS_CV & (IS_VAR|IS_CV)) && C_ISREF_P(value)) {
				ZVAL_COPY(&generator->value, C_REFVAL_P(value));

			} else {
				ZVAL_COPY_VALUE(&generator->value, value);
				if (IS_CV == IS_CV) {
					if (C_OPT_REFCOUNTED_P(value)) C_ADDREF_P(value);
				}
			}
		}
	} else {
		/* If no value was specified yield null */
		ZVAL_NULL(&generator->value);
	}

	/* Set the new yielded key */
	if (IS_CV != IS_UNUSED) {
		zval *key = _get_zval_ptr_cv_BP_VAR_R(opline->op2.var EXECUTE_DATA_CC);
		if ((IS_CV & (IS_CV|IS_VAR)) && UNEXPECTED(C_TYPE_P(key) == IS_REFERENCE)) {
			key = C_REFVAL_P(key);
		}
		ZVAL_COPY(&generator->key, key);

		if (C_TYPE(generator->key) == IS_LONG
		    && C_LVAL(generator->key) > generator->largest_used_integer_key
		) {
			generator->largest_used_integer_key = C_LVAL(generator->key);
		}
	} else {
		/* If no key was specified we use auto-increment keys */
		generator->largest_used_integer_key++;
		ZVAL_LONG(&generator->key, generator->largest_used_integer_key);
	}

	if (RETURN_VALUE_USED(opline)) {
		/* If the return value of yield is used set the send
		 * target and initialize it to NULL */
		generator->send_target = EX_VAR(opline->result.var);
		ZVAL_NULL(generator->send_target);
	} else {
		generator->send_target = NULL;
	}

	/* We increment to the next op, so we are at the correct position when the
	 * generator is resumed. */
	CREX_VM_INC_OPCODE();

	/* The GOTO VM uses a local opline variable. We need to set the opline
	 * variable in execute_data so we don't resume at an old position. */
	SAVE_OPLINE();

	CREX_VM_RETURN();
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_IS_IDENTICAL_NOTHROW_SPEC_CV_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	/* This is declared below the specializations for MAY_BE_LONG/MAY_BE_DOUBLE so those will be used instead if possible. */
	/* This optimizes $x === SOME_CONST_EXPR and $x === $y for non-refs and non-undef, which can't throw. */
	/* (Infinite recursion when comparing arrays is an uncatchable fatal error) */
	USE_OPLINE
	zval *op1, *op2;
	bool result;

	op1 = EX_VAR(opline->op1.var);
	op2 = EX_VAR(opline->op2.var);
	result = fast_is_identical_function(op1, op2);
	/* Free is a no-op for const/cv */
	CREX_VM_SMART_BRANCH(result, 0);
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_IS_NOT_IDENTICAL_NOTHROW_SPEC_CV_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *op1, *op2;
	bool result;

	op1 = EX_VAR(opline->op1.var);
	op2 = EX_VAR(opline->op2.var);
	result = fast_is_identical_function(op1, op2);
	/* Free is a no-op for const/cv */
	CREX_VM_SMART_BRANCH(!result, 0);
}

static CREX_OPCODE_HANDLER_RET CREX_FASTCALL CREX_NULL_HANDLER(CREX_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	SAVE_OPLINE();
	crex_error_noreturn(E_ERROR, "Invalid opcode %d/%d/%d.", OPLINE->opcode, OPLINE->op1_type, OPLINE->op2_type);
	CREX_VM_NEXT_OPCODE(); /* Never reached */
}


#if (CREX_VM_KIND == CREX_VM_KIND_HYBRID)
# undef CREX_VM_TAIL_CALL
# undef CREX_VM_CONTINUE
# undef CREX_VM_RETURN

# define CREX_VM_TAIL_CALL(call) call; CREX_VM_CONTINUE()
# define CREX_VM_CONTINUE()      HYBRID_NEXT()
# define CREX_VM_RETURN()        goto HYBRID_HALT_LABEL
#endif


#if (CREX_VM_KIND != CREX_VM_KIND_CALL) && (CREX_GCC_VERSION >= 4000) && !defined(__clang__)
# pragma GCC push_options
# pragma GCC optimize("no-gcse")
# pragma GCC optimize("no-ivopts")
#endif
CREX_API void execute_ex(crex_execute_data *ex)
{
	DCL_OPLINE

#if defined(CREX_VM_IP_GLOBAL_REG) || defined(CREX_VM_FP_GLOBAL_REG)
	struct {
#ifdef CREX_VM_IP_GLOBAL_REG
		const crex_op *orig_opline;
#endif
#ifdef CREX_VM_FP_GLOBAL_REG
		crex_execute_data *orig_execute_data;
#ifdef CREX_VM_HYBRID_JIT_RED_ZONE_SIZE
		char hybrid_jit_red_zone[CREX_VM_HYBRID_JIT_RED_ZONE_SIZE];
#endif
#endif
	} vm_stack_data;
#endif
#ifdef CREX_VM_IP_GLOBAL_REG
	vm_stack_data.orig_opline = opline;
#endif
#ifdef CREX_VM_FP_GLOBAL_REG
	vm_stack_data.orig_execute_data = execute_data;
	execute_data = ex;
#else
	crex_execute_data *execute_data = ex;
#endif

#if (CREX_VM_KIND == CREX_VM_KIND_HYBRID)
	if (UNEXPECTED(execute_data == NULL)) {
		static const void * const labels[] = {
			(void*)&&CREX_NOP_SPEC_LABEL,
			(void*)&&CREX_ADD_SPEC_CONST_CONST_LABEL,
			(void*)&&CREX_ADD_SPEC_CONST_TMPVARCV_LABEL,
			(void*)&&CREX_ADD_SPEC_CONST_TMPVARCV_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_ADD_SPEC_CONST_TMPVARCV_LABEL,
			(void*)&&CREX_ADD_SPEC_TMPVARCV_CONST_LABEL,
			(void*)&&CREX_ADD_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_ADD_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_ADD_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_ADD_SPEC_TMPVARCV_CONST_LABEL,
			(void*)&&CREX_ADD_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_ADD_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_ADD_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_ADD_SPEC_TMPVARCV_CONST_LABEL,
			(void*)&&CREX_ADD_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_ADD_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_ADD_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_SUB_SPEC_CONST_CONST_LABEL,
			(void*)&&CREX_SUB_SPEC_CONST_TMPVARCV_LABEL,
			(void*)&&CREX_SUB_SPEC_CONST_TMPVARCV_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_SUB_SPEC_CONST_TMPVARCV_LABEL,
			(void*)&&CREX_SUB_SPEC_TMPVARCV_CONST_LABEL,
			(void*)&&CREX_SUB_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_SUB_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_SUB_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_SUB_SPEC_TMPVARCV_CONST_LABEL,
			(void*)&&CREX_SUB_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_SUB_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_SUB_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_SUB_SPEC_TMPVARCV_CONST_LABEL,
			(void*)&&CREX_SUB_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_SUB_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_SUB_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_MUL_SPEC_CONST_CONST_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_MUL_SPEC_TMPVARCV_CONST_LABEL,
			(void*)&&CREX_MUL_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_MUL_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_MUL_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_MUL_SPEC_TMPVARCV_CONST_LABEL,
			(void*)&&CREX_MUL_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_MUL_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_MUL_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_MUL_SPEC_TMPVARCV_CONST_LABEL,
			(void*)&&CREX_MUL_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_MUL_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_MUL_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_DIV_SPEC_CONST_CONST_LABEL,
			(void*)&&CREX_DIV_SPEC_CONST_TMPVAR_LABEL,
			(void*)&&CREX_DIV_SPEC_CONST_TMPVAR_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_DIV_SPEC_CONST_CV_LABEL,
			(void*)&&CREX_DIV_SPEC_TMPVAR_CONST_LABEL,
			(void*)&&CREX_DIV_SPEC_TMPVAR_TMPVAR_LABEL,
			(void*)&&CREX_DIV_SPEC_TMPVAR_TMPVAR_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_DIV_SPEC_TMPVAR_CV_LABEL,
			(void*)&&CREX_DIV_SPEC_TMPVAR_CONST_LABEL,
			(void*)&&CREX_DIV_SPEC_TMPVAR_TMPVAR_LABEL,
			(void*)&&CREX_DIV_SPEC_TMPVAR_TMPVAR_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_DIV_SPEC_TMPVAR_CV_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_DIV_SPEC_CV_CONST_LABEL,
			(void*)&&CREX_DIV_SPEC_CV_TMPVAR_LABEL,
			(void*)&&CREX_DIV_SPEC_CV_TMPVAR_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_DIV_SPEC_CV_CV_LABEL,
			(void*)&&CREX_MOD_SPEC_CONST_CONST_LABEL,
			(void*)&&CREX_MOD_SPEC_CONST_TMPVARCV_LABEL,
			(void*)&&CREX_MOD_SPEC_CONST_TMPVARCV_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_MOD_SPEC_CONST_TMPVARCV_LABEL,
			(void*)&&CREX_MOD_SPEC_TMPVARCV_CONST_LABEL,
			(void*)&&CREX_MOD_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_MOD_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_MOD_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_MOD_SPEC_TMPVARCV_CONST_LABEL,
			(void*)&&CREX_MOD_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_MOD_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_MOD_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_MOD_SPEC_TMPVARCV_CONST_LABEL,
			(void*)&&CREX_MOD_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_MOD_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_MOD_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_SL_SPEC_CONST_CONST_LABEL,
			(void*)&&CREX_SL_SPEC_CONST_TMPVARCV_LABEL,
			(void*)&&CREX_SL_SPEC_CONST_TMPVARCV_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_SL_SPEC_CONST_TMPVARCV_LABEL,
			(void*)&&CREX_SL_SPEC_TMPVARCV_CONST_LABEL,
			(void*)&&CREX_SL_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_SL_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_SL_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_SL_SPEC_TMPVARCV_CONST_LABEL,
			(void*)&&CREX_SL_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_SL_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_SL_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_SL_SPEC_TMPVARCV_CONST_LABEL,
			(void*)&&CREX_SL_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_SL_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_SL_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_SR_SPEC_CONST_CONST_LABEL,
			(void*)&&CREX_SR_SPEC_CONST_TMPVARCV_LABEL,
			(void*)&&CREX_SR_SPEC_CONST_TMPVARCV_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_SR_SPEC_CONST_TMPVARCV_LABEL,
			(void*)&&CREX_SR_SPEC_TMPVARCV_CONST_LABEL,
			(void*)&&CREX_SR_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_SR_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_SR_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_SR_SPEC_TMPVARCV_CONST_LABEL,
			(void*)&&CREX_SR_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_SR_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_SR_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_SR_SPEC_TMPVARCV_CONST_LABEL,
			(void*)&&CREX_SR_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_SR_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_SR_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_CONCAT_SPEC_CONST_TMPVAR_LABEL,
			(void*)&&CREX_CONCAT_SPEC_CONST_TMPVAR_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_CONCAT_SPEC_CONST_CV_LABEL,
			(void*)&&CREX_CONCAT_SPEC_TMPVAR_CONST_LABEL,
			(void*)&&CREX_CONCAT_SPEC_TMPVAR_TMPVAR_LABEL,
			(void*)&&CREX_CONCAT_SPEC_TMPVAR_TMPVAR_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_CONCAT_SPEC_TMPVAR_CV_LABEL,
			(void*)&&CREX_CONCAT_SPEC_TMPVAR_CONST_LABEL,
			(void*)&&CREX_CONCAT_SPEC_TMPVAR_TMPVAR_LABEL,
			(void*)&&CREX_CONCAT_SPEC_TMPVAR_TMPVAR_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_CONCAT_SPEC_TMPVAR_CV_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_CONCAT_SPEC_CV_CONST_LABEL,
			(void*)&&CREX_CONCAT_SPEC_CV_TMPVAR_LABEL,
			(void*)&&CREX_CONCAT_SPEC_CV_TMPVAR_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_CONCAT_SPEC_CV_CV_LABEL,
			(void*)&&CREX_BW_OR_SPEC_CONST_CONST_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_BW_OR_SPEC_TMPVARCV_CONST_LABEL,
			(void*)&&CREX_BW_OR_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_BW_OR_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_BW_OR_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_BW_OR_SPEC_TMPVARCV_CONST_LABEL,
			(void*)&&CREX_BW_OR_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_BW_OR_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_BW_OR_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_BW_OR_SPEC_TMPVARCV_CONST_LABEL,
			(void*)&&CREX_BW_OR_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_BW_OR_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_BW_OR_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_BW_AND_SPEC_CONST_CONST_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_BW_AND_SPEC_TMPVARCV_CONST_LABEL,
			(void*)&&CREX_BW_AND_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_BW_AND_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_BW_AND_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_BW_AND_SPEC_TMPVARCV_CONST_LABEL,
			(void*)&&CREX_BW_AND_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_BW_AND_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_BW_AND_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_BW_AND_SPEC_TMPVARCV_CONST_LABEL,
			(void*)&&CREX_BW_AND_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_BW_AND_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_BW_AND_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_BW_XOR_SPEC_CONST_CONST_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_BW_XOR_SPEC_TMPVARCV_CONST_LABEL,
			(void*)&&CREX_BW_XOR_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_BW_XOR_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_BW_XOR_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_BW_XOR_SPEC_TMPVARCV_CONST_LABEL,
			(void*)&&CREX_BW_XOR_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_BW_XOR_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_BW_XOR_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_BW_XOR_SPEC_TMPVARCV_CONST_LABEL,
			(void*)&&CREX_BW_XOR_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_BW_XOR_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_BW_XOR_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_POW_SPEC_CONST_CONST_LABEL,
			(void*)&&CREX_POW_SPEC_CONST_TMPVAR_LABEL,
			(void*)&&CREX_POW_SPEC_CONST_TMPVAR_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_POW_SPEC_CONST_CV_LABEL,
			(void*)&&CREX_POW_SPEC_TMPVAR_CONST_LABEL,
			(void*)&&CREX_POW_SPEC_TMPVAR_TMPVAR_LABEL,
			(void*)&&CREX_POW_SPEC_TMPVAR_TMPVAR_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_POW_SPEC_TMPVAR_CV_LABEL,
			(void*)&&CREX_POW_SPEC_TMPVAR_CONST_LABEL,
			(void*)&&CREX_POW_SPEC_TMPVAR_TMPVAR_LABEL,
			(void*)&&CREX_POW_SPEC_TMPVAR_TMPVAR_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_POW_SPEC_TMPVAR_CV_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_POW_SPEC_CV_CONST_LABEL,
			(void*)&&CREX_POW_SPEC_CV_TMPVAR_LABEL,
			(void*)&&CREX_POW_SPEC_CV_TMPVAR_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_POW_SPEC_CV_CV_LABEL,
			(void*)&&CREX_BW_NOT_SPEC_CONST_LABEL,
			(void*)&&CREX_BW_NOT_SPEC_TMPVARCV_LABEL,
			(void*)&&CREX_BW_NOT_SPEC_TMPVARCV_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_BW_NOT_SPEC_TMPVARCV_LABEL,
			(void*)&&CREX_BOOL_NOT_SPEC_CONST_LABEL,
			(void*)&&CREX_BOOL_NOT_SPEC_TMPVAR_LABEL,
			(void*)&&CREX_BOOL_NOT_SPEC_TMPVAR_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_BOOL_NOT_SPEC_CV_LABEL,
			(void*)&&CREX_BOOL_XOR_SPEC_CONST_CONST_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_BOOL_XOR_SPEC_TMPVAR_CONST_LABEL,
			(void*)&&CREX_BOOL_XOR_SPEC_TMPVAR_TMPVAR_LABEL,
			(void*)&&CREX_BOOL_XOR_SPEC_TMPVAR_TMPVAR_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_BOOL_XOR_SPEC_TMPVAR_CONST_LABEL,
			(void*)&&CREX_BOOL_XOR_SPEC_TMPVAR_TMPVAR_LABEL,
			(void*)&&CREX_BOOL_XOR_SPEC_TMPVAR_TMPVAR_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_BOOL_XOR_SPEC_CV_CONST_LABEL,
			(void*)&&CREX_BOOL_XOR_SPEC_CV_TMPVAR_LABEL,
			(void*)&&CREX_BOOL_XOR_SPEC_CV_TMPVAR_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_BOOL_XOR_SPEC_CV_CV_LABEL,
			(void*)&&CREX_IS_IDENTICAL_SPEC_CONST_CONST_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_IS_IDENTICAL_SPEC_TMP_CONST_LABEL,
			(void*)&&CREX_IS_IDENTICAL_SPEC_TMP_TMP_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_IS_IDENTICAL_SPEC_VAR_CONST_LABEL,
			(void*)&&CREX_IS_IDENTICAL_SPEC_VAR_TMP_LABEL,
			(void*)&&CREX_IS_IDENTICAL_SPEC_VAR_VAR_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_IS_IDENTICAL_SPEC_CV_CONST_LABEL,
			(void*)&&CREX_IS_IDENTICAL_SPEC_CV_TMP_LABEL,
			(void*)&&CREX_IS_IDENTICAL_SPEC_CV_VAR_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_IS_IDENTICAL_SPEC_CV_CV_LABEL,
			(void*)&&CREX_IS_NOT_IDENTICAL_SPEC_CONST_CONST_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_IS_NOT_IDENTICAL_SPEC_TMP_CONST_LABEL,
			(void*)&&CREX_IS_NOT_IDENTICAL_SPEC_TMP_TMP_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_IS_NOT_IDENTICAL_SPEC_VAR_CONST_LABEL,
			(void*)&&CREX_IS_NOT_IDENTICAL_SPEC_VAR_TMP_LABEL,
			(void*)&&CREX_IS_NOT_IDENTICAL_SPEC_VAR_VAR_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_IS_NOT_IDENTICAL_SPEC_CV_CONST_LABEL,
			(void*)&&CREX_IS_NOT_IDENTICAL_SPEC_CV_TMP_LABEL,
			(void*)&&CREX_IS_NOT_IDENTICAL_SPEC_CV_VAR_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_IS_NOT_IDENTICAL_SPEC_CV_CV_LABEL,
			(void*)&&CREX_IS_EQUAL_SPEC_CONST_CONST_LABEL,
			(void*)&&CREX_IS_EQUAL_SPEC_CONST_CONST_LABEL,
			(void*)&&CREX_IS_EQUAL_SPEC_CONST_CONST_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_IS_EQUAL_SPEC_TMPVAR_CONST_LABEL,
			(void*)&&CREX_IS_EQUAL_SPEC_TMPVAR_CONST_JMPC_LABEL,
			(void*)&&CREX_IS_EQUAL_SPEC_TMPVAR_CONST_JMPNC_LABEL,
			(void*)&&CREX_IS_EQUAL_SPEC_TMPVAR_TMPVAR_LABEL,
			(void*)&&CREX_IS_EQUAL_SPEC_TMPVAR_TMPVAR_JMPC_LABEL,
			(void*)&&CREX_IS_EQUAL_SPEC_TMPVAR_TMPVAR_JMPNC_LABEL,
			(void*)&&CREX_IS_EQUAL_SPEC_TMPVAR_TMPVAR_LABEL,
			(void*)&&CREX_IS_EQUAL_SPEC_TMPVAR_TMPVAR_JMPC_LABEL,
			(void*)&&CREX_IS_EQUAL_SPEC_TMPVAR_TMPVAR_JMPNC_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_IS_EQUAL_SPEC_TMPVAR_CONST_LABEL,
			(void*)&&CREX_IS_EQUAL_SPEC_TMPVAR_CONST_JMPC_LABEL,
			(void*)&&CREX_IS_EQUAL_SPEC_TMPVAR_CONST_JMPNC_LABEL,
			(void*)&&CREX_IS_EQUAL_SPEC_TMPVAR_TMPVAR_LABEL,
			(void*)&&CREX_IS_EQUAL_SPEC_TMPVAR_TMPVAR_JMPC_LABEL,
			(void*)&&CREX_IS_EQUAL_SPEC_TMPVAR_TMPVAR_JMPNC_LABEL,
			(void*)&&CREX_IS_EQUAL_SPEC_TMPVAR_TMPVAR_LABEL,
			(void*)&&CREX_IS_EQUAL_SPEC_TMPVAR_TMPVAR_JMPC_LABEL,
			(void*)&&CREX_IS_EQUAL_SPEC_TMPVAR_TMPVAR_JMPNC_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_IS_EQUAL_SPEC_CV_CONST_LABEL,
			(void*)&&CREX_IS_EQUAL_SPEC_CV_CONST_JMPC_LABEL,
			(void*)&&CREX_IS_EQUAL_SPEC_CV_CONST_JMPNC_LABEL,
			(void*)&&CREX_IS_EQUAL_SPEC_CV_TMPVAR_LABEL,
			(void*)&&CREX_IS_EQUAL_SPEC_CV_TMPVAR_JMPC_LABEL,
			(void*)&&CREX_IS_EQUAL_SPEC_CV_TMPVAR_JMPNC_LABEL,
			(void*)&&CREX_IS_EQUAL_SPEC_CV_TMPVAR_LABEL,
			(void*)&&CREX_IS_EQUAL_SPEC_CV_TMPVAR_JMPC_LABEL,
			(void*)&&CREX_IS_EQUAL_SPEC_CV_TMPVAR_JMPNC_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_IS_EQUAL_SPEC_CV_CV_LABEL,
			(void*)&&CREX_IS_EQUAL_SPEC_CV_CV_JMPC_LABEL,
			(void*)&&CREX_IS_EQUAL_SPEC_CV_CV_JMPNC_LABEL,
			(void*)&&CREX_IS_NOT_EQUAL_SPEC_CONST_CONST_LABEL,
			(void*)&&CREX_IS_NOT_EQUAL_SPEC_CONST_CONST_LABEL,
			(void*)&&CREX_IS_NOT_EQUAL_SPEC_CONST_CONST_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_IS_NOT_EQUAL_SPEC_TMPVAR_CONST_LABEL,
			(void*)&&CREX_IS_NOT_EQUAL_SPEC_TMPVAR_CONST_JMPC_LABEL,
			(void*)&&CREX_IS_NOT_EQUAL_SPEC_TMPVAR_CONST_JMPNC_LABEL,
			(void*)&&CREX_IS_NOT_EQUAL_SPEC_TMPVAR_TMPVAR_LABEL,
			(void*)&&CREX_IS_NOT_EQUAL_SPEC_TMPVAR_TMPVAR_JMPC_LABEL,
			(void*)&&CREX_IS_NOT_EQUAL_SPEC_TMPVAR_TMPVAR_JMPNC_LABEL,
			(void*)&&CREX_IS_NOT_EQUAL_SPEC_TMPVAR_TMPVAR_LABEL,
			(void*)&&CREX_IS_NOT_EQUAL_SPEC_TMPVAR_TMPVAR_JMPC_LABEL,
			(void*)&&CREX_IS_NOT_EQUAL_SPEC_TMPVAR_TMPVAR_JMPNC_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_IS_NOT_EQUAL_SPEC_TMPVAR_CONST_LABEL,
			(void*)&&CREX_IS_NOT_EQUAL_SPEC_TMPVAR_CONST_JMPC_LABEL,
			(void*)&&CREX_IS_NOT_EQUAL_SPEC_TMPVAR_CONST_JMPNC_LABEL,
			(void*)&&CREX_IS_NOT_EQUAL_SPEC_TMPVAR_TMPVAR_LABEL,
			(void*)&&CREX_IS_NOT_EQUAL_SPEC_TMPVAR_TMPVAR_JMPC_LABEL,
			(void*)&&CREX_IS_NOT_EQUAL_SPEC_TMPVAR_TMPVAR_JMPNC_LABEL,
			(void*)&&CREX_IS_NOT_EQUAL_SPEC_TMPVAR_TMPVAR_LABEL,
			(void*)&&CREX_IS_NOT_EQUAL_SPEC_TMPVAR_TMPVAR_JMPC_LABEL,
			(void*)&&CREX_IS_NOT_EQUAL_SPEC_TMPVAR_TMPVAR_JMPNC_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_IS_NOT_EQUAL_SPEC_CV_CONST_LABEL,
			(void*)&&CREX_IS_NOT_EQUAL_SPEC_CV_CONST_JMPC_LABEL,
			(void*)&&CREX_IS_NOT_EQUAL_SPEC_CV_CONST_JMPNC_LABEL,
			(void*)&&CREX_IS_NOT_EQUAL_SPEC_CV_TMPVAR_LABEL,
			(void*)&&CREX_IS_NOT_EQUAL_SPEC_CV_TMPVAR_JMPC_LABEL,
			(void*)&&CREX_IS_NOT_EQUAL_SPEC_CV_TMPVAR_JMPNC_LABEL,
			(void*)&&CREX_IS_NOT_EQUAL_SPEC_CV_TMPVAR_LABEL,
			(void*)&&CREX_IS_NOT_EQUAL_SPEC_CV_TMPVAR_JMPC_LABEL,
			(void*)&&CREX_IS_NOT_EQUAL_SPEC_CV_TMPVAR_JMPNC_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_IS_NOT_EQUAL_SPEC_CV_CV_LABEL,
			(void*)&&CREX_IS_NOT_EQUAL_SPEC_CV_CV_JMPC_LABEL,
			(void*)&&CREX_IS_NOT_EQUAL_SPEC_CV_CV_JMPNC_LABEL,
			(void*)&&CREX_IS_SMALLER_SPEC_CONST_CONST_LABEL,
			(void*)&&CREX_IS_SMALLER_SPEC_CONST_CONST_LABEL,
			(void*)&&CREX_IS_SMALLER_SPEC_CONST_CONST_LABEL,
			(void*)&&CREX_IS_SMALLER_SPEC_CONST_TMPVARCV_LABEL,
			(void*)&&CREX_IS_SMALLER_SPEC_CONST_TMPVARCV_JMPC_LABEL,
			(void*)&&CREX_IS_SMALLER_SPEC_CONST_TMPVARCV_JMPNC_LABEL,
			(void*)&&CREX_IS_SMALLER_SPEC_CONST_TMPVARCV_LABEL,
			(void*)&&CREX_IS_SMALLER_SPEC_CONST_TMPVARCV_JMPC_LABEL,
			(void*)&&CREX_IS_SMALLER_SPEC_CONST_TMPVARCV_JMPNC_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_IS_SMALLER_SPEC_CONST_TMPVARCV_LABEL,
			(void*)&&CREX_IS_SMALLER_SPEC_CONST_TMPVARCV_JMPC_LABEL,
			(void*)&&CREX_IS_SMALLER_SPEC_CONST_TMPVARCV_JMPNC_LABEL,
			(void*)&&CREX_IS_SMALLER_SPEC_TMPVARCV_CONST_LABEL,
			(void*)&&CREX_IS_SMALLER_SPEC_TMPVARCV_CONST_JMPC_LABEL,
			(void*)&&CREX_IS_SMALLER_SPEC_TMPVARCV_CONST_JMPNC_LABEL,
			(void*)&&CREX_IS_SMALLER_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_IS_SMALLER_SPEC_TMPVARCV_TMPVARCV_JMPC_LABEL,
			(void*)&&CREX_IS_SMALLER_SPEC_TMPVARCV_TMPVARCV_JMPNC_LABEL,
			(void*)&&CREX_IS_SMALLER_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_IS_SMALLER_SPEC_TMPVARCV_TMPVARCV_JMPC_LABEL,
			(void*)&&CREX_IS_SMALLER_SPEC_TMPVARCV_TMPVARCV_JMPNC_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_IS_SMALLER_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_IS_SMALLER_SPEC_TMPVARCV_TMPVARCV_JMPC_LABEL,
			(void*)&&CREX_IS_SMALLER_SPEC_TMPVARCV_TMPVARCV_JMPNC_LABEL,
			(void*)&&CREX_IS_SMALLER_SPEC_TMPVARCV_CONST_LABEL,
			(void*)&&CREX_IS_SMALLER_SPEC_TMPVARCV_CONST_JMPC_LABEL,
			(void*)&&CREX_IS_SMALLER_SPEC_TMPVARCV_CONST_JMPNC_LABEL,
			(void*)&&CREX_IS_SMALLER_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_IS_SMALLER_SPEC_TMPVARCV_TMPVARCV_JMPC_LABEL,
			(void*)&&CREX_IS_SMALLER_SPEC_TMPVARCV_TMPVARCV_JMPNC_LABEL,
			(void*)&&CREX_IS_SMALLER_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_IS_SMALLER_SPEC_TMPVARCV_TMPVARCV_JMPC_LABEL,
			(void*)&&CREX_IS_SMALLER_SPEC_TMPVARCV_TMPVARCV_JMPNC_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_IS_SMALLER_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_IS_SMALLER_SPEC_TMPVARCV_TMPVARCV_JMPC_LABEL,
			(void*)&&CREX_IS_SMALLER_SPEC_TMPVARCV_TMPVARCV_JMPNC_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_IS_SMALLER_SPEC_TMPVARCV_CONST_LABEL,
			(void*)&&CREX_IS_SMALLER_SPEC_TMPVARCV_CONST_JMPC_LABEL,
			(void*)&&CREX_IS_SMALLER_SPEC_TMPVARCV_CONST_JMPNC_LABEL,
			(void*)&&CREX_IS_SMALLER_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_IS_SMALLER_SPEC_TMPVARCV_TMPVARCV_JMPC_LABEL,
			(void*)&&CREX_IS_SMALLER_SPEC_TMPVARCV_TMPVARCV_JMPNC_LABEL,
			(void*)&&CREX_IS_SMALLER_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_IS_SMALLER_SPEC_TMPVARCV_TMPVARCV_JMPC_LABEL,
			(void*)&&CREX_IS_SMALLER_SPEC_TMPVARCV_TMPVARCV_JMPNC_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_IS_SMALLER_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_IS_SMALLER_SPEC_TMPVARCV_TMPVARCV_JMPC_LABEL,
			(void*)&&CREX_IS_SMALLER_SPEC_TMPVARCV_TMPVARCV_JMPNC_LABEL,
			(void*)&&CREX_IS_SMALLER_OR_EQUAL_SPEC_CONST_CONST_LABEL,
			(void*)&&CREX_IS_SMALLER_OR_EQUAL_SPEC_CONST_CONST_LABEL,
			(void*)&&CREX_IS_SMALLER_OR_EQUAL_SPEC_CONST_CONST_LABEL,
			(void*)&&CREX_IS_SMALLER_OR_EQUAL_SPEC_CONST_TMPVARCV_LABEL,
			(void*)&&CREX_IS_SMALLER_OR_EQUAL_SPEC_CONST_TMPVARCV_JMPC_LABEL,
			(void*)&&CREX_IS_SMALLER_OR_EQUAL_SPEC_CONST_TMPVARCV_JMPNC_LABEL,
			(void*)&&CREX_IS_SMALLER_OR_EQUAL_SPEC_CONST_TMPVARCV_LABEL,
			(void*)&&CREX_IS_SMALLER_OR_EQUAL_SPEC_CONST_TMPVARCV_JMPC_LABEL,
			(void*)&&CREX_IS_SMALLER_OR_EQUAL_SPEC_CONST_TMPVARCV_JMPNC_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_IS_SMALLER_OR_EQUAL_SPEC_CONST_TMPVARCV_LABEL,
			(void*)&&CREX_IS_SMALLER_OR_EQUAL_SPEC_CONST_TMPVARCV_JMPC_LABEL,
			(void*)&&CREX_IS_SMALLER_OR_EQUAL_SPEC_CONST_TMPVARCV_JMPNC_LABEL,
			(void*)&&CREX_IS_SMALLER_OR_EQUAL_SPEC_TMPVARCV_CONST_LABEL,
			(void*)&&CREX_IS_SMALLER_OR_EQUAL_SPEC_TMPVARCV_CONST_JMPC_LABEL,
			(void*)&&CREX_IS_SMALLER_OR_EQUAL_SPEC_TMPVARCV_CONST_JMPNC_LABEL,
			(void*)&&CREX_IS_SMALLER_OR_EQUAL_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_IS_SMALLER_OR_EQUAL_SPEC_TMPVARCV_TMPVARCV_JMPC_LABEL,
			(void*)&&CREX_IS_SMALLER_OR_EQUAL_SPEC_TMPVARCV_TMPVARCV_JMPNC_LABEL,
			(void*)&&CREX_IS_SMALLER_OR_EQUAL_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_IS_SMALLER_OR_EQUAL_SPEC_TMPVARCV_TMPVARCV_JMPC_LABEL,
			(void*)&&CREX_IS_SMALLER_OR_EQUAL_SPEC_TMPVARCV_TMPVARCV_JMPNC_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_IS_SMALLER_OR_EQUAL_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_IS_SMALLER_OR_EQUAL_SPEC_TMPVARCV_TMPVARCV_JMPC_LABEL,
			(void*)&&CREX_IS_SMALLER_OR_EQUAL_SPEC_TMPVARCV_TMPVARCV_JMPNC_LABEL,
			(void*)&&CREX_IS_SMALLER_OR_EQUAL_SPEC_TMPVARCV_CONST_LABEL,
			(void*)&&CREX_IS_SMALLER_OR_EQUAL_SPEC_TMPVARCV_CONST_JMPC_LABEL,
			(void*)&&CREX_IS_SMALLER_OR_EQUAL_SPEC_TMPVARCV_CONST_JMPNC_LABEL,
			(void*)&&CREX_IS_SMALLER_OR_EQUAL_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_IS_SMALLER_OR_EQUAL_SPEC_TMPVARCV_TMPVARCV_JMPC_LABEL,
			(void*)&&CREX_IS_SMALLER_OR_EQUAL_SPEC_TMPVARCV_TMPVARCV_JMPNC_LABEL,
			(void*)&&CREX_IS_SMALLER_OR_EQUAL_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_IS_SMALLER_OR_EQUAL_SPEC_TMPVARCV_TMPVARCV_JMPC_LABEL,
			(void*)&&CREX_IS_SMALLER_OR_EQUAL_SPEC_TMPVARCV_TMPVARCV_JMPNC_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_IS_SMALLER_OR_EQUAL_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_IS_SMALLER_OR_EQUAL_SPEC_TMPVARCV_TMPVARCV_JMPC_LABEL,
			(void*)&&CREX_IS_SMALLER_OR_EQUAL_SPEC_TMPVARCV_TMPVARCV_JMPNC_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_IS_SMALLER_OR_EQUAL_SPEC_TMPVARCV_CONST_LABEL,
			(void*)&&CREX_IS_SMALLER_OR_EQUAL_SPEC_TMPVARCV_CONST_JMPC_LABEL,
			(void*)&&CREX_IS_SMALLER_OR_EQUAL_SPEC_TMPVARCV_CONST_JMPNC_LABEL,
			(void*)&&CREX_IS_SMALLER_OR_EQUAL_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_IS_SMALLER_OR_EQUAL_SPEC_TMPVARCV_TMPVARCV_JMPC_LABEL,
			(void*)&&CREX_IS_SMALLER_OR_EQUAL_SPEC_TMPVARCV_TMPVARCV_JMPNC_LABEL,
			(void*)&&CREX_IS_SMALLER_OR_EQUAL_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_IS_SMALLER_OR_EQUAL_SPEC_TMPVARCV_TMPVARCV_JMPC_LABEL,
			(void*)&&CREX_IS_SMALLER_OR_EQUAL_SPEC_TMPVARCV_TMPVARCV_JMPNC_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_IS_SMALLER_OR_EQUAL_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_IS_SMALLER_OR_EQUAL_SPEC_TMPVARCV_TMPVARCV_JMPC_LABEL,
			(void*)&&CREX_IS_SMALLER_OR_EQUAL_SPEC_TMPVARCV_TMPVARCV_JMPNC_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_ASSIGN_SPEC_VAR_CONST_RETVAL_UNUSED_LABEL,
			(void*)&&CREX_ASSIGN_SPEC_VAR_CONST_RETVAL_USED_LABEL,
			(void*)&&CREX_ASSIGN_SPEC_VAR_TMP_RETVAL_UNUSED_LABEL,
			(void*)&&CREX_ASSIGN_SPEC_VAR_TMP_RETVAL_USED_LABEL,
			(void*)&&CREX_ASSIGN_SPEC_VAR_VAR_RETVAL_UNUSED_LABEL,
			(void*)&&CREX_ASSIGN_SPEC_VAR_VAR_RETVAL_USED_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_ASSIGN_SPEC_VAR_CV_RETVAL_UNUSED_LABEL,
			(void*)&&CREX_ASSIGN_SPEC_VAR_CV_RETVAL_USED_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_ASSIGN_SPEC_CV_CONST_RETVAL_UNUSED_LABEL,
			(void*)&&CREX_ASSIGN_SPEC_CV_CONST_RETVAL_USED_LABEL,
			(void*)&&CREX_ASSIGN_SPEC_CV_TMP_RETVAL_UNUSED_LABEL,
			(void*)&&CREX_ASSIGN_SPEC_CV_TMP_RETVAL_USED_LABEL,
			(void*)&&CREX_ASSIGN_SPEC_CV_VAR_RETVAL_UNUSED_LABEL,
			(void*)&&CREX_ASSIGN_SPEC_CV_VAR_RETVAL_USED_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_ASSIGN_SPEC_CV_CV_RETVAL_UNUSED_LABEL,
			(void*)&&CREX_ASSIGN_SPEC_CV_CV_RETVAL_USED_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_ASSIGN_DIM_SPEC_VAR_CONST_OP_DATA_CONST_LABEL,
			(void*)&&CREX_ASSIGN_DIM_SPEC_VAR_CONST_OP_DATA_TMP_LABEL,
			(void*)&&CREX_ASSIGN_DIM_SPEC_VAR_CONST_OP_DATA_VAR_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_ASSIGN_DIM_SPEC_VAR_CONST_OP_DATA_CV_LABEL,
			(void*)&&CREX_ASSIGN_DIM_SPEC_VAR_TMPVAR_OP_DATA_CONST_LABEL,
			(void*)&&CREX_ASSIGN_DIM_SPEC_VAR_TMPVAR_OP_DATA_TMP_LABEL,
			(void*)&&CREX_ASSIGN_DIM_SPEC_VAR_TMPVAR_OP_DATA_VAR_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_ASSIGN_DIM_SPEC_VAR_TMPVAR_OP_DATA_CV_LABEL,
			(void*)&&CREX_ASSIGN_DIM_SPEC_VAR_TMPVAR_OP_DATA_CONST_LABEL,
			(void*)&&CREX_ASSIGN_DIM_SPEC_VAR_TMPVAR_OP_DATA_TMP_LABEL,
			(void*)&&CREX_ASSIGN_DIM_SPEC_VAR_TMPVAR_OP_DATA_VAR_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_ASSIGN_DIM_SPEC_VAR_TMPVAR_OP_DATA_CV_LABEL,
			(void*)&&CREX_ASSIGN_DIM_SPEC_VAR_UNUSED_OP_DATA_CONST_LABEL,
			(void*)&&CREX_ASSIGN_DIM_SPEC_VAR_UNUSED_OP_DATA_TMP_LABEL,
			(void*)&&CREX_ASSIGN_DIM_SPEC_VAR_UNUSED_OP_DATA_VAR_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_ASSIGN_DIM_SPEC_VAR_UNUSED_OP_DATA_CV_LABEL,
			(void*)&&CREX_ASSIGN_DIM_SPEC_VAR_CV_OP_DATA_CONST_LABEL,
			(void*)&&CREX_ASSIGN_DIM_SPEC_VAR_CV_OP_DATA_TMP_LABEL,
			(void*)&&CREX_ASSIGN_DIM_SPEC_VAR_CV_OP_DATA_VAR_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_ASSIGN_DIM_SPEC_VAR_CV_OP_DATA_CV_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_ASSIGN_DIM_SPEC_CV_CONST_OP_DATA_CONST_LABEL,
			(void*)&&CREX_ASSIGN_DIM_SPEC_CV_CONST_OP_DATA_TMP_LABEL,
			(void*)&&CREX_ASSIGN_DIM_SPEC_CV_CONST_OP_DATA_VAR_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_ASSIGN_DIM_SPEC_CV_CONST_OP_DATA_CV_LABEL,
			(void*)&&CREX_ASSIGN_DIM_SPEC_CV_TMPVAR_OP_DATA_CONST_LABEL,
			(void*)&&CREX_ASSIGN_DIM_SPEC_CV_TMPVAR_OP_DATA_TMP_LABEL,
			(void*)&&CREX_ASSIGN_DIM_SPEC_CV_TMPVAR_OP_DATA_VAR_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_ASSIGN_DIM_SPEC_CV_TMPVAR_OP_DATA_CV_LABEL,
			(void*)&&CREX_ASSIGN_DIM_SPEC_CV_TMPVAR_OP_DATA_CONST_LABEL,
			(void*)&&CREX_ASSIGN_DIM_SPEC_CV_TMPVAR_OP_DATA_TMP_LABEL,
			(void*)&&CREX_ASSIGN_DIM_SPEC_CV_TMPVAR_OP_DATA_VAR_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_ASSIGN_DIM_SPEC_CV_TMPVAR_OP_DATA_CV_LABEL,
			(void*)&&CREX_ASSIGN_DIM_SPEC_CV_UNUSED_OP_DATA_CONST_LABEL,
			(void*)&&CREX_ASSIGN_DIM_SPEC_CV_UNUSED_OP_DATA_TMP_LABEL,
			(void*)&&CREX_ASSIGN_DIM_SPEC_CV_UNUSED_OP_DATA_VAR_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_ASSIGN_DIM_SPEC_CV_UNUSED_OP_DATA_CV_LABEL,
			(void*)&&CREX_ASSIGN_DIM_SPEC_CV_CV_OP_DATA_CONST_LABEL,
			(void*)&&CREX_ASSIGN_DIM_SPEC_CV_CV_OP_DATA_TMP_LABEL,
			(void*)&&CREX_ASSIGN_DIM_SPEC_CV_CV_OP_DATA_VAR_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_ASSIGN_DIM_SPEC_CV_CV_OP_DATA_CV_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_ASSIGN_OBJ_SPEC_VAR_CONST_OP_DATA_CONST_LABEL,
			(void*)&&CREX_ASSIGN_OBJ_SPEC_VAR_CONST_OP_DATA_TMP_LABEL,
			(void*)&&CREX_ASSIGN_OBJ_SPEC_VAR_CONST_OP_DATA_VAR_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_ASSIGN_OBJ_SPEC_VAR_CONST_OP_DATA_CV_LABEL,
			(void*)&&CREX_ASSIGN_OBJ_SPEC_VAR_TMPVAR_OP_DATA_CONST_LABEL,
			(void*)&&CREX_ASSIGN_OBJ_SPEC_VAR_TMPVAR_OP_DATA_TMP_LABEL,
			(void*)&&CREX_ASSIGN_OBJ_SPEC_VAR_TMPVAR_OP_DATA_VAR_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_ASSIGN_OBJ_SPEC_VAR_TMPVAR_OP_DATA_CV_LABEL,
			(void*)&&CREX_ASSIGN_OBJ_SPEC_VAR_TMPVAR_OP_DATA_CONST_LABEL,
			(void*)&&CREX_ASSIGN_OBJ_SPEC_VAR_TMPVAR_OP_DATA_TMP_LABEL,
			(void*)&&CREX_ASSIGN_OBJ_SPEC_VAR_TMPVAR_OP_DATA_VAR_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_ASSIGN_OBJ_SPEC_VAR_TMPVAR_OP_DATA_CV_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_ASSIGN_OBJ_SPEC_VAR_CV_OP_DATA_CONST_LABEL,
			(void*)&&CREX_ASSIGN_OBJ_SPEC_VAR_CV_OP_DATA_TMP_LABEL,
			(void*)&&CREX_ASSIGN_OBJ_SPEC_VAR_CV_OP_DATA_VAR_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_ASSIGN_OBJ_SPEC_VAR_CV_OP_DATA_CV_LABEL,
			(void*)&&CREX_ASSIGN_OBJ_SPEC_UNUSED_CONST_OP_DATA_CONST_LABEL,
			(void*)&&CREX_ASSIGN_OBJ_SPEC_UNUSED_CONST_OP_DATA_TMP_LABEL,
			(void*)&&CREX_ASSIGN_OBJ_SPEC_UNUSED_CONST_OP_DATA_VAR_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_ASSIGN_OBJ_SPEC_UNUSED_CONST_OP_DATA_CV_LABEL,
			(void*)&&CREX_ASSIGN_OBJ_SPEC_UNUSED_TMPVAR_OP_DATA_CONST_LABEL,
			(void*)&&CREX_ASSIGN_OBJ_SPEC_UNUSED_TMPVAR_OP_DATA_TMP_LABEL,
			(void*)&&CREX_ASSIGN_OBJ_SPEC_UNUSED_TMPVAR_OP_DATA_VAR_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_ASSIGN_OBJ_SPEC_UNUSED_TMPVAR_OP_DATA_CV_LABEL,
			(void*)&&CREX_ASSIGN_OBJ_SPEC_UNUSED_TMPVAR_OP_DATA_CONST_LABEL,
			(void*)&&CREX_ASSIGN_OBJ_SPEC_UNUSED_TMPVAR_OP_DATA_TMP_LABEL,
			(void*)&&CREX_ASSIGN_OBJ_SPEC_UNUSED_TMPVAR_OP_DATA_VAR_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_ASSIGN_OBJ_SPEC_UNUSED_TMPVAR_OP_DATA_CV_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_ASSIGN_OBJ_SPEC_UNUSED_CV_OP_DATA_CONST_LABEL,
			(void*)&&CREX_ASSIGN_OBJ_SPEC_UNUSED_CV_OP_DATA_TMP_LABEL,
			(void*)&&CREX_ASSIGN_OBJ_SPEC_UNUSED_CV_OP_DATA_VAR_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_ASSIGN_OBJ_SPEC_UNUSED_CV_OP_DATA_CV_LABEL,
			(void*)&&CREX_ASSIGN_OBJ_SPEC_CV_CONST_OP_DATA_CONST_LABEL,
			(void*)&&CREX_ASSIGN_OBJ_SPEC_CV_CONST_OP_DATA_TMP_LABEL,
			(void*)&&CREX_ASSIGN_OBJ_SPEC_CV_CONST_OP_DATA_VAR_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_ASSIGN_OBJ_SPEC_CV_CONST_OP_DATA_CV_LABEL,
			(void*)&&CREX_ASSIGN_OBJ_SPEC_CV_TMPVAR_OP_DATA_CONST_LABEL,
			(void*)&&CREX_ASSIGN_OBJ_SPEC_CV_TMPVAR_OP_DATA_TMP_LABEL,
			(void*)&&CREX_ASSIGN_OBJ_SPEC_CV_TMPVAR_OP_DATA_VAR_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_ASSIGN_OBJ_SPEC_CV_TMPVAR_OP_DATA_CV_LABEL,
			(void*)&&CREX_ASSIGN_OBJ_SPEC_CV_TMPVAR_OP_DATA_CONST_LABEL,
			(void*)&&CREX_ASSIGN_OBJ_SPEC_CV_TMPVAR_OP_DATA_TMP_LABEL,
			(void*)&&CREX_ASSIGN_OBJ_SPEC_CV_TMPVAR_OP_DATA_VAR_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_ASSIGN_OBJ_SPEC_CV_TMPVAR_OP_DATA_CV_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_ASSIGN_OBJ_SPEC_CV_CV_OP_DATA_CONST_LABEL,
			(void*)&&CREX_ASSIGN_OBJ_SPEC_CV_CV_OP_DATA_TMP_LABEL,
			(void*)&&CREX_ASSIGN_OBJ_SPEC_CV_CV_OP_DATA_VAR_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_ASSIGN_OBJ_SPEC_CV_CV_OP_DATA_CV_LABEL,
			(void*)&&CREX_ASSIGN_STATIC_PROP_SPEC_OP_DATA_CONST_LABEL,
			(void*)&&CREX_ASSIGN_STATIC_PROP_SPEC_OP_DATA_TMP_LABEL,
			(void*)&&CREX_ASSIGN_STATIC_PROP_SPEC_OP_DATA_VAR_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_ASSIGN_STATIC_PROP_SPEC_OP_DATA_CV_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_ASSIGN_OP_SPEC_VAR_CONST_LABEL,
			(void*)&&CREX_ASSIGN_OP_SPEC_VAR_TMPVAR_LABEL,
			(void*)&&CREX_ASSIGN_OP_SPEC_VAR_TMPVAR_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_ASSIGN_OP_SPEC_VAR_CV_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_ASSIGN_OP_SPEC_CV_CONST_LABEL,
			(void*)&&CREX_ASSIGN_OP_SPEC_CV_TMPVAR_LABEL,
			(void*)&&CREX_ASSIGN_OP_SPEC_CV_TMPVAR_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_ASSIGN_OP_SPEC_CV_CV_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_ASSIGN_DIM_OP_SPEC_VAR_CONST_LABEL,
			(void*)&&CREX_ASSIGN_DIM_OP_SPEC_VAR_TMPVAR_LABEL,
			(void*)&&CREX_ASSIGN_DIM_OP_SPEC_VAR_TMPVAR_LABEL,
			(void*)&&CREX_ASSIGN_DIM_OP_SPEC_VAR_UNUSED_LABEL,
			(void*)&&CREX_ASSIGN_DIM_OP_SPEC_VAR_CV_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_ASSIGN_DIM_OP_SPEC_CV_CONST_LABEL,
			(void*)&&CREX_ASSIGN_DIM_OP_SPEC_CV_TMPVAR_LABEL,
			(void*)&&CREX_ASSIGN_DIM_OP_SPEC_CV_TMPVAR_LABEL,
			(void*)&&CREX_ASSIGN_DIM_OP_SPEC_CV_UNUSED_LABEL,
			(void*)&&CREX_ASSIGN_DIM_OP_SPEC_CV_CV_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_ASSIGN_OBJ_OP_SPEC_VAR_CONST_LABEL,
			(void*)&&CREX_ASSIGN_OBJ_OP_SPEC_VAR_TMPVAR_LABEL,
			(void*)&&CREX_ASSIGN_OBJ_OP_SPEC_VAR_TMPVAR_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_ASSIGN_OBJ_OP_SPEC_VAR_CV_LABEL,
			(void*)&&CREX_ASSIGN_OBJ_OP_SPEC_UNUSED_CONST_LABEL,
			(void*)&&CREX_ASSIGN_OBJ_OP_SPEC_UNUSED_TMPVAR_LABEL,
			(void*)&&CREX_ASSIGN_OBJ_OP_SPEC_UNUSED_TMPVAR_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_ASSIGN_OBJ_OP_SPEC_UNUSED_CV_LABEL,
			(void*)&&CREX_ASSIGN_OBJ_OP_SPEC_CV_CONST_LABEL,
			(void*)&&CREX_ASSIGN_OBJ_OP_SPEC_CV_TMPVAR_LABEL,
			(void*)&&CREX_ASSIGN_OBJ_OP_SPEC_CV_TMPVAR_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_ASSIGN_OBJ_OP_SPEC_CV_CV_LABEL,
			(void*)&&CREX_ASSIGN_STATIC_PROP_OP_SPEC_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_ASSIGN_REF_SPEC_VAR_VAR_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_ASSIGN_REF_SPEC_VAR_CV_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_ASSIGN_REF_SPEC_CV_VAR_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_ASSIGN_REF_SPEC_CV_CV_LABEL,
			(void*)&&CREX_QM_ASSIGN_SPEC_CONST_LABEL,
			(void*)&&CREX_QM_ASSIGN_SPEC_TMP_LABEL,
			(void*)&&CREX_QM_ASSIGN_SPEC_VAR_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_QM_ASSIGN_SPEC_CV_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_ASSIGN_OBJ_REF_SPEC_VAR_CONST_OP_DATA_VAR_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_ASSIGN_OBJ_REF_SPEC_VAR_CONST_OP_DATA_CV_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_ASSIGN_OBJ_REF_SPEC_VAR_TMPVAR_OP_DATA_VAR_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_ASSIGN_OBJ_REF_SPEC_VAR_TMPVAR_OP_DATA_CV_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_ASSIGN_OBJ_REF_SPEC_VAR_TMPVAR_OP_DATA_VAR_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_ASSIGN_OBJ_REF_SPEC_VAR_TMPVAR_OP_DATA_CV_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_ASSIGN_OBJ_REF_SPEC_VAR_CV_OP_DATA_VAR_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_ASSIGN_OBJ_REF_SPEC_VAR_CV_OP_DATA_CV_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_ASSIGN_OBJ_REF_SPEC_UNUSED_CONST_OP_DATA_VAR_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_ASSIGN_OBJ_REF_SPEC_UNUSED_CONST_OP_DATA_CV_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_ASSIGN_OBJ_REF_SPEC_UNUSED_TMPVAR_OP_DATA_VAR_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_ASSIGN_OBJ_REF_SPEC_UNUSED_TMPVAR_OP_DATA_CV_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_ASSIGN_OBJ_REF_SPEC_UNUSED_TMPVAR_OP_DATA_VAR_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_ASSIGN_OBJ_REF_SPEC_UNUSED_TMPVAR_OP_DATA_CV_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_ASSIGN_OBJ_REF_SPEC_UNUSED_CV_OP_DATA_VAR_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_ASSIGN_OBJ_REF_SPEC_UNUSED_CV_OP_DATA_CV_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_ASSIGN_OBJ_REF_SPEC_CV_CONST_OP_DATA_VAR_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_ASSIGN_OBJ_REF_SPEC_CV_CONST_OP_DATA_CV_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_ASSIGN_OBJ_REF_SPEC_CV_TMPVAR_OP_DATA_VAR_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_ASSIGN_OBJ_REF_SPEC_CV_TMPVAR_OP_DATA_CV_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_ASSIGN_OBJ_REF_SPEC_CV_TMPVAR_OP_DATA_VAR_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_ASSIGN_OBJ_REF_SPEC_CV_TMPVAR_OP_DATA_CV_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_ASSIGN_OBJ_REF_SPEC_CV_CV_OP_DATA_VAR_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_ASSIGN_OBJ_REF_SPEC_CV_CV_OP_DATA_CV_LABEL,
			(void*)&&CREX_ASSIGN_STATIC_PROP_REF_SPEC_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_PRE_INC_SPEC_VAR_RETVAL_UNUSED_LABEL,
			(void*)&&CREX_PRE_INC_SPEC_VAR_RETVAL_USED_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_PRE_INC_SPEC_CV_RETVAL_UNUSED_LABEL,
			(void*)&&CREX_PRE_INC_SPEC_CV_RETVAL_USED_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_PRE_DEC_SPEC_VAR_RETVAL_UNUSED_LABEL,
			(void*)&&CREX_PRE_DEC_SPEC_VAR_RETVAL_USED_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_PRE_DEC_SPEC_CV_RETVAL_UNUSED_LABEL,
			(void*)&&CREX_PRE_DEC_SPEC_CV_RETVAL_USED_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_POST_INC_SPEC_VAR_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_POST_INC_SPEC_CV_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_POST_DEC_SPEC_VAR_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_POST_DEC_SPEC_CV_LABEL,
			(void*)&&CREX_PRE_INC_STATIC_PROP_SPEC_LABEL,
			(void*)&&CREX_POST_INC_STATIC_PROP_SPEC_LABEL,
			(void*)&&CREX_JMP_SPEC_LABEL,
			(void*)&&CREX_JMPC_SPEC_CONST_LABEL,
			(void*)&&CREX_JMPC_SPEC_TMPVAR_LABEL,
			(void*)&&CREX_JMPC_SPEC_TMPVAR_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_JMPC_SPEC_CV_LABEL,
			(void*)&&CREX_JMPNC_SPEC_CONST_LABEL,
			(void*)&&CREX_JMPNC_SPEC_TMPVAR_LABEL,
			(void*)&&CREX_JMPNC_SPEC_TMPVAR_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_JMPNC_SPEC_CV_LABEL,
			(void*)&&CREX_JMPC_EX_SPEC_CONST_LABEL,
			(void*)&&CREX_JMPC_EX_SPEC_TMPVAR_LABEL,
			(void*)&&CREX_JMPC_EX_SPEC_TMPVAR_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_JMPC_EX_SPEC_CV_LABEL,
			(void*)&&CREX_JMPNC_EX_SPEC_CONST_LABEL,
			(void*)&&CREX_JMPNC_EX_SPEC_TMPVAR_LABEL,
			(void*)&&CREX_JMPNC_EX_SPEC_TMPVAR_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_JMPNC_EX_SPEC_CV_LABEL,
			(void*)&&CREX_CASE_SPEC_TMPVAR_CONST_LABEL,
			(void*)&&CREX_CASE_SPEC_TMPVAR_TMPVAR_LABEL,
			(void*)&&CREX_CASE_SPEC_TMPVAR_TMPVAR_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_CASE_SPEC_TMPVAR_CV_LABEL,
			(void*)&&CREX_CHECK_VAR_SPEC_CV_UNUSED_LABEL,
			(void*)&&CREX_SEND_VAR_NO_REF_EX_SPEC_VAR_CONST_LABEL,
			(void*)&&CREX_SEND_VAR_NO_REF_EX_SPEC_VAR_CONST_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_SEND_VAR_NO_REF_EX_SPEC_VAR_UNUSED_LABEL,
			(void*)&&CREX_SEND_VAR_NO_REF_EX_SPEC_VAR_UNUSED_QUICK_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_CAST_SPEC_CONST_LABEL,
			(void*)&&CREX_CAST_SPEC_TMP_LABEL,
			(void*)&&CREX_CAST_SPEC_VAR_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_CAST_SPEC_CV_LABEL,
			(void*)&&CREX_BOOL_SPEC_CONST_LABEL,
			(void*)&&CREX_BOOL_SPEC_TMPVAR_LABEL,
			(void*)&&CREX_BOOL_SPEC_TMPVAR_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_BOOL_SPEC_CV_LABEL,
			(void*)&&CREX_FAST_CONCAT_SPEC_CONST_CONST_LABEL,
			(void*)&&CREX_FAST_CONCAT_SPEC_CONST_TMPVAR_LABEL,
			(void*)&&CREX_FAST_CONCAT_SPEC_CONST_TMPVAR_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_FAST_CONCAT_SPEC_CONST_CV_LABEL,
			(void*)&&CREX_FAST_CONCAT_SPEC_TMPVAR_CONST_LABEL,
			(void*)&&CREX_FAST_CONCAT_SPEC_TMPVAR_TMPVAR_LABEL,
			(void*)&&CREX_FAST_CONCAT_SPEC_TMPVAR_TMPVAR_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_FAST_CONCAT_SPEC_TMPVAR_CV_LABEL,
			(void*)&&CREX_FAST_CONCAT_SPEC_TMPVAR_CONST_LABEL,
			(void*)&&CREX_FAST_CONCAT_SPEC_TMPVAR_TMPVAR_LABEL,
			(void*)&&CREX_FAST_CONCAT_SPEC_TMPVAR_TMPVAR_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_FAST_CONCAT_SPEC_TMPVAR_CV_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_FAST_CONCAT_SPEC_CV_CONST_LABEL,
			(void*)&&CREX_FAST_CONCAT_SPEC_CV_TMPVAR_LABEL,
			(void*)&&CREX_FAST_CONCAT_SPEC_CV_TMPVAR_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_FAST_CONCAT_SPEC_CV_CV_LABEL,
			(void*)&&CREX_ROPE_INIT_SPEC_UNUSED_CONST_LABEL,
			(void*)&&CREX_ROPE_INIT_SPEC_UNUSED_TMPVAR_LABEL,
			(void*)&&CREX_ROPE_INIT_SPEC_UNUSED_TMPVAR_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_ROPE_INIT_SPEC_UNUSED_CV_LABEL,
			(void*)&&CREX_ROPE_ADD_SPEC_TMP_CONST_LABEL,
			(void*)&&CREX_ROPE_ADD_SPEC_TMP_TMPVAR_LABEL,
			(void*)&&CREX_ROPE_ADD_SPEC_TMP_TMPVAR_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_ROPE_ADD_SPEC_TMP_CV_LABEL,
			(void*)&&CREX_ROPE_END_SPEC_TMP_CONST_LABEL,
			(void*)&&CREX_ROPE_END_SPEC_TMP_TMPVAR_LABEL,
			(void*)&&CREX_ROPE_END_SPEC_TMP_TMPVAR_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_ROPE_END_SPEC_TMP_CV_LABEL,
			(void*)&&CREX_BEGIN_SILENCE_SPEC_LABEL,
			(void*)&&CREX_END_SILENCE_SPEC_TMP_LABEL,
			(void*)&&CREX_INIT_FCALL_BY_NAME_SPEC_CONST_LABEL,
			(void*)&&CREX_DO_FCALL_SPEC_RETVAL_UNUSED_LABEL,
			(void*)&&CREX_DO_FCALL_SPEC_RETVAL_USED_LABEL,
			(void*)&&CREX_DO_FCALL_SPEC_OBSERVER_LABEL,
			(void*)&&CREX_DO_FCALL_SPEC_OBSERVER_LABEL,
			(void*)&&CREX_INIT_FCALL_SPEC_CONST_LABEL,
			(void*)&&CREX_RETURN_SPEC_CONST_LABEL,
			(void*)&&CREX_RETURN_SPEC_OBSERVER_LABEL,
			(void*)&&CREX_RETURN_SPEC_TMP_LABEL,
			(void*)&&CREX_RETURN_SPEC_OBSERVER_LABEL,
			(void*)&&CREX_RETURN_SPEC_VAR_LABEL,
			(void*)&&CREX_RETURN_SPEC_OBSERVER_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_RETURN_SPEC_CV_LABEL,
			(void*)&&CREX_RETURN_SPEC_OBSERVER_LABEL,
			(void*)&&CREX_RECV_SPEC_UNUSED_LABEL,
			(void*)&&CREX_RECV_INIT_SPEC_CONST_LABEL,
			(void*)&&CREX_SEND_VAL_SPEC_CONST_CONST_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_SEND_VAL_SPEC_CONST_UNUSED_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_SEND_VAL_SPEC_TMPVAR_CONST_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_SEND_VAL_SPEC_TMPVAR_UNUSED_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_SEND_VAL_SPEC_TMPVAR_CONST_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_SEND_VAL_SPEC_TMPVAR_UNUSED_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_SEND_VAR_EX_SPEC_VAR_CONST_LABEL,
			(void*)&&CREX_SEND_VAR_EX_SPEC_VAR_CONST_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_SEND_VAR_EX_SPEC_VAR_UNUSED_LABEL,
			(void*)&&CREX_SEND_VAR_EX_SPEC_VAR_UNUSED_QUICK_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_SEND_VAR_EX_SPEC_CV_CONST_LABEL,
			(void*)&&CREX_SEND_VAR_EX_SPEC_CV_CONST_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_SEND_VAR_EX_SPEC_CV_UNUSED_LABEL,
			(void*)&&CREX_SEND_VAR_EX_SPEC_CV_UNUSED_QUICK_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_SEND_REF_SPEC_VAR_CONST_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_SEND_REF_SPEC_VAR_UNUSED_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_SEND_REF_SPEC_CV_CONST_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_SEND_REF_SPEC_CV_UNUSED_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NEW_SPEC_CONST_UNUSED_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NEW_SPEC_VAR_UNUSED_LABEL,
			(void*)&&CREX_NEW_SPEC_UNUSED_UNUSED_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_INIT_NS_FCALL_BY_NAME_SPEC_CONST_LABEL,
			(void*)&&CREX_FREE_SPEC_TMPVAR_LABEL,
			(void*)&&CREX_INIT_ARRAY_SPEC_CONST_CONST_LABEL,
			(void*)&&CREX_INIT_ARRAY_SPEC_CONST_TMPVAR_LABEL,
			(void*)&&CREX_INIT_ARRAY_SPEC_CONST_TMPVAR_LABEL,
			(void*)&&CREX_INIT_ARRAY_SPEC_CONST_UNUSED_LABEL,
			(void*)&&CREX_INIT_ARRAY_SPEC_CONST_CV_LABEL,
			(void*)&&CREX_INIT_ARRAY_SPEC_TMP_CONST_LABEL,
			(void*)&&CREX_INIT_ARRAY_SPEC_TMP_TMPVAR_LABEL,
			(void*)&&CREX_INIT_ARRAY_SPEC_TMP_TMPVAR_LABEL,
			(void*)&&CREX_INIT_ARRAY_SPEC_TMP_UNUSED_LABEL,
			(void*)&&CREX_INIT_ARRAY_SPEC_TMP_CV_LABEL,
			(void*)&&CREX_INIT_ARRAY_SPEC_VAR_CONST_LABEL,
			(void*)&&CREX_INIT_ARRAY_SPEC_VAR_TMPVAR_LABEL,
			(void*)&&CREX_INIT_ARRAY_SPEC_VAR_TMPVAR_LABEL,
			(void*)&&CREX_INIT_ARRAY_SPEC_VAR_UNUSED_LABEL,
			(void*)&&CREX_INIT_ARRAY_SPEC_VAR_CV_LABEL,
			(void*)&&CREX_INIT_ARRAY_SPEC_UNUSED_CONST_LABEL,
			(void*)&&CREX_INIT_ARRAY_SPEC_UNUSED_TMPVAR_LABEL,
			(void*)&&CREX_INIT_ARRAY_SPEC_UNUSED_TMPVAR_LABEL,
			(void*)&&CREX_INIT_ARRAY_SPEC_UNUSED_UNUSED_LABEL,
			(void*)&&CREX_INIT_ARRAY_SPEC_UNUSED_CV_LABEL,
			(void*)&&CREX_INIT_ARRAY_SPEC_CV_CONST_LABEL,
			(void*)&&CREX_INIT_ARRAY_SPEC_CV_TMPVAR_LABEL,
			(void*)&&CREX_INIT_ARRAY_SPEC_CV_TMPVAR_LABEL,
			(void*)&&CREX_INIT_ARRAY_SPEC_CV_UNUSED_LABEL,
			(void*)&&CREX_INIT_ARRAY_SPEC_CV_CV_LABEL,
			(void*)&&CREX_ADD_ARRAY_ELEMENT_SPEC_CONST_CONST_LABEL,
			(void*)&&CREX_ADD_ARRAY_ELEMENT_SPEC_CONST_TMPVAR_LABEL,
			(void*)&&CREX_ADD_ARRAY_ELEMENT_SPEC_CONST_TMPVAR_LABEL,
			(void*)&&CREX_ADD_ARRAY_ELEMENT_SPEC_CONST_UNUSED_LABEL,
			(void*)&&CREX_ADD_ARRAY_ELEMENT_SPEC_CONST_CV_LABEL,
			(void*)&&CREX_ADD_ARRAY_ELEMENT_SPEC_TMP_CONST_LABEL,
			(void*)&&CREX_ADD_ARRAY_ELEMENT_SPEC_TMP_TMPVAR_LABEL,
			(void*)&&CREX_ADD_ARRAY_ELEMENT_SPEC_TMP_TMPVAR_LABEL,
			(void*)&&CREX_ADD_ARRAY_ELEMENT_SPEC_TMP_UNUSED_LABEL,
			(void*)&&CREX_ADD_ARRAY_ELEMENT_SPEC_TMP_CV_LABEL,
			(void*)&&CREX_ADD_ARRAY_ELEMENT_SPEC_VAR_CONST_LABEL,
			(void*)&&CREX_ADD_ARRAY_ELEMENT_SPEC_VAR_TMPVAR_LABEL,
			(void*)&&CREX_ADD_ARRAY_ELEMENT_SPEC_VAR_TMPVAR_LABEL,
			(void*)&&CREX_ADD_ARRAY_ELEMENT_SPEC_VAR_UNUSED_LABEL,
			(void*)&&CREX_ADD_ARRAY_ELEMENT_SPEC_VAR_CV_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_ADD_ARRAY_ELEMENT_SPEC_CV_CONST_LABEL,
			(void*)&&CREX_ADD_ARRAY_ELEMENT_SPEC_CV_TMPVAR_LABEL,
			(void*)&&CREX_ADD_ARRAY_ELEMENT_SPEC_CV_TMPVAR_LABEL,
			(void*)&&CREX_ADD_ARRAY_ELEMENT_SPEC_CV_UNUSED_LABEL,
			(void*)&&CREX_ADD_ARRAY_ELEMENT_SPEC_CV_CV_LABEL,
			(void*)&&CREX_INCLUDE_OR_EVAL_SPEC_CONST_LABEL,
			(void*)&&CREX_INCLUDE_OR_EVAL_SPEC_OBSERVER_LABEL,
			(void*)&&CREX_INCLUDE_OR_EVAL_SPEC_TMPVAR_LABEL,
			(void*)&&CREX_INCLUDE_OR_EVAL_SPEC_OBSERVER_LABEL,
			(void*)&&CREX_INCLUDE_OR_EVAL_SPEC_TMPVAR_LABEL,
			(void*)&&CREX_INCLUDE_OR_EVAL_SPEC_OBSERVER_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_INCLUDE_OR_EVAL_SPEC_CV_LABEL,
			(void*)&&CREX_INCLUDE_OR_EVAL_SPEC_OBSERVER_LABEL,
			(void*)&&CREX_UNSET_VAR_SPEC_CONST_UNUSED_LABEL,
			(void*)&&CREX_UNSET_VAR_SPEC_TMPVAR_UNUSED_LABEL,
			(void*)&&CREX_UNSET_VAR_SPEC_TMPVAR_UNUSED_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_UNSET_VAR_SPEC_CV_UNUSED_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_UNSET_DIM_SPEC_VAR_CONST_LABEL,
			(void*)&&CREX_UNSET_DIM_SPEC_VAR_TMPVAR_LABEL,
			(void*)&&CREX_UNSET_DIM_SPEC_VAR_TMPVAR_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_UNSET_DIM_SPEC_VAR_CV_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_UNSET_DIM_SPEC_CV_CONST_LABEL,
			(void*)&&CREX_UNSET_DIM_SPEC_CV_TMPVAR_LABEL,
			(void*)&&CREX_UNSET_DIM_SPEC_CV_TMPVAR_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_UNSET_DIM_SPEC_CV_CV_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_UNSET_OBJ_SPEC_VAR_CONST_LABEL,
			(void*)&&CREX_UNSET_OBJ_SPEC_VAR_TMPVAR_LABEL,
			(void*)&&CREX_UNSET_OBJ_SPEC_VAR_TMPVAR_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_UNSET_OBJ_SPEC_VAR_CV_LABEL,
			(void*)&&CREX_UNSET_OBJ_SPEC_UNUSED_CONST_LABEL,
			(void*)&&CREX_UNSET_OBJ_SPEC_UNUSED_TMPVAR_LABEL,
			(void*)&&CREX_UNSET_OBJ_SPEC_UNUSED_TMPVAR_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_UNSET_OBJ_SPEC_UNUSED_CV_LABEL,
			(void*)&&CREX_UNSET_OBJ_SPEC_CV_CONST_LABEL,
			(void*)&&CREX_UNSET_OBJ_SPEC_CV_TMPVAR_LABEL,
			(void*)&&CREX_UNSET_OBJ_SPEC_CV_TMPVAR_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_UNSET_OBJ_SPEC_CV_CV_LABEL,
			(void*)&&CREX_FE_RESET_R_SPEC_CONST_LABEL,
			(void*)&&CREX_FE_RESET_R_SPEC_TMP_LABEL,
			(void*)&&CREX_FE_RESET_R_SPEC_VAR_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_FE_RESET_R_SPEC_CV_LABEL,
			(void*)&&CREX_FE_FETCH_R_SPEC_VAR_LABEL,
			(void*)&&CREX_EXIT_SPEC_LABEL,
			(void*)&&CREX_FETCH_R_SPEC_CONST_UNUSED_LABEL,
			(void*)&&CREX_FETCH_R_SPEC_TMPVAR_UNUSED_LABEL,
			(void*)&&CREX_FETCH_R_SPEC_TMPVAR_UNUSED_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_FETCH_R_SPEC_CV_UNUSED_LABEL,
			(void*)&&CREX_FETCH_DIM_R_SPEC_CONST_CONST_LABEL,
			(void*)&&CREX_FETCH_DIM_R_SPEC_CONST_TMPVAR_LABEL,
			(void*)&&CREX_FETCH_DIM_R_SPEC_CONST_TMPVAR_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_FETCH_DIM_R_SPEC_CONST_CV_LABEL,
			(void*)&&CREX_FETCH_DIM_R_SPEC_TMPVAR_CONST_LABEL,
			(void*)&&CREX_FETCH_DIM_R_SPEC_TMPVAR_TMPVAR_LABEL,
			(void*)&&CREX_FETCH_DIM_R_SPEC_TMPVAR_TMPVAR_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_FETCH_DIM_R_SPEC_TMPVAR_CV_LABEL,
			(void*)&&CREX_FETCH_DIM_R_SPEC_TMPVAR_CONST_LABEL,
			(void*)&&CREX_FETCH_DIM_R_SPEC_TMPVAR_TMPVAR_LABEL,
			(void*)&&CREX_FETCH_DIM_R_SPEC_TMPVAR_TMPVAR_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_FETCH_DIM_R_SPEC_TMPVAR_CV_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_FETCH_DIM_R_SPEC_CV_CONST_LABEL,
			(void*)&&CREX_FETCH_DIM_R_SPEC_CV_TMPVAR_LABEL,
			(void*)&&CREX_FETCH_DIM_R_SPEC_CV_TMPVAR_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_FETCH_DIM_R_SPEC_CV_CV_LABEL,
			(void*)&&CREX_FETCH_OBJ_R_SPEC_CONST_CONST_LABEL,
			(void*)&&CREX_FETCH_OBJ_R_SPEC_CONST_TMPVAR_LABEL,
			(void*)&&CREX_FETCH_OBJ_R_SPEC_CONST_TMPVAR_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_FETCH_OBJ_R_SPEC_CONST_CV_LABEL,
			(void*)&&CREX_FETCH_OBJ_R_SPEC_TMPVAR_CONST_LABEL,
			(void*)&&CREX_FETCH_OBJ_R_SPEC_TMPVAR_TMPVAR_LABEL,
			(void*)&&CREX_FETCH_OBJ_R_SPEC_TMPVAR_TMPVAR_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_FETCH_OBJ_R_SPEC_TMPVAR_CV_LABEL,
			(void*)&&CREX_FETCH_OBJ_R_SPEC_TMPVAR_CONST_LABEL,
			(void*)&&CREX_FETCH_OBJ_R_SPEC_TMPVAR_TMPVAR_LABEL,
			(void*)&&CREX_FETCH_OBJ_R_SPEC_TMPVAR_TMPVAR_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_FETCH_OBJ_R_SPEC_TMPVAR_CV_LABEL,
			(void*)&&CREX_FETCH_OBJ_R_SPEC_UNUSED_CONST_LABEL,
			(void*)&&CREX_FETCH_OBJ_R_SPEC_UNUSED_TMPVAR_LABEL,
			(void*)&&CREX_FETCH_OBJ_R_SPEC_UNUSED_TMPVAR_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_FETCH_OBJ_R_SPEC_UNUSED_CV_LABEL,
			(void*)&&CREX_FETCH_OBJ_R_SPEC_CV_CONST_LABEL,
			(void*)&&CREX_FETCH_OBJ_R_SPEC_CV_TMPVAR_LABEL,
			(void*)&&CREX_FETCH_OBJ_R_SPEC_CV_TMPVAR_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_FETCH_OBJ_R_SPEC_CV_CV_LABEL,
			(void*)&&CREX_FETCH_W_SPEC_CONST_UNUSED_LABEL,
			(void*)&&CREX_FETCH_W_SPEC_TMPVAR_UNUSED_LABEL,
			(void*)&&CREX_FETCH_W_SPEC_TMPVAR_UNUSED_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_FETCH_W_SPEC_CV_UNUSED_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_FETCH_DIM_W_SPEC_VAR_CONST_LABEL,
			(void*)&&CREX_FETCH_DIM_W_SPEC_VAR_TMPVAR_LABEL,
			(void*)&&CREX_FETCH_DIM_W_SPEC_VAR_TMPVAR_LABEL,
			(void*)&&CREX_FETCH_DIM_W_SPEC_VAR_UNUSED_LABEL,
			(void*)&&CREX_FETCH_DIM_W_SPEC_VAR_CV_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_FETCH_DIM_W_SPEC_CV_CONST_LABEL,
			(void*)&&CREX_FETCH_DIM_W_SPEC_CV_TMPVAR_LABEL,
			(void*)&&CREX_FETCH_DIM_W_SPEC_CV_TMPVAR_LABEL,
			(void*)&&CREX_FETCH_DIM_W_SPEC_CV_UNUSED_LABEL,
			(void*)&&CREX_FETCH_DIM_W_SPEC_CV_CV_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_FETCH_OBJ_W_SPEC_VAR_CONST_LABEL,
			(void*)&&CREX_FETCH_OBJ_W_SPEC_VAR_TMPVAR_LABEL,
			(void*)&&CREX_FETCH_OBJ_W_SPEC_VAR_TMPVAR_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_FETCH_OBJ_W_SPEC_VAR_CV_LABEL,
			(void*)&&CREX_FETCH_OBJ_W_SPEC_UNUSED_CONST_LABEL,
			(void*)&&CREX_FETCH_OBJ_W_SPEC_UNUSED_TMPVAR_LABEL,
			(void*)&&CREX_FETCH_OBJ_W_SPEC_UNUSED_TMPVAR_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_FETCH_OBJ_W_SPEC_UNUSED_CV_LABEL,
			(void*)&&CREX_FETCH_OBJ_W_SPEC_CV_CONST_LABEL,
			(void*)&&CREX_FETCH_OBJ_W_SPEC_CV_TMPVAR_LABEL,
			(void*)&&CREX_FETCH_OBJ_W_SPEC_CV_TMPVAR_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_FETCH_OBJ_W_SPEC_CV_CV_LABEL,
			(void*)&&CREX_FETCH_RW_SPEC_CONST_UNUSED_LABEL,
			(void*)&&CREX_FETCH_RW_SPEC_TMPVAR_UNUSED_LABEL,
			(void*)&&CREX_FETCH_RW_SPEC_TMPVAR_UNUSED_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_FETCH_RW_SPEC_CV_UNUSED_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_FETCH_DIM_RW_SPEC_VAR_CONST_LABEL,
			(void*)&&CREX_FETCH_DIM_RW_SPEC_VAR_TMPVAR_LABEL,
			(void*)&&CREX_FETCH_DIM_RW_SPEC_VAR_TMPVAR_LABEL,
			(void*)&&CREX_FETCH_DIM_RW_SPEC_VAR_UNUSED_LABEL,
			(void*)&&CREX_FETCH_DIM_RW_SPEC_VAR_CV_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_FETCH_DIM_RW_SPEC_CV_CONST_LABEL,
			(void*)&&CREX_FETCH_DIM_RW_SPEC_CV_TMPVAR_LABEL,
			(void*)&&CREX_FETCH_DIM_RW_SPEC_CV_TMPVAR_LABEL,
			(void*)&&CREX_FETCH_DIM_RW_SPEC_CV_UNUSED_LABEL,
			(void*)&&CREX_FETCH_DIM_RW_SPEC_CV_CV_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_FETCH_OBJ_RW_SPEC_VAR_CONST_LABEL,
			(void*)&&CREX_FETCH_OBJ_RW_SPEC_VAR_TMPVAR_LABEL,
			(void*)&&CREX_FETCH_OBJ_RW_SPEC_VAR_TMPVAR_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_FETCH_OBJ_RW_SPEC_VAR_CV_LABEL,
			(void*)&&CREX_FETCH_OBJ_RW_SPEC_UNUSED_CONST_LABEL,
			(void*)&&CREX_FETCH_OBJ_RW_SPEC_UNUSED_TMPVAR_LABEL,
			(void*)&&CREX_FETCH_OBJ_RW_SPEC_UNUSED_TMPVAR_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_FETCH_OBJ_RW_SPEC_UNUSED_CV_LABEL,
			(void*)&&CREX_FETCH_OBJ_RW_SPEC_CV_CONST_LABEL,
			(void*)&&CREX_FETCH_OBJ_RW_SPEC_CV_TMPVAR_LABEL,
			(void*)&&CREX_FETCH_OBJ_RW_SPEC_CV_TMPVAR_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_FETCH_OBJ_RW_SPEC_CV_CV_LABEL,
			(void*)&&CREX_FETCH_IS_SPEC_CONST_UNUSED_LABEL,
			(void*)&&CREX_FETCH_IS_SPEC_TMPVAR_UNUSED_LABEL,
			(void*)&&CREX_FETCH_IS_SPEC_TMPVAR_UNUSED_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_FETCH_IS_SPEC_CV_UNUSED_LABEL,
			(void*)&&CREX_FETCH_DIM_IS_SPEC_CONST_CONST_LABEL,
			(void*)&&CREX_FETCH_DIM_IS_SPEC_CONST_TMPVAR_LABEL,
			(void*)&&CREX_FETCH_DIM_IS_SPEC_CONST_TMPVAR_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_FETCH_DIM_IS_SPEC_CONST_CV_LABEL,
			(void*)&&CREX_FETCH_DIM_IS_SPEC_TMPVAR_CONST_LABEL,
			(void*)&&CREX_FETCH_DIM_IS_SPEC_TMPVAR_TMPVAR_LABEL,
			(void*)&&CREX_FETCH_DIM_IS_SPEC_TMPVAR_TMPVAR_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_FETCH_DIM_IS_SPEC_TMPVAR_CV_LABEL,
			(void*)&&CREX_FETCH_DIM_IS_SPEC_TMPVAR_CONST_LABEL,
			(void*)&&CREX_FETCH_DIM_IS_SPEC_TMPVAR_TMPVAR_LABEL,
			(void*)&&CREX_FETCH_DIM_IS_SPEC_TMPVAR_TMPVAR_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_FETCH_DIM_IS_SPEC_TMPVAR_CV_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_FETCH_DIM_IS_SPEC_CV_CONST_LABEL,
			(void*)&&CREX_FETCH_DIM_IS_SPEC_CV_TMPVAR_LABEL,
			(void*)&&CREX_FETCH_DIM_IS_SPEC_CV_TMPVAR_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_FETCH_DIM_IS_SPEC_CV_CV_LABEL,
			(void*)&&CREX_FETCH_OBJ_IS_SPEC_CONST_CONST_LABEL,
			(void*)&&CREX_FETCH_OBJ_IS_SPEC_CONST_TMPVAR_LABEL,
			(void*)&&CREX_FETCH_OBJ_IS_SPEC_CONST_TMPVAR_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_FETCH_OBJ_IS_SPEC_CONST_CV_LABEL,
			(void*)&&CREX_FETCH_OBJ_IS_SPEC_TMPVAR_CONST_LABEL,
			(void*)&&CREX_FETCH_OBJ_IS_SPEC_TMPVAR_TMPVAR_LABEL,
			(void*)&&CREX_FETCH_OBJ_IS_SPEC_TMPVAR_TMPVAR_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_FETCH_OBJ_IS_SPEC_TMPVAR_CV_LABEL,
			(void*)&&CREX_FETCH_OBJ_IS_SPEC_TMPVAR_CONST_LABEL,
			(void*)&&CREX_FETCH_OBJ_IS_SPEC_TMPVAR_TMPVAR_LABEL,
			(void*)&&CREX_FETCH_OBJ_IS_SPEC_TMPVAR_TMPVAR_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_FETCH_OBJ_IS_SPEC_TMPVAR_CV_LABEL,
			(void*)&&CREX_FETCH_OBJ_IS_SPEC_UNUSED_CONST_LABEL,
			(void*)&&CREX_FETCH_OBJ_IS_SPEC_UNUSED_TMPVAR_LABEL,
			(void*)&&CREX_FETCH_OBJ_IS_SPEC_UNUSED_TMPVAR_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_FETCH_OBJ_IS_SPEC_UNUSED_CV_LABEL,
			(void*)&&CREX_FETCH_OBJ_IS_SPEC_CV_CONST_LABEL,
			(void*)&&CREX_FETCH_OBJ_IS_SPEC_CV_TMPVAR_LABEL,
			(void*)&&CREX_FETCH_OBJ_IS_SPEC_CV_TMPVAR_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_FETCH_OBJ_IS_SPEC_CV_CV_LABEL,
			(void*)&&CREX_FETCH_FUNC_ARG_SPEC_CONST_UNUSED_LABEL,
			(void*)&&CREX_FETCH_FUNC_ARG_SPEC_TMPVAR_UNUSED_LABEL,
			(void*)&&CREX_FETCH_FUNC_ARG_SPEC_TMPVAR_UNUSED_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_FETCH_FUNC_ARG_SPEC_CV_UNUSED_LABEL,
			(void*)&&CREX_FETCH_DIM_FUNC_ARG_SPEC_CONST_CONST_LABEL,
			(void*)&&CREX_FETCH_DIM_FUNC_ARG_SPEC_CONST_TMPVAR_LABEL,
			(void*)&&CREX_FETCH_DIM_FUNC_ARG_SPEC_CONST_TMPVAR_LABEL,
			(void*)&&CREX_FETCH_DIM_FUNC_ARG_SPEC_CONST_UNUSED_LABEL,
			(void*)&&CREX_FETCH_DIM_FUNC_ARG_SPEC_CONST_CV_LABEL,
			(void*)&&CREX_FETCH_DIM_FUNC_ARG_SPEC_TMP_CONST_LABEL,
			(void*)&&CREX_FETCH_DIM_FUNC_ARG_SPEC_TMP_TMPVAR_LABEL,
			(void*)&&CREX_FETCH_DIM_FUNC_ARG_SPEC_TMP_TMPVAR_LABEL,
			(void*)&&CREX_FETCH_DIM_FUNC_ARG_SPEC_TMP_UNUSED_LABEL,
			(void*)&&CREX_FETCH_DIM_FUNC_ARG_SPEC_TMP_CV_LABEL,
			(void*)&&CREX_FETCH_DIM_FUNC_ARG_SPEC_VAR_CONST_LABEL,
			(void*)&&CREX_FETCH_DIM_FUNC_ARG_SPEC_VAR_TMPVAR_LABEL,
			(void*)&&CREX_FETCH_DIM_FUNC_ARG_SPEC_VAR_TMPVAR_LABEL,
			(void*)&&CREX_FETCH_DIM_FUNC_ARG_SPEC_VAR_UNUSED_LABEL,
			(void*)&&CREX_FETCH_DIM_FUNC_ARG_SPEC_VAR_CV_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_FETCH_DIM_FUNC_ARG_SPEC_CV_CONST_LABEL,
			(void*)&&CREX_FETCH_DIM_FUNC_ARG_SPEC_CV_TMPVAR_LABEL,
			(void*)&&CREX_FETCH_DIM_FUNC_ARG_SPEC_CV_TMPVAR_LABEL,
			(void*)&&CREX_FETCH_DIM_FUNC_ARG_SPEC_CV_UNUSED_LABEL,
			(void*)&&CREX_FETCH_DIM_FUNC_ARG_SPEC_CV_CV_LABEL,
			(void*)&&CREX_FETCH_OBJ_FUNC_ARG_SPEC_CONST_CONST_LABEL,
			(void*)&&CREX_FETCH_OBJ_FUNC_ARG_SPEC_CONST_TMPVAR_LABEL,
			(void*)&&CREX_FETCH_OBJ_FUNC_ARG_SPEC_CONST_TMPVAR_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_FETCH_OBJ_FUNC_ARG_SPEC_CONST_CV_LABEL,
			(void*)&&CREX_FETCH_OBJ_FUNC_ARG_SPEC_TMP_CONST_LABEL,
			(void*)&&CREX_FETCH_OBJ_FUNC_ARG_SPEC_TMP_TMPVAR_LABEL,
			(void*)&&CREX_FETCH_OBJ_FUNC_ARG_SPEC_TMP_TMPVAR_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_FETCH_OBJ_FUNC_ARG_SPEC_TMP_CV_LABEL,
			(void*)&&CREX_FETCH_OBJ_FUNC_ARG_SPEC_VAR_CONST_LABEL,
			(void*)&&CREX_FETCH_OBJ_FUNC_ARG_SPEC_VAR_TMPVAR_LABEL,
			(void*)&&CREX_FETCH_OBJ_FUNC_ARG_SPEC_VAR_TMPVAR_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_FETCH_OBJ_FUNC_ARG_SPEC_VAR_CV_LABEL,
			(void*)&&CREX_FETCH_OBJ_FUNC_ARG_SPEC_UNUSED_CONST_LABEL,
			(void*)&&CREX_FETCH_OBJ_FUNC_ARG_SPEC_UNUSED_TMPVAR_LABEL,
			(void*)&&CREX_FETCH_OBJ_FUNC_ARG_SPEC_UNUSED_TMPVAR_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_FETCH_OBJ_FUNC_ARG_SPEC_UNUSED_CV_LABEL,
			(void*)&&CREX_FETCH_OBJ_FUNC_ARG_SPEC_CV_CONST_LABEL,
			(void*)&&CREX_FETCH_OBJ_FUNC_ARG_SPEC_CV_TMPVAR_LABEL,
			(void*)&&CREX_FETCH_OBJ_FUNC_ARG_SPEC_CV_TMPVAR_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_FETCH_OBJ_FUNC_ARG_SPEC_CV_CV_LABEL,
			(void*)&&CREX_FETCH_UNSET_SPEC_CONST_UNUSED_LABEL,
			(void*)&&CREX_FETCH_UNSET_SPEC_TMPVAR_UNUSED_LABEL,
			(void*)&&CREX_FETCH_UNSET_SPEC_TMPVAR_UNUSED_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_FETCH_UNSET_SPEC_CV_UNUSED_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_FETCH_DIM_UNSET_SPEC_VAR_CONST_LABEL,
			(void*)&&CREX_FETCH_DIM_UNSET_SPEC_VAR_TMPVAR_LABEL,
			(void*)&&CREX_FETCH_DIM_UNSET_SPEC_VAR_TMPVAR_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_FETCH_DIM_UNSET_SPEC_VAR_CV_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_FETCH_DIM_UNSET_SPEC_CV_CONST_LABEL,
			(void*)&&CREX_FETCH_DIM_UNSET_SPEC_CV_TMPVAR_LABEL,
			(void*)&&CREX_FETCH_DIM_UNSET_SPEC_CV_TMPVAR_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_FETCH_DIM_UNSET_SPEC_CV_CV_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_FETCH_OBJ_UNSET_SPEC_VAR_CONST_LABEL,
			(void*)&&CREX_FETCH_OBJ_UNSET_SPEC_VAR_TMPVAR_LABEL,
			(void*)&&CREX_FETCH_OBJ_UNSET_SPEC_VAR_TMPVAR_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_FETCH_OBJ_UNSET_SPEC_VAR_CV_LABEL,
			(void*)&&CREX_FETCH_OBJ_UNSET_SPEC_UNUSED_CONST_LABEL,
			(void*)&&CREX_FETCH_OBJ_UNSET_SPEC_UNUSED_TMPVAR_LABEL,
			(void*)&&CREX_FETCH_OBJ_UNSET_SPEC_UNUSED_TMPVAR_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_FETCH_OBJ_UNSET_SPEC_UNUSED_CV_LABEL,
			(void*)&&CREX_FETCH_OBJ_UNSET_SPEC_CV_CONST_LABEL,
			(void*)&&CREX_FETCH_OBJ_UNSET_SPEC_CV_TMPVAR_LABEL,
			(void*)&&CREX_FETCH_OBJ_UNSET_SPEC_CV_TMPVAR_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_FETCH_OBJ_UNSET_SPEC_CV_CV_LABEL,
			(void*)&&CREX_FETCH_LIST_R_SPEC_CONST_CONST_LABEL,
			(void*)&&CREX_FETCH_LIST_R_SPEC_CONST_TMPVAR_LABEL,
			(void*)&&CREX_FETCH_LIST_R_SPEC_CONST_TMPVAR_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_FETCH_LIST_R_SPEC_CONST_CV_LABEL,
			(void*)&&CREX_FETCH_LIST_R_SPEC_TMPVARCV_CONST_LABEL,
			(void*)&&CREX_FETCH_LIST_R_SPEC_TMPVARCV_TMPVAR_LABEL,
			(void*)&&CREX_FETCH_LIST_R_SPEC_TMPVARCV_TMPVAR_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_FETCH_LIST_R_SPEC_TMPVARCV_CV_LABEL,
			(void*)&&CREX_FETCH_LIST_R_SPEC_TMPVARCV_CONST_LABEL,
			(void*)&&CREX_FETCH_LIST_R_SPEC_TMPVARCV_TMPVAR_LABEL,
			(void*)&&CREX_FETCH_LIST_R_SPEC_TMPVARCV_TMPVAR_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_FETCH_LIST_R_SPEC_TMPVARCV_CV_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_FETCH_LIST_R_SPEC_TMPVARCV_CONST_LABEL,
			(void*)&&CREX_FETCH_LIST_R_SPEC_TMPVARCV_TMPVAR_LABEL,
			(void*)&&CREX_FETCH_LIST_R_SPEC_TMPVARCV_TMPVAR_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_FETCH_LIST_R_SPEC_TMPVARCV_CV_LABEL,
			(void*)&&CREX_FETCH_CONSTANT_SPEC_UNUSED_CONST_LABEL,
			(void*)&&CREX_CHECK_FUNC_ARG_SPEC_UNUSED_CONST_LABEL,
			(void*)&&CREX_CHECK_FUNC_ARG_SPEC_UNUSED_CONST_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_CHECK_FUNC_ARG_SPEC_UNUSED_UNUSED_LABEL,
			(void*)&&CREX_CHECK_FUNC_ARG_SPEC_UNUSED_UNUSED_QUICK_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_EXT_STMT_SPEC_LABEL,
			(void*)&&CREX_EXT_FCALL_BEGIN_SPEC_LABEL,
			(void*)&&CREX_EXT_FCALL_END_SPEC_LABEL,
			(void*)&&CREX_EXT_NOP_SPEC_LABEL,
			(void*)&&CREX_TICKS_SPEC_LABEL,
			(void*)&&CREX_SEND_VAR_NO_REF_SPEC_VAR_CONST_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_SEND_VAR_NO_REF_SPEC_VAR_UNUSED_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_CATCH_SPEC_CONST_LABEL,
			(void*)&&CREX_THROW_SPEC_CONST_LABEL,
			(void*)&&CREX_THROW_SPEC_TMPVAR_LABEL,
			(void*)&&CREX_THROW_SPEC_TMPVAR_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_THROW_SPEC_CV_LABEL,
			(void*)&&CREX_FETCH_CLASS_SPEC_UNUSED_CONST_LABEL,
			(void*)&&CREX_FETCH_CLASS_SPEC_UNUSED_TMPVAR_LABEL,
			(void*)&&CREX_FETCH_CLASS_SPEC_UNUSED_TMPVAR_LABEL,
			(void*)&&CREX_FETCH_CLASS_SPEC_UNUSED_UNUSED_LABEL,
			(void*)&&CREX_FETCH_CLASS_SPEC_UNUSED_CV_LABEL,
			(void*)&&CREX_CLONE_SPEC_CONST_LABEL,
			(void*)&&CREX_CLONE_SPEC_TMPVAR_LABEL,
			(void*)&&CREX_CLONE_SPEC_TMPVAR_LABEL,
			(void*)&&CREX_CLONE_SPEC_UNUSED_LABEL,
			(void*)&&CREX_CLONE_SPEC_CV_LABEL,
			(void*)&&CREX_RETURN_BY_REF_SPEC_CONST_LABEL,
			(void*)&&CREX_RETURN_BY_REF_SPEC_OBSERVER_LABEL,
			(void*)&&CREX_RETURN_BY_REF_SPEC_TMP_LABEL,
			(void*)&&CREX_RETURN_BY_REF_SPEC_OBSERVER_LABEL,
			(void*)&&CREX_RETURN_BY_REF_SPEC_VAR_LABEL,
			(void*)&&CREX_RETURN_BY_REF_SPEC_OBSERVER_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_RETURN_BY_REF_SPEC_CV_LABEL,
			(void*)&&CREX_RETURN_BY_REF_SPEC_OBSERVER_LABEL,
			(void*)&&CREX_INIT_METHOD_CALL_SPEC_CONST_CONST_LABEL,
			(void*)&&CREX_INIT_METHOD_CALL_SPEC_CONST_TMPVAR_LABEL,
			(void*)&&CREX_INIT_METHOD_CALL_SPEC_CONST_TMPVAR_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_INIT_METHOD_CALL_SPEC_CONST_CV_LABEL,
			(void*)&&CREX_INIT_METHOD_CALL_SPEC_TMPVAR_CONST_LABEL,
			(void*)&&CREX_INIT_METHOD_CALL_SPEC_TMPVAR_TMPVAR_LABEL,
			(void*)&&CREX_INIT_METHOD_CALL_SPEC_TMPVAR_TMPVAR_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_INIT_METHOD_CALL_SPEC_TMPVAR_CV_LABEL,
			(void*)&&CREX_INIT_METHOD_CALL_SPEC_TMPVAR_CONST_LABEL,
			(void*)&&CREX_INIT_METHOD_CALL_SPEC_TMPVAR_TMPVAR_LABEL,
			(void*)&&CREX_INIT_METHOD_CALL_SPEC_TMPVAR_TMPVAR_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_INIT_METHOD_CALL_SPEC_TMPVAR_CV_LABEL,
			(void*)&&CREX_INIT_METHOD_CALL_SPEC_UNUSED_CONST_LABEL,
			(void*)&&CREX_INIT_METHOD_CALL_SPEC_UNUSED_TMPVAR_LABEL,
			(void*)&&CREX_INIT_METHOD_CALL_SPEC_UNUSED_TMPVAR_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_INIT_METHOD_CALL_SPEC_UNUSED_CV_LABEL,
			(void*)&&CREX_INIT_METHOD_CALL_SPEC_CV_CONST_LABEL,
			(void*)&&CREX_INIT_METHOD_CALL_SPEC_CV_TMPVAR_LABEL,
			(void*)&&CREX_INIT_METHOD_CALL_SPEC_CV_TMPVAR_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_INIT_METHOD_CALL_SPEC_CV_CV_LABEL,
			(void*)&&CREX_INIT_STATIC_METHOD_CALL_SPEC_CONST_CONST_LABEL,
			(void*)&&CREX_INIT_STATIC_METHOD_CALL_SPEC_CONST_TMPVAR_LABEL,
			(void*)&&CREX_INIT_STATIC_METHOD_CALL_SPEC_CONST_TMPVAR_LABEL,
			(void*)&&CREX_INIT_STATIC_METHOD_CALL_SPEC_CONST_UNUSED_LABEL,
			(void*)&&CREX_INIT_STATIC_METHOD_CALL_SPEC_CONST_CV_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_INIT_STATIC_METHOD_CALL_SPEC_VAR_CONST_LABEL,
			(void*)&&CREX_INIT_STATIC_METHOD_CALL_SPEC_VAR_TMPVAR_LABEL,
			(void*)&&CREX_INIT_STATIC_METHOD_CALL_SPEC_VAR_TMPVAR_LABEL,
			(void*)&&CREX_INIT_STATIC_METHOD_CALL_SPEC_VAR_UNUSED_LABEL,
			(void*)&&CREX_INIT_STATIC_METHOD_CALL_SPEC_VAR_CV_LABEL,
			(void*)&&CREX_INIT_STATIC_METHOD_CALL_SPEC_UNUSED_CONST_LABEL,
			(void*)&&CREX_INIT_STATIC_METHOD_CALL_SPEC_UNUSED_TMPVAR_LABEL,
			(void*)&&CREX_INIT_STATIC_METHOD_CALL_SPEC_UNUSED_TMPVAR_LABEL,
			(void*)&&CREX_INIT_STATIC_METHOD_CALL_SPEC_UNUSED_UNUSED_LABEL,
			(void*)&&CREX_INIT_STATIC_METHOD_CALL_SPEC_UNUSED_CV_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_ISSET_ISEMPTY_VAR_SPEC_CONST_UNUSED_LABEL,
			(void*)&&CREX_ISSET_ISEMPTY_VAR_SPEC_TMPVAR_UNUSED_LABEL,
			(void*)&&CREX_ISSET_ISEMPTY_VAR_SPEC_TMPVAR_UNUSED_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_ISSET_ISEMPTY_VAR_SPEC_CV_UNUSED_LABEL,
			(void*)&&CREX_ISSET_ISEMPTY_DIM_OBJ_SPEC_CONST_CONST_LABEL,
			(void*)&&CREX_ISSET_ISEMPTY_DIM_OBJ_SPEC_CONST_TMPVAR_LABEL,
			(void*)&&CREX_ISSET_ISEMPTY_DIM_OBJ_SPEC_CONST_TMPVAR_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_ISSET_ISEMPTY_DIM_OBJ_SPEC_CONST_CV_LABEL,
			(void*)&&CREX_ISSET_ISEMPTY_DIM_OBJ_SPEC_TMPVAR_CONST_LABEL,
			(void*)&&CREX_ISSET_ISEMPTY_DIM_OBJ_SPEC_TMPVAR_TMPVAR_LABEL,
			(void*)&&CREX_ISSET_ISEMPTY_DIM_OBJ_SPEC_TMPVAR_TMPVAR_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_ISSET_ISEMPTY_DIM_OBJ_SPEC_TMPVAR_CV_LABEL,
			(void*)&&CREX_ISSET_ISEMPTY_DIM_OBJ_SPEC_TMPVAR_CONST_LABEL,
			(void*)&&CREX_ISSET_ISEMPTY_DIM_OBJ_SPEC_TMPVAR_TMPVAR_LABEL,
			(void*)&&CREX_ISSET_ISEMPTY_DIM_OBJ_SPEC_TMPVAR_TMPVAR_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_ISSET_ISEMPTY_DIM_OBJ_SPEC_TMPVAR_CV_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_ISSET_ISEMPTY_DIM_OBJ_SPEC_CV_CONST_LABEL,
			(void*)&&CREX_ISSET_ISEMPTY_DIM_OBJ_SPEC_CV_TMPVAR_LABEL,
			(void*)&&CREX_ISSET_ISEMPTY_DIM_OBJ_SPEC_CV_TMPVAR_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_ISSET_ISEMPTY_DIM_OBJ_SPEC_CV_CV_LABEL,
			(void*)&&CREX_SEND_VAL_EX_SPEC_CONST_CONST_LABEL,
			(void*)&&CREX_SEND_VAL_EX_SPEC_CONST_CONST_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_SEND_VAL_EX_SPEC_CONST_UNUSED_LABEL,
			(void*)&&CREX_SEND_VAL_EX_SPEC_CONST_UNUSED_QUICK_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_SEND_VAL_EX_SPEC_TMP_CONST_LABEL,
			(void*)&&CREX_SEND_VAL_EX_SPEC_TMP_CONST_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_SEND_VAL_EX_SPEC_TMP_UNUSED_LABEL,
			(void*)&&CREX_SEND_VAL_EX_SPEC_TMP_UNUSED_QUICK_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_SEND_VAR_SPEC_VAR_CONST_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_SEND_VAR_SPEC_VAR_UNUSED_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_SEND_VAR_SPEC_CV_CONST_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_SEND_VAR_SPEC_CV_UNUSED_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_INIT_USER_CALL_SPEC_CONST_CONST_LABEL,
			(void*)&&CREX_INIT_USER_CALL_SPEC_CONST_TMPVAR_LABEL,
			(void*)&&CREX_INIT_USER_CALL_SPEC_CONST_TMPVAR_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_INIT_USER_CALL_SPEC_CONST_CV_LABEL,
			(void*)&&CREX_SEND_ARRAY_SPEC_LABEL,
			(void*)&&CREX_SEND_USER_SPEC_CONST_LABEL,
			(void*)&&CREX_SEND_USER_SPEC_TMP_LABEL,
			(void*)&&CREX_SEND_USER_SPEC_VAR_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_SEND_USER_SPEC_CV_LABEL,
			(void*)&&CREX_STRLEN_SPEC_CONST_LABEL,
			(void*)&&CREX_STRLEN_SPEC_TMPVAR_LABEL,
			(void*)&&CREX_STRLEN_SPEC_TMPVAR_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_STRLEN_SPEC_CV_LABEL,
			(void*)&&CREX_DEFINED_SPEC_CONST_LABEL,
			(void*)&&CREX_TYPE_CHECK_SPEC_CONST_LABEL,
			(void*)&&CREX_TYPE_CHECK_SPEC_TMPVAR_LABEL,
			(void*)&&CREX_TYPE_CHECK_SPEC_TMPVAR_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_TYPE_CHECK_SPEC_CV_LABEL,
			(void*)&&CREX_VERIFY_RETURN_TYPE_SPEC_CONST_UNUSED_LABEL,
			(void*)&&CREX_VERIFY_RETURN_TYPE_SPEC_TMP_UNUSED_LABEL,
			(void*)&&CREX_VERIFY_RETURN_TYPE_SPEC_VAR_UNUSED_LABEL,
			(void*)&&CREX_VERIFY_RETURN_TYPE_SPEC_UNUSED_UNUSED_LABEL,
			(void*)&&CREX_VERIFY_RETURN_TYPE_SPEC_CV_UNUSED_LABEL,
			(void*)&&CREX_FE_RESET_RW_SPEC_CONST_LABEL,
			(void*)&&CREX_FE_RESET_RW_SPEC_TMP_LABEL,
			(void*)&&CREX_FE_RESET_RW_SPEC_VAR_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_FE_RESET_RW_SPEC_CV_LABEL,
			(void*)&&CREX_FE_FETCH_RW_SPEC_VAR_LABEL,
			(void*)&&CREX_FE_FREE_SPEC_TMPVAR_LABEL,
			(void*)&&CREX_INIT_DYNAMIC_CALL_SPEC_CONST_LABEL,
			(void*)&&CREX_INIT_DYNAMIC_CALL_SPEC_TMPVAR_LABEL,
			(void*)&&CREX_INIT_DYNAMIC_CALL_SPEC_TMPVAR_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_INIT_DYNAMIC_CALL_SPEC_CV_LABEL,
			(void*)&&CREX_DO_ICALL_SPEC_RETVAL_UNUSED_LABEL,
			(void*)&&CREX_DO_ICALL_SPEC_RETVAL_USED_LABEL,
			(void*)&&CREX_DO_ICALL_SPEC_OBSERVER_LABEL,
			(void*)&&CREX_DO_ICALL_SPEC_OBSERVER_LABEL,
			(void*)&&CREX_DO_UCALL_SPEC_RETVAL_UNUSED_LABEL,
			(void*)&&CREX_DO_UCALL_SPEC_RETVAL_USED_LABEL,
			(void*)&&CREX_DO_UCALL_SPEC_OBSERVER_LABEL,
			(void*)&&CREX_DO_UCALL_SPEC_OBSERVER_LABEL,
			(void*)&&CREX_DO_FCALL_BY_NAME_SPEC_RETVAL_UNUSED_LABEL,
			(void*)&&CREX_DO_FCALL_BY_NAME_SPEC_RETVAL_USED_LABEL,
			(void*)&&CREX_DO_FCALL_BY_NAME_SPEC_OBSERVER_LABEL,
			(void*)&&CREX_DO_FCALL_BY_NAME_SPEC_OBSERVER_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_PRE_INC_OBJ_SPEC_VAR_CONST_LABEL,
			(void*)&&CREX_PRE_INC_OBJ_SPEC_VAR_TMPVAR_LABEL,
			(void*)&&CREX_PRE_INC_OBJ_SPEC_VAR_TMPVAR_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_PRE_INC_OBJ_SPEC_VAR_CV_LABEL,
			(void*)&&CREX_PRE_INC_OBJ_SPEC_UNUSED_CONST_LABEL,
			(void*)&&CREX_PRE_INC_OBJ_SPEC_UNUSED_TMPVAR_LABEL,
			(void*)&&CREX_PRE_INC_OBJ_SPEC_UNUSED_TMPVAR_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_PRE_INC_OBJ_SPEC_UNUSED_CV_LABEL,
			(void*)&&CREX_PRE_INC_OBJ_SPEC_CV_CONST_LABEL,
			(void*)&&CREX_PRE_INC_OBJ_SPEC_CV_TMPVAR_LABEL,
			(void*)&&CREX_PRE_INC_OBJ_SPEC_CV_TMPVAR_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_PRE_INC_OBJ_SPEC_CV_CV_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_POST_INC_OBJ_SPEC_VAR_CONST_LABEL,
			(void*)&&CREX_POST_INC_OBJ_SPEC_VAR_TMPVAR_LABEL,
			(void*)&&CREX_POST_INC_OBJ_SPEC_VAR_TMPVAR_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_POST_INC_OBJ_SPEC_VAR_CV_LABEL,
			(void*)&&CREX_POST_INC_OBJ_SPEC_UNUSED_CONST_LABEL,
			(void*)&&CREX_POST_INC_OBJ_SPEC_UNUSED_TMPVAR_LABEL,
			(void*)&&CREX_POST_INC_OBJ_SPEC_UNUSED_TMPVAR_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_POST_INC_OBJ_SPEC_UNUSED_CV_LABEL,
			(void*)&&CREX_POST_INC_OBJ_SPEC_CV_CONST_LABEL,
			(void*)&&CREX_POST_INC_OBJ_SPEC_CV_TMPVAR_LABEL,
			(void*)&&CREX_POST_INC_OBJ_SPEC_CV_TMPVAR_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_POST_INC_OBJ_SPEC_CV_CV_LABEL,
			(void*)&&CREX_ECHO_SPEC_CONST_LABEL,
			(void*)&&CREX_ECHO_SPEC_TMPVAR_LABEL,
			(void*)&&CREX_ECHO_SPEC_TMPVAR_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_ECHO_SPEC_CV_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_INSTANCEOF_SPEC_TMPVAR_CONST_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_INSTANCEOF_SPEC_TMPVAR_VAR_LABEL,
			(void*)&&CREX_INSTANCEOF_SPEC_TMPVAR_UNUSED_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_INSTANCEOF_SPEC_TMPVAR_CONST_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_INSTANCEOF_SPEC_TMPVAR_VAR_LABEL,
			(void*)&&CREX_INSTANCEOF_SPEC_TMPVAR_UNUSED_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_INSTANCEOF_SPEC_CV_CONST_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_INSTANCEOF_SPEC_CV_VAR_LABEL,
			(void*)&&CREX_INSTANCEOF_SPEC_CV_UNUSED_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_GENERATOR_CREATE_SPEC_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_MAKE_REF_SPEC_VAR_UNUSED_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_MAKE_REF_SPEC_CV_UNUSED_LABEL,
			(void*)&&CREX_DECLARE_FUNCTION_SPEC_LABEL,
			(void*)&&CREX_DECLARE_LAMBDA_FUNCTION_SPEC_CONST_LABEL,
			(void*)&&CREX_DECLARE_CONST_SPEC_CONST_CONST_LABEL,
			(void*)&&CREX_DECLARE_CLASS_SPEC_CONST_LABEL,
			(void*)&&CREX_DECLARE_CLASS_DELAYED_SPEC_CONST_CONST_LABEL,
			(void*)&&CREX_DECLARE_ANON_CLASS_SPEC_LABEL,
			(void*)&&CREX_ADD_ARRAY_UNPACK_SPEC_LABEL,
			(void*)&&CREX_ISSET_ISEMPTY_PROP_OBJ_SPEC_CONST_CONST_LABEL,
			(void*)&&CREX_ISSET_ISEMPTY_PROP_OBJ_SPEC_CONST_TMPVAR_LABEL,
			(void*)&&CREX_ISSET_ISEMPTY_PROP_OBJ_SPEC_CONST_TMPVAR_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_ISSET_ISEMPTY_PROP_OBJ_SPEC_CONST_CV_LABEL,
			(void*)&&CREX_ISSET_ISEMPTY_PROP_OBJ_SPEC_TMPVAR_CONST_LABEL,
			(void*)&&CREX_ISSET_ISEMPTY_PROP_OBJ_SPEC_TMPVAR_TMPVAR_LABEL,
			(void*)&&CREX_ISSET_ISEMPTY_PROP_OBJ_SPEC_TMPVAR_TMPVAR_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_ISSET_ISEMPTY_PROP_OBJ_SPEC_TMPVAR_CV_LABEL,
			(void*)&&CREX_ISSET_ISEMPTY_PROP_OBJ_SPEC_TMPVAR_CONST_LABEL,
			(void*)&&CREX_ISSET_ISEMPTY_PROP_OBJ_SPEC_TMPVAR_TMPVAR_LABEL,
			(void*)&&CREX_ISSET_ISEMPTY_PROP_OBJ_SPEC_TMPVAR_TMPVAR_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_ISSET_ISEMPTY_PROP_OBJ_SPEC_TMPVAR_CV_LABEL,
			(void*)&&CREX_ISSET_ISEMPTY_PROP_OBJ_SPEC_UNUSED_CONST_LABEL,
			(void*)&&CREX_ISSET_ISEMPTY_PROP_OBJ_SPEC_UNUSED_TMPVAR_LABEL,
			(void*)&&CREX_ISSET_ISEMPTY_PROP_OBJ_SPEC_UNUSED_TMPVAR_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_ISSET_ISEMPTY_PROP_OBJ_SPEC_UNUSED_CV_LABEL,
			(void*)&&CREX_ISSET_ISEMPTY_PROP_OBJ_SPEC_CV_CONST_LABEL,
			(void*)&&CREX_ISSET_ISEMPTY_PROP_OBJ_SPEC_CV_TMPVAR_LABEL,
			(void*)&&CREX_ISSET_ISEMPTY_PROP_OBJ_SPEC_CV_TMPVAR_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_ISSET_ISEMPTY_PROP_OBJ_SPEC_CV_CV_LABEL,
			(void*)&&CREX_HANDLE_EXCEPTION_SPEC_LABEL,
			(void*)&&CREX_USER_OPCODE_SPEC_LABEL,
			(void*)&&CREX_ASSERT_CHECK_SPEC_LABEL,
			(void*)&&CREX_JMP_SET_SPEC_CONST_LABEL,
			(void*)&&CREX_JMP_SET_SPEC_TMP_LABEL,
			(void*)&&CREX_JMP_SET_SPEC_VAR_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_JMP_SET_SPEC_CV_LABEL,
			(void*)&&CREX_UNSET_CV_SPEC_CV_UNUSED_LABEL,
			(void*)&&CREX_ISSET_ISEMPTY_CV_SPEC_CV_UNUSED_SET_LABEL,
			(void*)&&CREX_ISSET_ISEMPTY_CV_SPEC_CV_UNUSED_EMPTY_LABEL,
			(void*)&&CREX_FETCH_LIST_W_SPEC_VAR_CONST_LABEL,
			(void*)&&CREX_FETCH_LIST_W_SPEC_VAR_TMPVAR_LABEL,
			(void*)&&CREX_FETCH_LIST_W_SPEC_VAR_TMPVAR_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_FETCH_LIST_W_SPEC_VAR_CV_LABEL,
			(void*)&&CREX_SEPARATE_SPEC_VAR_UNUSED_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_FETCH_CLASS_NAME_SPEC_TMPVAR_LABEL,
			(void*)&&CREX_FETCH_CLASS_NAME_SPEC_TMPVAR_LABEL,
			(void*)&&CREX_FETCH_CLASS_NAME_SPEC_UNUSED_LABEL,
			(void*)&&CREX_FETCH_CLASS_NAME_SPEC_CV_LABEL,
			(void*)&&CREX_CALL_TRAMPOLINE_SPEC_LABEL,
			(void*)&&CREX_CALL_TRAMPOLINE_SPEC_OBSERVER_LABEL,
			(void*)&&CREX_DISCARD_EXCEPTION_SPEC_LABEL,
			(void*)&&CREX_YIELD_SPEC_CONST_CONST_LABEL,
			(void*)&&CREX_YIELD_SPEC_CONST_TMPVAR_LABEL,
			(void*)&&CREX_YIELD_SPEC_CONST_TMPVAR_LABEL,
			(void*)&&CREX_YIELD_SPEC_CONST_UNUSED_LABEL,
			(void*)&&CREX_YIELD_SPEC_CONST_CV_LABEL,
			(void*)&&CREX_YIELD_SPEC_TMP_CONST_LABEL,
			(void*)&&CREX_YIELD_SPEC_TMP_TMPVAR_LABEL,
			(void*)&&CREX_YIELD_SPEC_TMP_TMPVAR_LABEL,
			(void*)&&CREX_YIELD_SPEC_TMP_UNUSED_LABEL,
			(void*)&&CREX_YIELD_SPEC_TMP_CV_LABEL,
			(void*)&&CREX_YIELD_SPEC_VAR_CONST_LABEL,
			(void*)&&CREX_YIELD_SPEC_VAR_TMPVAR_LABEL,
			(void*)&&CREX_YIELD_SPEC_VAR_TMPVAR_LABEL,
			(void*)&&CREX_YIELD_SPEC_VAR_UNUSED_LABEL,
			(void*)&&CREX_YIELD_SPEC_VAR_CV_LABEL,
			(void*)&&CREX_YIELD_SPEC_UNUSED_CONST_LABEL,
			(void*)&&CREX_YIELD_SPEC_UNUSED_TMPVAR_LABEL,
			(void*)&&CREX_YIELD_SPEC_UNUSED_TMPVAR_LABEL,
			(void*)&&CREX_YIELD_SPEC_UNUSED_UNUSED_LABEL,
			(void*)&&CREX_YIELD_SPEC_UNUSED_CV_LABEL,
			(void*)&&CREX_YIELD_SPEC_CV_CONST_LABEL,
			(void*)&&CREX_YIELD_SPEC_CV_TMPVAR_LABEL,
			(void*)&&CREX_YIELD_SPEC_CV_TMPVAR_LABEL,
			(void*)&&CREX_YIELD_SPEC_CV_UNUSED_LABEL,
			(void*)&&CREX_YIELD_SPEC_CV_CV_LABEL,
			(void*)&&CREX_GENERATOR_RETURN_SPEC_CONST_LABEL,
			(void*)&&CREX_GENERATOR_RETURN_SPEC_OBSERVER_LABEL,
			(void*)&&CREX_GENERATOR_RETURN_SPEC_TMP_LABEL,
			(void*)&&CREX_GENERATOR_RETURN_SPEC_OBSERVER_LABEL,
			(void*)&&CREX_GENERATOR_RETURN_SPEC_VAR_LABEL,
			(void*)&&CREX_GENERATOR_RETURN_SPEC_OBSERVER_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_GENERATOR_RETURN_SPEC_CV_LABEL,
			(void*)&&CREX_GENERATOR_RETURN_SPEC_OBSERVER_LABEL,
			(void*)&&CREX_FAST_CALL_SPEC_LABEL,
			(void*)&&CREX_FAST_RET_SPEC_LABEL,
			(void*)&&CREX_RECV_VARIADIC_SPEC_UNUSED_LABEL,
			(void*)&&CREX_SEND_UNPACK_SPEC_LABEL,
			(void*)&&CREX_YIELD_FROM_SPEC_CONST_LABEL,
			(void*)&&CREX_YIELD_FROM_SPEC_TMPVAR_LABEL,
			(void*)&&CREX_YIELD_FROM_SPEC_TMPVAR_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_YIELD_FROM_SPEC_CV_LABEL,
			(void*)&&CREX_COPY_TMP_SPEC_TMPVAR_UNUSED_LABEL,
			(void*)&&CREX_BIND_GLOBAL_SPEC_CV_CONST_LABEL,
			(void*)&&CREX_COALESCE_SPEC_CONST_LABEL,
			(void*)&&CREX_COALESCE_SPEC_TMP_LABEL,
			(void*)&&CREX_COALESCE_SPEC_VAR_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_COALESCE_SPEC_CV_LABEL,
			(void*)&&CREX_SPACESHIP_SPEC_CONST_CONST_LABEL,
			(void*)&&CREX_SPACESHIP_SPEC_CONST_TMPVAR_LABEL,
			(void*)&&CREX_SPACESHIP_SPEC_CONST_TMPVAR_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_SPACESHIP_SPEC_CONST_CV_LABEL,
			(void*)&&CREX_SPACESHIP_SPEC_TMPVAR_CONST_LABEL,
			(void*)&&CREX_SPACESHIP_SPEC_TMPVAR_TMPVAR_LABEL,
			(void*)&&CREX_SPACESHIP_SPEC_TMPVAR_TMPVAR_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_SPACESHIP_SPEC_TMPVAR_CV_LABEL,
			(void*)&&CREX_SPACESHIP_SPEC_TMPVAR_CONST_LABEL,
			(void*)&&CREX_SPACESHIP_SPEC_TMPVAR_TMPVAR_LABEL,
			(void*)&&CREX_SPACESHIP_SPEC_TMPVAR_TMPVAR_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_SPACESHIP_SPEC_TMPVAR_CV_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_SPACESHIP_SPEC_CV_CONST_LABEL,
			(void*)&&CREX_SPACESHIP_SPEC_CV_TMPVAR_LABEL,
			(void*)&&CREX_SPACESHIP_SPEC_CV_TMPVAR_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_SPACESHIP_SPEC_CV_CV_LABEL,
			(void*)&&CREX_FUNC_NUM_ARGS_SPEC_UNUSED_UNUSED_LABEL,
			(void*)&&CREX_FUNC_GET_ARGS_SPEC_CONST_UNUSED_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_FUNC_GET_ARGS_SPEC_UNUSED_UNUSED_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_FETCH_STATIC_PROP_R_SPEC_LABEL,
			(void*)&&CREX_FETCH_STATIC_PROP_W_SPEC_LABEL,
			(void*)&&CREX_FETCH_STATIC_PROP_RW_SPEC_LABEL,
			(void*)&&CREX_FETCH_STATIC_PROP_IS_SPEC_LABEL,
			(void*)&&CREX_FETCH_STATIC_PROP_FUNC_ARG_SPEC_LABEL,
			(void*)&&CREX_FETCH_STATIC_PROP_UNSET_SPEC_LABEL,
			(void*)&&CREX_UNSET_STATIC_PROP_SPEC_LABEL,
			(void*)&&CREX_ISSET_ISEMPTY_STATIC_PROP_SPEC_LABEL,
			(void*)&&CREX_FETCH_CLASS_CONSTANT_SPEC_CONST_CONST_LABEL,
			(void*)&&CREX_FETCH_CLASS_CONSTANT_SPEC_CONST_TMPVARCV_LABEL,
			(void*)&&CREX_FETCH_CLASS_CONSTANT_SPEC_CONST_TMPVARCV_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_FETCH_CLASS_CONSTANT_SPEC_CONST_TMPVARCV_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_FETCH_CLASS_CONSTANT_SPEC_VAR_CONST_LABEL,
			(void*)&&CREX_FETCH_CLASS_CONSTANT_SPEC_VAR_TMPVARCV_LABEL,
			(void*)&&CREX_FETCH_CLASS_CONSTANT_SPEC_VAR_TMPVARCV_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_FETCH_CLASS_CONSTANT_SPEC_VAR_TMPVARCV_LABEL,
			(void*)&&CREX_FETCH_CLASS_CONSTANT_SPEC_UNUSED_CONST_LABEL,
			(void*)&&CREX_FETCH_CLASS_CONSTANT_SPEC_UNUSED_TMPVARCV_LABEL,
			(void*)&&CREX_FETCH_CLASS_CONSTANT_SPEC_UNUSED_TMPVARCV_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_FETCH_CLASS_CONSTANT_SPEC_UNUSED_TMPVARCV_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_BIND_LEXICAL_SPEC_TMP_CV_LABEL,
			(void*)&&CREX_BIND_STATIC_SPEC_CV_LABEL,
			(void*)&&CREX_FETCH_THIS_SPEC_UNUSED_UNUSED_LABEL,
			(void*)&&CREX_SEND_FUNC_ARG_SPEC_VAR_CONST_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_SEND_FUNC_ARG_SPEC_VAR_UNUSED_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_ISSET_ISEMPTY_THIS_SPEC_UNUSED_UNUSED_LABEL,
			(void*)&&CREX_SWITCH_LONG_SPEC_CONST_CONST_LABEL,
			(void*)&&CREX_SWITCH_LONG_SPEC_TMPVARCV_CONST_LABEL,
			(void*)&&CREX_SWITCH_LONG_SPEC_TMPVARCV_CONST_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_SWITCH_LONG_SPEC_TMPVARCV_CONST_LABEL,
			(void*)&&CREX_SWITCH_STRING_SPEC_CONST_CONST_LABEL,
			(void*)&&CREX_SWITCH_STRING_SPEC_TMPVARCV_CONST_LABEL,
			(void*)&&CREX_SWITCH_STRING_SPEC_TMPVARCV_CONST_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_SWITCH_STRING_SPEC_TMPVARCV_CONST_LABEL,
			(void*)&&CREX_IN_ARRAY_SPEC_CONST_CONST_LABEL,
			(void*)&&CREX_IN_ARRAY_SPEC_TMP_CONST_LABEL,
			(void*)&&CREX_IN_ARRAY_SPEC_VAR_CONST_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_IN_ARRAY_SPEC_CV_CONST_LABEL,
			(void*)&&CREX_COUNT_SPEC_CONST_UNUSED_LABEL,
			(void*)&&CREX_COUNT_SPEC_TMPVAR_UNUSED_LABEL,
			(void*)&&CREX_COUNT_SPEC_TMPVAR_UNUSED_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_COUNT_SPEC_CV_UNUSED_LABEL,
			(void*)&&CREX_GET_CLASS_SPEC_CONST_UNUSED_LABEL,
			(void*)&&CREX_GET_CLASS_SPEC_TMPVAR_UNUSED_LABEL,
			(void*)&&CREX_GET_CLASS_SPEC_TMPVAR_UNUSED_LABEL,
			(void*)&&CREX_GET_CLASS_SPEC_UNUSED_UNUSED_LABEL,
			(void*)&&CREX_GET_CLASS_SPEC_CV_UNUSED_LABEL,
			(void*)&&CREX_GET_CALLED_CLASS_SPEC_UNUSED_UNUSED_LABEL,
			(void*)&&CREX_GET_TYPE_SPEC_CONST_UNUSED_LABEL,
			(void*)&&CREX_GET_TYPE_SPEC_TMP_UNUSED_LABEL,
			(void*)&&CREX_GET_TYPE_SPEC_VAR_UNUSED_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_GET_TYPE_SPEC_CV_UNUSED_LABEL,
			(void*)&&CREX_ARRAY_KEY_EXISTS_SPEC_CONST_CONST_LABEL,
			(void*)&&CREX_ARRAY_KEY_EXISTS_SPEC_CONST_TMPVAR_LABEL,
			(void*)&&CREX_ARRAY_KEY_EXISTS_SPEC_CONST_TMPVAR_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_ARRAY_KEY_EXISTS_SPEC_CONST_CV_LABEL,
			(void*)&&CREX_ARRAY_KEY_EXISTS_SPEC_TMPVAR_CONST_LABEL,
			(void*)&&CREX_ARRAY_KEY_EXISTS_SPEC_TMPVAR_TMPVAR_LABEL,
			(void*)&&CREX_ARRAY_KEY_EXISTS_SPEC_TMPVAR_TMPVAR_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_ARRAY_KEY_EXISTS_SPEC_TMPVAR_CV_LABEL,
			(void*)&&CREX_ARRAY_KEY_EXISTS_SPEC_TMPVAR_CONST_LABEL,
			(void*)&&CREX_ARRAY_KEY_EXISTS_SPEC_TMPVAR_TMPVAR_LABEL,
			(void*)&&CREX_ARRAY_KEY_EXISTS_SPEC_TMPVAR_TMPVAR_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_ARRAY_KEY_EXISTS_SPEC_TMPVAR_CV_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_ARRAY_KEY_EXISTS_SPEC_CV_CONST_LABEL,
			(void*)&&CREX_ARRAY_KEY_EXISTS_SPEC_CV_TMPVAR_LABEL,
			(void*)&&CREX_ARRAY_KEY_EXISTS_SPEC_CV_TMPVAR_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_ARRAY_KEY_EXISTS_SPEC_CV_CV_LABEL,
			(void*)&&CREX_MATCH_SPEC_CONST_CONST_LABEL,
			(void*)&&CREX_MATCH_SPEC_TMPVARCV_CONST_LABEL,
			(void*)&&CREX_MATCH_SPEC_TMPVARCV_CONST_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_MATCH_SPEC_TMPVARCV_CONST_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_CASE_STRICT_SPEC_TMP_CONST_LABEL,
			(void*)&&CREX_CASE_STRICT_SPEC_TMP_TMP_LABEL,
			(void*)&&CREX_CASE_STRICT_SPEC_TMP_VAR_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_CASE_STRICT_SPEC_TMP_CV_LABEL,
			(void*)&&CREX_CASE_STRICT_SPEC_VAR_CONST_LABEL,
			(void*)&&CREX_CASE_STRICT_SPEC_VAR_TMP_LABEL,
			(void*)&&CREX_CASE_STRICT_SPEC_VAR_VAR_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_CASE_STRICT_SPEC_VAR_CV_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_MATCH_ERROR_SPEC_CONST_UNUSED_LABEL,
			(void*)&&CREX_MATCH_ERROR_SPEC_TMPVARCV_UNUSED_LABEL,
			(void*)&&CREX_MATCH_ERROR_SPEC_TMPVARCV_UNUSED_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_MATCH_ERROR_SPEC_TMPVARCV_UNUSED_LABEL,
			(void*)&&CREX_JMP_NULL_SPEC_CONST_LABEL,
			(void*)&&CREX_JMP_NULL_SPEC_TMP_LABEL,
			(void*)&&CREX_JMP_NULL_SPEC_VAR_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_JMP_NULL_SPEC_CV_LABEL,
			(void*)&&CREX_CHECK_UNDEF_ARGS_SPEC_UNUSED_UNUSED_LABEL,
			(void*)&&CREX_FETCH_GLOBALS_SPEC_UNUSED_UNUSED_LABEL,
			(void*)&&CREX_VERIFY_NEVER_TYPE_SPEC_UNUSED_UNUSED_LABEL,
			(void*)&&CREX_CALLABLE_CONVERT_SPEC_UNUSED_UNUSED_LABEL,
			(void*)&&CREX_BIND_INIT_STATIC_OR_JMP_SPEC_CV_LABEL,
			(void*)&&CREX_RECV_NOTYPE_SPEC_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_COUNT_ARRAY_SPEC_TMPVAR_UNUSED_LABEL,
			(void*)&&CREX_COUNT_ARRAY_SPEC_TMPVAR_UNUSED_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_COUNT_ARRAY_SPEC_CV_UNUSED_LABEL,
			(void*)&&CREX_JMP_FORWARD_SPEC_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_ADD_LONG_NO_OVERFLOW_SPEC_TMPVARCV_CONST_LABEL,
			(void*)&&CREX_ADD_LONG_NO_OVERFLOW_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_ADD_LONG_NO_OVERFLOW_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_ADD_LONG_NO_OVERFLOW_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_ADD_LONG_NO_OVERFLOW_SPEC_TMPVARCV_CONST_LABEL,
			(void*)&&CREX_ADD_LONG_NO_OVERFLOW_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_ADD_LONG_NO_OVERFLOW_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_ADD_LONG_NO_OVERFLOW_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_ADD_LONG_NO_OVERFLOW_SPEC_TMPVARCV_CONST_LABEL,
			(void*)&&CREX_ADD_LONG_NO_OVERFLOW_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_ADD_LONG_NO_OVERFLOW_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_ADD_LONG_NO_OVERFLOW_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_ADD_LONG_SPEC_TMPVARCV_CONST_LABEL,
			(void*)&&CREX_ADD_LONG_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_ADD_LONG_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_ADD_LONG_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_ADD_LONG_SPEC_TMPVARCV_CONST_LABEL,
			(void*)&&CREX_ADD_LONG_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_ADD_LONG_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_ADD_LONG_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_ADD_LONG_SPEC_TMPVARCV_CONST_LABEL,
			(void*)&&CREX_ADD_LONG_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_ADD_LONG_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_ADD_LONG_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_ADD_DOUBLE_SPEC_TMPVARCV_CONST_LABEL,
			(void*)&&CREX_ADD_DOUBLE_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_ADD_DOUBLE_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_ADD_DOUBLE_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_ADD_DOUBLE_SPEC_TMPVARCV_CONST_LABEL,
			(void*)&&CREX_ADD_DOUBLE_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_ADD_DOUBLE_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_ADD_DOUBLE_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_ADD_DOUBLE_SPEC_TMPVARCV_CONST_LABEL,
			(void*)&&CREX_ADD_DOUBLE_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_ADD_DOUBLE_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_ADD_DOUBLE_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_SUB_LONG_NO_OVERFLOW_SPEC_CONST_TMPVARCV_LABEL,
			(void*)&&CREX_SUB_LONG_NO_OVERFLOW_SPEC_CONST_TMPVARCV_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_SUB_LONG_NO_OVERFLOW_SPEC_CONST_TMPVARCV_LABEL,
			(void*)&&CREX_SUB_LONG_NO_OVERFLOW_SPEC_TMPVARCV_CONST_LABEL,
			(void*)&&CREX_SUB_LONG_NO_OVERFLOW_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_SUB_LONG_NO_OVERFLOW_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_SUB_LONG_NO_OVERFLOW_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_SUB_LONG_NO_OVERFLOW_SPEC_TMPVARCV_CONST_LABEL,
			(void*)&&CREX_SUB_LONG_NO_OVERFLOW_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_SUB_LONG_NO_OVERFLOW_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_SUB_LONG_NO_OVERFLOW_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_SUB_LONG_NO_OVERFLOW_SPEC_TMPVARCV_CONST_LABEL,
			(void*)&&CREX_SUB_LONG_NO_OVERFLOW_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_SUB_LONG_NO_OVERFLOW_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_SUB_LONG_NO_OVERFLOW_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_SUB_LONG_SPEC_CONST_TMPVARCV_LABEL,
			(void*)&&CREX_SUB_LONG_SPEC_CONST_TMPVARCV_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_SUB_LONG_SPEC_CONST_TMPVARCV_LABEL,
			(void*)&&CREX_SUB_LONG_SPEC_TMPVARCV_CONST_LABEL,
			(void*)&&CREX_SUB_LONG_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_SUB_LONG_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_SUB_LONG_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_SUB_LONG_SPEC_TMPVARCV_CONST_LABEL,
			(void*)&&CREX_SUB_LONG_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_SUB_LONG_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_SUB_LONG_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_SUB_LONG_SPEC_TMPVARCV_CONST_LABEL,
			(void*)&&CREX_SUB_LONG_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_SUB_LONG_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_SUB_LONG_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_SUB_DOUBLE_SPEC_CONST_TMPVARCV_LABEL,
			(void*)&&CREX_SUB_DOUBLE_SPEC_CONST_TMPVARCV_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_SUB_DOUBLE_SPEC_CONST_TMPVARCV_LABEL,
			(void*)&&CREX_SUB_DOUBLE_SPEC_TMPVARCV_CONST_LABEL,
			(void*)&&CREX_SUB_DOUBLE_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_SUB_DOUBLE_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_SUB_DOUBLE_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_SUB_DOUBLE_SPEC_TMPVARCV_CONST_LABEL,
			(void*)&&CREX_SUB_DOUBLE_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_SUB_DOUBLE_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_SUB_DOUBLE_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_SUB_DOUBLE_SPEC_TMPVARCV_CONST_LABEL,
			(void*)&&CREX_SUB_DOUBLE_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_SUB_DOUBLE_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_SUB_DOUBLE_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_MUL_LONG_NO_OVERFLOW_SPEC_TMPVARCV_CONST_LABEL,
			(void*)&&CREX_MUL_LONG_NO_OVERFLOW_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_MUL_LONG_NO_OVERFLOW_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_MUL_LONG_NO_OVERFLOW_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_MUL_LONG_NO_OVERFLOW_SPEC_TMPVARCV_CONST_LABEL,
			(void*)&&CREX_MUL_LONG_NO_OVERFLOW_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_MUL_LONG_NO_OVERFLOW_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_MUL_LONG_NO_OVERFLOW_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_MUL_LONG_NO_OVERFLOW_SPEC_TMPVARCV_CONST_LABEL,
			(void*)&&CREX_MUL_LONG_NO_OVERFLOW_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_MUL_LONG_NO_OVERFLOW_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_MUL_LONG_NO_OVERFLOW_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_MUL_LONG_SPEC_TMPVARCV_CONST_LABEL,
			(void*)&&CREX_MUL_LONG_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_MUL_LONG_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_MUL_LONG_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_MUL_LONG_SPEC_TMPVARCV_CONST_LABEL,
			(void*)&&CREX_MUL_LONG_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_MUL_LONG_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_MUL_LONG_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_MUL_LONG_SPEC_TMPVARCV_CONST_LABEL,
			(void*)&&CREX_MUL_LONG_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_MUL_LONG_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_MUL_LONG_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_MUL_DOUBLE_SPEC_TMPVARCV_CONST_LABEL,
			(void*)&&CREX_MUL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_MUL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_MUL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_MUL_DOUBLE_SPEC_TMPVARCV_CONST_LABEL,
			(void*)&&CREX_MUL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_MUL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_MUL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_MUL_DOUBLE_SPEC_TMPVARCV_CONST_LABEL,
			(void*)&&CREX_MUL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_MUL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_MUL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_IS_EQUAL_LONG_SPEC_TMPVARCV_CONST_LABEL,
			(void*)&&CREX_IS_EQUAL_LONG_SPEC_TMPVARCV_CONST_JMPC_LABEL,
			(void*)&&CREX_IS_EQUAL_LONG_SPEC_TMPVARCV_CONST_JMPNC_LABEL,
			(void*)&&CREX_IS_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_IS_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPC_LABEL,
			(void*)&&CREX_IS_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPNC_LABEL,
			(void*)&&CREX_IS_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_IS_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPC_LABEL,
			(void*)&&CREX_IS_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPNC_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_IS_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_IS_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPC_LABEL,
			(void*)&&CREX_IS_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPNC_LABEL,
			(void*)&&CREX_IS_EQUAL_LONG_SPEC_TMPVARCV_CONST_LABEL,
			(void*)&&CREX_IS_EQUAL_LONG_SPEC_TMPVARCV_CONST_JMPC_LABEL,
			(void*)&&CREX_IS_EQUAL_LONG_SPEC_TMPVARCV_CONST_JMPNC_LABEL,
			(void*)&&CREX_IS_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_IS_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPC_LABEL,
			(void*)&&CREX_IS_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPNC_LABEL,
			(void*)&&CREX_IS_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_IS_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPC_LABEL,
			(void*)&&CREX_IS_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPNC_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_IS_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_IS_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPC_LABEL,
			(void*)&&CREX_IS_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPNC_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_IS_EQUAL_LONG_SPEC_TMPVARCV_CONST_LABEL,
			(void*)&&CREX_IS_EQUAL_LONG_SPEC_TMPVARCV_CONST_JMPC_LABEL,
			(void*)&&CREX_IS_EQUAL_LONG_SPEC_TMPVARCV_CONST_JMPNC_LABEL,
			(void*)&&CREX_IS_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_IS_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPC_LABEL,
			(void*)&&CREX_IS_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPNC_LABEL,
			(void*)&&CREX_IS_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_IS_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPC_LABEL,
			(void*)&&CREX_IS_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPNC_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_IS_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_IS_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPC_LABEL,
			(void*)&&CREX_IS_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPNC_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_IS_EQUAL_DOUBLE_SPEC_TMPVARCV_CONST_LABEL,
			(void*)&&CREX_IS_EQUAL_DOUBLE_SPEC_TMPVARCV_CONST_JMPC_LABEL,
			(void*)&&CREX_IS_EQUAL_DOUBLE_SPEC_TMPVARCV_CONST_JMPNC_LABEL,
			(void*)&&CREX_IS_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_IS_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPC_LABEL,
			(void*)&&CREX_IS_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPNC_LABEL,
			(void*)&&CREX_IS_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_IS_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPC_LABEL,
			(void*)&&CREX_IS_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPNC_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_IS_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_IS_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPC_LABEL,
			(void*)&&CREX_IS_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPNC_LABEL,
			(void*)&&CREX_IS_EQUAL_DOUBLE_SPEC_TMPVARCV_CONST_LABEL,
			(void*)&&CREX_IS_EQUAL_DOUBLE_SPEC_TMPVARCV_CONST_JMPC_LABEL,
			(void*)&&CREX_IS_EQUAL_DOUBLE_SPEC_TMPVARCV_CONST_JMPNC_LABEL,
			(void*)&&CREX_IS_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_IS_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPC_LABEL,
			(void*)&&CREX_IS_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPNC_LABEL,
			(void*)&&CREX_IS_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_IS_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPC_LABEL,
			(void*)&&CREX_IS_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPNC_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_IS_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_IS_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPC_LABEL,
			(void*)&&CREX_IS_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPNC_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_IS_EQUAL_DOUBLE_SPEC_TMPVARCV_CONST_LABEL,
			(void*)&&CREX_IS_EQUAL_DOUBLE_SPEC_TMPVARCV_CONST_JMPC_LABEL,
			(void*)&&CREX_IS_EQUAL_DOUBLE_SPEC_TMPVARCV_CONST_JMPNC_LABEL,
			(void*)&&CREX_IS_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_IS_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPC_LABEL,
			(void*)&&CREX_IS_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPNC_LABEL,
			(void*)&&CREX_IS_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_IS_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPC_LABEL,
			(void*)&&CREX_IS_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPNC_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_IS_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_IS_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPC_LABEL,
			(void*)&&CREX_IS_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPNC_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_IS_NOT_EQUAL_LONG_SPEC_TMPVARCV_CONST_LABEL,
			(void*)&&CREX_IS_NOT_EQUAL_LONG_SPEC_TMPVARCV_CONST_JMPC_LABEL,
			(void*)&&CREX_IS_NOT_EQUAL_LONG_SPEC_TMPVARCV_CONST_JMPNC_LABEL,
			(void*)&&CREX_IS_NOT_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_IS_NOT_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPC_LABEL,
			(void*)&&CREX_IS_NOT_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPNC_LABEL,
			(void*)&&CREX_IS_NOT_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_IS_NOT_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPC_LABEL,
			(void*)&&CREX_IS_NOT_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPNC_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_IS_NOT_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_IS_NOT_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPC_LABEL,
			(void*)&&CREX_IS_NOT_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPNC_LABEL,
			(void*)&&CREX_IS_NOT_EQUAL_LONG_SPEC_TMPVARCV_CONST_LABEL,
			(void*)&&CREX_IS_NOT_EQUAL_LONG_SPEC_TMPVARCV_CONST_JMPC_LABEL,
			(void*)&&CREX_IS_NOT_EQUAL_LONG_SPEC_TMPVARCV_CONST_JMPNC_LABEL,
			(void*)&&CREX_IS_NOT_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_IS_NOT_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPC_LABEL,
			(void*)&&CREX_IS_NOT_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPNC_LABEL,
			(void*)&&CREX_IS_NOT_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_IS_NOT_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPC_LABEL,
			(void*)&&CREX_IS_NOT_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPNC_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_IS_NOT_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_IS_NOT_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPC_LABEL,
			(void*)&&CREX_IS_NOT_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPNC_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_IS_NOT_EQUAL_LONG_SPEC_TMPVARCV_CONST_LABEL,
			(void*)&&CREX_IS_NOT_EQUAL_LONG_SPEC_TMPVARCV_CONST_JMPC_LABEL,
			(void*)&&CREX_IS_NOT_EQUAL_LONG_SPEC_TMPVARCV_CONST_JMPNC_LABEL,
			(void*)&&CREX_IS_NOT_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_IS_NOT_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPC_LABEL,
			(void*)&&CREX_IS_NOT_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPNC_LABEL,
			(void*)&&CREX_IS_NOT_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_IS_NOT_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPC_LABEL,
			(void*)&&CREX_IS_NOT_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPNC_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_IS_NOT_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_IS_NOT_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPC_LABEL,
			(void*)&&CREX_IS_NOT_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPNC_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_IS_NOT_EQUAL_DOUBLE_SPEC_TMPVARCV_CONST_LABEL,
			(void*)&&CREX_IS_NOT_EQUAL_DOUBLE_SPEC_TMPVARCV_CONST_JMPC_LABEL,
			(void*)&&CREX_IS_NOT_EQUAL_DOUBLE_SPEC_TMPVARCV_CONST_JMPNC_LABEL,
			(void*)&&CREX_IS_NOT_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_IS_NOT_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPC_LABEL,
			(void*)&&CREX_IS_NOT_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPNC_LABEL,
			(void*)&&CREX_IS_NOT_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_IS_NOT_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPC_LABEL,
			(void*)&&CREX_IS_NOT_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPNC_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_IS_NOT_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_IS_NOT_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPC_LABEL,
			(void*)&&CREX_IS_NOT_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPNC_LABEL,
			(void*)&&CREX_IS_NOT_EQUAL_DOUBLE_SPEC_TMPVARCV_CONST_LABEL,
			(void*)&&CREX_IS_NOT_EQUAL_DOUBLE_SPEC_TMPVARCV_CONST_JMPC_LABEL,
			(void*)&&CREX_IS_NOT_EQUAL_DOUBLE_SPEC_TMPVARCV_CONST_JMPNC_LABEL,
			(void*)&&CREX_IS_NOT_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_IS_NOT_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPC_LABEL,
			(void*)&&CREX_IS_NOT_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPNC_LABEL,
			(void*)&&CREX_IS_NOT_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_IS_NOT_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPC_LABEL,
			(void*)&&CREX_IS_NOT_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPNC_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_IS_NOT_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_IS_NOT_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPC_LABEL,
			(void*)&&CREX_IS_NOT_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPNC_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_IS_NOT_EQUAL_DOUBLE_SPEC_TMPVARCV_CONST_LABEL,
			(void*)&&CREX_IS_NOT_EQUAL_DOUBLE_SPEC_TMPVARCV_CONST_JMPC_LABEL,
			(void*)&&CREX_IS_NOT_EQUAL_DOUBLE_SPEC_TMPVARCV_CONST_JMPNC_LABEL,
			(void*)&&CREX_IS_NOT_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_IS_NOT_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPC_LABEL,
			(void*)&&CREX_IS_NOT_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPNC_LABEL,
			(void*)&&CREX_IS_NOT_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_IS_NOT_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPC_LABEL,
			(void*)&&CREX_IS_NOT_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPNC_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_IS_NOT_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_IS_NOT_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPC_LABEL,
			(void*)&&CREX_IS_NOT_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPNC_LABEL,
			(void*)&&CREX_IS_IDENTICAL_NOTHROW_SPEC_CV_CONST_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_IS_IDENTICAL_NOTHROW_SPEC_CV_CV_LABEL,
			(void*)&&CREX_IS_NOT_IDENTICAL_NOTHROW_SPEC_CV_CONST_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_IS_NOT_IDENTICAL_NOTHROW_SPEC_CV_CV_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_IS_SMALLER_LONG_SPEC_CONST_TMPVARCV_LABEL,
			(void*)&&CREX_IS_SMALLER_LONG_SPEC_CONST_TMPVARCV_JMPC_LABEL,
			(void*)&&CREX_IS_SMALLER_LONG_SPEC_CONST_TMPVARCV_JMPNC_LABEL,
			(void*)&&CREX_IS_SMALLER_LONG_SPEC_CONST_TMPVARCV_LABEL,
			(void*)&&CREX_IS_SMALLER_LONG_SPEC_CONST_TMPVARCV_JMPC_LABEL,
			(void*)&&CREX_IS_SMALLER_LONG_SPEC_CONST_TMPVARCV_JMPNC_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_IS_SMALLER_LONG_SPEC_CONST_TMPVARCV_LABEL,
			(void*)&&CREX_IS_SMALLER_LONG_SPEC_CONST_TMPVARCV_JMPC_LABEL,
			(void*)&&CREX_IS_SMALLER_LONG_SPEC_CONST_TMPVARCV_JMPNC_LABEL,
			(void*)&&CREX_IS_SMALLER_LONG_SPEC_TMPVARCV_CONST_LABEL,
			(void*)&&CREX_IS_SMALLER_LONG_SPEC_TMPVARCV_CONST_JMPC_LABEL,
			(void*)&&CREX_IS_SMALLER_LONG_SPEC_TMPVARCV_CONST_JMPNC_LABEL,
			(void*)&&CREX_IS_SMALLER_LONG_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_IS_SMALLER_LONG_SPEC_TMPVARCV_TMPVARCV_JMPC_LABEL,
			(void*)&&CREX_IS_SMALLER_LONG_SPEC_TMPVARCV_TMPVARCV_JMPNC_LABEL,
			(void*)&&CREX_IS_SMALLER_LONG_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_IS_SMALLER_LONG_SPEC_TMPVARCV_TMPVARCV_JMPC_LABEL,
			(void*)&&CREX_IS_SMALLER_LONG_SPEC_TMPVARCV_TMPVARCV_JMPNC_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_IS_SMALLER_LONG_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_IS_SMALLER_LONG_SPEC_TMPVARCV_TMPVARCV_JMPC_LABEL,
			(void*)&&CREX_IS_SMALLER_LONG_SPEC_TMPVARCV_TMPVARCV_JMPNC_LABEL,
			(void*)&&CREX_IS_SMALLER_LONG_SPEC_TMPVARCV_CONST_LABEL,
			(void*)&&CREX_IS_SMALLER_LONG_SPEC_TMPVARCV_CONST_JMPC_LABEL,
			(void*)&&CREX_IS_SMALLER_LONG_SPEC_TMPVARCV_CONST_JMPNC_LABEL,
			(void*)&&CREX_IS_SMALLER_LONG_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_IS_SMALLER_LONG_SPEC_TMPVARCV_TMPVARCV_JMPC_LABEL,
			(void*)&&CREX_IS_SMALLER_LONG_SPEC_TMPVARCV_TMPVARCV_JMPNC_LABEL,
			(void*)&&CREX_IS_SMALLER_LONG_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_IS_SMALLER_LONG_SPEC_TMPVARCV_TMPVARCV_JMPC_LABEL,
			(void*)&&CREX_IS_SMALLER_LONG_SPEC_TMPVARCV_TMPVARCV_JMPNC_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_IS_SMALLER_LONG_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_IS_SMALLER_LONG_SPEC_TMPVARCV_TMPVARCV_JMPC_LABEL,
			(void*)&&CREX_IS_SMALLER_LONG_SPEC_TMPVARCV_TMPVARCV_JMPNC_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_IS_SMALLER_LONG_SPEC_TMPVARCV_CONST_LABEL,
			(void*)&&CREX_IS_SMALLER_LONG_SPEC_TMPVARCV_CONST_JMPC_LABEL,
			(void*)&&CREX_IS_SMALLER_LONG_SPEC_TMPVARCV_CONST_JMPNC_LABEL,
			(void*)&&CREX_IS_SMALLER_LONG_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_IS_SMALLER_LONG_SPEC_TMPVARCV_TMPVARCV_JMPC_LABEL,
			(void*)&&CREX_IS_SMALLER_LONG_SPEC_TMPVARCV_TMPVARCV_JMPNC_LABEL,
			(void*)&&CREX_IS_SMALLER_LONG_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_IS_SMALLER_LONG_SPEC_TMPVARCV_TMPVARCV_JMPC_LABEL,
			(void*)&&CREX_IS_SMALLER_LONG_SPEC_TMPVARCV_TMPVARCV_JMPNC_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_IS_SMALLER_LONG_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_IS_SMALLER_LONG_SPEC_TMPVARCV_TMPVARCV_JMPC_LABEL,
			(void*)&&CREX_IS_SMALLER_LONG_SPEC_TMPVARCV_TMPVARCV_JMPNC_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_IS_SMALLER_DOUBLE_SPEC_CONST_TMPVARCV_LABEL,
			(void*)&&CREX_IS_SMALLER_DOUBLE_SPEC_CONST_TMPVARCV_JMPC_LABEL,
			(void*)&&CREX_IS_SMALLER_DOUBLE_SPEC_CONST_TMPVARCV_JMPNC_LABEL,
			(void*)&&CREX_IS_SMALLER_DOUBLE_SPEC_CONST_TMPVARCV_LABEL,
			(void*)&&CREX_IS_SMALLER_DOUBLE_SPEC_CONST_TMPVARCV_JMPC_LABEL,
			(void*)&&CREX_IS_SMALLER_DOUBLE_SPEC_CONST_TMPVARCV_JMPNC_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_IS_SMALLER_DOUBLE_SPEC_CONST_TMPVARCV_LABEL,
			(void*)&&CREX_IS_SMALLER_DOUBLE_SPEC_CONST_TMPVARCV_JMPC_LABEL,
			(void*)&&CREX_IS_SMALLER_DOUBLE_SPEC_CONST_TMPVARCV_JMPNC_LABEL,
			(void*)&&CREX_IS_SMALLER_DOUBLE_SPEC_TMPVARCV_CONST_LABEL,
			(void*)&&CREX_IS_SMALLER_DOUBLE_SPEC_TMPVARCV_CONST_JMPC_LABEL,
			(void*)&&CREX_IS_SMALLER_DOUBLE_SPEC_TMPVARCV_CONST_JMPNC_LABEL,
			(void*)&&CREX_IS_SMALLER_DOUBLE_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_IS_SMALLER_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPC_LABEL,
			(void*)&&CREX_IS_SMALLER_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPNC_LABEL,
			(void*)&&CREX_IS_SMALLER_DOUBLE_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_IS_SMALLER_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPC_LABEL,
			(void*)&&CREX_IS_SMALLER_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPNC_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_IS_SMALLER_DOUBLE_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_IS_SMALLER_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPC_LABEL,
			(void*)&&CREX_IS_SMALLER_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPNC_LABEL,
			(void*)&&CREX_IS_SMALLER_DOUBLE_SPEC_TMPVARCV_CONST_LABEL,
			(void*)&&CREX_IS_SMALLER_DOUBLE_SPEC_TMPVARCV_CONST_JMPC_LABEL,
			(void*)&&CREX_IS_SMALLER_DOUBLE_SPEC_TMPVARCV_CONST_JMPNC_LABEL,
			(void*)&&CREX_IS_SMALLER_DOUBLE_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_IS_SMALLER_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPC_LABEL,
			(void*)&&CREX_IS_SMALLER_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPNC_LABEL,
			(void*)&&CREX_IS_SMALLER_DOUBLE_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_IS_SMALLER_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPC_LABEL,
			(void*)&&CREX_IS_SMALLER_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPNC_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_IS_SMALLER_DOUBLE_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_IS_SMALLER_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPC_LABEL,
			(void*)&&CREX_IS_SMALLER_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPNC_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_IS_SMALLER_DOUBLE_SPEC_TMPVARCV_CONST_LABEL,
			(void*)&&CREX_IS_SMALLER_DOUBLE_SPEC_TMPVARCV_CONST_JMPC_LABEL,
			(void*)&&CREX_IS_SMALLER_DOUBLE_SPEC_TMPVARCV_CONST_JMPNC_LABEL,
			(void*)&&CREX_IS_SMALLER_DOUBLE_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_IS_SMALLER_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPC_LABEL,
			(void*)&&CREX_IS_SMALLER_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPNC_LABEL,
			(void*)&&CREX_IS_SMALLER_DOUBLE_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_IS_SMALLER_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPC_LABEL,
			(void*)&&CREX_IS_SMALLER_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPNC_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_IS_SMALLER_DOUBLE_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_IS_SMALLER_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPC_LABEL,
			(void*)&&CREX_IS_SMALLER_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPNC_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_IS_SMALLER_OR_EQUAL_LONG_SPEC_CONST_TMPVARCV_LABEL,
			(void*)&&CREX_IS_SMALLER_OR_EQUAL_LONG_SPEC_CONST_TMPVARCV_JMPC_LABEL,
			(void*)&&CREX_IS_SMALLER_OR_EQUAL_LONG_SPEC_CONST_TMPVARCV_JMPNC_LABEL,
			(void*)&&CREX_IS_SMALLER_OR_EQUAL_LONG_SPEC_CONST_TMPVARCV_LABEL,
			(void*)&&CREX_IS_SMALLER_OR_EQUAL_LONG_SPEC_CONST_TMPVARCV_JMPC_LABEL,
			(void*)&&CREX_IS_SMALLER_OR_EQUAL_LONG_SPEC_CONST_TMPVARCV_JMPNC_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_IS_SMALLER_OR_EQUAL_LONG_SPEC_CONST_TMPVARCV_LABEL,
			(void*)&&CREX_IS_SMALLER_OR_EQUAL_LONG_SPEC_CONST_TMPVARCV_JMPC_LABEL,
			(void*)&&CREX_IS_SMALLER_OR_EQUAL_LONG_SPEC_CONST_TMPVARCV_JMPNC_LABEL,
			(void*)&&CREX_IS_SMALLER_OR_EQUAL_LONG_SPEC_TMPVARCV_CONST_LABEL,
			(void*)&&CREX_IS_SMALLER_OR_EQUAL_LONG_SPEC_TMPVARCV_CONST_JMPC_LABEL,
			(void*)&&CREX_IS_SMALLER_OR_EQUAL_LONG_SPEC_TMPVARCV_CONST_JMPNC_LABEL,
			(void*)&&CREX_IS_SMALLER_OR_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_IS_SMALLER_OR_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPC_LABEL,
			(void*)&&CREX_IS_SMALLER_OR_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPNC_LABEL,
			(void*)&&CREX_IS_SMALLER_OR_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_IS_SMALLER_OR_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPC_LABEL,
			(void*)&&CREX_IS_SMALLER_OR_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPNC_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_IS_SMALLER_OR_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_IS_SMALLER_OR_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPC_LABEL,
			(void*)&&CREX_IS_SMALLER_OR_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPNC_LABEL,
			(void*)&&CREX_IS_SMALLER_OR_EQUAL_LONG_SPEC_TMPVARCV_CONST_LABEL,
			(void*)&&CREX_IS_SMALLER_OR_EQUAL_LONG_SPEC_TMPVARCV_CONST_JMPC_LABEL,
			(void*)&&CREX_IS_SMALLER_OR_EQUAL_LONG_SPEC_TMPVARCV_CONST_JMPNC_LABEL,
			(void*)&&CREX_IS_SMALLER_OR_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_IS_SMALLER_OR_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPC_LABEL,
			(void*)&&CREX_IS_SMALLER_OR_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPNC_LABEL,
			(void*)&&CREX_IS_SMALLER_OR_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_IS_SMALLER_OR_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPC_LABEL,
			(void*)&&CREX_IS_SMALLER_OR_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPNC_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_IS_SMALLER_OR_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_IS_SMALLER_OR_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPC_LABEL,
			(void*)&&CREX_IS_SMALLER_OR_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPNC_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_IS_SMALLER_OR_EQUAL_LONG_SPEC_TMPVARCV_CONST_LABEL,
			(void*)&&CREX_IS_SMALLER_OR_EQUAL_LONG_SPEC_TMPVARCV_CONST_JMPC_LABEL,
			(void*)&&CREX_IS_SMALLER_OR_EQUAL_LONG_SPEC_TMPVARCV_CONST_JMPNC_LABEL,
			(void*)&&CREX_IS_SMALLER_OR_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_IS_SMALLER_OR_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPC_LABEL,
			(void*)&&CREX_IS_SMALLER_OR_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPNC_LABEL,
			(void*)&&CREX_IS_SMALLER_OR_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_IS_SMALLER_OR_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPC_LABEL,
			(void*)&&CREX_IS_SMALLER_OR_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPNC_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_IS_SMALLER_OR_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_IS_SMALLER_OR_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPC_LABEL,
			(void*)&&CREX_IS_SMALLER_OR_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPNC_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_CONST_TMPVARCV_LABEL,
			(void*)&&CREX_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_CONST_TMPVARCV_JMPC_LABEL,
			(void*)&&CREX_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_CONST_TMPVARCV_JMPNC_LABEL,
			(void*)&&CREX_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_CONST_TMPVARCV_LABEL,
			(void*)&&CREX_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_CONST_TMPVARCV_JMPC_LABEL,
			(void*)&&CREX_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_CONST_TMPVARCV_JMPNC_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_CONST_TMPVARCV_LABEL,
			(void*)&&CREX_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_CONST_TMPVARCV_JMPC_LABEL,
			(void*)&&CREX_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_CONST_TMPVARCV_JMPNC_LABEL,
			(void*)&&CREX_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_TMPVARCV_CONST_LABEL,
			(void*)&&CREX_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_TMPVARCV_CONST_JMPC_LABEL,
			(void*)&&CREX_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_TMPVARCV_CONST_JMPNC_LABEL,
			(void*)&&CREX_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPC_LABEL,
			(void*)&&CREX_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPNC_LABEL,
			(void*)&&CREX_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPC_LABEL,
			(void*)&&CREX_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPNC_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPC_LABEL,
			(void*)&&CREX_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPNC_LABEL,
			(void*)&&CREX_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_TMPVARCV_CONST_LABEL,
			(void*)&&CREX_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_TMPVARCV_CONST_JMPC_LABEL,
			(void*)&&CREX_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_TMPVARCV_CONST_JMPNC_LABEL,
			(void*)&&CREX_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPC_LABEL,
			(void*)&&CREX_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPNC_LABEL,
			(void*)&&CREX_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPC_LABEL,
			(void*)&&CREX_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPNC_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPC_LABEL,
			(void*)&&CREX_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPNC_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_TMPVARCV_CONST_LABEL,
			(void*)&&CREX_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_TMPVARCV_CONST_JMPC_LABEL,
			(void*)&&CREX_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_TMPVARCV_CONST_JMPNC_LABEL,
			(void*)&&CREX_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPC_LABEL,
			(void*)&&CREX_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPNC_LABEL,
			(void*)&&CREX_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPC_LABEL,
			(void*)&&CREX_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPNC_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_LABEL,
			(void*)&&CREX_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPC_LABEL,
			(void*)&&CREX_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPNC_LABEL,
			(void*)&&CREX_PRE_INC_LONG_NO_OVERFLOW_SPEC_CV_RETVAL_UNUSED_LABEL,
			(void*)&&CREX_PRE_INC_LONG_NO_OVERFLOW_SPEC_CV_RETVAL_USED_LABEL,
			(void*)&&CREX_PRE_INC_LONG_SPEC_CV_RETVAL_UNUSED_LABEL,
			(void*)&&CREX_PRE_INC_LONG_SPEC_CV_RETVAL_USED_LABEL,
			(void*)&&CREX_PRE_DEC_LONG_NO_OVERFLOW_SPEC_CV_RETVAL_UNUSED_LABEL,
			(void*)&&CREX_PRE_DEC_LONG_NO_OVERFLOW_SPEC_CV_RETVAL_USED_LABEL,
			(void*)&&CREX_PRE_DEC_LONG_SPEC_CV_RETVAL_UNUSED_LABEL,
			(void*)&&CREX_PRE_DEC_LONG_SPEC_CV_RETVAL_USED_LABEL,
			(void*)&&CREX_POST_INC_LONG_NO_OVERFLOW_SPEC_CV_LABEL,
			(void*)&&CREX_POST_INC_LONG_SPEC_CV_LABEL,
			(void*)&&CREX_POST_DEC_LONG_NO_OVERFLOW_SPEC_CV_LABEL,
			(void*)&&CREX_POST_DEC_LONG_SPEC_CV_LABEL,
			(void*)&&CREX_QM_ASSIGN_LONG_SPEC_CONST_LABEL,
			(void*)&&CREX_QM_ASSIGN_LONG_SPEC_TMPVARCV_LABEL,
			(void*)&&CREX_QM_ASSIGN_LONG_SPEC_TMPVARCV_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_QM_ASSIGN_LONG_SPEC_TMPVARCV_LABEL,
			(void*)&&CREX_QM_ASSIGN_DOUBLE_SPEC_CONST_LABEL,
			(void*)&&CREX_QM_ASSIGN_DOUBLE_SPEC_TMPVARCV_LABEL,
			(void*)&&CREX_QM_ASSIGN_DOUBLE_SPEC_TMPVARCV_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_QM_ASSIGN_DOUBLE_SPEC_TMPVARCV_LABEL,
			(void*)&&CREX_QM_ASSIGN_NOREF_SPEC_CONST_LABEL,
			(void*)&&CREX_QM_ASSIGN_NOREF_SPEC_TMPVARCV_LABEL,
			(void*)&&CREX_QM_ASSIGN_NOREF_SPEC_TMPVARCV_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_QM_ASSIGN_NOREF_SPEC_TMPVARCV_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_FETCH_DIM_R_INDEX_SPEC_CONST_TMPVARCV_LABEL,
			(void*)&&CREX_FETCH_DIM_R_INDEX_SPEC_CONST_TMPVARCV_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_FETCH_DIM_R_INDEX_SPEC_CONST_TMPVARCV_LABEL,
			(void*)&&CREX_FETCH_DIM_R_INDEX_SPEC_TMPVAR_CONST_LABEL,
			(void*)&&CREX_FETCH_DIM_R_INDEX_SPEC_TMPVAR_TMPVARCV_LABEL,
			(void*)&&CREX_FETCH_DIM_R_INDEX_SPEC_TMPVAR_TMPVARCV_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_FETCH_DIM_R_INDEX_SPEC_TMPVAR_TMPVARCV_LABEL,
			(void*)&&CREX_FETCH_DIM_R_INDEX_SPEC_TMPVAR_CONST_LABEL,
			(void*)&&CREX_FETCH_DIM_R_INDEX_SPEC_TMPVAR_TMPVARCV_LABEL,
			(void*)&&CREX_FETCH_DIM_R_INDEX_SPEC_TMPVAR_TMPVARCV_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_FETCH_DIM_R_INDEX_SPEC_TMPVAR_TMPVARCV_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_FETCH_DIM_R_INDEX_SPEC_CV_CONST_LABEL,
			(void*)&&CREX_FETCH_DIM_R_INDEX_SPEC_CV_TMPVARCV_LABEL,
			(void*)&&CREX_FETCH_DIM_R_INDEX_SPEC_CV_TMPVARCV_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_FETCH_DIM_R_INDEX_SPEC_CV_TMPVARCV_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_SEND_VAR_SIMPLE_SPEC_VAR_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_SEND_VAR_SIMPLE_SPEC_CV_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_SEND_VAR_EX_SIMPLE_SPEC_VAR_UNUSED_LABEL,
			(void*)&&CREX_NULL_LABEL,
			(void*)&&CREX_SEND_VAR_EX_SIMPLE_SPEC_CV_UNUSED_LABEL,
			(void*)&&CREX_SEND_VAL_SIMPLE_SPEC_CONST_LABEL,
			(void*)&&CREX_SEND_VAL_EX_SIMPLE_SPEC_CONST_LABEL,
			(void*)&&CREX_FE_FETCH_R_SIMPLE_SPEC_VAR_CV_RETVAL_UNUSED_LABEL,
			(void*)&&CREX_FE_FETCH_R_SIMPLE_SPEC_VAR_CV_RETVAL_USED_LABEL,
			(void*)&&CREX_NULL_LABEL
		};
		crex_opcode_handlers = (const void **) labels;
		crex_handlers_count = sizeof(labels) / sizeof(void*);
		memset(&hybrid_halt_op, 0, sizeof(hybrid_halt_op));
		hybrid_halt_op.handler = (void*)&&HYBRID_HALT_LABEL;
#ifdef CREX_VM_HYBRID_JIT_RED_ZONE_SIZE
		memset(vm_stack_data.hybrid_jit_red_zone, 0, CREX_VM_HYBRID_JIT_RED_ZONE_SIZE);
#endif
		if (crex_touch_vm_stack_data) {
			crex_touch_vm_stack_data(&vm_stack_data);
		}
		goto HYBRID_HALT_LABEL;
	}
#endif

	LOAD_OPLINE();
	CREX_VM_LOOP_INTERRUPT_CHECK();

#ifdef CREX_CHECK_STACK_LIMIT
	if (UNEXPECTED(crex_call_stack_overflowed(EG(stack_limit)))) {
		crex_call_stack_size_error();
		/* No opline was executed before exception */
		EG(opline_before_exception) = NULL;
		LOAD_OPLINE();
		/* Fall through to handle exception below. */
	}
#endif /* CREX_CHECK_STACK_LIMIT */

	while (1) {
#if !defined(CREX_VM_FP_GLOBAL_REG) || !defined(CREX_VM_IP_GLOBAL_REG)
			int ret;
#endif
#if (CREX_VM_KIND == CREX_VM_KIND_HYBRID)
		HYBRID_SWITCH() {
#else
#if defined(CREX_VM_FP_GLOBAL_REG) && defined(CREX_VM_IP_GLOBAL_REG)
		((opcode_handler_t)OPLINE->handler)(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
		if (UNEXPECTED(!OPLINE)) {
#else
		if (UNEXPECTED((ret = ((opcode_handler_t)OPLINE->handler)(CREX_OPCODE_HANDLER_ARGS_PASSTHRU)) != 0)) {
#endif
#endif
#if (CREX_VM_KIND == CREX_VM_KIND_HYBRID)
			HYBRID_CASE(CREX_ASSIGN_STATIC_PROP_OP_SPEC):
				VM_TRACE(CREX_ASSIGN_STATIC_PROP_OP_SPEC)
				CREX_ASSIGN_STATIC_PROP_OP_SPEC_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_PRE_INC_STATIC_PROP_SPEC):
				VM_TRACE(CREX_PRE_INC_STATIC_PROP_SPEC)
				CREX_PRE_INC_STATIC_PROP_SPEC_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_POST_INC_STATIC_PROP_SPEC):
				VM_TRACE(CREX_POST_INC_STATIC_PROP_SPEC)
				CREX_POST_INC_STATIC_PROP_SPEC_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FETCH_STATIC_PROP_R_SPEC):
				VM_TRACE(CREX_FETCH_STATIC_PROP_R_SPEC)
				CREX_FETCH_STATIC_PROP_R_SPEC_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FETCH_STATIC_PROP_W_SPEC):
				VM_TRACE(CREX_FETCH_STATIC_PROP_W_SPEC)
				CREX_FETCH_STATIC_PROP_W_SPEC_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FETCH_STATIC_PROP_RW_SPEC):
				VM_TRACE(CREX_FETCH_STATIC_PROP_RW_SPEC)
				CREX_FETCH_STATIC_PROP_RW_SPEC_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FETCH_STATIC_PROP_FUNC_ARG_SPEC):
				VM_TRACE(CREX_FETCH_STATIC_PROP_FUNC_ARG_SPEC)
				CREX_FETCH_STATIC_PROP_FUNC_ARG_SPEC_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FETCH_STATIC_PROP_UNSET_SPEC):
				VM_TRACE(CREX_FETCH_STATIC_PROP_UNSET_SPEC)
				CREX_FETCH_STATIC_PROP_UNSET_SPEC_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FETCH_STATIC_PROP_IS_SPEC):
				VM_TRACE(CREX_FETCH_STATIC_PROP_IS_SPEC)
				CREX_FETCH_STATIC_PROP_IS_SPEC_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ASSIGN_STATIC_PROP_SPEC_OP_DATA_CONST):
				VM_TRACE(CREX_ASSIGN_STATIC_PROP_SPEC_OP_DATA_CONST)
				CREX_ASSIGN_STATIC_PROP_SPEC_OP_DATA_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ASSIGN_STATIC_PROP_SPEC_OP_DATA_TMP):
				VM_TRACE(CREX_ASSIGN_STATIC_PROP_SPEC_OP_DATA_TMP)
				CREX_ASSIGN_STATIC_PROP_SPEC_OP_DATA_TMP_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ASSIGN_STATIC_PROP_SPEC_OP_DATA_VAR):
				VM_TRACE(CREX_ASSIGN_STATIC_PROP_SPEC_OP_DATA_VAR)
				CREX_ASSIGN_STATIC_PROP_SPEC_OP_DATA_VAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ASSIGN_STATIC_PROP_SPEC_OP_DATA_CV):
				VM_TRACE(CREX_ASSIGN_STATIC_PROP_SPEC_OP_DATA_CV)
				CREX_ASSIGN_STATIC_PROP_SPEC_OP_DATA_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ASSIGN_STATIC_PROP_REF_SPEC):
				VM_TRACE(CREX_ASSIGN_STATIC_PROP_REF_SPEC)
				CREX_ASSIGN_STATIC_PROP_REF_SPEC_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
crex_leave_helper_SPEC_LABEL:
{
	crex_execute_data *old_execute_data;
	uint32_t call_info = EX_CALL_INFO();
	SAVE_OPLINE();

	if (EXPECTED((call_info & (CREX_CALL_CODE|CREX_CALL_TOP|CREX_CALL_HAS_SYMBOL_TABLE|CREX_CALL_FREE_EXTRA_ARGS|CREX_CALL_ALLOCATED|CREX_CALL_HAS_EXTRA_NAMED_PARAMS)) == 0)) {
		EG(current_execute_data) = EX(prev_execute_data);
		i_free_compiled_variables(execute_data);

#ifdef CREX_PREFER_RELOAD
		call_info = EX_CALL_INFO();
#endif
		if (UNEXPECTED(call_info & CREX_CALL_RELEASE_THIS)) {
			OBJ_RELEASE(C_OBJ(execute_data->This));
		} else if (UNEXPECTED(call_info & CREX_CALL_CLOSURE)) {
			OBJ_RELEASE(CREX_CLOSURE_OBJECT(EX(func)));
		}
		EG(vm_stack_top) = (zval*)execute_data;
		execute_data = EX(prev_execute_data);

		if (UNEXPECTED(EG(exception) != NULL)) {
			crex_rethrow_exception(execute_data);
			HANDLE_EXCEPTION_LEAVE();
		}

		LOAD_NEXT_OPLINE();
		CREX_VM_LEAVE();
	} else if (EXPECTED((call_info & (CREX_CALL_CODE|CREX_CALL_TOP)) == 0)) {
		EG(current_execute_data) = EX(prev_execute_data);
		i_free_compiled_variables(execute_data);

#ifdef CREX_PREFER_RELOAD
		call_info = EX_CALL_INFO();
#endif
		if (UNEXPECTED(call_info & CREX_CALL_HAS_SYMBOL_TABLE)) {
			crex_clean_and_cache_symbol_table(EX(symbol_table));
		}

		if (UNEXPECTED(call_info & CREX_CALL_HAS_EXTRA_NAMED_PARAMS)) {
			crex_free_extra_named_params(EX(extra_named_params));
		}

		/* Free extra args before releasing the closure,
		 * as that may free the op_array. */
		crex_vm_stack_free_extra_args_ex(call_info, execute_data);

		if (UNEXPECTED(call_info & CREX_CALL_RELEASE_THIS)) {
			OBJ_RELEASE(C_OBJ(execute_data->This));
		} else if (UNEXPECTED(call_info & CREX_CALL_CLOSURE)) {
			OBJ_RELEASE(CREX_CLOSURE_OBJECT(EX(func)));
		}

		old_execute_data = execute_data;
		execute_data = EX(prev_execute_data);
		crex_vm_stack_free_call_frame_ex(call_info, old_execute_data);

		if (UNEXPECTED(EG(exception) != NULL)) {
			crex_rethrow_exception(execute_data);
			HANDLE_EXCEPTION_LEAVE();
		}

		LOAD_NEXT_OPLINE();
		CREX_VM_LEAVE();
	} else if (EXPECTED((call_info & CREX_CALL_TOP) == 0)) {
		if (EX(func)->op_array.last_var > 0) {
			crex_detach_symbol_table(execute_data);
			call_info |= CREX_CALL_NEEDS_REATTACH;
		}
		crex_destroy_static_vars(&EX(func)->op_array);
		destroy_op_array(&EX(func)->op_array);
		efree_size(EX(func), sizeof(crex_op_array));
		old_execute_data = execute_data;
		execute_data = EG(current_execute_data) = EX(prev_execute_data);
		crex_vm_stack_free_call_frame_ex(call_info, old_execute_data);

		if (call_info & CREX_CALL_NEEDS_REATTACH) {
			if (EX(func)->op_array.last_var > 0) {
				crex_attach_symbol_table(execute_data);
			} else {
				CREX_ADD_CALL_FLAG(execute_data, CREX_CALL_NEEDS_REATTACH);
			}
		}
		if (UNEXPECTED(EG(exception) != NULL)) {
			crex_rethrow_exception(execute_data);
			HANDLE_EXCEPTION_LEAVE();
		}

		LOAD_NEXT_OPLINE();
		CREX_VM_LEAVE();
	} else {
		if (EXPECTED((call_info & CREX_CALL_CODE) == 0)) {
			EG(current_execute_data) = EX(prev_execute_data);
			i_free_compiled_variables(execute_data);
#ifdef CREX_PREFER_RELOAD
			call_info = EX_CALL_INFO();
#endif
			if (UNEXPECTED(call_info & (CREX_CALL_HAS_SYMBOL_TABLE|CREX_CALL_FREE_EXTRA_ARGS|CREX_CALL_HAS_EXTRA_NAMED_PARAMS))) {
				if (UNEXPECTED(call_info & CREX_CALL_HAS_SYMBOL_TABLE)) {
					crex_clean_and_cache_symbol_table(EX(symbol_table));
				}
				crex_vm_stack_free_extra_args_ex(call_info, execute_data);
				if (UNEXPECTED(call_info & CREX_CALL_HAS_EXTRA_NAMED_PARAMS)) {
					crex_free_extra_named_params(EX(extra_named_params));
				}
			}
			if (UNEXPECTED(call_info & CREX_CALL_CLOSURE)) {
				OBJ_RELEASE(CREX_CLOSURE_OBJECT(EX(func)));
			}
			CREX_VM_RETURN();
		} else /* if (call_kind == CREX_CALL_TOP_CODE) */ {
			crex_array *symbol_table = EX(symbol_table);

			if (EX(func)->op_array.last_var > 0) {
				crex_detach_symbol_table(execute_data);
				call_info |= CREX_CALL_NEEDS_REATTACH;
			}
			if (call_info & CREX_CALL_NEEDS_REATTACH) {
				old_execute_data = EX(prev_execute_data);
				while (old_execute_data) {
					if (old_execute_data->func && (CREX_CALL_INFO(old_execute_data) & CREX_CALL_HAS_SYMBOL_TABLE)) {
						if (old_execute_data->symbol_table == symbol_table) {
							if (old_execute_data->func->op_array.last_var > 0) {
								crex_attach_symbol_table(old_execute_data);
							} else {
								CREX_ADD_CALL_FLAG(old_execute_data, CREX_CALL_NEEDS_REATTACH);
							}
						}
						break;
					}
					old_execute_data = old_execute_data->prev_execute_data;
				}
			}
			EG(current_execute_data) = EX(prev_execute_data);
			CREX_VM_RETURN();
		}
	}
}

			HYBRID_CASE(CREX_JMP_SPEC):
				VM_TRACE(CREX_JMP_SPEC)
				CREX_JMP_SPEC_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_DO_ICALL_SPEC_RETVAL_UNUSED):
				VM_TRACE(CREX_DO_ICALL_SPEC_RETVAL_UNUSED)
				CREX_DO_ICALL_SPEC_RETVAL_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_DO_ICALL_SPEC_RETVAL_USED):
				VM_TRACE(CREX_DO_ICALL_SPEC_RETVAL_USED)
				CREX_DO_ICALL_SPEC_RETVAL_USED_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_DO_ICALL_SPEC_OBSERVER):
				VM_TRACE(CREX_DO_ICALL_SPEC_OBSERVER)
				CREX_DO_ICALL_SPEC_OBSERVER_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_DO_UCALL_SPEC_RETVAL_UNUSED):
				VM_TRACE(CREX_DO_UCALL_SPEC_RETVAL_UNUSED)
				CREX_DO_UCALL_SPEC_RETVAL_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_DO_UCALL_SPEC_RETVAL_USED):
				VM_TRACE(CREX_DO_UCALL_SPEC_RETVAL_USED)
				CREX_DO_UCALL_SPEC_RETVAL_USED_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_DO_UCALL_SPEC_OBSERVER):
				VM_TRACE(CREX_DO_UCALL_SPEC_OBSERVER)
				CREX_DO_UCALL_SPEC_OBSERVER_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_DO_FCALL_BY_NAME_SPEC_RETVAL_UNUSED):
				VM_TRACE(CREX_DO_FCALL_BY_NAME_SPEC_RETVAL_UNUSED)
				CREX_DO_FCALL_BY_NAME_SPEC_RETVAL_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_DO_FCALL_BY_NAME_SPEC_RETVAL_USED):
				VM_TRACE(CREX_DO_FCALL_BY_NAME_SPEC_RETVAL_USED)
				CREX_DO_FCALL_BY_NAME_SPEC_RETVAL_USED_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_DO_FCALL_BY_NAME_SPEC_OBSERVER):
				VM_TRACE(CREX_DO_FCALL_BY_NAME_SPEC_OBSERVER)
				CREX_DO_FCALL_BY_NAME_SPEC_OBSERVER_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_DO_FCALL_SPEC_RETVAL_UNUSED):
				VM_TRACE(CREX_DO_FCALL_SPEC_RETVAL_UNUSED)
				CREX_DO_FCALL_SPEC_RETVAL_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_DO_FCALL_SPEC_RETVAL_USED):
				VM_TRACE(CREX_DO_FCALL_SPEC_RETVAL_USED)
				CREX_DO_FCALL_SPEC_RETVAL_USED_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_DO_FCALL_SPEC_OBSERVER):
				VM_TRACE(CREX_DO_FCALL_SPEC_OBSERVER)
				CREX_DO_FCALL_SPEC_OBSERVER_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_GENERATOR_CREATE_SPEC):
				VM_TRACE(CREX_GENERATOR_CREATE_SPEC)
				CREX_GENERATOR_CREATE_SPEC_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_SEND_UNPACK_SPEC):
				VM_TRACE(CREX_SEND_UNPACK_SPEC)
				CREX_SEND_UNPACK_SPEC_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_SEND_ARRAY_SPEC):
				VM_TRACE(CREX_SEND_ARRAY_SPEC)
				CREX_SEND_ARRAY_SPEC_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_RECV_NOTYPE_SPEC):
				VM_TRACE(CREX_RECV_NOTYPE_SPEC)
				CREX_RECV_NOTYPE_SPEC_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ADD_ARRAY_UNPACK_SPEC):
				VM_TRACE(CREX_ADD_ARRAY_UNPACK_SPEC)
				CREX_ADD_ARRAY_UNPACK_SPEC_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_UNSET_STATIC_PROP_SPEC):
				VM_TRACE(CREX_UNSET_STATIC_PROP_SPEC)
				CREX_UNSET_STATIC_PROP_SPEC_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ISSET_ISEMPTY_STATIC_PROP_SPEC):
				VM_TRACE(CREX_ISSET_ISEMPTY_STATIC_PROP_SPEC)
				CREX_ISSET_ISEMPTY_STATIC_PROP_SPEC_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_EXIT_SPEC):
				VM_TRACE(CREX_EXIT_SPEC)
				CREX_EXIT_SPEC_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_BEGIN_SILENCE_SPEC):
				VM_TRACE(CREX_BEGIN_SILENCE_SPEC)
				CREX_BEGIN_SILENCE_SPEC_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_EXT_STMT_SPEC):
				VM_TRACE(CREX_EXT_STMT_SPEC)
				CREX_EXT_STMT_SPEC_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_EXT_FCALL_BEGIN_SPEC):
				VM_TRACE(CREX_EXT_FCALL_BEGIN_SPEC)
				CREX_EXT_FCALL_BEGIN_SPEC_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_EXT_FCALL_END_SPEC):
				VM_TRACE(CREX_EXT_FCALL_END_SPEC)
				CREX_EXT_FCALL_END_SPEC_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_DECLARE_ANON_CLASS_SPEC):
				VM_TRACE(CREX_DECLARE_ANON_CLASS_SPEC)
				CREX_DECLARE_ANON_CLASS_SPEC_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_DECLARE_FUNCTION_SPEC):
				VM_TRACE(CREX_DECLARE_FUNCTION_SPEC)
				CREX_DECLARE_FUNCTION_SPEC_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_TICKS_SPEC):
				VM_TRACE(CREX_TICKS_SPEC)
				CREX_TICKS_SPEC_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_EXT_NOP_SPEC):
				VM_TRACE(CREX_EXT_NOP_SPEC)
				CREX_EXT_NOP_SPEC_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_NOP_SPEC):
				VM_TRACE(CREX_NOP_SPEC)
				CREX_NOP_SPEC_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_HANDLE_EXCEPTION_SPEC):
				VM_TRACE(CREX_HANDLE_EXCEPTION_SPEC)
				CREX_HANDLE_EXCEPTION_SPEC_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_USER_OPCODE_SPEC):
				VM_TRACE(CREX_USER_OPCODE_SPEC)
				CREX_USER_OPCODE_SPEC_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_DISCARD_EXCEPTION_SPEC):
				VM_TRACE(CREX_DISCARD_EXCEPTION_SPEC)
				CREX_DISCARD_EXCEPTION_SPEC_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FAST_CALL_SPEC):
				VM_TRACE(CREX_FAST_CALL_SPEC)
				CREX_FAST_CALL_SPEC_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FAST_RET_SPEC):
				VM_TRACE(CREX_FAST_RET_SPEC)
				CREX_FAST_RET_SPEC_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ASSERT_CHECK_SPEC):
				VM_TRACE(CREX_ASSERT_CHECK_SPEC)
				CREX_ASSERT_CHECK_SPEC_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_CALL_TRAMPOLINE_SPEC):
				VM_TRACE(CREX_CALL_TRAMPOLINE_SPEC)
				CREX_CALL_TRAMPOLINE_SPEC_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_CALL_TRAMPOLINE_SPEC_OBSERVER):
				VM_TRACE(CREX_CALL_TRAMPOLINE_SPEC_OBSERVER)
				CREX_CALL_TRAMPOLINE_SPEC_OBSERVER_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_JMP_FORWARD_SPEC):
				VM_TRACE(CREX_JMP_FORWARD_SPEC)
				CREX_JMP_FORWARD_SPEC_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_INIT_FCALL_BY_NAME_SPEC_CONST):
				VM_TRACE(CREX_INIT_FCALL_BY_NAME_SPEC_CONST)
				CREX_INIT_FCALL_BY_NAME_SPEC_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_INIT_DYNAMIC_CALL_SPEC_CONST):
				VM_TRACE(CREX_INIT_DYNAMIC_CALL_SPEC_CONST)
				CREX_INIT_DYNAMIC_CALL_SPEC_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_INIT_NS_FCALL_BY_NAME_SPEC_CONST):
				VM_TRACE(CREX_INIT_NS_FCALL_BY_NAME_SPEC_CONST)
				CREX_INIT_NS_FCALL_BY_NAME_SPEC_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_INIT_FCALL_SPEC_CONST):
				VM_TRACE(CREX_INIT_FCALL_SPEC_CONST)
				CREX_INIT_FCALL_SPEC_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_RECV_INIT_SPEC_CONST):
				VM_TRACE(CREX_RECV_INIT_SPEC_CONST)
				CREX_RECV_INIT_SPEC_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_INIT_DYNAMIC_CALL_SPEC_TMPVAR):
				VM_TRACE(CREX_INIT_DYNAMIC_CALL_SPEC_TMPVAR)
				CREX_INIT_DYNAMIC_CALL_SPEC_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_RECV_SPEC_UNUSED):
				VM_TRACE(CREX_RECV_SPEC_UNUSED)
				CREX_RECV_SPEC_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_RECV_VARIADIC_SPEC_UNUSED):
				VM_TRACE(CREX_RECV_VARIADIC_SPEC_UNUSED)
				CREX_RECV_VARIADIC_SPEC_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_INIT_DYNAMIC_CALL_SPEC_CV):
				VM_TRACE(CREX_INIT_DYNAMIC_CALL_SPEC_CV)
				CREX_INIT_DYNAMIC_CALL_SPEC_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_BW_NOT_SPEC_CONST):
				VM_TRACE(CREX_BW_NOT_SPEC_CONST)
				CREX_BW_NOT_SPEC_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_BOOL_NOT_SPEC_CONST):
				VM_TRACE(CREX_BOOL_NOT_SPEC_CONST)
				CREX_BOOL_NOT_SPEC_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ECHO_SPEC_CONST):
				VM_TRACE(CREX_ECHO_SPEC_CONST)
				CREX_ECHO_SPEC_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_JMPC_SPEC_CONST):
				VM_TRACE(CREX_JMPC_SPEC_CONST)
				CREX_JMPC_SPEC_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_JMPNC_SPEC_CONST):
				VM_TRACE(CREX_JMPNC_SPEC_CONST)
				CREX_JMPNC_SPEC_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_JMPC_EX_SPEC_CONST):
				VM_TRACE(CREX_JMPC_EX_SPEC_CONST)
				CREX_JMPC_EX_SPEC_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_JMPNC_EX_SPEC_CONST):
				VM_TRACE(CREX_JMPNC_EX_SPEC_CONST)
				CREX_JMPNC_EX_SPEC_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_RETURN_SPEC_CONST):
				VM_TRACE(CREX_RETURN_SPEC_CONST)
{
	USE_OPLINE
	zval *retval_ptr;
	zval *return_value;

	retval_ptr = RT_CONSTANT(opline, opline->op1);
	return_value = EX(return_value);

	if (IS_CONST == IS_CV && UNEXPECTED(C_TYPE_INFO_P(retval_ptr) == IS_UNDEF)) {
		SAVE_OPLINE();
		retval_ptr = ZVAL_UNDEFINED_OP1();
		if (return_value) {
			ZVAL_NULL(return_value);
		}
	} else if (!return_value) {
		if (IS_CONST & (IS_VAR|IS_TMP_VAR)) {
			if (C_REFCOUNTED_P(retval_ptr) && !C_DELREF_P(retval_ptr)) {
				SAVE_OPLINE();
				rc_dtor_func(C_COUNTED_P(retval_ptr));
			}
		}
	} else {
		if ((IS_CONST & (IS_CONST|IS_TMP_VAR))) {
			ZVAL_COPY_VALUE(return_value, retval_ptr);
			if (IS_CONST == IS_CONST) {
				if (UNEXPECTED(C_OPT_REFCOUNTED_P(return_value))) {
					C_ADDREF_P(return_value);
				}
			}
		} else if (IS_CONST == IS_CV) {
			do {
				if (C_OPT_REFCOUNTED_P(retval_ptr)) {
					if (EXPECTED(!C_OPT_ISREF_P(retval_ptr))) {
						if (EXPECTED(!(EX_CALL_INFO() & (CREX_CALL_CODE|CREX_CALL_OBSERVED)))) {
							crex_refcounted *ref = C_COUNTED_P(retval_ptr);
							ZVAL_COPY_VALUE(return_value, retval_ptr);
							if (GC_MAY_LEAK(ref)) {
								SAVE_OPLINE();
								gc_possible_root(ref);
							}
							ZVAL_NULL(retval_ptr);
							break;
						} else {
							C_ADDREF_P(retval_ptr);
						}
					} else {
						retval_ptr = C_REFVAL_P(retval_ptr);
						if (C_OPT_REFCOUNTED_P(retval_ptr)) {
							C_ADDREF_P(retval_ptr);
						}
					}
				}
				ZVAL_COPY_VALUE(return_value, retval_ptr);
			} while (0);
		} else /* if (IS_CONST == IS_VAR) */ {
			if (UNEXPECTED(C_ISREF_P(retval_ptr))) {
				crex_refcounted *ref = C_COUNTED_P(retval_ptr);

				retval_ptr = C_REFVAL_P(retval_ptr);
				ZVAL_COPY_VALUE(return_value, retval_ptr);
				if (UNEXPECTED(GC_DELREF(ref) == 0)) {
					efree_size(ref, sizeof(crex_reference));
				} else if (C_OPT_REFCOUNTED_P(retval_ptr)) {
					C_ADDREF_P(retval_ptr);
				}
			} else {
				ZVAL_COPY_VALUE(return_value, retval_ptr);
			}
		}
	}



	goto crex_leave_helper_SPEC_LABEL;
}

			HYBRID_CASE(CREX_RETURN_SPEC_OBSERVER):
				VM_TRACE(CREX_RETURN_SPEC_OBSERVER)
{
	USE_OPLINE
	zval *retval_ptr;
	zval *return_value;
	zval observer_retval;

	retval_ptr = get_zval_ptr_undef(opline->op1_type, opline->op1, BP_VAR_R);
	return_value = EX(return_value);
	if (!return_value) { return_value = &observer_retval; };
	if (opline->op1_type == IS_CV && UNEXPECTED(C_TYPE_INFO_P(retval_ptr) == IS_UNDEF)) {
		SAVE_OPLINE();
		retval_ptr = ZVAL_UNDEFINED_OP1();
		if (return_value) {
			ZVAL_NULL(return_value);
		}
	} else if (!return_value) {
		if (opline->op1_type & (IS_VAR|IS_TMP_VAR)) {
			if (C_REFCOUNTED_P(retval_ptr) && !C_DELREF_P(retval_ptr)) {
				SAVE_OPLINE();
				rc_dtor_func(C_COUNTED_P(retval_ptr));
			}
		}
	} else {
		if ((opline->op1_type & (IS_CONST|IS_TMP_VAR))) {
			ZVAL_COPY_VALUE(return_value, retval_ptr);
			if (opline->op1_type == IS_CONST) {
				if (UNEXPECTED(C_OPT_REFCOUNTED_P(return_value))) {
					C_ADDREF_P(return_value);
				}
			}
		} else if (opline->op1_type == IS_CV) {
			do {
				if (C_OPT_REFCOUNTED_P(retval_ptr)) {
					if (EXPECTED(!C_OPT_ISREF_P(retval_ptr))) {
						if (EXPECTED(!(EX_CALL_INFO() & (CREX_CALL_CODE|CREX_CALL_OBSERVED)))) {
							crex_refcounted *ref = C_COUNTED_P(retval_ptr);
							ZVAL_COPY_VALUE(return_value, retval_ptr);
							if (GC_MAY_LEAK(ref)) {
								SAVE_OPLINE();
								gc_possible_root(ref);
							}
							ZVAL_NULL(retval_ptr);
							break;
						} else {
							C_ADDREF_P(retval_ptr);
						}
					} else {
						retval_ptr = C_REFVAL_P(retval_ptr);
						if (C_OPT_REFCOUNTED_P(retval_ptr)) {
							C_ADDREF_P(retval_ptr);
						}
					}
				}
				ZVAL_COPY_VALUE(return_value, retval_ptr);
			} while (0);
		} else /* if (opline->op1_type == IS_VAR) */ {
			if (UNEXPECTED(C_ISREF_P(retval_ptr))) {
				crex_refcounted *ref = C_COUNTED_P(retval_ptr);

				retval_ptr = C_REFVAL_P(retval_ptr);
				ZVAL_COPY_VALUE(return_value, retval_ptr);
				if (UNEXPECTED(GC_DELREF(ref) == 0)) {
					efree_size(ref, sizeof(crex_reference));
				} else if (C_OPT_REFCOUNTED_P(retval_ptr)) {
					C_ADDREF_P(retval_ptr);
				}
			} else {
				ZVAL_COPY_VALUE(return_value, retval_ptr);
			}
		}
	}
	SAVE_OPLINE();
	crex_observer_fcall_end(execute_data, return_value);
	if (return_value == &observer_retval) { zval_ptr_dtor_nogc(&observer_retval); };
	goto crex_leave_helper_SPEC_LABEL;
}

			HYBRID_CASE(CREX_RETURN_BY_REF_SPEC_CONST):
				VM_TRACE(CREX_RETURN_BY_REF_SPEC_CONST)
				CREX_RETURN_BY_REF_SPEC_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_RETURN_BY_REF_SPEC_OBSERVER):
				VM_TRACE(CREX_RETURN_BY_REF_SPEC_OBSERVER)
				CREX_RETURN_BY_REF_SPEC_OBSERVER_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_GENERATOR_RETURN_SPEC_CONST):
				VM_TRACE(CREX_GENERATOR_RETURN_SPEC_CONST)
				CREX_GENERATOR_RETURN_SPEC_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_GENERATOR_RETURN_SPEC_OBSERVER):
				VM_TRACE(CREX_GENERATOR_RETURN_SPEC_OBSERVER)
				CREX_GENERATOR_RETURN_SPEC_OBSERVER_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_THROW_SPEC_CONST):
				VM_TRACE(CREX_THROW_SPEC_CONST)
				CREX_THROW_SPEC_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_CATCH_SPEC_CONST):
				VM_TRACE(CREX_CATCH_SPEC_CONST)
				CREX_CATCH_SPEC_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_SEND_USER_SPEC_CONST):
				VM_TRACE(CREX_SEND_USER_SPEC_CONST)
				CREX_SEND_USER_SPEC_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_BOOL_SPEC_CONST):
				VM_TRACE(CREX_BOOL_SPEC_CONST)
				CREX_BOOL_SPEC_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_CLONE_SPEC_CONST):
				VM_TRACE(CREX_CLONE_SPEC_CONST)
				CREX_CLONE_SPEC_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_CAST_SPEC_CONST):
				VM_TRACE(CREX_CAST_SPEC_CONST)
				CREX_CAST_SPEC_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_INCLUDE_OR_EVAL_SPEC_CONST):
				VM_TRACE(CREX_INCLUDE_OR_EVAL_SPEC_CONST)
				CREX_INCLUDE_OR_EVAL_SPEC_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_INCLUDE_OR_EVAL_SPEC_OBSERVER):
				VM_TRACE(CREX_INCLUDE_OR_EVAL_SPEC_OBSERVER)
				CREX_INCLUDE_OR_EVAL_SPEC_OBSERVER_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FE_RESET_R_SPEC_CONST):
				VM_TRACE(CREX_FE_RESET_R_SPEC_CONST)
				CREX_FE_RESET_R_SPEC_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FE_RESET_RW_SPEC_CONST):
				VM_TRACE(CREX_FE_RESET_RW_SPEC_CONST)
				CREX_FE_RESET_RW_SPEC_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_JMP_SET_SPEC_CONST):
				VM_TRACE(CREX_JMP_SET_SPEC_CONST)
				CREX_JMP_SET_SPEC_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_COALESCE_SPEC_CONST):
				VM_TRACE(CREX_COALESCE_SPEC_CONST)
				CREX_COALESCE_SPEC_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_JMP_NULL_SPEC_CONST):
				VM_TRACE(CREX_JMP_NULL_SPEC_CONST)
				CREX_JMP_NULL_SPEC_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_QM_ASSIGN_SPEC_CONST):
				VM_TRACE(CREX_QM_ASSIGN_SPEC_CONST)
				CREX_QM_ASSIGN_SPEC_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_DECLARE_CLASS_SPEC_CONST):
				VM_TRACE(CREX_DECLARE_CLASS_SPEC_CONST)
				CREX_DECLARE_CLASS_SPEC_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_DECLARE_LAMBDA_FUNCTION_SPEC_CONST):
				VM_TRACE(CREX_DECLARE_LAMBDA_FUNCTION_SPEC_CONST)
				CREX_DECLARE_LAMBDA_FUNCTION_SPEC_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_YIELD_FROM_SPEC_CONST):
				VM_TRACE(CREX_YIELD_FROM_SPEC_CONST)
				CREX_YIELD_FROM_SPEC_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_STRLEN_SPEC_CONST):
				VM_TRACE(CREX_STRLEN_SPEC_CONST)
				CREX_STRLEN_SPEC_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_TYPE_CHECK_SPEC_CONST):
				VM_TRACE(CREX_TYPE_CHECK_SPEC_CONST)
				CREX_TYPE_CHECK_SPEC_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_DEFINED_SPEC_CONST):
				VM_TRACE(CREX_DEFINED_SPEC_CONST)
				CREX_DEFINED_SPEC_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_QM_ASSIGN_LONG_SPEC_CONST):
				VM_TRACE(CREX_QM_ASSIGN_LONG_SPEC_CONST)
				CREX_QM_ASSIGN_LONG_SPEC_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_QM_ASSIGN_DOUBLE_SPEC_CONST):
				VM_TRACE(CREX_QM_ASSIGN_DOUBLE_SPEC_CONST)
				CREX_QM_ASSIGN_DOUBLE_SPEC_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_QM_ASSIGN_NOREF_SPEC_CONST):
				VM_TRACE(CREX_QM_ASSIGN_NOREF_SPEC_CONST)
				CREX_QM_ASSIGN_NOREF_SPEC_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_SEND_VAL_SIMPLE_SPEC_CONST):
				VM_TRACE(CREX_SEND_VAL_SIMPLE_SPEC_CONST)
				CREX_SEND_VAL_SIMPLE_SPEC_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_SEND_VAL_EX_SIMPLE_SPEC_CONST):
				VM_TRACE(CREX_SEND_VAL_EX_SIMPLE_SPEC_CONST)
				CREX_SEND_VAL_EX_SIMPLE_SPEC_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ADD_SPEC_CONST_CONST):
				VM_TRACE(CREX_ADD_SPEC_CONST_CONST)
				CREX_ADD_SPEC_CONST_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_SUB_SPEC_CONST_CONST):
				VM_TRACE(CREX_SUB_SPEC_CONST_CONST)
				CREX_SUB_SPEC_CONST_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_MUL_SPEC_CONST_CONST):
				VM_TRACE(CREX_MUL_SPEC_CONST_CONST)
				CREX_MUL_SPEC_CONST_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_DIV_SPEC_CONST_CONST):
				VM_TRACE(CREX_DIV_SPEC_CONST_CONST)
				CREX_DIV_SPEC_CONST_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_MOD_SPEC_CONST_CONST):
				VM_TRACE(CREX_MOD_SPEC_CONST_CONST)
				CREX_MOD_SPEC_CONST_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_SL_SPEC_CONST_CONST):
				VM_TRACE(CREX_SL_SPEC_CONST_CONST)
				CREX_SL_SPEC_CONST_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_SR_SPEC_CONST_CONST):
				VM_TRACE(CREX_SR_SPEC_CONST_CONST)
				CREX_SR_SPEC_CONST_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_POW_SPEC_CONST_CONST):
				VM_TRACE(CREX_POW_SPEC_CONST_CONST)
				CREX_POW_SPEC_CONST_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_IS_IDENTICAL_SPEC_CONST_CONST):
				VM_TRACE(CREX_IS_IDENTICAL_SPEC_CONST_CONST)
				CREX_IS_IDENTICAL_SPEC_CONST_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_IS_NOT_IDENTICAL_SPEC_CONST_CONST):
				VM_TRACE(CREX_IS_NOT_IDENTICAL_SPEC_CONST_CONST)
				CREX_IS_NOT_IDENTICAL_SPEC_CONST_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_IS_EQUAL_SPEC_CONST_CONST):
				VM_TRACE(CREX_IS_EQUAL_SPEC_CONST_CONST)
				CREX_IS_EQUAL_SPEC_CONST_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_IS_NOT_EQUAL_SPEC_CONST_CONST):
				VM_TRACE(CREX_IS_NOT_EQUAL_SPEC_CONST_CONST)
				CREX_IS_NOT_EQUAL_SPEC_CONST_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_IS_SMALLER_SPEC_CONST_CONST):
				VM_TRACE(CREX_IS_SMALLER_SPEC_CONST_CONST)
				CREX_IS_SMALLER_SPEC_CONST_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_IS_SMALLER_OR_EQUAL_SPEC_CONST_CONST):
				VM_TRACE(CREX_IS_SMALLER_OR_EQUAL_SPEC_CONST_CONST)
				CREX_IS_SMALLER_OR_EQUAL_SPEC_CONST_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_SPACESHIP_SPEC_CONST_CONST):
				VM_TRACE(CREX_SPACESHIP_SPEC_CONST_CONST)
				CREX_SPACESHIP_SPEC_CONST_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_BW_OR_SPEC_CONST_CONST):
				VM_TRACE(CREX_BW_OR_SPEC_CONST_CONST)
				CREX_BW_OR_SPEC_CONST_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_BW_AND_SPEC_CONST_CONST):
				VM_TRACE(CREX_BW_AND_SPEC_CONST_CONST)
				CREX_BW_AND_SPEC_CONST_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_BW_XOR_SPEC_CONST_CONST):
				VM_TRACE(CREX_BW_XOR_SPEC_CONST_CONST)
				CREX_BW_XOR_SPEC_CONST_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_BOOL_XOR_SPEC_CONST_CONST):
				VM_TRACE(CREX_BOOL_XOR_SPEC_CONST_CONST)
				CREX_BOOL_XOR_SPEC_CONST_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FETCH_DIM_R_SPEC_CONST_CONST):
				VM_TRACE(CREX_FETCH_DIM_R_SPEC_CONST_CONST)
				CREX_FETCH_DIM_R_SPEC_CONST_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FETCH_DIM_IS_SPEC_CONST_CONST):
				VM_TRACE(CREX_FETCH_DIM_IS_SPEC_CONST_CONST)
				CREX_FETCH_DIM_IS_SPEC_CONST_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FETCH_DIM_FUNC_ARG_SPEC_CONST_CONST):
				VM_TRACE(CREX_FETCH_DIM_FUNC_ARG_SPEC_CONST_CONST)
				CREX_FETCH_DIM_FUNC_ARG_SPEC_CONST_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FETCH_OBJ_R_SPEC_CONST_CONST):
				VM_TRACE(CREX_FETCH_OBJ_R_SPEC_CONST_CONST)
				CREX_FETCH_OBJ_R_SPEC_CONST_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FETCH_OBJ_IS_SPEC_CONST_CONST):
				VM_TRACE(CREX_FETCH_OBJ_IS_SPEC_CONST_CONST)
				CREX_FETCH_OBJ_IS_SPEC_CONST_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FETCH_OBJ_FUNC_ARG_SPEC_CONST_CONST):
				VM_TRACE(CREX_FETCH_OBJ_FUNC_ARG_SPEC_CONST_CONST)
				CREX_FETCH_OBJ_FUNC_ARG_SPEC_CONST_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FETCH_LIST_R_SPEC_CONST_CONST):
				VM_TRACE(CREX_FETCH_LIST_R_SPEC_CONST_CONST)
				CREX_FETCH_LIST_R_SPEC_CONST_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FAST_CONCAT_SPEC_CONST_CONST):
				VM_TRACE(CREX_FAST_CONCAT_SPEC_CONST_CONST)
				CREX_FAST_CONCAT_SPEC_CONST_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_INIT_METHOD_CALL_SPEC_CONST_CONST):
				VM_TRACE(CREX_INIT_METHOD_CALL_SPEC_CONST_CONST)
				CREX_INIT_METHOD_CALL_SPEC_CONST_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_INIT_STATIC_METHOD_CALL_SPEC_CONST_CONST):
				VM_TRACE(CREX_INIT_STATIC_METHOD_CALL_SPEC_CONST_CONST)
				CREX_INIT_STATIC_METHOD_CALL_SPEC_CONST_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_INIT_USER_CALL_SPEC_CONST_CONST):
				VM_TRACE(CREX_INIT_USER_CALL_SPEC_CONST_CONST)
				CREX_INIT_USER_CALL_SPEC_CONST_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_SEND_VAL_SPEC_CONST_CONST):
				VM_TRACE(CREX_SEND_VAL_SPEC_CONST_CONST)
				CREX_SEND_VAL_SPEC_CONST_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_SEND_VAL_EX_SPEC_CONST_CONST):
				VM_TRACE(CREX_SEND_VAL_EX_SPEC_CONST_CONST)
				CREX_SEND_VAL_EX_SPEC_CONST_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FETCH_CLASS_CONSTANT_SPEC_CONST_CONST):
				VM_TRACE(CREX_FETCH_CLASS_CONSTANT_SPEC_CONST_CONST)
				CREX_FETCH_CLASS_CONSTANT_SPEC_CONST_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ADD_ARRAY_ELEMENT_SPEC_CONST_CONST):
				VM_TRACE(CREX_ADD_ARRAY_ELEMENT_SPEC_CONST_CONST)
				CREX_ADD_ARRAY_ELEMENT_SPEC_CONST_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_INIT_ARRAY_SPEC_CONST_CONST):
				VM_TRACE(CREX_INIT_ARRAY_SPEC_CONST_CONST)
				CREX_INIT_ARRAY_SPEC_CONST_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ISSET_ISEMPTY_DIM_OBJ_SPEC_CONST_CONST):
				VM_TRACE(CREX_ISSET_ISEMPTY_DIM_OBJ_SPEC_CONST_CONST)
				CREX_ISSET_ISEMPTY_DIM_OBJ_SPEC_CONST_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ISSET_ISEMPTY_PROP_OBJ_SPEC_CONST_CONST):
				VM_TRACE(CREX_ISSET_ISEMPTY_PROP_OBJ_SPEC_CONST_CONST)
				CREX_ISSET_ISEMPTY_PROP_OBJ_SPEC_CONST_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ARRAY_KEY_EXISTS_SPEC_CONST_CONST):
				VM_TRACE(CREX_ARRAY_KEY_EXISTS_SPEC_CONST_CONST)
				CREX_ARRAY_KEY_EXISTS_SPEC_CONST_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_DECLARE_CLASS_DELAYED_SPEC_CONST_CONST):
				VM_TRACE(CREX_DECLARE_CLASS_DELAYED_SPEC_CONST_CONST)
				CREX_DECLARE_CLASS_DELAYED_SPEC_CONST_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_DECLARE_CONST_SPEC_CONST_CONST):
				VM_TRACE(CREX_DECLARE_CONST_SPEC_CONST_CONST)
				CREX_DECLARE_CONST_SPEC_CONST_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_YIELD_SPEC_CONST_CONST):
				VM_TRACE(CREX_YIELD_SPEC_CONST_CONST)
				CREX_YIELD_SPEC_CONST_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_SWITCH_LONG_SPEC_CONST_CONST):
				VM_TRACE(CREX_SWITCH_LONG_SPEC_CONST_CONST)
				CREX_SWITCH_LONG_SPEC_CONST_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_SWITCH_STRING_SPEC_CONST_CONST):
				VM_TRACE(CREX_SWITCH_STRING_SPEC_CONST_CONST)
				CREX_SWITCH_STRING_SPEC_CONST_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_MATCH_SPEC_CONST_CONST):
				VM_TRACE(CREX_MATCH_SPEC_CONST_CONST)
				CREX_MATCH_SPEC_CONST_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_IN_ARRAY_SPEC_CONST_CONST):
				VM_TRACE(CREX_IN_ARRAY_SPEC_CONST_CONST)
				CREX_IN_ARRAY_SPEC_CONST_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ADD_SPEC_CONST_TMPVARCV):
				VM_TRACE(CREX_ADD_SPEC_CONST_TMPVARCV)
				CREX_ADD_SPEC_CONST_TMPVARCV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_SUB_SPEC_CONST_TMPVARCV):
				VM_TRACE(CREX_SUB_SPEC_CONST_TMPVARCV)
				CREX_SUB_SPEC_CONST_TMPVARCV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_MOD_SPEC_CONST_TMPVARCV):
				VM_TRACE(CREX_MOD_SPEC_CONST_TMPVARCV)
				CREX_MOD_SPEC_CONST_TMPVARCV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_SL_SPEC_CONST_TMPVARCV):
				VM_TRACE(CREX_SL_SPEC_CONST_TMPVARCV)
				CREX_SL_SPEC_CONST_TMPVARCV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_SR_SPEC_CONST_TMPVARCV):
				VM_TRACE(CREX_SR_SPEC_CONST_TMPVARCV)
				CREX_SR_SPEC_CONST_TMPVARCV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_IS_SMALLER_SPEC_CONST_TMPVARCV):
				VM_TRACE(CREX_IS_SMALLER_SPEC_CONST_TMPVARCV)
				CREX_IS_SMALLER_SPEC_CONST_TMPVARCV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_IS_SMALLER_SPEC_CONST_TMPVARCV_JMPZ):
				VM_TRACE(CREX_IS_SMALLER_SPEC_CONST_TMPVARCV_JMPZ)
				CREX_IS_SMALLER_SPEC_CONST_TMPVARCV_JMPC_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_IS_SMALLER_SPEC_CONST_TMPVARCV_JMPNZ):
				VM_TRACE(CREX_IS_SMALLER_SPEC_CONST_TMPVARCV_JMPNZ)
				CREX_IS_SMALLER_SPEC_CONST_TMPVARCV_JMPNC_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_IS_SMALLER_OR_EQUAL_SPEC_CONST_TMPVARCV):
				VM_TRACE(CREX_IS_SMALLER_OR_EQUAL_SPEC_CONST_TMPVARCV)
				CREX_IS_SMALLER_OR_EQUAL_SPEC_CONST_TMPVARCV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_IS_SMALLER_OR_EQUAL_SPEC_CONST_TMPVARCV_JMPZ):
				VM_TRACE(CREX_IS_SMALLER_OR_EQUAL_SPEC_CONST_TMPVARCV_JMPZ)
				CREX_IS_SMALLER_OR_EQUAL_SPEC_CONST_TMPVARCV_JMPC_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_IS_SMALLER_OR_EQUAL_SPEC_CONST_TMPVARCV_JMPNZ):
				VM_TRACE(CREX_IS_SMALLER_OR_EQUAL_SPEC_CONST_TMPVARCV_JMPNZ)
				CREX_IS_SMALLER_OR_EQUAL_SPEC_CONST_TMPVARCV_JMPNC_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FETCH_CLASS_CONSTANT_SPEC_CONST_TMPVARCV):
				VM_TRACE(CREX_FETCH_CLASS_CONSTANT_SPEC_CONST_TMPVARCV)
				CREX_FETCH_CLASS_CONSTANT_SPEC_CONST_TMPVARCV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_SUB_LONG_NO_OVERFLOW_SPEC_CONST_TMPVARCV):
				VM_TRACE(CREX_SUB_LONG_NO_OVERFLOW_SPEC_CONST_TMPVARCV)
				CREX_SUB_LONG_NO_OVERFLOW_SPEC_CONST_TMPVARCV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_SUB_LONG_SPEC_CONST_TMPVARCV):
				VM_TRACE(CREX_SUB_LONG_SPEC_CONST_TMPVARCV)
				CREX_SUB_LONG_SPEC_CONST_TMPVARCV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_SUB_DOUBLE_SPEC_CONST_TMPVARCV):
				VM_TRACE(CREX_SUB_DOUBLE_SPEC_CONST_TMPVARCV)
				CREX_SUB_DOUBLE_SPEC_CONST_TMPVARCV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_IS_SMALLER_LONG_SPEC_CONST_TMPVARCV):
				VM_TRACE(CREX_IS_SMALLER_LONG_SPEC_CONST_TMPVARCV)
				CREX_IS_SMALLER_LONG_SPEC_CONST_TMPVARCV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_IS_SMALLER_LONG_SPEC_CONST_TMPVARCV_JMPZ):
				VM_TRACE(CREX_IS_SMALLER_LONG_SPEC_CONST_TMPVARCV_JMPZ)
				CREX_IS_SMALLER_LONG_SPEC_CONST_TMPVARCV_JMPC_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_IS_SMALLER_LONG_SPEC_CONST_TMPVARCV_JMPNZ):
				VM_TRACE(CREX_IS_SMALLER_LONG_SPEC_CONST_TMPVARCV_JMPNZ)
				CREX_IS_SMALLER_LONG_SPEC_CONST_TMPVARCV_JMPNC_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_IS_SMALLER_DOUBLE_SPEC_CONST_TMPVARCV):
				VM_TRACE(CREX_IS_SMALLER_DOUBLE_SPEC_CONST_TMPVARCV)
				CREX_IS_SMALLER_DOUBLE_SPEC_CONST_TMPVARCV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_IS_SMALLER_DOUBLE_SPEC_CONST_TMPVARCV_JMPZ):
				VM_TRACE(CREX_IS_SMALLER_DOUBLE_SPEC_CONST_TMPVARCV_JMPZ)
				CREX_IS_SMALLER_DOUBLE_SPEC_CONST_TMPVARCV_JMPC_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_IS_SMALLER_DOUBLE_SPEC_CONST_TMPVARCV_JMPNZ):
				VM_TRACE(CREX_IS_SMALLER_DOUBLE_SPEC_CONST_TMPVARCV_JMPNZ)
				CREX_IS_SMALLER_DOUBLE_SPEC_CONST_TMPVARCV_JMPNC_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_IS_SMALLER_OR_EQUAL_LONG_SPEC_CONST_TMPVARCV):
				VM_TRACE(CREX_IS_SMALLER_OR_EQUAL_LONG_SPEC_CONST_TMPVARCV)
				CREX_IS_SMALLER_OR_EQUAL_LONG_SPEC_CONST_TMPVARCV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_IS_SMALLER_OR_EQUAL_LONG_SPEC_CONST_TMPVARCV_JMPZ):
				VM_TRACE(CREX_IS_SMALLER_OR_EQUAL_LONG_SPEC_CONST_TMPVARCV_JMPZ)
				CREX_IS_SMALLER_OR_EQUAL_LONG_SPEC_CONST_TMPVARCV_JMPC_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_IS_SMALLER_OR_EQUAL_LONG_SPEC_CONST_TMPVARCV_JMPNZ):
				VM_TRACE(CREX_IS_SMALLER_OR_EQUAL_LONG_SPEC_CONST_TMPVARCV_JMPNZ)
				CREX_IS_SMALLER_OR_EQUAL_LONG_SPEC_CONST_TMPVARCV_JMPNC_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_CONST_TMPVARCV):
				VM_TRACE(CREX_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_CONST_TMPVARCV)
				CREX_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_CONST_TMPVARCV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_CONST_TMPVARCV_JMPZ):
				VM_TRACE(CREX_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_CONST_TMPVARCV_JMPZ)
				CREX_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_CONST_TMPVARCV_JMPC_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_CONST_TMPVARCV_JMPNZ):
				VM_TRACE(CREX_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_CONST_TMPVARCV_JMPNZ)
				CREX_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_CONST_TMPVARCV_JMPNC_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FETCH_DIM_R_INDEX_SPEC_CONST_TMPVARCV):
				VM_TRACE(CREX_FETCH_DIM_R_INDEX_SPEC_CONST_TMPVARCV)
				CREX_FETCH_DIM_R_INDEX_SPEC_CONST_TMPVARCV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_DIV_SPEC_CONST_TMPVAR):
				VM_TRACE(CREX_DIV_SPEC_CONST_TMPVAR)
				CREX_DIV_SPEC_CONST_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_POW_SPEC_CONST_TMPVAR):
				VM_TRACE(CREX_POW_SPEC_CONST_TMPVAR)
				CREX_POW_SPEC_CONST_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_CONCAT_SPEC_CONST_TMPVAR):
				VM_TRACE(CREX_CONCAT_SPEC_CONST_TMPVAR)
				CREX_CONCAT_SPEC_CONST_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_SPACESHIP_SPEC_CONST_TMPVAR):
				VM_TRACE(CREX_SPACESHIP_SPEC_CONST_TMPVAR)
				CREX_SPACESHIP_SPEC_CONST_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FETCH_DIM_R_SPEC_CONST_TMPVAR):
				VM_TRACE(CREX_FETCH_DIM_R_SPEC_CONST_TMPVAR)
				CREX_FETCH_DIM_R_SPEC_CONST_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FETCH_DIM_IS_SPEC_CONST_TMPVAR):
				VM_TRACE(CREX_FETCH_DIM_IS_SPEC_CONST_TMPVAR)
				CREX_FETCH_DIM_IS_SPEC_CONST_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FETCH_DIM_FUNC_ARG_SPEC_CONST_TMPVAR):
				VM_TRACE(CREX_FETCH_DIM_FUNC_ARG_SPEC_CONST_TMPVAR)
				CREX_FETCH_DIM_FUNC_ARG_SPEC_CONST_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FETCH_OBJ_R_SPEC_CONST_TMPVAR):
				VM_TRACE(CREX_FETCH_OBJ_R_SPEC_CONST_TMPVAR)
				CREX_FETCH_OBJ_R_SPEC_CONST_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FETCH_OBJ_IS_SPEC_CONST_TMPVAR):
				VM_TRACE(CREX_FETCH_OBJ_IS_SPEC_CONST_TMPVAR)
				CREX_FETCH_OBJ_IS_SPEC_CONST_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FETCH_OBJ_FUNC_ARG_SPEC_CONST_TMPVAR):
				VM_TRACE(CREX_FETCH_OBJ_FUNC_ARG_SPEC_CONST_TMPVAR)
				CREX_FETCH_OBJ_FUNC_ARG_SPEC_CONST_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FETCH_LIST_R_SPEC_CONST_TMPVAR):
				VM_TRACE(CREX_FETCH_LIST_R_SPEC_CONST_TMPVAR)
				CREX_FETCH_LIST_R_SPEC_CONST_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FAST_CONCAT_SPEC_CONST_TMPVAR):
				VM_TRACE(CREX_FAST_CONCAT_SPEC_CONST_TMPVAR)
				CREX_FAST_CONCAT_SPEC_CONST_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_INIT_METHOD_CALL_SPEC_CONST_TMPVAR):
				VM_TRACE(CREX_INIT_METHOD_CALL_SPEC_CONST_TMPVAR)
				CREX_INIT_METHOD_CALL_SPEC_CONST_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_INIT_STATIC_METHOD_CALL_SPEC_CONST_TMPVAR):
				VM_TRACE(CREX_INIT_STATIC_METHOD_CALL_SPEC_CONST_TMPVAR)
				CREX_INIT_STATIC_METHOD_CALL_SPEC_CONST_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_INIT_USER_CALL_SPEC_CONST_TMPVAR):
				VM_TRACE(CREX_INIT_USER_CALL_SPEC_CONST_TMPVAR)
				CREX_INIT_USER_CALL_SPEC_CONST_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ADD_ARRAY_ELEMENT_SPEC_CONST_TMPVAR):
				VM_TRACE(CREX_ADD_ARRAY_ELEMENT_SPEC_CONST_TMPVAR)
				CREX_ADD_ARRAY_ELEMENT_SPEC_CONST_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_INIT_ARRAY_SPEC_CONST_TMPVAR):
				VM_TRACE(CREX_INIT_ARRAY_SPEC_CONST_TMPVAR)
				CREX_INIT_ARRAY_SPEC_CONST_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ISSET_ISEMPTY_DIM_OBJ_SPEC_CONST_TMPVAR):
				VM_TRACE(CREX_ISSET_ISEMPTY_DIM_OBJ_SPEC_CONST_TMPVAR)
				CREX_ISSET_ISEMPTY_DIM_OBJ_SPEC_CONST_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ISSET_ISEMPTY_PROP_OBJ_SPEC_CONST_TMPVAR):
				VM_TRACE(CREX_ISSET_ISEMPTY_PROP_OBJ_SPEC_CONST_TMPVAR)
				CREX_ISSET_ISEMPTY_PROP_OBJ_SPEC_CONST_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ARRAY_KEY_EXISTS_SPEC_CONST_TMPVAR):
				VM_TRACE(CREX_ARRAY_KEY_EXISTS_SPEC_CONST_TMPVAR)
				CREX_ARRAY_KEY_EXISTS_SPEC_CONST_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_YIELD_SPEC_CONST_TMPVAR):
				VM_TRACE(CREX_YIELD_SPEC_CONST_TMPVAR)
				CREX_YIELD_SPEC_CONST_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FETCH_R_SPEC_CONST_UNUSED):
				VM_TRACE(CREX_FETCH_R_SPEC_CONST_UNUSED)
				CREX_FETCH_R_SPEC_CONST_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FETCH_W_SPEC_CONST_UNUSED):
				VM_TRACE(CREX_FETCH_W_SPEC_CONST_UNUSED)
				CREX_FETCH_W_SPEC_CONST_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FETCH_RW_SPEC_CONST_UNUSED):
				VM_TRACE(CREX_FETCH_RW_SPEC_CONST_UNUSED)
				CREX_FETCH_RW_SPEC_CONST_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FETCH_FUNC_ARG_SPEC_CONST_UNUSED):
				VM_TRACE(CREX_FETCH_FUNC_ARG_SPEC_CONST_UNUSED)
				CREX_FETCH_FUNC_ARG_SPEC_CONST_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FETCH_UNSET_SPEC_CONST_UNUSED):
				VM_TRACE(CREX_FETCH_UNSET_SPEC_CONST_UNUSED)
				CREX_FETCH_UNSET_SPEC_CONST_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FETCH_IS_SPEC_CONST_UNUSED):
				VM_TRACE(CREX_FETCH_IS_SPEC_CONST_UNUSED)
				CREX_FETCH_IS_SPEC_CONST_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FETCH_DIM_FUNC_ARG_SPEC_CONST_UNUSED):
				VM_TRACE(CREX_FETCH_DIM_FUNC_ARG_SPEC_CONST_UNUSED)
				CREX_FETCH_DIM_FUNC_ARG_SPEC_CONST_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_INIT_STATIC_METHOD_CALL_SPEC_CONST_UNUSED):
				VM_TRACE(CREX_INIT_STATIC_METHOD_CALL_SPEC_CONST_UNUSED)
				CREX_INIT_STATIC_METHOD_CALL_SPEC_CONST_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_VERIFY_RETURN_TYPE_SPEC_CONST_UNUSED):
				VM_TRACE(CREX_VERIFY_RETURN_TYPE_SPEC_CONST_UNUSED)
				CREX_VERIFY_RETURN_TYPE_SPEC_CONST_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_SEND_VAL_SPEC_CONST_UNUSED):
				VM_TRACE(CREX_SEND_VAL_SPEC_CONST_UNUSED)
				CREX_SEND_VAL_SPEC_CONST_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_SEND_VAL_EX_SPEC_CONST_UNUSED):
				VM_TRACE(CREX_SEND_VAL_EX_SPEC_CONST_UNUSED)
				CREX_SEND_VAL_EX_SPEC_CONST_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_SEND_VAL_EX_SPEC_CONST_UNUSED_QUICK):
				VM_TRACE(CREX_SEND_VAL_EX_SPEC_CONST_UNUSED_QUICK)
				CREX_SEND_VAL_EX_SPEC_CONST_UNUSED_QUICK_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_NEW_SPEC_CONST_UNUSED):
				VM_TRACE(CREX_NEW_SPEC_CONST_UNUSED)
				CREX_NEW_SPEC_CONST_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ADD_ARRAY_ELEMENT_SPEC_CONST_UNUSED):
				VM_TRACE(CREX_ADD_ARRAY_ELEMENT_SPEC_CONST_UNUSED)
				CREX_ADD_ARRAY_ELEMENT_SPEC_CONST_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_INIT_ARRAY_SPEC_CONST_UNUSED):
				VM_TRACE(CREX_INIT_ARRAY_SPEC_CONST_UNUSED)
				CREX_INIT_ARRAY_SPEC_CONST_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_UNSET_VAR_SPEC_CONST_UNUSED):
				VM_TRACE(CREX_UNSET_VAR_SPEC_CONST_UNUSED)
				CREX_UNSET_VAR_SPEC_CONST_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ISSET_ISEMPTY_VAR_SPEC_CONST_UNUSED):
				VM_TRACE(CREX_ISSET_ISEMPTY_VAR_SPEC_CONST_UNUSED)
				CREX_ISSET_ISEMPTY_VAR_SPEC_CONST_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_YIELD_SPEC_CONST_UNUSED):
				VM_TRACE(CREX_YIELD_SPEC_CONST_UNUSED)
				CREX_YIELD_SPEC_CONST_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_MATCH_ERROR_SPEC_CONST_UNUSED):
				VM_TRACE(CREX_MATCH_ERROR_SPEC_CONST_UNUSED)
				CREX_MATCH_ERROR_SPEC_CONST_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_COUNT_SPEC_CONST_UNUSED):
				VM_TRACE(CREX_COUNT_SPEC_CONST_UNUSED)
				CREX_COUNT_SPEC_CONST_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_GET_CLASS_SPEC_CONST_UNUSED):
				VM_TRACE(CREX_GET_CLASS_SPEC_CONST_UNUSED)
				CREX_GET_CLASS_SPEC_CONST_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_GET_TYPE_SPEC_CONST_UNUSED):
				VM_TRACE(CREX_GET_TYPE_SPEC_CONST_UNUSED)
				CREX_GET_TYPE_SPEC_CONST_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FUNC_GET_ARGS_SPEC_CONST_UNUSED):
				VM_TRACE(CREX_FUNC_GET_ARGS_SPEC_CONST_UNUSED)
				CREX_FUNC_GET_ARGS_SPEC_CONST_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_DIV_SPEC_CONST_CV):
				VM_TRACE(CREX_DIV_SPEC_CONST_CV)
				CREX_DIV_SPEC_CONST_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_POW_SPEC_CONST_CV):
				VM_TRACE(CREX_POW_SPEC_CONST_CV)
				CREX_POW_SPEC_CONST_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_CONCAT_SPEC_CONST_CV):
				VM_TRACE(CREX_CONCAT_SPEC_CONST_CV)
				CREX_CONCAT_SPEC_CONST_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_SPACESHIP_SPEC_CONST_CV):
				VM_TRACE(CREX_SPACESHIP_SPEC_CONST_CV)
				CREX_SPACESHIP_SPEC_CONST_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FETCH_DIM_R_SPEC_CONST_CV):
				VM_TRACE(CREX_FETCH_DIM_R_SPEC_CONST_CV)
				CREX_FETCH_DIM_R_SPEC_CONST_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FETCH_DIM_IS_SPEC_CONST_CV):
				VM_TRACE(CREX_FETCH_DIM_IS_SPEC_CONST_CV)
				CREX_FETCH_DIM_IS_SPEC_CONST_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FETCH_DIM_FUNC_ARG_SPEC_CONST_CV):
				VM_TRACE(CREX_FETCH_DIM_FUNC_ARG_SPEC_CONST_CV)
				CREX_FETCH_DIM_FUNC_ARG_SPEC_CONST_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FETCH_OBJ_R_SPEC_CONST_CV):
				VM_TRACE(CREX_FETCH_OBJ_R_SPEC_CONST_CV)
				CREX_FETCH_OBJ_R_SPEC_CONST_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FETCH_OBJ_IS_SPEC_CONST_CV):
				VM_TRACE(CREX_FETCH_OBJ_IS_SPEC_CONST_CV)
				CREX_FETCH_OBJ_IS_SPEC_CONST_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FETCH_OBJ_FUNC_ARG_SPEC_CONST_CV):
				VM_TRACE(CREX_FETCH_OBJ_FUNC_ARG_SPEC_CONST_CV)
				CREX_FETCH_OBJ_FUNC_ARG_SPEC_CONST_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FETCH_LIST_R_SPEC_CONST_CV):
				VM_TRACE(CREX_FETCH_LIST_R_SPEC_CONST_CV)
				CREX_FETCH_LIST_R_SPEC_CONST_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FAST_CONCAT_SPEC_CONST_CV):
				VM_TRACE(CREX_FAST_CONCAT_SPEC_CONST_CV)
				CREX_FAST_CONCAT_SPEC_CONST_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_INIT_METHOD_CALL_SPEC_CONST_CV):
				VM_TRACE(CREX_INIT_METHOD_CALL_SPEC_CONST_CV)
				CREX_INIT_METHOD_CALL_SPEC_CONST_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_INIT_STATIC_METHOD_CALL_SPEC_CONST_CV):
				VM_TRACE(CREX_INIT_STATIC_METHOD_CALL_SPEC_CONST_CV)
				CREX_INIT_STATIC_METHOD_CALL_SPEC_CONST_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_INIT_USER_CALL_SPEC_CONST_CV):
				VM_TRACE(CREX_INIT_USER_CALL_SPEC_CONST_CV)
				CREX_INIT_USER_CALL_SPEC_CONST_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ADD_ARRAY_ELEMENT_SPEC_CONST_CV):
				VM_TRACE(CREX_ADD_ARRAY_ELEMENT_SPEC_CONST_CV)
				CREX_ADD_ARRAY_ELEMENT_SPEC_CONST_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_INIT_ARRAY_SPEC_CONST_CV):
				VM_TRACE(CREX_INIT_ARRAY_SPEC_CONST_CV)
				CREX_INIT_ARRAY_SPEC_CONST_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ISSET_ISEMPTY_DIM_OBJ_SPEC_CONST_CV):
				VM_TRACE(CREX_ISSET_ISEMPTY_DIM_OBJ_SPEC_CONST_CV)
				CREX_ISSET_ISEMPTY_DIM_OBJ_SPEC_CONST_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ISSET_ISEMPTY_PROP_OBJ_SPEC_CONST_CV):
				VM_TRACE(CREX_ISSET_ISEMPTY_PROP_OBJ_SPEC_CONST_CV)
				CREX_ISSET_ISEMPTY_PROP_OBJ_SPEC_CONST_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ARRAY_KEY_EXISTS_SPEC_CONST_CV):
				VM_TRACE(CREX_ARRAY_KEY_EXISTS_SPEC_CONST_CV)
				CREX_ARRAY_KEY_EXISTS_SPEC_CONST_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_YIELD_SPEC_CONST_CV):
				VM_TRACE(CREX_YIELD_SPEC_CONST_CV)
				CREX_YIELD_SPEC_CONST_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_BW_NOT_SPEC_TMPVARCV):
				VM_TRACE(CREX_BW_NOT_SPEC_TMPVARCV)
				CREX_BW_NOT_SPEC_TMPVARCV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_QM_ASSIGN_LONG_SPEC_TMPVARCV):
				VM_TRACE(CREX_QM_ASSIGN_LONG_SPEC_TMPVARCV)
				CREX_QM_ASSIGN_LONG_SPEC_TMPVARCV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_QM_ASSIGN_DOUBLE_SPEC_TMPVARCV):
				VM_TRACE(CREX_QM_ASSIGN_DOUBLE_SPEC_TMPVARCV)
				CREX_QM_ASSIGN_DOUBLE_SPEC_TMPVARCV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_QM_ASSIGN_NOREF_SPEC_TMPVARCV):
				VM_TRACE(CREX_QM_ASSIGN_NOREF_SPEC_TMPVARCV)
				CREX_QM_ASSIGN_NOREF_SPEC_TMPVARCV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ADD_SPEC_TMPVARCV_CONST):
				VM_TRACE(CREX_ADD_SPEC_TMPVARCV_CONST)
				CREX_ADD_SPEC_TMPVARCV_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_SUB_SPEC_TMPVARCV_CONST):
				VM_TRACE(CREX_SUB_SPEC_TMPVARCV_CONST)
				CREX_SUB_SPEC_TMPVARCV_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_MUL_SPEC_TMPVARCV_CONST):
				VM_TRACE(CREX_MUL_SPEC_TMPVARCV_CONST)
				CREX_MUL_SPEC_TMPVARCV_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_MOD_SPEC_TMPVARCV_CONST):
				VM_TRACE(CREX_MOD_SPEC_TMPVARCV_CONST)
				CREX_MOD_SPEC_TMPVARCV_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_SL_SPEC_TMPVARCV_CONST):
				VM_TRACE(CREX_SL_SPEC_TMPVARCV_CONST)
				CREX_SL_SPEC_TMPVARCV_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_SR_SPEC_TMPVARCV_CONST):
				VM_TRACE(CREX_SR_SPEC_TMPVARCV_CONST)
				CREX_SR_SPEC_TMPVARCV_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_IS_SMALLER_SPEC_TMPVARCV_CONST):
				VM_TRACE(CREX_IS_SMALLER_SPEC_TMPVARCV_CONST)
				CREX_IS_SMALLER_SPEC_TMPVARCV_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_IS_SMALLER_SPEC_TMPVARCV_CONST_JMPZ):
				VM_TRACE(CREX_IS_SMALLER_SPEC_TMPVARCV_CONST_JMPZ)
				CREX_IS_SMALLER_SPEC_TMPVARCV_CONST_JMPC_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_IS_SMALLER_SPEC_TMPVARCV_CONST_JMPNZ):
				VM_TRACE(CREX_IS_SMALLER_SPEC_TMPVARCV_CONST_JMPNZ)
				CREX_IS_SMALLER_SPEC_TMPVARCV_CONST_JMPNC_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_IS_SMALLER_OR_EQUAL_SPEC_TMPVARCV_CONST):
				VM_TRACE(CREX_IS_SMALLER_OR_EQUAL_SPEC_TMPVARCV_CONST)
				CREX_IS_SMALLER_OR_EQUAL_SPEC_TMPVARCV_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_IS_SMALLER_OR_EQUAL_SPEC_TMPVARCV_CONST_JMPZ):
				VM_TRACE(CREX_IS_SMALLER_OR_EQUAL_SPEC_TMPVARCV_CONST_JMPZ)
				CREX_IS_SMALLER_OR_EQUAL_SPEC_TMPVARCV_CONST_JMPC_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_IS_SMALLER_OR_EQUAL_SPEC_TMPVARCV_CONST_JMPNZ):
				VM_TRACE(CREX_IS_SMALLER_OR_EQUAL_SPEC_TMPVARCV_CONST_JMPNZ)
				CREX_IS_SMALLER_OR_EQUAL_SPEC_TMPVARCV_CONST_JMPNC_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_BW_OR_SPEC_TMPVARCV_CONST):
				VM_TRACE(CREX_BW_OR_SPEC_TMPVARCV_CONST)
				CREX_BW_OR_SPEC_TMPVARCV_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_BW_AND_SPEC_TMPVARCV_CONST):
				VM_TRACE(CREX_BW_AND_SPEC_TMPVARCV_CONST)
				CREX_BW_AND_SPEC_TMPVARCV_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_BW_XOR_SPEC_TMPVARCV_CONST):
				VM_TRACE(CREX_BW_XOR_SPEC_TMPVARCV_CONST)
				CREX_BW_XOR_SPEC_TMPVARCV_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FETCH_LIST_R_SPEC_TMPVARCV_CONST):
				VM_TRACE(CREX_FETCH_LIST_R_SPEC_TMPVARCV_CONST)
				CREX_FETCH_LIST_R_SPEC_TMPVARCV_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_SWITCH_LONG_SPEC_TMPVARCV_CONST):
				VM_TRACE(CREX_SWITCH_LONG_SPEC_TMPVARCV_CONST)
				CREX_SWITCH_LONG_SPEC_TMPVARCV_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_SWITCH_STRING_SPEC_TMPVARCV_CONST):
				VM_TRACE(CREX_SWITCH_STRING_SPEC_TMPVARCV_CONST)
				CREX_SWITCH_STRING_SPEC_TMPVARCV_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_MATCH_SPEC_TMPVARCV_CONST):
				VM_TRACE(CREX_MATCH_SPEC_TMPVARCV_CONST)
				CREX_MATCH_SPEC_TMPVARCV_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ADD_LONG_NO_OVERFLOW_SPEC_TMPVARCV_CONST):
				VM_TRACE(CREX_ADD_LONG_NO_OVERFLOW_SPEC_TMPVARCV_CONST)
				CREX_ADD_LONG_NO_OVERFLOW_SPEC_TMPVARCV_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ADD_LONG_SPEC_TMPVARCV_CONST):
				VM_TRACE(CREX_ADD_LONG_SPEC_TMPVARCV_CONST)
				CREX_ADD_LONG_SPEC_TMPVARCV_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ADD_DOUBLE_SPEC_TMPVARCV_CONST):
				VM_TRACE(CREX_ADD_DOUBLE_SPEC_TMPVARCV_CONST)
				CREX_ADD_DOUBLE_SPEC_TMPVARCV_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_SUB_LONG_NO_OVERFLOW_SPEC_TMPVARCV_CONST):
				VM_TRACE(CREX_SUB_LONG_NO_OVERFLOW_SPEC_TMPVARCV_CONST)
				CREX_SUB_LONG_NO_OVERFLOW_SPEC_TMPVARCV_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_SUB_LONG_SPEC_TMPVARCV_CONST):
				VM_TRACE(CREX_SUB_LONG_SPEC_TMPVARCV_CONST)
				CREX_SUB_LONG_SPEC_TMPVARCV_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_SUB_DOUBLE_SPEC_TMPVARCV_CONST):
				VM_TRACE(CREX_SUB_DOUBLE_SPEC_TMPVARCV_CONST)
				CREX_SUB_DOUBLE_SPEC_TMPVARCV_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_MUL_LONG_NO_OVERFLOW_SPEC_TMPVARCV_CONST):
				VM_TRACE(CREX_MUL_LONG_NO_OVERFLOW_SPEC_TMPVARCV_CONST)
				CREX_MUL_LONG_NO_OVERFLOW_SPEC_TMPVARCV_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_MUL_LONG_SPEC_TMPVARCV_CONST):
				VM_TRACE(CREX_MUL_LONG_SPEC_TMPVARCV_CONST)
				CREX_MUL_LONG_SPEC_TMPVARCV_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_MUL_DOUBLE_SPEC_TMPVARCV_CONST):
				VM_TRACE(CREX_MUL_DOUBLE_SPEC_TMPVARCV_CONST)
				CREX_MUL_DOUBLE_SPEC_TMPVARCV_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_IS_EQUAL_LONG_SPEC_TMPVARCV_CONST):
				VM_TRACE(CREX_IS_EQUAL_LONG_SPEC_TMPVARCV_CONST)
				CREX_IS_EQUAL_LONG_SPEC_TMPVARCV_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_IS_EQUAL_LONG_SPEC_TMPVARCV_CONST_JMPZ):
				VM_TRACE(CREX_IS_EQUAL_LONG_SPEC_TMPVARCV_CONST_JMPZ)
				CREX_IS_EQUAL_LONG_SPEC_TMPVARCV_CONST_JMPC_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_IS_EQUAL_LONG_SPEC_TMPVARCV_CONST_JMPNZ):
				VM_TRACE(CREX_IS_EQUAL_LONG_SPEC_TMPVARCV_CONST_JMPNZ)
				CREX_IS_EQUAL_LONG_SPEC_TMPVARCV_CONST_JMPNC_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_IS_EQUAL_DOUBLE_SPEC_TMPVARCV_CONST):
				VM_TRACE(CREX_IS_EQUAL_DOUBLE_SPEC_TMPVARCV_CONST)
				CREX_IS_EQUAL_DOUBLE_SPEC_TMPVARCV_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_IS_EQUAL_DOUBLE_SPEC_TMPVARCV_CONST_JMPZ):
				VM_TRACE(CREX_IS_EQUAL_DOUBLE_SPEC_TMPVARCV_CONST_JMPZ)
				CREX_IS_EQUAL_DOUBLE_SPEC_TMPVARCV_CONST_JMPC_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_IS_EQUAL_DOUBLE_SPEC_TMPVARCV_CONST_JMPNZ):
				VM_TRACE(CREX_IS_EQUAL_DOUBLE_SPEC_TMPVARCV_CONST_JMPNZ)
				CREX_IS_EQUAL_DOUBLE_SPEC_TMPVARCV_CONST_JMPNC_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_IS_NOT_EQUAL_LONG_SPEC_TMPVARCV_CONST):
				VM_TRACE(CREX_IS_NOT_EQUAL_LONG_SPEC_TMPVARCV_CONST)
				CREX_IS_NOT_EQUAL_LONG_SPEC_TMPVARCV_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_IS_NOT_EQUAL_LONG_SPEC_TMPVARCV_CONST_JMPZ):
				VM_TRACE(CREX_IS_NOT_EQUAL_LONG_SPEC_TMPVARCV_CONST_JMPZ)
				CREX_IS_NOT_EQUAL_LONG_SPEC_TMPVARCV_CONST_JMPC_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_IS_NOT_EQUAL_LONG_SPEC_TMPVARCV_CONST_JMPNZ):
				VM_TRACE(CREX_IS_NOT_EQUAL_LONG_SPEC_TMPVARCV_CONST_JMPNZ)
				CREX_IS_NOT_EQUAL_LONG_SPEC_TMPVARCV_CONST_JMPNC_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_IS_NOT_EQUAL_DOUBLE_SPEC_TMPVARCV_CONST):
				VM_TRACE(CREX_IS_NOT_EQUAL_DOUBLE_SPEC_TMPVARCV_CONST)
				CREX_IS_NOT_EQUAL_DOUBLE_SPEC_TMPVARCV_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_IS_NOT_EQUAL_DOUBLE_SPEC_TMPVARCV_CONST_JMPZ):
				VM_TRACE(CREX_IS_NOT_EQUAL_DOUBLE_SPEC_TMPVARCV_CONST_JMPZ)
				CREX_IS_NOT_EQUAL_DOUBLE_SPEC_TMPVARCV_CONST_JMPC_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_IS_NOT_EQUAL_DOUBLE_SPEC_TMPVARCV_CONST_JMPNZ):
				VM_TRACE(CREX_IS_NOT_EQUAL_DOUBLE_SPEC_TMPVARCV_CONST_JMPNZ)
				CREX_IS_NOT_EQUAL_DOUBLE_SPEC_TMPVARCV_CONST_JMPNC_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_IS_SMALLER_LONG_SPEC_TMPVARCV_CONST):
				VM_TRACE(CREX_IS_SMALLER_LONG_SPEC_TMPVARCV_CONST)
				CREX_IS_SMALLER_LONG_SPEC_TMPVARCV_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_IS_SMALLER_LONG_SPEC_TMPVARCV_CONST_JMPZ):
				VM_TRACE(CREX_IS_SMALLER_LONG_SPEC_TMPVARCV_CONST_JMPZ)
				CREX_IS_SMALLER_LONG_SPEC_TMPVARCV_CONST_JMPC_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_IS_SMALLER_LONG_SPEC_TMPVARCV_CONST_JMPNZ):
				VM_TRACE(CREX_IS_SMALLER_LONG_SPEC_TMPVARCV_CONST_JMPNZ)
				CREX_IS_SMALLER_LONG_SPEC_TMPVARCV_CONST_JMPNC_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_IS_SMALLER_DOUBLE_SPEC_TMPVARCV_CONST):
				VM_TRACE(CREX_IS_SMALLER_DOUBLE_SPEC_TMPVARCV_CONST)
				CREX_IS_SMALLER_DOUBLE_SPEC_TMPVARCV_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_IS_SMALLER_DOUBLE_SPEC_TMPVARCV_CONST_JMPZ):
				VM_TRACE(CREX_IS_SMALLER_DOUBLE_SPEC_TMPVARCV_CONST_JMPZ)
				CREX_IS_SMALLER_DOUBLE_SPEC_TMPVARCV_CONST_JMPC_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_IS_SMALLER_DOUBLE_SPEC_TMPVARCV_CONST_JMPNZ):
				VM_TRACE(CREX_IS_SMALLER_DOUBLE_SPEC_TMPVARCV_CONST_JMPNZ)
				CREX_IS_SMALLER_DOUBLE_SPEC_TMPVARCV_CONST_JMPNC_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_IS_SMALLER_OR_EQUAL_LONG_SPEC_TMPVARCV_CONST):
				VM_TRACE(CREX_IS_SMALLER_OR_EQUAL_LONG_SPEC_TMPVARCV_CONST)
				CREX_IS_SMALLER_OR_EQUAL_LONG_SPEC_TMPVARCV_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_IS_SMALLER_OR_EQUAL_LONG_SPEC_TMPVARCV_CONST_JMPZ):
				VM_TRACE(CREX_IS_SMALLER_OR_EQUAL_LONG_SPEC_TMPVARCV_CONST_JMPZ)
				CREX_IS_SMALLER_OR_EQUAL_LONG_SPEC_TMPVARCV_CONST_JMPC_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_IS_SMALLER_OR_EQUAL_LONG_SPEC_TMPVARCV_CONST_JMPNZ):
				VM_TRACE(CREX_IS_SMALLER_OR_EQUAL_LONG_SPEC_TMPVARCV_CONST_JMPNZ)
				CREX_IS_SMALLER_OR_EQUAL_LONG_SPEC_TMPVARCV_CONST_JMPNC_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_TMPVARCV_CONST):
				VM_TRACE(CREX_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_TMPVARCV_CONST)
				CREX_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_TMPVARCV_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_TMPVARCV_CONST_JMPZ):
				VM_TRACE(CREX_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_TMPVARCV_CONST_JMPZ)
				CREX_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_TMPVARCV_CONST_JMPC_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_TMPVARCV_CONST_JMPNZ):
				VM_TRACE(CREX_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_TMPVARCV_CONST_JMPNZ)
				CREX_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_TMPVARCV_CONST_JMPNC_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ADD_SPEC_TMPVARCV_TMPVARCV):
				VM_TRACE(CREX_ADD_SPEC_TMPVARCV_TMPVARCV)
				CREX_ADD_SPEC_TMPVARCV_TMPVARCV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_SUB_SPEC_TMPVARCV_TMPVARCV):
				VM_TRACE(CREX_SUB_SPEC_TMPVARCV_TMPVARCV)
				CREX_SUB_SPEC_TMPVARCV_TMPVARCV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_MUL_SPEC_TMPVARCV_TMPVARCV):
				VM_TRACE(CREX_MUL_SPEC_TMPVARCV_TMPVARCV)
				CREX_MUL_SPEC_TMPVARCV_TMPVARCV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_MOD_SPEC_TMPVARCV_TMPVARCV):
				VM_TRACE(CREX_MOD_SPEC_TMPVARCV_TMPVARCV)
				CREX_MOD_SPEC_TMPVARCV_TMPVARCV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_SL_SPEC_TMPVARCV_TMPVARCV):
				VM_TRACE(CREX_SL_SPEC_TMPVARCV_TMPVARCV)
				CREX_SL_SPEC_TMPVARCV_TMPVARCV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_SR_SPEC_TMPVARCV_TMPVARCV):
				VM_TRACE(CREX_SR_SPEC_TMPVARCV_TMPVARCV)
				CREX_SR_SPEC_TMPVARCV_TMPVARCV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_IS_SMALLER_SPEC_TMPVARCV_TMPVARCV):
				VM_TRACE(CREX_IS_SMALLER_SPEC_TMPVARCV_TMPVARCV)
				CREX_IS_SMALLER_SPEC_TMPVARCV_TMPVARCV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_IS_SMALLER_SPEC_TMPVARCV_TMPVARCV_JMPZ):
				VM_TRACE(CREX_IS_SMALLER_SPEC_TMPVARCV_TMPVARCV_JMPZ)
				CREX_IS_SMALLER_SPEC_TMPVARCV_TMPVARCV_JMPC_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_IS_SMALLER_SPEC_TMPVARCV_TMPVARCV_JMPNZ):
				VM_TRACE(CREX_IS_SMALLER_SPEC_TMPVARCV_TMPVARCV_JMPNZ)
				CREX_IS_SMALLER_SPEC_TMPVARCV_TMPVARCV_JMPNC_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_IS_SMALLER_OR_EQUAL_SPEC_TMPVARCV_TMPVARCV):
				VM_TRACE(CREX_IS_SMALLER_OR_EQUAL_SPEC_TMPVARCV_TMPVARCV)
				CREX_IS_SMALLER_OR_EQUAL_SPEC_TMPVARCV_TMPVARCV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_IS_SMALLER_OR_EQUAL_SPEC_TMPVARCV_TMPVARCV_JMPZ):
				VM_TRACE(CREX_IS_SMALLER_OR_EQUAL_SPEC_TMPVARCV_TMPVARCV_JMPZ)
				CREX_IS_SMALLER_OR_EQUAL_SPEC_TMPVARCV_TMPVARCV_JMPC_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_IS_SMALLER_OR_EQUAL_SPEC_TMPVARCV_TMPVARCV_JMPNZ):
				VM_TRACE(CREX_IS_SMALLER_OR_EQUAL_SPEC_TMPVARCV_TMPVARCV_JMPNZ)
				CREX_IS_SMALLER_OR_EQUAL_SPEC_TMPVARCV_TMPVARCV_JMPNC_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_BW_OR_SPEC_TMPVARCV_TMPVARCV):
				VM_TRACE(CREX_BW_OR_SPEC_TMPVARCV_TMPVARCV)
				CREX_BW_OR_SPEC_TMPVARCV_TMPVARCV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_BW_AND_SPEC_TMPVARCV_TMPVARCV):
				VM_TRACE(CREX_BW_AND_SPEC_TMPVARCV_TMPVARCV)
				CREX_BW_AND_SPEC_TMPVARCV_TMPVARCV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_BW_XOR_SPEC_TMPVARCV_TMPVARCV):
				VM_TRACE(CREX_BW_XOR_SPEC_TMPVARCV_TMPVARCV)
				CREX_BW_XOR_SPEC_TMPVARCV_TMPVARCV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ADD_LONG_NO_OVERFLOW_SPEC_TMPVARCV_TMPVARCV):
				VM_TRACE(CREX_ADD_LONG_NO_OVERFLOW_SPEC_TMPVARCV_TMPVARCV)
				CREX_ADD_LONG_NO_OVERFLOW_SPEC_TMPVARCV_TMPVARCV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ADD_LONG_SPEC_TMPVARCV_TMPVARCV):
				VM_TRACE(CREX_ADD_LONG_SPEC_TMPVARCV_TMPVARCV)
				CREX_ADD_LONG_SPEC_TMPVARCV_TMPVARCV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ADD_DOUBLE_SPEC_TMPVARCV_TMPVARCV):
				VM_TRACE(CREX_ADD_DOUBLE_SPEC_TMPVARCV_TMPVARCV)
				CREX_ADD_DOUBLE_SPEC_TMPVARCV_TMPVARCV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_SUB_LONG_NO_OVERFLOW_SPEC_TMPVARCV_TMPVARCV):
				VM_TRACE(CREX_SUB_LONG_NO_OVERFLOW_SPEC_TMPVARCV_TMPVARCV)
				CREX_SUB_LONG_NO_OVERFLOW_SPEC_TMPVARCV_TMPVARCV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_SUB_LONG_SPEC_TMPVARCV_TMPVARCV):
				VM_TRACE(CREX_SUB_LONG_SPEC_TMPVARCV_TMPVARCV)
				CREX_SUB_LONG_SPEC_TMPVARCV_TMPVARCV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_SUB_DOUBLE_SPEC_TMPVARCV_TMPVARCV):
				VM_TRACE(CREX_SUB_DOUBLE_SPEC_TMPVARCV_TMPVARCV)
				CREX_SUB_DOUBLE_SPEC_TMPVARCV_TMPVARCV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_MUL_LONG_NO_OVERFLOW_SPEC_TMPVARCV_TMPVARCV):
				VM_TRACE(CREX_MUL_LONG_NO_OVERFLOW_SPEC_TMPVARCV_TMPVARCV)
				CREX_MUL_LONG_NO_OVERFLOW_SPEC_TMPVARCV_TMPVARCV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_MUL_LONG_SPEC_TMPVARCV_TMPVARCV):
				VM_TRACE(CREX_MUL_LONG_SPEC_TMPVARCV_TMPVARCV)
				CREX_MUL_LONG_SPEC_TMPVARCV_TMPVARCV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_MUL_DOUBLE_SPEC_TMPVARCV_TMPVARCV):
				VM_TRACE(CREX_MUL_DOUBLE_SPEC_TMPVARCV_TMPVARCV)
				CREX_MUL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_IS_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV):
				VM_TRACE(CREX_IS_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV)
				CREX_IS_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_IS_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPZ):
				VM_TRACE(CREX_IS_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPZ)
				CREX_IS_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPC_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_IS_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPNZ):
				VM_TRACE(CREX_IS_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPNZ)
				CREX_IS_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPNC_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_IS_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV):
				VM_TRACE(CREX_IS_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV)
				CREX_IS_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_IS_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPZ):
				VM_TRACE(CREX_IS_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPZ)
				CREX_IS_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPC_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_IS_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPNZ):
				VM_TRACE(CREX_IS_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPNZ)
				CREX_IS_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPNC_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_IS_NOT_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV):
				VM_TRACE(CREX_IS_NOT_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV)
				CREX_IS_NOT_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_IS_NOT_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPZ):
				VM_TRACE(CREX_IS_NOT_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPZ)
				CREX_IS_NOT_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPC_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_IS_NOT_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPNZ):
				VM_TRACE(CREX_IS_NOT_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPNZ)
				CREX_IS_NOT_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPNC_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_IS_NOT_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV):
				VM_TRACE(CREX_IS_NOT_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV)
				CREX_IS_NOT_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_IS_NOT_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPZ):
				VM_TRACE(CREX_IS_NOT_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPZ)
				CREX_IS_NOT_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPC_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_IS_NOT_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPNZ):
				VM_TRACE(CREX_IS_NOT_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPNZ)
				CREX_IS_NOT_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPNC_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_IS_SMALLER_LONG_SPEC_TMPVARCV_TMPVARCV):
				VM_TRACE(CREX_IS_SMALLER_LONG_SPEC_TMPVARCV_TMPVARCV)
				CREX_IS_SMALLER_LONG_SPEC_TMPVARCV_TMPVARCV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_IS_SMALLER_LONG_SPEC_TMPVARCV_TMPVARCV_JMPZ):
				VM_TRACE(CREX_IS_SMALLER_LONG_SPEC_TMPVARCV_TMPVARCV_JMPZ)
				CREX_IS_SMALLER_LONG_SPEC_TMPVARCV_TMPVARCV_JMPC_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_IS_SMALLER_LONG_SPEC_TMPVARCV_TMPVARCV_JMPNZ):
				VM_TRACE(CREX_IS_SMALLER_LONG_SPEC_TMPVARCV_TMPVARCV_JMPNZ)
				CREX_IS_SMALLER_LONG_SPEC_TMPVARCV_TMPVARCV_JMPNC_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_IS_SMALLER_DOUBLE_SPEC_TMPVARCV_TMPVARCV):
				VM_TRACE(CREX_IS_SMALLER_DOUBLE_SPEC_TMPVARCV_TMPVARCV)
				CREX_IS_SMALLER_DOUBLE_SPEC_TMPVARCV_TMPVARCV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_IS_SMALLER_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPZ):
				VM_TRACE(CREX_IS_SMALLER_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPZ)
				CREX_IS_SMALLER_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPC_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_IS_SMALLER_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPNZ):
				VM_TRACE(CREX_IS_SMALLER_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPNZ)
				CREX_IS_SMALLER_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPNC_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_IS_SMALLER_OR_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV):
				VM_TRACE(CREX_IS_SMALLER_OR_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV)
				CREX_IS_SMALLER_OR_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_IS_SMALLER_OR_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPZ):
				VM_TRACE(CREX_IS_SMALLER_OR_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPZ)
				CREX_IS_SMALLER_OR_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPC_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_IS_SMALLER_OR_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPNZ):
				VM_TRACE(CREX_IS_SMALLER_OR_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPNZ)
				CREX_IS_SMALLER_OR_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPNC_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV):
				VM_TRACE(CREX_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV)
				CREX_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPZ):
				VM_TRACE(CREX_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPZ)
				CREX_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPC_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPNZ):
				VM_TRACE(CREX_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPNZ)
				CREX_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPNC_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FETCH_LIST_R_SPEC_TMPVARCV_TMPVAR):
				VM_TRACE(CREX_FETCH_LIST_R_SPEC_TMPVARCV_TMPVAR)
				CREX_FETCH_LIST_R_SPEC_TMPVARCV_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_MATCH_ERROR_SPEC_TMPVARCV_UNUSED):
				VM_TRACE(CREX_MATCH_ERROR_SPEC_TMPVARCV_UNUSED)
				CREX_MATCH_ERROR_SPEC_TMPVARCV_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FETCH_LIST_R_SPEC_TMPVARCV_CV):
				VM_TRACE(CREX_FETCH_LIST_R_SPEC_TMPVARCV_CV)
				CREX_FETCH_LIST_R_SPEC_TMPVARCV_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_BOOL_NOT_SPEC_TMPVAR):
				VM_TRACE(CREX_BOOL_NOT_SPEC_TMPVAR)
				CREX_BOOL_NOT_SPEC_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ECHO_SPEC_TMPVAR):
				VM_TRACE(CREX_ECHO_SPEC_TMPVAR)
				CREX_ECHO_SPEC_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_JMPC_SPEC_TMPVAR):
				VM_TRACE(CREX_JMPC_SPEC_TMPVAR)
				CREX_JMPC_SPEC_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_JMPNC_SPEC_TMPVAR):
				VM_TRACE(CREX_JMPNC_SPEC_TMPVAR)
				CREX_JMPNC_SPEC_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_JMPC_EX_SPEC_TMPVAR):
				VM_TRACE(CREX_JMPC_EX_SPEC_TMPVAR)
				CREX_JMPC_EX_SPEC_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_JMPNC_EX_SPEC_TMPVAR):
				VM_TRACE(CREX_JMPNC_EX_SPEC_TMPVAR)
				CREX_JMPNC_EX_SPEC_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FREE_SPEC_TMPVAR):
				VM_TRACE(CREX_FREE_SPEC_TMPVAR)
				CREX_FREE_SPEC_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FE_FREE_SPEC_TMPVAR):
				VM_TRACE(CREX_FE_FREE_SPEC_TMPVAR)
				CREX_FE_FREE_SPEC_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_THROW_SPEC_TMPVAR):
				VM_TRACE(CREX_THROW_SPEC_TMPVAR)
				CREX_THROW_SPEC_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_BOOL_SPEC_TMPVAR):
				VM_TRACE(CREX_BOOL_SPEC_TMPVAR)
				CREX_BOOL_SPEC_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_CLONE_SPEC_TMPVAR):
				VM_TRACE(CREX_CLONE_SPEC_TMPVAR)
				CREX_CLONE_SPEC_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_INCLUDE_OR_EVAL_SPEC_TMPVAR):
				VM_TRACE(CREX_INCLUDE_OR_EVAL_SPEC_TMPVAR)
				CREX_INCLUDE_OR_EVAL_SPEC_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_YIELD_FROM_SPEC_TMPVAR):
				VM_TRACE(CREX_YIELD_FROM_SPEC_TMPVAR)
				CREX_YIELD_FROM_SPEC_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_STRLEN_SPEC_TMPVAR):
				VM_TRACE(CREX_STRLEN_SPEC_TMPVAR)
				CREX_STRLEN_SPEC_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_TYPE_CHECK_SPEC_TMPVAR):
				VM_TRACE(CREX_TYPE_CHECK_SPEC_TMPVAR)
				CREX_TYPE_CHECK_SPEC_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FETCH_CLASS_NAME_SPEC_TMPVAR):
				VM_TRACE(CREX_FETCH_CLASS_NAME_SPEC_TMPVAR)
				CREX_FETCH_CLASS_NAME_SPEC_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_DIV_SPEC_TMPVAR_CONST):
				VM_TRACE(CREX_DIV_SPEC_TMPVAR_CONST)
				CREX_DIV_SPEC_TMPVAR_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_POW_SPEC_TMPVAR_CONST):
				VM_TRACE(CREX_POW_SPEC_TMPVAR_CONST)
				CREX_POW_SPEC_TMPVAR_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_CONCAT_SPEC_TMPVAR_CONST):
				VM_TRACE(CREX_CONCAT_SPEC_TMPVAR_CONST)
				CREX_CONCAT_SPEC_TMPVAR_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_IS_EQUAL_SPEC_TMPVAR_CONST):
				VM_TRACE(CREX_IS_EQUAL_SPEC_TMPVAR_CONST)
				CREX_IS_EQUAL_SPEC_TMPVAR_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_IS_EQUAL_SPEC_TMPVAR_CONST_JMPZ):
				VM_TRACE(CREX_IS_EQUAL_SPEC_TMPVAR_CONST_JMPZ)
				CREX_IS_EQUAL_SPEC_TMPVAR_CONST_JMPC_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_IS_EQUAL_SPEC_TMPVAR_CONST_JMPNZ):
				VM_TRACE(CREX_IS_EQUAL_SPEC_TMPVAR_CONST_JMPNZ)
				CREX_IS_EQUAL_SPEC_TMPVAR_CONST_JMPNC_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_IS_NOT_EQUAL_SPEC_TMPVAR_CONST):
				VM_TRACE(CREX_IS_NOT_EQUAL_SPEC_TMPVAR_CONST)
				CREX_IS_NOT_EQUAL_SPEC_TMPVAR_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_IS_NOT_EQUAL_SPEC_TMPVAR_CONST_JMPZ):
				VM_TRACE(CREX_IS_NOT_EQUAL_SPEC_TMPVAR_CONST_JMPZ)
				CREX_IS_NOT_EQUAL_SPEC_TMPVAR_CONST_JMPC_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_IS_NOT_EQUAL_SPEC_TMPVAR_CONST_JMPNZ):
				VM_TRACE(CREX_IS_NOT_EQUAL_SPEC_TMPVAR_CONST_JMPNZ)
				CREX_IS_NOT_EQUAL_SPEC_TMPVAR_CONST_JMPNC_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_SPACESHIP_SPEC_TMPVAR_CONST):
				VM_TRACE(CREX_SPACESHIP_SPEC_TMPVAR_CONST)
				CREX_SPACESHIP_SPEC_TMPVAR_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_BOOL_XOR_SPEC_TMPVAR_CONST):
				VM_TRACE(CREX_BOOL_XOR_SPEC_TMPVAR_CONST)
				CREX_BOOL_XOR_SPEC_TMPVAR_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FETCH_DIM_R_SPEC_TMPVAR_CONST):
				VM_TRACE(CREX_FETCH_DIM_R_SPEC_TMPVAR_CONST)
				CREX_FETCH_DIM_R_SPEC_TMPVAR_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FETCH_DIM_IS_SPEC_TMPVAR_CONST):
				VM_TRACE(CREX_FETCH_DIM_IS_SPEC_TMPVAR_CONST)
				CREX_FETCH_DIM_IS_SPEC_TMPVAR_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FETCH_OBJ_R_SPEC_TMPVAR_CONST):
				VM_TRACE(CREX_FETCH_OBJ_R_SPEC_TMPVAR_CONST)
				CREX_FETCH_OBJ_R_SPEC_TMPVAR_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FETCH_OBJ_IS_SPEC_TMPVAR_CONST):
				VM_TRACE(CREX_FETCH_OBJ_IS_SPEC_TMPVAR_CONST)
				CREX_FETCH_OBJ_IS_SPEC_TMPVAR_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FAST_CONCAT_SPEC_TMPVAR_CONST):
				VM_TRACE(CREX_FAST_CONCAT_SPEC_TMPVAR_CONST)
				CREX_FAST_CONCAT_SPEC_TMPVAR_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_INIT_METHOD_CALL_SPEC_TMPVAR_CONST):
				VM_TRACE(CREX_INIT_METHOD_CALL_SPEC_TMPVAR_CONST)
				CREX_INIT_METHOD_CALL_SPEC_TMPVAR_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_SEND_VAL_SPEC_TMPVAR_CONST):
				VM_TRACE(CREX_SEND_VAL_SPEC_TMPVAR_CONST)
				CREX_SEND_VAL_SPEC_TMPVAR_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_CASE_SPEC_TMPVAR_CONST):
				VM_TRACE(CREX_CASE_SPEC_TMPVAR_CONST)
				CREX_CASE_SPEC_TMPVAR_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ISSET_ISEMPTY_DIM_OBJ_SPEC_TMPVAR_CONST):
				VM_TRACE(CREX_ISSET_ISEMPTY_DIM_OBJ_SPEC_TMPVAR_CONST)
				CREX_ISSET_ISEMPTY_DIM_OBJ_SPEC_TMPVAR_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ISSET_ISEMPTY_PROP_OBJ_SPEC_TMPVAR_CONST):
				VM_TRACE(CREX_ISSET_ISEMPTY_PROP_OBJ_SPEC_TMPVAR_CONST)
				CREX_ISSET_ISEMPTY_PROP_OBJ_SPEC_TMPVAR_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ARRAY_KEY_EXISTS_SPEC_TMPVAR_CONST):
				VM_TRACE(CREX_ARRAY_KEY_EXISTS_SPEC_TMPVAR_CONST)
				CREX_ARRAY_KEY_EXISTS_SPEC_TMPVAR_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_INSTANCEOF_SPEC_TMPVAR_CONST):
				VM_TRACE(CREX_INSTANCEOF_SPEC_TMPVAR_CONST)
				CREX_INSTANCEOF_SPEC_TMPVAR_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FETCH_DIM_R_INDEX_SPEC_TMPVAR_CONST):
				VM_TRACE(CREX_FETCH_DIM_R_INDEX_SPEC_TMPVAR_CONST)
				CREX_FETCH_DIM_R_INDEX_SPEC_TMPVAR_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FETCH_DIM_R_INDEX_SPEC_TMPVAR_TMPVARCV):
				VM_TRACE(CREX_FETCH_DIM_R_INDEX_SPEC_TMPVAR_TMPVARCV)
				CREX_FETCH_DIM_R_INDEX_SPEC_TMPVAR_TMPVARCV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_DIV_SPEC_TMPVAR_TMPVAR):
				VM_TRACE(CREX_DIV_SPEC_TMPVAR_TMPVAR)
				CREX_DIV_SPEC_TMPVAR_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_POW_SPEC_TMPVAR_TMPVAR):
				VM_TRACE(CREX_POW_SPEC_TMPVAR_TMPVAR)
				CREX_POW_SPEC_TMPVAR_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_CONCAT_SPEC_TMPVAR_TMPVAR):
				VM_TRACE(CREX_CONCAT_SPEC_TMPVAR_TMPVAR)
				CREX_CONCAT_SPEC_TMPVAR_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_IS_EQUAL_SPEC_TMPVAR_TMPVAR):
				VM_TRACE(CREX_IS_EQUAL_SPEC_TMPVAR_TMPVAR)
				CREX_IS_EQUAL_SPEC_TMPVAR_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_IS_EQUAL_SPEC_TMPVAR_TMPVAR_JMPZ):
				VM_TRACE(CREX_IS_EQUAL_SPEC_TMPVAR_TMPVAR_JMPZ)
				CREX_IS_EQUAL_SPEC_TMPVAR_TMPVAR_JMPC_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_IS_EQUAL_SPEC_TMPVAR_TMPVAR_JMPNZ):
				VM_TRACE(CREX_IS_EQUAL_SPEC_TMPVAR_TMPVAR_JMPNZ)
				CREX_IS_EQUAL_SPEC_TMPVAR_TMPVAR_JMPNC_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_IS_NOT_EQUAL_SPEC_TMPVAR_TMPVAR):
				VM_TRACE(CREX_IS_NOT_EQUAL_SPEC_TMPVAR_TMPVAR)
				CREX_IS_NOT_EQUAL_SPEC_TMPVAR_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_IS_NOT_EQUAL_SPEC_TMPVAR_TMPVAR_JMPZ):
				VM_TRACE(CREX_IS_NOT_EQUAL_SPEC_TMPVAR_TMPVAR_JMPZ)
				CREX_IS_NOT_EQUAL_SPEC_TMPVAR_TMPVAR_JMPC_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_IS_NOT_EQUAL_SPEC_TMPVAR_TMPVAR_JMPNZ):
				VM_TRACE(CREX_IS_NOT_EQUAL_SPEC_TMPVAR_TMPVAR_JMPNZ)
				CREX_IS_NOT_EQUAL_SPEC_TMPVAR_TMPVAR_JMPNC_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_SPACESHIP_SPEC_TMPVAR_TMPVAR):
				VM_TRACE(CREX_SPACESHIP_SPEC_TMPVAR_TMPVAR)
				CREX_SPACESHIP_SPEC_TMPVAR_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_BOOL_XOR_SPEC_TMPVAR_TMPVAR):
				VM_TRACE(CREX_BOOL_XOR_SPEC_TMPVAR_TMPVAR)
				CREX_BOOL_XOR_SPEC_TMPVAR_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FETCH_DIM_R_SPEC_TMPVAR_TMPVAR):
				VM_TRACE(CREX_FETCH_DIM_R_SPEC_TMPVAR_TMPVAR)
				CREX_FETCH_DIM_R_SPEC_TMPVAR_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FETCH_DIM_IS_SPEC_TMPVAR_TMPVAR):
				VM_TRACE(CREX_FETCH_DIM_IS_SPEC_TMPVAR_TMPVAR)
				CREX_FETCH_DIM_IS_SPEC_TMPVAR_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FETCH_OBJ_R_SPEC_TMPVAR_TMPVAR):
				VM_TRACE(CREX_FETCH_OBJ_R_SPEC_TMPVAR_TMPVAR)
				CREX_FETCH_OBJ_R_SPEC_TMPVAR_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FETCH_OBJ_IS_SPEC_TMPVAR_TMPVAR):
				VM_TRACE(CREX_FETCH_OBJ_IS_SPEC_TMPVAR_TMPVAR)
				CREX_FETCH_OBJ_IS_SPEC_TMPVAR_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FAST_CONCAT_SPEC_TMPVAR_TMPVAR):
				VM_TRACE(CREX_FAST_CONCAT_SPEC_TMPVAR_TMPVAR)
				CREX_FAST_CONCAT_SPEC_TMPVAR_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_INIT_METHOD_CALL_SPEC_TMPVAR_TMPVAR):
				VM_TRACE(CREX_INIT_METHOD_CALL_SPEC_TMPVAR_TMPVAR)
				CREX_INIT_METHOD_CALL_SPEC_TMPVAR_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_CASE_SPEC_TMPVAR_TMPVAR):
				VM_TRACE(CREX_CASE_SPEC_TMPVAR_TMPVAR)
				CREX_CASE_SPEC_TMPVAR_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ISSET_ISEMPTY_DIM_OBJ_SPEC_TMPVAR_TMPVAR):
				VM_TRACE(CREX_ISSET_ISEMPTY_DIM_OBJ_SPEC_TMPVAR_TMPVAR)
				CREX_ISSET_ISEMPTY_DIM_OBJ_SPEC_TMPVAR_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ISSET_ISEMPTY_PROP_OBJ_SPEC_TMPVAR_TMPVAR):
				VM_TRACE(CREX_ISSET_ISEMPTY_PROP_OBJ_SPEC_TMPVAR_TMPVAR)
				CREX_ISSET_ISEMPTY_PROP_OBJ_SPEC_TMPVAR_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ARRAY_KEY_EXISTS_SPEC_TMPVAR_TMPVAR):
				VM_TRACE(CREX_ARRAY_KEY_EXISTS_SPEC_TMPVAR_TMPVAR)
				CREX_ARRAY_KEY_EXISTS_SPEC_TMPVAR_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_INSTANCEOF_SPEC_TMPVAR_VAR):
				VM_TRACE(CREX_INSTANCEOF_SPEC_TMPVAR_VAR)
				CREX_INSTANCEOF_SPEC_TMPVAR_VAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FETCH_R_SPEC_TMPVAR_UNUSED):
				VM_TRACE(CREX_FETCH_R_SPEC_TMPVAR_UNUSED)
				CREX_FETCH_R_SPEC_TMPVAR_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FETCH_W_SPEC_TMPVAR_UNUSED):
				VM_TRACE(CREX_FETCH_W_SPEC_TMPVAR_UNUSED)
				CREX_FETCH_W_SPEC_TMPVAR_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FETCH_RW_SPEC_TMPVAR_UNUSED):
				VM_TRACE(CREX_FETCH_RW_SPEC_TMPVAR_UNUSED)
				CREX_FETCH_RW_SPEC_TMPVAR_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FETCH_FUNC_ARG_SPEC_TMPVAR_UNUSED):
				VM_TRACE(CREX_FETCH_FUNC_ARG_SPEC_TMPVAR_UNUSED)
				CREX_FETCH_FUNC_ARG_SPEC_TMPVAR_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FETCH_UNSET_SPEC_TMPVAR_UNUSED):
				VM_TRACE(CREX_FETCH_UNSET_SPEC_TMPVAR_UNUSED)
				CREX_FETCH_UNSET_SPEC_TMPVAR_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FETCH_IS_SPEC_TMPVAR_UNUSED):
				VM_TRACE(CREX_FETCH_IS_SPEC_TMPVAR_UNUSED)
				CREX_FETCH_IS_SPEC_TMPVAR_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_SEND_VAL_SPEC_TMPVAR_UNUSED):
				VM_TRACE(CREX_SEND_VAL_SPEC_TMPVAR_UNUSED)
				CREX_SEND_VAL_SPEC_TMPVAR_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_UNSET_VAR_SPEC_TMPVAR_UNUSED):
				VM_TRACE(CREX_UNSET_VAR_SPEC_TMPVAR_UNUSED)
				CREX_UNSET_VAR_SPEC_TMPVAR_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ISSET_ISEMPTY_VAR_SPEC_TMPVAR_UNUSED):
				VM_TRACE(CREX_ISSET_ISEMPTY_VAR_SPEC_TMPVAR_UNUSED)
				CREX_ISSET_ISEMPTY_VAR_SPEC_TMPVAR_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_INSTANCEOF_SPEC_TMPVAR_UNUSED):
				VM_TRACE(CREX_INSTANCEOF_SPEC_TMPVAR_UNUSED)
				CREX_INSTANCEOF_SPEC_TMPVAR_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_COUNT_SPEC_TMPVAR_UNUSED):
				VM_TRACE(CREX_COUNT_SPEC_TMPVAR_UNUSED)
				CREX_COUNT_SPEC_TMPVAR_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_COUNT_ARRAY_SPEC_TMPVAR_UNUSED):
				VM_TRACE(CREX_COUNT_ARRAY_SPEC_TMPVAR_UNUSED)
				CREX_COUNT_ARRAY_SPEC_TMPVAR_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_GET_CLASS_SPEC_TMPVAR_UNUSED):
				VM_TRACE(CREX_GET_CLASS_SPEC_TMPVAR_UNUSED)
				CREX_GET_CLASS_SPEC_TMPVAR_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_COPY_TMP_SPEC_TMPVAR_UNUSED):
				VM_TRACE(CREX_COPY_TMP_SPEC_TMPVAR_UNUSED)
				CREX_COPY_TMP_SPEC_TMPVAR_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_DIV_SPEC_TMPVAR_CV):
				VM_TRACE(CREX_DIV_SPEC_TMPVAR_CV)
				CREX_DIV_SPEC_TMPVAR_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_POW_SPEC_TMPVAR_CV):
				VM_TRACE(CREX_POW_SPEC_TMPVAR_CV)
				CREX_POW_SPEC_TMPVAR_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_CONCAT_SPEC_TMPVAR_CV):
				VM_TRACE(CREX_CONCAT_SPEC_TMPVAR_CV)
				CREX_CONCAT_SPEC_TMPVAR_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_SPACESHIP_SPEC_TMPVAR_CV):
				VM_TRACE(CREX_SPACESHIP_SPEC_TMPVAR_CV)
				CREX_SPACESHIP_SPEC_TMPVAR_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FETCH_DIM_R_SPEC_TMPVAR_CV):
				VM_TRACE(CREX_FETCH_DIM_R_SPEC_TMPVAR_CV)
				CREX_FETCH_DIM_R_SPEC_TMPVAR_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FETCH_DIM_IS_SPEC_TMPVAR_CV):
				VM_TRACE(CREX_FETCH_DIM_IS_SPEC_TMPVAR_CV)
				CREX_FETCH_DIM_IS_SPEC_TMPVAR_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FETCH_OBJ_R_SPEC_TMPVAR_CV):
				VM_TRACE(CREX_FETCH_OBJ_R_SPEC_TMPVAR_CV)
				CREX_FETCH_OBJ_R_SPEC_TMPVAR_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FETCH_OBJ_IS_SPEC_TMPVAR_CV):
				VM_TRACE(CREX_FETCH_OBJ_IS_SPEC_TMPVAR_CV)
				CREX_FETCH_OBJ_IS_SPEC_TMPVAR_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FAST_CONCAT_SPEC_TMPVAR_CV):
				VM_TRACE(CREX_FAST_CONCAT_SPEC_TMPVAR_CV)
				CREX_FAST_CONCAT_SPEC_TMPVAR_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_INIT_METHOD_CALL_SPEC_TMPVAR_CV):
				VM_TRACE(CREX_INIT_METHOD_CALL_SPEC_TMPVAR_CV)
				CREX_INIT_METHOD_CALL_SPEC_TMPVAR_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_CASE_SPEC_TMPVAR_CV):
				VM_TRACE(CREX_CASE_SPEC_TMPVAR_CV)
				CREX_CASE_SPEC_TMPVAR_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ISSET_ISEMPTY_DIM_OBJ_SPEC_TMPVAR_CV):
				VM_TRACE(CREX_ISSET_ISEMPTY_DIM_OBJ_SPEC_TMPVAR_CV)
				CREX_ISSET_ISEMPTY_DIM_OBJ_SPEC_TMPVAR_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ISSET_ISEMPTY_PROP_OBJ_SPEC_TMPVAR_CV):
				VM_TRACE(CREX_ISSET_ISEMPTY_PROP_OBJ_SPEC_TMPVAR_CV)
				CREX_ISSET_ISEMPTY_PROP_OBJ_SPEC_TMPVAR_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ARRAY_KEY_EXISTS_SPEC_TMPVAR_CV):
				VM_TRACE(CREX_ARRAY_KEY_EXISTS_SPEC_TMPVAR_CV)
				CREX_ARRAY_KEY_EXISTS_SPEC_TMPVAR_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_RETURN_SPEC_TMP):
				VM_TRACE(CREX_RETURN_SPEC_TMP)
{
	USE_OPLINE
	zval *retval_ptr;
	zval *return_value;

	retval_ptr = _get_zval_ptr_tmp(opline->op1.var EXECUTE_DATA_CC);
	return_value = EX(return_value);

	if (IS_TMP_VAR == IS_CV && UNEXPECTED(C_TYPE_INFO_P(retval_ptr) == IS_UNDEF)) {
		SAVE_OPLINE();
		retval_ptr = ZVAL_UNDEFINED_OP1();
		if (return_value) {
			ZVAL_NULL(return_value);
		}
	} else if (!return_value) {
		if (IS_TMP_VAR & (IS_VAR|IS_TMP_VAR)) {
			if (C_REFCOUNTED_P(retval_ptr) && !C_DELREF_P(retval_ptr)) {
				SAVE_OPLINE();
				rc_dtor_func(C_COUNTED_P(retval_ptr));
			}
		}
	} else {
		if ((IS_TMP_VAR & (IS_CONST|IS_TMP_VAR))) {
			ZVAL_COPY_VALUE(return_value, retval_ptr);
			if (IS_TMP_VAR == IS_CONST) {
				if (UNEXPECTED(C_OPT_REFCOUNTED_P(return_value))) {
					C_ADDREF_P(return_value);
				}
			}
		} else if (IS_TMP_VAR == IS_CV) {
			do {
				if (C_OPT_REFCOUNTED_P(retval_ptr)) {
					if (EXPECTED(!C_OPT_ISREF_P(retval_ptr))) {
						if (EXPECTED(!(EX_CALL_INFO() & (CREX_CALL_CODE|CREX_CALL_OBSERVED)))) {
							crex_refcounted *ref = C_COUNTED_P(retval_ptr);
							ZVAL_COPY_VALUE(return_value, retval_ptr);
							if (GC_MAY_LEAK(ref)) {
								SAVE_OPLINE();
								gc_possible_root(ref);
							}
							ZVAL_NULL(retval_ptr);
							break;
						} else {
							C_ADDREF_P(retval_ptr);
						}
					} else {
						retval_ptr = C_REFVAL_P(retval_ptr);
						if (C_OPT_REFCOUNTED_P(retval_ptr)) {
							C_ADDREF_P(retval_ptr);
						}
					}
				}
				ZVAL_COPY_VALUE(return_value, retval_ptr);
			} while (0);
		} else /* if (IS_TMP_VAR == IS_VAR) */ {
			if (UNEXPECTED(C_ISREF_P(retval_ptr))) {
				crex_refcounted *ref = C_COUNTED_P(retval_ptr);

				retval_ptr = C_REFVAL_P(retval_ptr);
				ZVAL_COPY_VALUE(return_value, retval_ptr);
				if (UNEXPECTED(GC_DELREF(ref) == 0)) {
					efree_size(ref, sizeof(crex_reference));
				} else if (C_OPT_REFCOUNTED_P(retval_ptr)) {
					C_ADDREF_P(retval_ptr);
				}
			} else {
				ZVAL_COPY_VALUE(return_value, retval_ptr);
			}
		}
	}



	goto crex_leave_helper_SPEC_LABEL;
}

			HYBRID_CASE(CREX_RETURN_BY_REF_SPEC_TMP):
				VM_TRACE(CREX_RETURN_BY_REF_SPEC_TMP)
				CREX_RETURN_BY_REF_SPEC_TMP_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_GENERATOR_RETURN_SPEC_TMP):
				VM_TRACE(CREX_GENERATOR_RETURN_SPEC_TMP)
				CREX_GENERATOR_RETURN_SPEC_TMP_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_SEND_USER_SPEC_TMP):
				VM_TRACE(CREX_SEND_USER_SPEC_TMP)
				CREX_SEND_USER_SPEC_TMP_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_CAST_SPEC_TMP):
				VM_TRACE(CREX_CAST_SPEC_TMP)
				CREX_CAST_SPEC_TMP_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FE_RESET_R_SPEC_TMP):
				VM_TRACE(CREX_FE_RESET_R_SPEC_TMP)
				CREX_FE_RESET_R_SPEC_TMP_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FE_RESET_RW_SPEC_TMP):
				VM_TRACE(CREX_FE_RESET_RW_SPEC_TMP)
				CREX_FE_RESET_RW_SPEC_TMP_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_END_SILENCE_SPEC_TMP):
				VM_TRACE(CREX_END_SILENCE_SPEC_TMP)
				CREX_END_SILENCE_SPEC_TMP_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_JMP_SET_SPEC_TMP):
				VM_TRACE(CREX_JMP_SET_SPEC_TMP)
				CREX_JMP_SET_SPEC_TMP_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_COALESCE_SPEC_TMP):
				VM_TRACE(CREX_COALESCE_SPEC_TMP)
				CREX_COALESCE_SPEC_TMP_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_JMP_NULL_SPEC_TMP):
				VM_TRACE(CREX_JMP_NULL_SPEC_TMP)
				CREX_JMP_NULL_SPEC_TMP_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_QM_ASSIGN_SPEC_TMP):
				VM_TRACE(CREX_QM_ASSIGN_SPEC_TMP)
				CREX_QM_ASSIGN_SPEC_TMP_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_IS_IDENTICAL_SPEC_TMP_CONST):
				VM_TRACE(CREX_IS_IDENTICAL_SPEC_TMP_CONST)
				CREX_IS_IDENTICAL_SPEC_TMP_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_CASE_STRICT_SPEC_TMP_CONST):
				VM_TRACE(CREX_CASE_STRICT_SPEC_TMP_CONST)
				CREX_CASE_STRICT_SPEC_TMP_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_IS_NOT_IDENTICAL_SPEC_TMP_CONST):
				VM_TRACE(CREX_IS_NOT_IDENTICAL_SPEC_TMP_CONST)
				CREX_IS_NOT_IDENTICAL_SPEC_TMP_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FETCH_DIM_FUNC_ARG_SPEC_TMP_CONST):
				VM_TRACE(CREX_FETCH_DIM_FUNC_ARG_SPEC_TMP_CONST)
				CREX_FETCH_DIM_FUNC_ARG_SPEC_TMP_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FETCH_OBJ_FUNC_ARG_SPEC_TMP_CONST):
				VM_TRACE(CREX_FETCH_OBJ_FUNC_ARG_SPEC_TMP_CONST)
				CREX_FETCH_OBJ_FUNC_ARG_SPEC_TMP_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ROPE_ADD_SPEC_TMP_CONST):
				VM_TRACE(CREX_ROPE_ADD_SPEC_TMP_CONST)
				CREX_ROPE_ADD_SPEC_TMP_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ROPE_END_SPEC_TMP_CONST):
				VM_TRACE(CREX_ROPE_END_SPEC_TMP_CONST)
				CREX_ROPE_END_SPEC_TMP_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_SEND_VAL_EX_SPEC_TMP_CONST):
				VM_TRACE(CREX_SEND_VAL_EX_SPEC_TMP_CONST)
				CREX_SEND_VAL_EX_SPEC_TMP_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ADD_ARRAY_ELEMENT_SPEC_TMP_CONST):
				VM_TRACE(CREX_ADD_ARRAY_ELEMENT_SPEC_TMP_CONST)
				CREX_ADD_ARRAY_ELEMENT_SPEC_TMP_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_INIT_ARRAY_SPEC_TMP_CONST):
				VM_TRACE(CREX_INIT_ARRAY_SPEC_TMP_CONST)
				CREX_INIT_ARRAY_SPEC_TMP_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_YIELD_SPEC_TMP_CONST):
				VM_TRACE(CREX_YIELD_SPEC_TMP_CONST)
				CREX_YIELD_SPEC_TMP_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_IN_ARRAY_SPEC_TMP_CONST):
				VM_TRACE(CREX_IN_ARRAY_SPEC_TMP_CONST)
				CREX_IN_ARRAY_SPEC_TMP_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FETCH_DIM_FUNC_ARG_SPEC_TMP_TMPVAR):
				VM_TRACE(CREX_FETCH_DIM_FUNC_ARG_SPEC_TMP_TMPVAR)
				CREX_FETCH_DIM_FUNC_ARG_SPEC_TMP_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FETCH_OBJ_FUNC_ARG_SPEC_TMP_TMPVAR):
				VM_TRACE(CREX_FETCH_OBJ_FUNC_ARG_SPEC_TMP_TMPVAR)
				CREX_FETCH_OBJ_FUNC_ARG_SPEC_TMP_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ROPE_ADD_SPEC_TMP_TMPVAR):
				VM_TRACE(CREX_ROPE_ADD_SPEC_TMP_TMPVAR)
				CREX_ROPE_ADD_SPEC_TMP_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ROPE_END_SPEC_TMP_TMPVAR):
				VM_TRACE(CREX_ROPE_END_SPEC_TMP_TMPVAR)
				CREX_ROPE_END_SPEC_TMP_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ADD_ARRAY_ELEMENT_SPEC_TMP_TMPVAR):
				VM_TRACE(CREX_ADD_ARRAY_ELEMENT_SPEC_TMP_TMPVAR)
				CREX_ADD_ARRAY_ELEMENT_SPEC_TMP_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_INIT_ARRAY_SPEC_TMP_TMPVAR):
				VM_TRACE(CREX_INIT_ARRAY_SPEC_TMP_TMPVAR)
				CREX_INIT_ARRAY_SPEC_TMP_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_YIELD_SPEC_TMP_TMPVAR):
				VM_TRACE(CREX_YIELD_SPEC_TMP_TMPVAR)
				CREX_YIELD_SPEC_TMP_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_IS_IDENTICAL_SPEC_TMP_TMP):
				VM_TRACE(CREX_IS_IDENTICAL_SPEC_TMP_TMP)
				CREX_IS_IDENTICAL_SPEC_TMP_TMP_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_CASE_STRICT_SPEC_TMP_TMP):
				VM_TRACE(CREX_CASE_STRICT_SPEC_TMP_TMP)
				CREX_CASE_STRICT_SPEC_TMP_TMP_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_IS_NOT_IDENTICAL_SPEC_TMP_TMP):
				VM_TRACE(CREX_IS_NOT_IDENTICAL_SPEC_TMP_TMP)
				CREX_IS_NOT_IDENTICAL_SPEC_TMP_TMP_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_CASE_STRICT_SPEC_TMP_VAR):
				VM_TRACE(CREX_CASE_STRICT_SPEC_TMP_VAR)
				CREX_CASE_STRICT_SPEC_TMP_VAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FETCH_DIM_FUNC_ARG_SPEC_TMP_UNUSED):
				VM_TRACE(CREX_FETCH_DIM_FUNC_ARG_SPEC_TMP_UNUSED)
				CREX_FETCH_DIM_FUNC_ARG_SPEC_TMP_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_VERIFY_RETURN_TYPE_SPEC_TMP_UNUSED):
				VM_TRACE(CREX_VERIFY_RETURN_TYPE_SPEC_TMP_UNUSED)
				CREX_VERIFY_RETURN_TYPE_SPEC_TMP_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_SEND_VAL_EX_SPEC_TMP_UNUSED):
				VM_TRACE(CREX_SEND_VAL_EX_SPEC_TMP_UNUSED)
				CREX_SEND_VAL_EX_SPEC_TMP_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_SEND_VAL_EX_SPEC_TMP_UNUSED_QUICK):
				VM_TRACE(CREX_SEND_VAL_EX_SPEC_TMP_UNUSED_QUICK)
				CREX_SEND_VAL_EX_SPEC_TMP_UNUSED_QUICK_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ADD_ARRAY_ELEMENT_SPEC_TMP_UNUSED):
				VM_TRACE(CREX_ADD_ARRAY_ELEMENT_SPEC_TMP_UNUSED)
				CREX_ADD_ARRAY_ELEMENT_SPEC_TMP_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_INIT_ARRAY_SPEC_TMP_UNUSED):
				VM_TRACE(CREX_INIT_ARRAY_SPEC_TMP_UNUSED)
				CREX_INIT_ARRAY_SPEC_TMP_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_YIELD_SPEC_TMP_UNUSED):
				VM_TRACE(CREX_YIELD_SPEC_TMP_UNUSED)
				CREX_YIELD_SPEC_TMP_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_GET_TYPE_SPEC_TMP_UNUSED):
				VM_TRACE(CREX_GET_TYPE_SPEC_TMP_UNUSED)
				CREX_GET_TYPE_SPEC_TMP_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_CASE_STRICT_SPEC_TMP_CV):
				VM_TRACE(CREX_CASE_STRICT_SPEC_TMP_CV)
				CREX_CASE_STRICT_SPEC_TMP_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FETCH_DIM_FUNC_ARG_SPEC_TMP_CV):
				VM_TRACE(CREX_FETCH_DIM_FUNC_ARG_SPEC_TMP_CV)
				CREX_FETCH_DIM_FUNC_ARG_SPEC_TMP_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FETCH_OBJ_FUNC_ARG_SPEC_TMP_CV):
				VM_TRACE(CREX_FETCH_OBJ_FUNC_ARG_SPEC_TMP_CV)
				CREX_FETCH_OBJ_FUNC_ARG_SPEC_TMP_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ROPE_ADD_SPEC_TMP_CV):
				VM_TRACE(CREX_ROPE_ADD_SPEC_TMP_CV)
				CREX_ROPE_ADD_SPEC_TMP_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ROPE_END_SPEC_TMP_CV):
				VM_TRACE(CREX_ROPE_END_SPEC_TMP_CV)
				CREX_ROPE_END_SPEC_TMP_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ADD_ARRAY_ELEMENT_SPEC_TMP_CV):
				VM_TRACE(CREX_ADD_ARRAY_ELEMENT_SPEC_TMP_CV)
				CREX_ADD_ARRAY_ELEMENT_SPEC_TMP_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_INIT_ARRAY_SPEC_TMP_CV):
				VM_TRACE(CREX_INIT_ARRAY_SPEC_TMP_CV)
				CREX_INIT_ARRAY_SPEC_TMP_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_YIELD_SPEC_TMP_CV):
				VM_TRACE(CREX_YIELD_SPEC_TMP_CV)
				CREX_YIELD_SPEC_TMP_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_BIND_LEXICAL_SPEC_TMP_CV):
				VM_TRACE(CREX_BIND_LEXICAL_SPEC_TMP_CV)
				CREX_BIND_LEXICAL_SPEC_TMP_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_PRE_INC_SPEC_VAR_RETVAL_UNUSED):
				VM_TRACE(CREX_PRE_INC_SPEC_VAR_RETVAL_UNUSED)
				CREX_PRE_INC_SPEC_VAR_RETVAL_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_PRE_INC_SPEC_VAR_RETVAL_USED):
				VM_TRACE(CREX_PRE_INC_SPEC_VAR_RETVAL_USED)
				CREX_PRE_INC_SPEC_VAR_RETVAL_USED_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_PRE_DEC_SPEC_VAR_RETVAL_UNUSED):
				VM_TRACE(CREX_PRE_DEC_SPEC_VAR_RETVAL_UNUSED)
				CREX_PRE_DEC_SPEC_VAR_RETVAL_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_PRE_DEC_SPEC_VAR_RETVAL_USED):
				VM_TRACE(CREX_PRE_DEC_SPEC_VAR_RETVAL_USED)
				CREX_PRE_DEC_SPEC_VAR_RETVAL_USED_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_POST_INC_SPEC_VAR):
				VM_TRACE(CREX_POST_INC_SPEC_VAR)
				CREX_POST_INC_SPEC_VAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_POST_DEC_SPEC_VAR):
				VM_TRACE(CREX_POST_DEC_SPEC_VAR)
				CREX_POST_DEC_SPEC_VAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_RETURN_SPEC_VAR):
				VM_TRACE(CREX_RETURN_SPEC_VAR)
{
	USE_OPLINE
	zval *retval_ptr;
	zval *return_value;

	retval_ptr = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);
	return_value = EX(return_value);

	if (IS_VAR == IS_CV && UNEXPECTED(C_TYPE_INFO_P(retval_ptr) == IS_UNDEF)) {
		SAVE_OPLINE();
		retval_ptr = ZVAL_UNDEFINED_OP1();
		if (return_value) {
			ZVAL_NULL(return_value);
		}
	} else if (!return_value) {
		if (IS_VAR & (IS_VAR|IS_TMP_VAR)) {
			if (C_REFCOUNTED_P(retval_ptr) && !C_DELREF_P(retval_ptr)) {
				SAVE_OPLINE();
				rc_dtor_func(C_COUNTED_P(retval_ptr));
			}
		}
	} else {
		if ((IS_VAR & (IS_CONST|IS_TMP_VAR))) {
			ZVAL_COPY_VALUE(return_value, retval_ptr);
			if (IS_VAR == IS_CONST) {
				if (UNEXPECTED(C_OPT_REFCOUNTED_P(return_value))) {
					C_ADDREF_P(return_value);
				}
			}
		} else if (IS_VAR == IS_CV) {
			do {
				if (C_OPT_REFCOUNTED_P(retval_ptr)) {
					if (EXPECTED(!C_OPT_ISREF_P(retval_ptr))) {
						if (EXPECTED(!(EX_CALL_INFO() & (CREX_CALL_CODE|CREX_CALL_OBSERVED)))) {
							crex_refcounted *ref = C_COUNTED_P(retval_ptr);
							ZVAL_COPY_VALUE(return_value, retval_ptr);
							if (GC_MAY_LEAK(ref)) {
								SAVE_OPLINE();
								gc_possible_root(ref);
							}
							ZVAL_NULL(retval_ptr);
							break;
						} else {
							C_ADDREF_P(retval_ptr);
						}
					} else {
						retval_ptr = C_REFVAL_P(retval_ptr);
						if (C_OPT_REFCOUNTED_P(retval_ptr)) {
							C_ADDREF_P(retval_ptr);
						}
					}
				}
				ZVAL_COPY_VALUE(return_value, retval_ptr);
			} while (0);
		} else /* if (IS_VAR == IS_VAR) */ {
			if (UNEXPECTED(C_ISREF_P(retval_ptr))) {
				crex_refcounted *ref = C_COUNTED_P(retval_ptr);

				retval_ptr = C_REFVAL_P(retval_ptr);
				ZVAL_COPY_VALUE(return_value, retval_ptr);
				if (UNEXPECTED(GC_DELREF(ref) == 0)) {
					efree_size(ref, sizeof(crex_reference));
				} else if (C_OPT_REFCOUNTED_P(retval_ptr)) {
					C_ADDREF_P(retval_ptr);
				}
			} else {
				ZVAL_COPY_VALUE(return_value, retval_ptr);
			}
		}
	}



	goto crex_leave_helper_SPEC_LABEL;
}

			HYBRID_CASE(CREX_RETURN_BY_REF_SPEC_VAR):
				VM_TRACE(CREX_RETURN_BY_REF_SPEC_VAR)
				CREX_RETURN_BY_REF_SPEC_VAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_GENERATOR_RETURN_SPEC_VAR):
				VM_TRACE(CREX_GENERATOR_RETURN_SPEC_VAR)
				CREX_GENERATOR_RETURN_SPEC_VAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_SEND_USER_SPEC_VAR):
				VM_TRACE(CREX_SEND_USER_SPEC_VAR)
				CREX_SEND_USER_SPEC_VAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_CAST_SPEC_VAR):
				VM_TRACE(CREX_CAST_SPEC_VAR)
				CREX_CAST_SPEC_VAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FE_RESET_R_SPEC_VAR):
				VM_TRACE(CREX_FE_RESET_R_SPEC_VAR)
				CREX_FE_RESET_R_SPEC_VAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FE_RESET_RW_SPEC_VAR):
				VM_TRACE(CREX_FE_RESET_RW_SPEC_VAR)
				CREX_FE_RESET_RW_SPEC_VAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FE_FETCH_R_SPEC_VAR):
				VM_TRACE(CREX_FE_FETCH_R_SPEC_VAR)
				CREX_FE_FETCH_R_SPEC_VAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FE_FETCH_RW_SPEC_VAR):
				VM_TRACE(CREX_FE_FETCH_RW_SPEC_VAR)
				CREX_FE_FETCH_RW_SPEC_VAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_JMP_SET_SPEC_VAR):
				VM_TRACE(CREX_JMP_SET_SPEC_VAR)
				CREX_JMP_SET_SPEC_VAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_COALESCE_SPEC_VAR):
				VM_TRACE(CREX_COALESCE_SPEC_VAR)
				CREX_COALESCE_SPEC_VAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_JMP_NULL_SPEC_VAR):
				VM_TRACE(CREX_JMP_NULL_SPEC_VAR)
				CREX_JMP_NULL_SPEC_VAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_QM_ASSIGN_SPEC_VAR):
				VM_TRACE(CREX_QM_ASSIGN_SPEC_VAR)
				CREX_QM_ASSIGN_SPEC_VAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_SEND_VAR_SIMPLE_SPEC_VAR):
				VM_TRACE(CREX_SEND_VAR_SIMPLE_SPEC_VAR)
				CREX_SEND_VAR_SIMPLE_SPEC_VAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_IS_IDENTICAL_SPEC_VAR_CONST):
				VM_TRACE(CREX_IS_IDENTICAL_SPEC_VAR_CONST)
				CREX_IS_IDENTICAL_SPEC_VAR_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_CASE_STRICT_SPEC_VAR_CONST):
				VM_TRACE(CREX_CASE_STRICT_SPEC_VAR_CONST)
				CREX_CASE_STRICT_SPEC_VAR_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_IS_NOT_IDENTICAL_SPEC_VAR_CONST):
				VM_TRACE(CREX_IS_NOT_IDENTICAL_SPEC_VAR_CONST)
				CREX_IS_NOT_IDENTICAL_SPEC_VAR_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ASSIGN_OBJ_OP_SPEC_VAR_CONST):
				VM_TRACE(CREX_ASSIGN_OBJ_OP_SPEC_VAR_CONST)
				CREX_ASSIGN_OBJ_OP_SPEC_VAR_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ASSIGN_DIM_OP_SPEC_VAR_CONST):
				VM_TRACE(CREX_ASSIGN_DIM_OP_SPEC_VAR_CONST)
				CREX_ASSIGN_DIM_OP_SPEC_VAR_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ASSIGN_OP_SPEC_VAR_CONST):
				VM_TRACE(CREX_ASSIGN_OP_SPEC_VAR_CONST)
				CREX_ASSIGN_OP_SPEC_VAR_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_PRE_INC_OBJ_SPEC_VAR_CONST):
				VM_TRACE(CREX_PRE_INC_OBJ_SPEC_VAR_CONST)
				CREX_PRE_INC_OBJ_SPEC_VAR_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_POST_INC_OBJ_SPEC_VAR_CONST):
				VM_TRACE(CREX_POST_INC_OBJ_SPEC_VAR_CONST)
				CREX_POST_INC_OBJ_SPEC_VAR_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FETCH_DIM_W_SPEC_VAR_CONST):
				VM_TRACE(CREX_FETCH_DIM_W_SPEC_VAR_CONST)
				CREX_FETCH_DIM_W_SPEC_VAR_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FETCH_DIM_RW_SPEC_VAR_CONST):
				VM_TRACE(CREX_FETCH_DIM_RW_SPEC_VAR_CONST)
				CREX_FETCH_DIM_RW_SPEC_VAR_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FETCH_DIM_FUNC_ARG_SPEC_VAR_CONST):
				VM_TRACE(CREX_FETCH_DIM_FUNC_ARG_SPEC_VAR_CONST)
				CREX_FETCH_DIM_FUNC_ARG_SPEC_VAR_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FETCH_DIM_UNSET_SPEC_VAR_CONST):
				VM_TRACE(CREX_FETCH_DIM_UNSET_SPEC_VAR_CONST)
				CREX_FETCH_DIM_UNSET_SPEC_VAR_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FETCH_OBJ_W_SPEC_VAR_CONST):
				VM_TRACE(CREX_FETCH_OBJ_W_SPEC_VAR_CONST)
				CREX_FETCH_OBJ_W_SPEC_VAR_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FETCH_OBJ_RW_SPEC_VAR_CONST):
				VM_TRACE(CREX_FETCH_OBJ_RW_SPEC_VAR_CONST)
				CREX_FETCH_OBJ_RW_SPEC_VAR_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FETCH_OBJ_FUNC_ARG_SPEC_VAR_CONST):
				VM_TRACE(CREX_FETCH_OBJ_FUNC_ARG_SPEC_VAR_CONST)
				CREX_FETCH_OBJ_FUNC_ARG_SPEC_VAR_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FETCH_OBJ_UNSET_SPEC_VAR_CONST):
				VM_TRACE(CREX_FETCH_OBJ_UNSET_SPEC_VAR_CONST)
				CREX_FETCH_OBJ_UNSET_SPEC_VAR_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FETCH_LIST_W_SPEC_VAR_CONST):
				VM_TRACE(CREX_FETCH_LIST_W_SPEC_VAR_CONST)
				CREX_FETCH_LIST_W_SPEC_VAR_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ASSIGN_OBJ_SPEC_VAR_CONST_OP_DATA_CONST):
				VM_TRACE(CREX_ASSIGN_OBJ_SPEC_VAR_CONST_OP_DATA_CONST)
				CREX_ASSIGN_OBJ_SPEC_VAR_CONST_OP_DATA_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ASSIGN_OBJ_SPEC_VAR_CONST_OP_DATA_TMP):
				VM_TRACE(CREX_ASSIGN_OBJ_SPEC_VAR_CONST_OP_DATA_TMP)
				CREX_ASSIGN_OBJ_SPEC_VAR_CONST_OP_DATA_TMP_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ASSIGN_OBJ_SPEC_VAR_CONST_OP_DATA_VAR):
				VM_TRACE(CREX_ASSIGN_OBJ_SPEC_VAR_CONST_OP_DATA_VAR)
				CREX_ASSIGN_OBJ_SPEC_VAR_CONST_OP_DATA_VAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ASSIGN_OBJ_SPEC_VAR_CONST_OP_DATA_CV):
				VM_TRACE(CREX_ASSIGN_OBJ_SPEC_VAR_CONST_OP_DATA_CV)
				CREX_ASSIGN_OBJ_SPEC_VAR_CONST_OP_DATA_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ASSIGN_DIM_SPEC_VAR_CONST_OP_DATA_CONST):
				VM_TRACE(CREX_ASSIGN_DIM_SPEC_VAR_CONST_OP_DATA_CONST)
				CREX_ASSIGN_DIM_SPEC_VAR_CONST_OP_DATA_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ASSIGN_DIM_SPEC_VAR_CONST_OP_DATA_TMP):
				VM_TRACE(CREX_ASSIGN_DIM_SPEC_VAR_CONST_OP_DATA_TMP)
				CREX_ASSIGN_DIM_SPEC_VAR_CONST_OP_DATA_TMP_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ASSIGN_DIM_SPEC_VAR_CONST_OP_DATA_VAR):
				VM_TRACE(CREX_ASSIGN_DIM_SPEC_VAR_CONST_OP_DATA_VAR)
				CREX_ASSIGN_DIM_SPEC_VAR_CONST_OP_DATA_VAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ASSIGN_DIM_SPEC_VAR_CONST_OP_DATA_CV):
				VM_TRACE(CREX_ASSIGN_DIM_SPEC_VAR_CONST_OP_DATA_CV)
				CREX_ASSIGN_DIM_SPEC_VAR_CONST_OP_DATA_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ASSIGN_SPEC_VAR_CONST_RETVAL_UNUSED):
				VM_TRACE(CREX_ASSIGN_SPEC_VAR_CONST_RETVAL_UNUSED)
				CREX_ASSIGN_SPEC_VAR_CONST_RETVAL_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ASSIGN_SPEC_VAR_CONST_RETVAL_USED):
				VM_TRACE(CREX_ASSIGN_SPEC_VAR_CONST_RETVAL_USED)
				CREX_ASSIGN_SPEC_VAR_CONST_RETVAL_USED_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ASSIGN_OBJ_REF_SPEC_VAR_CONST_OP_DATA_VAR):
				VM_TRACE(CREX_ASSIGN_OBJ_REF_SPEC_VAR_CONST_OP_DATA_VAR)
				CREX_ASSIGN_OBJ_REF_SPEC_VAR_CONST_OP_DATA_VAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ASSIGN_OBJ_REF_SPEC_VAR_CONST_OP_DATA_CV):
				VM_TRACE(CREX_ASSIGN_OBJ_REF_SPEC_VAR_CONST_OP_DATA_CV)
				CREX_ASSIGN_OBJ_REF_SPEC_VAR_CONST_OP_DATA_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_INIT_STATIC_METHOD_CALL_SPEC_VAR_CONST):
				VM_TRACE(CREX_INIT_STATIC_METHOD_CALL_SPEC_VAR_CONST)
				CREX_INIT_STATIC_METHOD_CALL_SPEC_VAR_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_SEND_VAR_SPEC_VAR_CONST):
				VM_TRACE(CREX_SEND_VAR_SPEC_VAR_CONST)
				CREX_SEND_VAR_SPEC_VAR_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_SEND_VAR_NO_REF_SPEC_VAR_CONST):
				VM_TRACE(CREX_SEND_VAR_NO_REF_SPEC_VAR_CONST)
				CREX_SEND_VAR_NO_REF_SPEC_VAR_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_SEND_VAR_NO_REF_EX_SPEC_VAR_CONST):
				VM_TRACE(CREX_SEND_VAR_NO_REF_EX_SPEC_VAR_CONST)
				CREX_SEND_VAR_NO_REF_EX_SPEC_VAR_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_SEND_REF_SPEC_VAR_CONST):
				VM_TRACE(CREX_SEND_REF_SPEC_VAR_CONST)
				CREX_SEND_REF_SPEC_VAR_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_SEND_VAR_EX_SPEC_VAR_CONST):
				VM_TRACE(CREX_SEND_VAR_EX_SPEC_VAR_CONST)
				CREX_SEND_VAR_EX_SPEC_VAR_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_SEND_FUNC_ARG_SPEC_VAR_CONST):
				VM_TRACE(CREX_SEND_FUNC_ARG_SPEC_VAR_CONST)
				CREX_SEND_FUNC_ARG_SPEC_VAR_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FETCH_CLASS_CONSTANT_SPEC_VAR_CONST):
				VM_TRACE(CREX_FETCH_CLASS_CONSTANT_SPEC_VAR_CONST)
				CREX_FETCH_CLASS_CONSTANT_SPEC_VAR_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ADD_ARRAY_ELEMENT_SPEC_VAR_CONST):
				VM_TRACE(CREX_ADD_ARRAY_ELEMENT_SPEC_VAR_CONST)
				CREX_ADD_ARRAY_ELEMENT_SPEC_VAR_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_INIT_ARRAY_SPEC_VAR_CONST):
				VM_TRACE(CREX_INIT_ARRAY_SPEC_VAR_CONST)
				CREX_INIT_ARRAY_SPEC_VAR_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_UNSET_DIM_SPEC_VAR_CONST):
				VM_TRACE(CREX_UNSET_DIM_SPEC_VAR_CONST)
				CREX_UNSET_DIM_SPEC_VAR_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_UNSET_OBJ_SPEC_VAR_CONST):
				VM_TRACE(CREX_UNSET_OBJ_SPEC_VAR_CONST)
				CREX_UNSET_OBJ_SPEC_VAR_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_YIELD_SPEC_VAR_CONST):
				VM_TRACE(CREX_YIELD_SPEC_VAR_CONST)
				CREX_YIELD_SPEC_VAR_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_IN_ARRAY_SPEC_VAR_CONST):
				VM_TRACE(CREX_IN_ARRAY_SPEC_VAR_CONST)
				CREX_IN_ARRAY_SPEC_VAR_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FETCH_CLASS_CONSTANT_SPEC_VAR_TMPVARCV):
				VM_TRACE(CREX_FETCH_CLASS_CONSTANT_SPEC_VAR_TMPVARCV)
				CREX_FETCH_CLASS_CONSTANT_SPEC_VAR_TMPVARCV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ASSIGN_OBJ_OP_SPEC_VAR_TMPVAR):
				VM_TRACE(CREX_ASSIGN_OBJ_OP_SPEC_VAR_TMPVAR)
				CREX_ASSIGN_OBJ_OP_SPEC_VAR_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ASSIGN_DIM_OP_SPEC_VAR_TMPVAR):
				VM_TRACE(CREX_ASSIGN_DIM_OP_SPEC_VAR_TMPVAR)
				CREX_ASSIGN_DIM_OP_SPEC_VAR_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ASSIGN_OP_SPEC_VAR_TMPVAR):
				VM_TRACE(CREX_ASSIGN_OP_SPEC_VAR_TMPVAR)
				CREX_ASSIGN_OP_SPEC_VAR_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_PRE_INC_OBJ_SPEC_VAR_TMPVAR):
				VM_TRACE(CREX_PRE_INC_OBJ_SPEC_VAR_TMPVAR)
				CREX_PRE_INC_OBJ_SPEC_VAR_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_POST_INC_OBJ_SPEC_VAR_TMPVAR):
				VM_TRACE(CREX_POST_INC_OBJ_SPEC_VAR_TMPVAR)
				CREX_POST_INC_OBJ_SPEC_VAR_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FETCH_DIM_W_SPEC_VAR_TMPVAR):
				VM_TRACE(CREX_FETCH_DIM_W_SPEC_VAR_TMPVAR)
				CREX_FETCH_DIM_W_SPEC_VAR_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FETCH_DIM_RW_SPEC_VAR_TMPVAR):
				VM_TRACE(CREX_FETCH_DIM_RW_SPEC_VAR_TMPVAR)
				CREX_FETCH_DIM_RW_SPEC_VAR_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FETCH_DIM_FUNC_ARG_SPEC_VAR_TMPVAR):
				VM_TRACE(CREX_FETCH_DIM_FUNC_ARG_SPEC_VAR_TMPVAR)
				CREX_FETCH_DIM_FUNC_ARG_SPEC_VAR_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FETCH_DIM_UNSET_SPEC_VAR_TMPVAR):
				VM_TRACE(CREX_FETCH_DIM_UNSET_SPEC_VAR_TMPVAR)
				CREX_FETCH_DIM_UNSET_SPEC_VAR_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FETCH_OBJ_W_SPEC_VAR_TMPVAR):
				VM_TRACE(CREX_FETCH_OBJ_W_SPEC_VAR_TMPVAR)
				CREX_FETCH_OBJ_W_SPEC_VAR_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FETCH_OBJ_RW_SPEC_VAR_TMPVAR):
				VM_TRACE(CREX_FETCH_OBJ_RW_SPEC_VAR_TMPVAR)
				CREX_FETCH_OBJ_RW_SPEC_VAR_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FETCH_OBJ_FUNC_ARG_SPEC_VAR_TMPVAR):
				VM_TRACE(CREX_FETCH_OBJ_FUNC_ARG_SPEC_VAR_TMPVAR)
				CREX_FETCH_OBJ_FUNC_ARG_SPEC_VAR_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FETCH_OBJ_UNSET_SPEC_VAR_TMPVAR):
				VM_TRACE(CREX_FETCH_OBJ_UNSET_SPEC_VAR_TMPVAR)
				CREX_FETCH_OBJ_UNSET_SPEC_VAR_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FETCH_LIST_W_SPEC_VAR_TMPVAR):
				VM_TRACE(CREX_FETCH_LIST_W_SPEC_VAR_TMPVAR)
				CREX_FETCH_LIST_W_SPEC_VAR_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ASSIGN_OBJ_SPEC_VAR_TMPVAR_OP_DATA_CONST):
				VM_TRACE(CREX_ASSIGN_OBJ_SPEC_VAR_TMPVAR_OP_DATA_CONST)
				CREX_ASSIGN_OBJ_SPEC_VAR_TMPVAR_OP_DATA_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ASSIGN_OBJ_SPEC_VAR_TMPVAR_OP_DATA_TMP):
				VM_TRACE(CREX_ASSIGN_OBJ_SPEC_VAR_TMPVAR_OP_DATA_TMP)
				CREX_ASSIGN_OBJ_SPEC_VAR_TMPVAR_OP_DATA_TMP_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ASSIGN_OBJ_SPEC_VAR_TMPVAR_OP_DATA_VAR):
				VM_TRACE(CREX_ASSIGN_OBJ_SPEC_VAR_TMPVAR_OP_DATA_VAR)
				CREX_ASSIGN_OBJ_SPEC_VAR_TMPVAR_OP_DATA_VAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ASSIGN_OBJ_SPEC_VAR_TMPVAR_OP_DATA_CV):
				VM_TRACE(CREX_ASSIGN_OBJ_SPEC_VAR_TMPVAR_OP_DATA_CV)
				CREX_ASSIGN_OBJ_SPEC_VAR_TMPVAR_OP_DATA_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ASSIGN_DIM_SPEC_VAR_TMPVAR_OP_DATA_CONST):
				VM_TRACE(CREX_ASSIGN_DIM_SPEC_VAR_TMPVAR_OP_DATA_CONST)
				CREX_ASSIGN_DIM_SPEC_VAR_TMPVAR_OP_DATA_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ASSIGN_DIM_SPEC_VAR_TMPVAR_OP_DATA_TMP):
				VM_TRACE(CREX_ASSIGN_DIM_SPEC_VAR_TMPVAR_OP_DATA_TMP)
				CREX_ASSIGN_DIM_SPEC_VAR_TMPVAR_OP_DATA_TMP_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ASSIGN_DIM_SPEC_VAR_TMPVAR_OP_DATA_VAR):
				VM_TRACE(CREX_ASSIGN_DIM_SPEC_VAR_TMPVAR_OP_DATA_VAR)
				CREX_ASSIGN_DIM_SPEC_VAR_TMPVAR_OP_DATA_VAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ASSIGN_DIM_SPEC_VAR_TMPVAR_OP_DATA_CV):
				VM_TRACE(CREX_ASSIGN_DIM_SPEC_VAR_TMPVAR_OP_DATA_CV)
				CREX_ASSIGN_DIM_SPEC_VAR_TMPVAR_OP_DATA_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ASSIGN_OBJ_REF_SPEC_VAR_TMPVAR_OP_DATA_VAR):
				VM_TRACE(CREX_ASSIGN_OBJ_REF_SPEC_VAR_TMPVAR_OP_DATA_VAR)
				CREX_ASSIGN_OBJ_REF_SPEC_VAR_TMPVAR_OP_DATA_VAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ASSIGN_OBJ_REF_SPEC_VAR_TMPVAR_OP_DATA_CV):
				VM_TRACE(CREX_ASSIGN_OBJ_REF_SPEC_VAR_TMPVAR_OP_DATA_CV)
				CREX_ASSIGN_OBJ_REF_SPEC_VAR_TMPVAR_OP_DATA_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_INIT_STATIC_METHOD_CALL_SPEC_VAR_TMPVAR):
				VM_TRACE(CREX_INIT_STATIC_METHOD_CALL_SPEC_VAR_TMPVAR)
				CREX_INIT_STATIC_METHOD_CALL_SPEC_VAR_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ADD_ARRAY_ELEMENT_SPEC_VAR_TMPVAR):
				VM_TRACE(CREX_ADD_ARRAY_ELEMENT_SPEC_VAR_TMPVAR)
				CREX_ADD_ARRAY_ELEMENT_SPEC_VAR_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_INIT_ARRAY_SPEC_VAR_TMPVAR):
				VM_TRACE(CREX_INIT_ARRAY_SPEC_VAR_TMPVAR)
				CREX_INIT_ARRAY_SPEC_VAR_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_UNSET_DIM_SPEC_VAR_TMPVAR):
				VM_TRACE(CREX_UNSET_DIM_SPEC_VAR_TMPVAR)
				CREX_UNSET_DIM_SPEC_VAR_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_UNSET_OBJ_SPEC_VAR_TMPVAR):
				VM_TRACE(CREX_UNSET_OBJ_SPEC_VAR_TMPVAR)
				CREX_UNSET_OBJ_SPEC_VAR_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_YIELD_SPEC_VAR_TMPVAR):
				VM_TRACE(CREX_YIELD_SPEC_VAR_TMPVAR)
				CREX_YIELD_SPEC_VAR_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_IS_IDENTICAL_SPEC_VAR_TMP):
				VM_TRACE(CREX_IS_IDENTICAL_SPEC_VAR_TMP)
				CREX_IS_IDENTICAL_SPEC_VAR_TMP_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_CASE_STRICT_SPEC_VAR_TMP):
				VM_TRACE(CREX_CASE_STRICT_SPEC_VAR_TMP)
				CREX_CASE_STRICT_SPEC_VAR_TMP_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_IS_NOT_IDENTICAL_SPEC_VAR_TMP):
				VM_TRACE(CREX_IS_NOT_IDENTICAL_SPEC_VAR_TMP)
				CREX_IS_NOT_IDENTICAL_SPEC_VAR_TMP_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ASSIGN_SPEC_VAR_TMP_RETVAL_UNUSED):
				VM_TRACE(CREX_ASSIGN_SPEC_VAR_TMP_RETVAL_UNUSED)
				CREX_ASSIGN_SPEC_VAR_TMP_RETVAL_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ASSIGN_SPEC_VAR_TMP_RETVAL_USED):
				VM_TRACE(CREX_ASSIGN_SPEC_VAR_TMP_RETVAL_USED)
				CREX_ASSIGN_SPEC_VAR_TMP_RETVAL_USED_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_IS_IDENTICAL_SPEC_VAR_VAR):
				VM_TRACE(CREX_IS_IDENTICAL_SPEC_VAR_VAR)
				CREX_IS_IDENTICAL_SPEC_VAR_VAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_CASE_STRICT_SPEC_VAR_VAR):
				VM_TRACE(CREX_CASE_STRICT_SPEC_VAR_VAR)
				CREX_CASE_STRICT_SPEC_VAR_VAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_IS_NOT_IDENTICAL_SPEC_VAR_VAR):
				VM_TRACE(CREX_IS_NOT_IDENTICAL_SPEC_VAR_VAR)
				CREX_IS_NOT_IDENTICAL_SPEC_VAR_VAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ASSIGN_SPEC_VAR_VAR_RETVAL_UNUSED):
				VM_TRACE(CREX_ASSIGN_SPEC_VAR_VAR_RETVAL_UNUSED)
				CREX_ASSIGN_SPEC_VAR_VAR_RETVAL_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ASSIGN_SPEC_VAR_VAR_RETVAL_USED):
				VM_TRACE(CREX_ASSIGN_SPEC_VAR_VAR_RETVAL_USED)
				CREX_ASSIGN_SPEC_VAR_VAR_RETVAL_USED_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ASSIGN_REF_SPEC_VAR_VAR):
				VM_TRACE(CREX_ASSIGN_REF_SPEC_VAR_VAR)
				CREX_ASSIGN_REF_SPEC_VAR_VAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ASSIGN_DIM_OP_SPEC_VAR_UNUSED):
				VM_TRACE(CREX_ASSIGN_DIM_OP_SPEC_VAR_UNUSED)
				CREX_ASSIGN_DIM_OP_SPEC_VAR_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FETCH_DIM_W_SPEC_VAR_UNUSED):
				VM_TRACE(CREX_FETCH_DIM_W_SPEC_VAR_UNUSED)
				CREX_FETCH_DIM_W_SPEC_VAR_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FETCH_DIM_RW_SPEC_VAR_UNUSED):
				VM_TRACE(CREX_FETCH_DIM_RW_SPEC_VAR_UNUSED)
				CREX_FETCH_DIM_RW_SPEC_VAR_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FETCH_DIM_FUNC_ARG_SPEC_VAR_UNUSED):
				VM_TRACE(CREX_FETCH_DIM_FUNC_ARG_SPEC_VAR_UNUSED)
				CREX_FETCH_DIM_FUNC_ARG_SPEC_VAR_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ASSIGN_DIM_SPEC_VAR_UNUSED_OP_DATA_CONST):
				VM_TRACE(CREX_ASSIGN_DIM_SPEC_VAR_UNUSED_OP_DATA_CONST)
				CREX_ASSIGN_DIM_SPEC_VAR_UNUSED_OP_DATA_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ASSIGN_DIM_SPEC_VAR_UNUSED_OP_DATA_TMP):
				VM_TRACE(CREX_ASSIGN_DIM_SPEC_VAR_UNUSED_OP_DATA_TMP)
				CREX_ASSIGN_DIM_SPEC_VAR_UNUSED_OP_DATA_TMP_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ASSIGN_DIM_SPEC_VAR_UNUSED_OP_DATA_VAR):
				VM_TRACE(CREX_ASSIGN_DIM_SPEC_VAR_UNUSED_OP_DATA_VAR)
				CREX_ASSIGN_DIM_SPEC_VAR_UNUSED_OP_DATA_VAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ASSIGN_DIM_SPEC_VAR_UNUSED_OP_DATA_CV):
				VM_TRACE(CREX_ASSIGN_DIM_SPEC_VAR_UNUSED_OP_DATA_CV)
				CREX_ASSIGN_DIM_SPEC_VAR_UNUSED_OP_DATA_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_INIT_STATIC_METHOD_CALL_SPEC_VAR_UNUSED):
				VM_TRACE(CREX_INIT_STATIC_METHOD_CALL_SPEC_VAR_UNUSED)
				CREX_INIT_STATIC_METHOD_CALL_SPEC_VAR_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_VERIFY_RETURN_TYPE_SPEC_VAR_UNUSED):
				VM_TRACE(CREX_VERIFY_RETURN_TYPE_SPEC_VAR_UNUSED)
				CREX_VERIFY_RETURN_TYPE_SPEC_VAR_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_SEND_VAR_SPEC_VAR_UNUSED):
				VM_TRACE(CREX_SEND_VAR_SPEC_VAR_UNUSED)
				CREX_SEND_VAR_SPEC_VAR_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_SEND_VAR_NO_REF_SPEC_VAR_UNUSED):
				VM_TRACE(CREX_SEND_VAR_NO_REF_SPEC_VAR_UNUSED)
				CREX_SEND_VAR_NO_REF_SPEC_VAR_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_SEND_VAR_NO_REF_EX_SPEC_VAR_UNUSED):
				VM_TRACE(CREX_SEND_VAR_NO_REF_EX_SPEC_VAR_UNUSED)
				CREX_SEND_VAR_NO_REF_EX_SPEC_VAR_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_SEND_VAR_NO_REF_EX_SPEC_VAR_UNUSED_QUICK):
				VM_TRACE(CREX_SEND_VAR_NO_REF_EX_SPEC_VAR_UNUSED_QUICK)
				CREX_SEND_VAR_NO_REF_EX_SPEC_VAR_UNUSED_QUICK_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_SEND_REF_SPEC_VAR_UNUSED):
				VM_TRACE(CREX_SEND_REF_SPEC_VAR_UNUSED)
				CREX_SEND_REF_SPEC_VAR_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_SEND_VAR_EX_SPEC_VAR_UNUSED):
				VM_TRACE(CREX_SEND_VAR_EX_SPEC_VAR_UNUSED)
				CREX_SEND_VAR_EX_SPEC_VAR_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_SEND_VAR_EX_SPEC_VAR_UNUSED_QUICK):
				VM_TRACE(CREX_SEND_VAR_EX_SPEC_VAR_UNUSED_QUICK)
				CREX_SEND_VAR_EX_SPEC_VAR_UNUSED_QUICK_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_SEND_FUNC_ARG_SPEC_VAR_UNUSED):
				VM_TRACE(CREX_SEND_FUNC_ARG_SPEC_VAR_UNUSED)
				CREX_SEND_FUNC_ARG_SPEC_VAR_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_NEW_SPEC_VAR_UNUSED):
				VM_TRACE(CREX_NEW_SPEC_VAR_UNUSED)
				CREX_NEW_SPEC_VAR_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ADD_ARRAY_ELEMENT_SPEC_VAR_UNUSED):
				VM_TRACE(CREX_ADD_ARRAY_ELEMENT_SPEC_VAR_UNUSED)
				CREX_ADD_ARRAY_ELEMENT_SPEC_VAR_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_INIT_ARRAY_SPEC_VAR_UNUSED):
				VM_TRACE(CREX_INIT_ARRAY_SPEC_VAR_UNUSED)
				CREX_INIT_ARRAY_SPEC_VAR_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_SEPARATE_SPEC_VAR_UNUSED):
				VM_TRACE(CREX_SEPARATE_SPEC_VAR_UNUSED)
				CREX_SEPARATE_SPEC_VAR_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_YIELD_SPEC_VAR_UNUSED):
				VM_TRACE(CREX_YIELD_SPEC_VAR_UNUSED)
				CREX_YIELD_SPEC_VAR_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_MAKE_REF_SPEC_VAR_UNUSED):
				VM_TRACE(CREX_MAKE_REF_SPEC_VAR_UNUSED)
				CREX_MAKE_REF_SPEC_VAR_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_GET_TYPE_SPEC_VAR_UNUSED):
				VM_TRACE(CREX_GET_TYPE_SPEC_VAR_UNUSED)
				CREX_GET_TYPE_SPEC_VAR_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_SEND_VAR_EX_SIMPLE_SPEC_VAR_UNUSED):
				VM_TRACE(CREX_SEND_VAR_EX_SIMPLE_SPEC_VAR_UNUSED)
				CREX_SEND_VAR_EX_SIMPLE_SPEC_VAR_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_CASE_STRICT_SPEC_VAR_CV):
				VM_TRACE(CREX_CASE_STRICT_SPEC_VAR_CV)
				CREX_CASE_STRICT_SPEC_VAR_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ASSIGN_OBJ_OP_SPEC_VAR_CV):
				VM_TRACE(CREX_ASSIGN_OBJ_OP_SPEC_VAR_CV)
				CREX_ASSIGN_OBJ_OP_SPEC_VAR_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ASSIGN_DIM_OP_SPEC_VAR_CV):
				VM_TRACE(CREX_ASSIGN_DIM_OP_SPEC_VAR_CV)
				CREX_ASSIGN_DIM_OP_SPEC_VAR_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ASSIGN_OP_SPEC_VAR_CV):
				VM_TRACE(CREX_ASSIGN_OP_SPEC_VAR_CV)
				CREX_ASSIGN_OP_SPEC_VAR_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_PRE_INC_OBJ_SPEC_VAR_CV):
				VM_TRACE(CREX_PRE_INC_OBJ_SPEC_VAR_CV)
				CREX_PRE_INC_OBJ_SPEC_VAR_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_POST_INC_OBJ_SPEC_VAR_CV):
				VM_TRACE(CREX_POST_INC_OBJ_SPEC_VAR_CV)
				CREX_POST_INC_OBJ_SPEC_VAR_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FETCH_DIM_W_SPEC_VAR_CV):
				VM_TRACE(CREX_FETCH_DIM_W_SPEC_VAR_CV)
				CREX_FETCH_DIM_W_SPEC_VAR_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FETCH_DIM_RW_SPEC_VAR_CV):
				VM_TRACE(CREX_FETCH_DIM_RW_SPEC_VAR_CV)
				CREX_FETCH_DIM_RW_SPEC_VAR_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FETCH_DIM_FUNC_ARG_SPEC_VAR_CV):
				VM_TRACE(CREX_FETCH_DIM_FUNC_ARG_SPEC_VAR_CV)
				CREX_FETCH_DIM_FUNC_ARG_SPEC_VAR_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FETCH_DIM_UNSET_SPEC_VAR_CV):
				VM_TRACE(CREX_FETCH_DIM_UNSET_SPEC_VAR_CV)
				CREX_FETCH_DIM_UNSET_SPEC_VAR_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FETCH_OBJ_W_SPEC_VAR_CV):
				VM_TRACE(CREX_FETCH_OBJ_W_SPEC_VAR_CV)
				CREX_FETCH_OBJ_W_SPEC_VAR_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FETCH_OBJ_RW_SPEC_VAR_CV):
				VM_TRACE(CREX_FETCH_OBJ_RW_SPEC_VAR_CV)
				CREX_FETCH_OBJ_RW_SPEC_VAR_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FETCH_OBJ_FUNC_ARG_SPEC_VAR_CV):
				VM_TRACE(CREX_FETCH_OBJ_FUNC_ARG_SPEC_VAR_CV)
				CREX_FETCH_OBJ_FUNC_ARG_SPEC_VAR_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FETCH_OBJ_UNSET_SPEC_VAR_CV):
				VM_TRACE(CREX_FETCH_OBJ_UNSET_SPEC_VAR_CV)
				CREX_FETCH_OBJ_UNSET_SPEC_VAR_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FETCH_LIST_W_SPEC_VAR_CV):
				VM_TRACE(CREX_FETCH_LIST_W_SPEC_VAR_CV)
				CREX_FETCH_LIST_W_SPEC_VAR_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ASSIGN_OBJ_SPEC_VAR_CV_OP_DATA_CONST):
				VM_TRACE(CREX_ASSIGN_OBJ_SPEC_VAR_CV_OP_DATA_CONST)
				CREX_ASSIGN_OBJ_SPEC_VAR_CV_OP_DATA_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ASSIGN_OBJ_SPEC_VAR_CV_OP_DATA_TMP):
				VM_TRACE(CREX_ASSIGN_OBJ_SPEC_VAR_CV_OP_DATA_TMP)
				CREX_ASSIGN_OBJ_SPEC_VAR_CV_OP_DATA_TMP_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ASSIGN_OBJ_SPEC_VAR_CV_OP_DATA_VAR):
				VM_TRACE(CREX_ASSIGN_OBJ_SPEC_VAR_CV_OP_DATA_VAR)
				CREX_ASSIGN_OBJ_SPEC_VAR_CV_OP_DATA_VAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ASSIGN_OBJ_SPEC_VAR_CV_OP_DATA_CV):
				VM_TRACE(CREX_ASSIGN_OBJ_SPEC_VAR_CV_OP_DATA_CV)
				CREX_ASSIGN_OBJ_SPEC_VAR_CV_OP_DATA_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ASSIGN_DIM_SPEC_VAR_CV_OP_DATA_CONST):
				VM_TRACE(CREX_ASSIGN_DIM_SPEC_VAR_CV_OP_DATA_CONST)
				CREX_ASSIGN_DIM_SPEC_VAR_CV_OP_DATA_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ASSIGN_DIM_SPEC_VAR_CV_OP_DATA_TMP):
				VM_TRACE(CREX_ASSIGN_DIM_SPEC_VAR_CV_OP_DATA_TMP)
				CREX_ASSIGN_DIM_SPEC_VAR_CV_OP_DATA_TMP_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ASSIGN_DIM_SPEC_VAR_CV_OP_DATA_VAR):
				VM_TRACE(CREX_ASSIGN_DIM_SPEC_VAR_CV_OP_DATA_VAR)
				CREX_ASSIGN_DIM_SPEC_VAR_CV_OP_DATA_VAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ASSIGN_DIM_SPEC_VAR_CV_OP_DATA_CV):
				VM_TRACE(CREX_ASSIGN_DIM_SPEC_VAR_CV_OP_DATA_CV)
				CREX_ASSIGN_DIM_SPEC_VAR_CV_OP_DATA_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ASSIGN_SPEC_VAR_CV_RETVAL_UNUSED):
				VM_TRACE(CREX_ASSIGN_SPEC_VAR_CV_RETVAL_UNUSED)
				CREX_ASSIGN_SPEC_VAR_CV_RETVAL_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ASSIGN_SPEC_VAR_CV_RETVAL_USED):
				VM_TRACE(CREX_ASSIGN_SPEC_VAR_CV_RETVAL_USED)
				CREX_ASSIGN_SPEC_VAR_CV_RETVAL_USED_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ASSIGN_REF_SPEC_VAR_CV):
				VM_TRACE(CREX_ASSIGN_REF_SPEC_VAR_CV)
				CREX_ASSIGN_REF_SPEC_VAR_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ASSIGN_OBJ_REF_SPEC_VAR_CV_OP_DATA_VAR):
				VM_TRACE(CREX_ASSIGN_OBJ_REF_SPEC_VAR_CV_OP_DATA_VAR)
				CREX_ASSIGN_OBJ_REF_SPEC_VAR_CV_OP_DATA_VAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ASSIGN_OBJ_REF_SPEC_VAR_CV_OP_DATA_CV):
				VM_TRACE(CREX_ASSIGN_OBJ_REF_SPEC_VAR_CV_OP_DATA_CV)
				CREX_ASSIGN_OBJ_REF_SPEC_VAR_CV_OP_DATA_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_INIT_STATIC_METHOD_CALL_SPEC_VAR_CV):
				VM_TRACE(CREX_INIT_STATIC_METHOD_CALL_SPEC_VAR_CV)
				CREX_INIT_STATIC_METHOD_CALL_SPEC_VAR_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ADD_ARRAY_ELEMENT_SPEC_VAR_CV):
				VM_TRACE(CREX_ADD_ARRAY_ELEMENT_SPEC_VAR_CV)
				CREX_ADD_ARRAY_ELEMENT_SPEC_VAR_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_INIT_ARRAY_SPEC_VAR_CV):
				VM_TRACE(CREX_INIT_ARRAY_SPEC_VAR_CV)
				CREX_INIT_ARRAY_SPEC_VAR_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_UNSET_DIM_SPEC_VAR_CV):
				VM_TRACE(CREX_UNSET_DIM_SPEC_VAR_CV)
				CREX_UNSET_DIM_SPEC_VAR_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_UNSET_OBJ_SPEC_VAR_CV):
				VM_TRACE(CREX_UNSET_OBJ_SPEC_VAR_CV)
				CREX_UNSET_OBJ_SPEC_VAR_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_YIELD_SPEC_VAR_CV):
				VM_TRACE(CREX_YIELD_SPEC_VAR_CV)
				CREX_YIELD_SPEC_VAR_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FE_FETCH_R_SIMPLE_SPEC_VAR_CV_RETVAL_UNUSED):
				VM_TRACE(CREX_FE_FETCH_R_SIMPLE_SPEC_VAR_CV_RETVAL_UNUSED)
				CREX_FE_FETCH_R_SIMPLE_SPEC_VAR_CV_RETVAL_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FE_FETCH_R_SIMPLE_SPEC_VAR_CV_RETVAL_USED):
				VM_TRACE(CREX_FE_FETCH_R_SIMPLE_SPEC_VAR_CV_RETVAL_USED)
				CREX_FE_FETCH_R_SIMPLE_SPEC_VAR_CV_RETVAL_USED_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_CLONE_SPEC_UNUSED):
				VM_TRACE(CREX_CLONE_SPEC_UNUSED)
				CREX_CLONE_SPEC_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FETCH_CLASS_NAME_SPEC_UNUSED):
				VM_TRACE(CREX_FETCH_CLASS_NAME_SPEC_UNUSED)
				CREX_FETCH_CLASS_NAME_SPEC_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ASSIGN_OBJ_OP_SPEC_UNUSED_CONST):
				VM_TRACE(CREX_ASSIGN_OBJ_OP_SPEC_UNUSED_CONST)
				CREX_ASSIGN_OBJ_OP_SPEC_UNUSED_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_PRE_INC_OBJ_SPEC_UNUSED_CONST):
				VM_TRACE(CREX_PRE_INC_OBJ_SPEC_UNUSED_CONST)
				CREX_PRE_INC_OBJ_SPEC_UNUSED_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_POST_INC_OBJ_SPEC_UNUSED_CONST):
				VM_TRACE(CREX_POST_INC_OBJ_SPEC_UNUSED_CONST)
				CREX_POST_INC_OBJ_SPEC_UNUSED_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FETCH_OBJ_R_SPEC_UNUSED_CONST):
				VM_TRACE(CREX_FETCH_OBJ_R_SPEC_UNUSED_CONST)
				CREX_FETCH_OBJ_R_SPEC_UNUSED_CONST_INLINE_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FETCH_OBJ_W_SPEC_UNUSED_CONST):
				VM_TRACE(CREX_FETCH_OBJ_W_SPEC_UNUSED_CONST)
				CREX_FETCH_OBJ_W_SPEC_UNUSED_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FETCH_OBJ_RW_SPEC_UNUSED_CONST):
				VM_TRACE(CREX_FETCH_OBJ_RW_SPEC_UNUSED_CONST)
				CREX_FETCH_OBJ_RW_SPEC_UNUSED_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FETCH_OBJ_IS_SPEC_UNUSED_CONST):
				VM_TRACE(CREX_FETCH_OBJ_IS_SPEC_UNUSED_CONST)
				CREX_FETCH_OBJ_IS_SPEC_UNUSED_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FETCH_OBJ_FUNC_ARG_SPEC_UNUSED_CONST):
				VM_TRACE(CREX_FETCH_OBJ_FUNC_ARG_SPEC_UNUSED_CONST)
				CREX_FETCH_OBJ_FUNC_ARG_SPEC_UNUSED_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FETCH_OBJ_UNSET_SPEC_UNUSED_CONST):
				VM_TRACE(CREX_FETCH_OBJ_UNSET_SPEC_UNUSED_CONST)
				CREX_FETCH_OBJ_UNSET_SPEC_UNUSED_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ASSIGN_OBJ_SPEC_UNUSED_CONST_OP_DATA_CONST):
				VM_TRACE(CREX_ASSIGN_OBJ_SPEC_UNUSED_CONST_OP_DATA_CONST)
				CREX_ASSIGN_OBJ_SPEC_UNUSED_CONST_OP_DATA_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ASSIGN_OBJ_SPEC_UNUSED_CONST_OP_DATA_TMP):
				VM_TRACE(CREX_ASSIGN_OBJ_SPEC_UNUSED_CONST_OP_DATA_TMP)
				CREX_ASSIGN_OBJ_SPEC_UNUSED_CONST_OP_DATA_TMP_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ASSIGN_OBJ_SPEC_UNUSED_CONST_OP_DATA_VAR):
				VM_TRACE(CREX_ASSIGN_OBJ_SPEC_UNUSED_CONST_OP_DATA_VAR)
				CREX_ASSIGN_OBJ_SPEC_UNUSED_CONST_OP_DATA_VAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ASSIGN_OBJ_SPEC_UNUSED_CONST_OP_DATA_CV):
				VM_TRACE(CREX_ASSIGN_OBJ_SPEC_UNUSED_CONST_OP_DATA_CV)
				CREX_ASSIGN_OBJ_SPEC_UNUSED_CONST_OP_DATA_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ASSIGN_OBJ_REF_SPEC_UNUSED_CONST_OP_DATA_VAR):
				VM_TRACE(CREX_ASSIGN_OBJ_REF_SPEC_UNUSED_CONST_OP_DATA_VAR)
				CREX_ASSIGN_OBJ_REF_SPEC_UNUSED_CONST_OP_DATA_VAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ASSIGN_OBJ_REF_SPEC_UNUSED_CONST_OP_DATA_CV):
				VM_TRACE(CREX_ASSIGN_OBJ_REF_SPEC_UNUSED_CONST_OP_DATA_CV)
				CREX_ASSIGN_OBJ_REF_SPEC_UNUSED_CONST_OP_DATA_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ROPE_INIT_SPEC_UNUSED_CONST):
				VM_TRACE(CREX_ROPE_INIT_SPEC_UNUSED_CONST)
				CREX_ROPE_INIT_SPEC_UNUSED_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FETCH_CLASS_SPEC_UNUSED_CONST):
				VM_TRACE(CREX_FETCH_CLASS_SPEC_UNUSED_CONST)
				CREX_FETCH_CLASS_SPEC_UNUSED_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_INIT_METHOD_CALL_SPEC_UNUSED_CONST):
				VM_TRACE(CREX_INIT_METHOD_CALL_SPEC_UNUSED_CONST)
				CREX_INIT_METHOD_CALL_SPEC_UNUSED_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_INIT_STATIC_METHOD_CALL_SPEC_UNUSED_CONST):
				VM_TRACE(CREX_INIT_STATIC_METHOD_CALL_SPEC_UNUSED_CONST)
				CREX_INIT_STATIC_METHOD_CALL_SPEC_UNUSED_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_CHECK_FUNC_ARG_SPEC_UNUSED_CONST):
				VM_TRACE(CREX_CHECK_FUNC_ARG_SPEC_UNUSED_CONST)
				CREX_CHECK_FUNC_ARG_SPEC_UNUSED_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FETCH_CONSTANT_SPEC_UNUSED_CONST):
				VM_TRACE(CREX_FETCH_CONSTANT_SPEC_UNUSED_CONST)
				CREX_FETCH_CONSTANT_SPEC_UNUSED_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FETCH_CLASS_CONSTANT_SPEC_UNUSED_CONST):
				VM_TRACE(CREX_FETCH_CLASS_CONSTANT_SPEC_UNUSED_CONST)
				CREX_FETCH_CLASS_CONSTANT_SPEC_UNUSED_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_INIT_ARRAY_SPEC_UNUSED_CONST):
				VM_TRACE(CREX_INIT_ARRAY_SPEC_UNUSED_CONST)
				CREX_INIT_ARRAY_SPEC_UNUSED_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_UNSET_OBJ_SPEC_UNUSED_CONST):
				VM_TRACE(CREX_UNSET_OBJ_SPEC_UNUSED_CONST)
				CREX_UNSET_OBJ_SPEC_UNUSED_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ISSET_ISEMPTY_PROP_OBJ_SPEC_UNUSED_CONST):
				VM_TRACE(CREX_ISSET_ISEMPTY_PROP_OBJ_SPEC_UNUSED_CONST)
				CREX_ISSET_ISEMPTY_PROP_OBJ_SPEC_UNUSED_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_YIELD_SPEC_UNUSED_CONST):
				VM_TRACE(CREX_YIELD_SPEC_UNUSED_CONST)
				CREX_YIELD_SPEC_UNUSED_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FETCH_CLASS_CONSTANT_SPEC_UNUSED_TMPVARCV):
				VM_TRACE(CREX_FETCH_CLASS_CONSTANT_SPEC_UNUSED_TMPVARCV)
				CREX_FETCH_CLASS_CONSTANT_SPEC_UNUSED_TMPVARCV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ASSIGN_OBJ_OP_SPEC_UNUSED_TMPVAR):
				VM_TRACE(CREX_ASSIGN_OBJ_OP_SPEC_UNUSED_TMPVAR)
				CREX_ASSIGN_OBJ_OP_SPEC_UNUSED_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_PRE_INC_OBJ_SPEC_UNUSED_TMPVAR):
				VM_TRACE(CREX_PRE_INC_OBJ_SPEC_UNUSED_TMPVAR)
				CREX_PRE_INC_OBJ_SPEC_UNUSED_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_POST_INC_OBJ_SPEC_UNUSED_TMPVAR):
				VM_TRACE(CREX_POST_INC_OBJ_SPEC_UNUSED_TMPVAR)
				CREX_POST_INC_OBJ_SPEC_UNUSED_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FETCH_OBJ_R_SPEC_UNUSED_TMPVAR):
				VM_TRACE(CREX_FETCH_OBJ_R_SPEC_UNUSED_TMPVAR)
				CREX_FETCH_OBJ_R_SPEC_UNUSED_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FETCH_OBJ_W_SPEC_UNUSED_TMPVAR):
				VM_TRACE(CREX_FETCH_OBJ_W_SPEC_UNUSED_TMPVAR)
				CREX_FETCH_OBJ_W_SPEC_UNUSED_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FETCH_OBJ_RW_SPEC_UNUSED_TMPVAR):
				VM_TRACE(CREX_FETCH_OBJ_RW_SPEC_UNUSED_TMPVAR)
				CREX_FETCH_OBJ_RW_SPEC_UNUSED_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FETCH_OBJ_IS_SPEC_UNUSED_TMPVAR):
				VM_TRACE(CREX_FETCH_OBJ_IS_SPEC_UNUSED_TMPVAR)
				CREX_FETCH_OBJ_IS_SPEC_UNUSED_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FETCH_OBJ_FUNC_ARG_SPEC_UNUSED_TMPVAR):
				VM_TRACE(CREX_FETCH_OBJ_FUNC_ARG_SPEC_UNUSED_TMPVAR)
				CREX_FETCH_OBJ_FUNC_ARG_SPEC_UNUSED_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FETCH_OBJ_UNSET_SPEC_UNUSED_TMPVAR):
				VM_TRACE(CREX_FETCH_OBJ_UNSET_SPEC_UNUSED_TMPVAR)
				CREX_FETCH_OBJ_UNSET_SPEC_UNUSED_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ASSIGN_OBJ_SPEC_UNUSED_TMPVAR_OP_DATA_CONST):
				VM_TRACE(CREX_ASSIGN_OBJ_SPEC_UNUSED_TMPVAR_OP_DATA_CONST)
				CREX_ASSIGN_OBJ_SPEC_UNUSED_TMPVAR_OP_DATA_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ASSIGN_OBJ_SPEC_UNUSED_TMPVAR_OP_DATA_TMP):
				VM_TRACE(CREX_ASSIGN_OBJ_SPEC_UNUSED_TMPVAR_OP_DATA_TMP)
				CREX_ASSIGN_OBJ_SPEC_UNUSED_TMPVAR_OP_DATA_TMP_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ASSIGN_OBJ_SPEC_UNUSED_TMPVAR_OP_DATA_VAR):
				VM_TRACE(CREX_ASSIGN_OBJ_SPEC_UNUSED_TMPVAR_OP_DATA_VAR)
				CREX_ASSIGN_OBJ_SPEC_UNUSED_TMPVAR_OP_DATA_VAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ASSIGN_OBJ_SPEC_UNUSED_TMPVAR_OP_DATA_CV):
				VM_TRACE(CREX_ASSIGN_OBJ_SPEC_UNUSED_TMPVAR_OP_DATA_CV)
				CREX_ASSIGN_OBJ_SPEC_UNUSED_TMPVAR_OP_DATA_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ASSIGN_OBJ_REF_SPEC_UNUSED_TMPVAR_OP_DATA_VAR):
				VM_TRACE(CREX_ASSIGN_OBJ_REF_SPEC_UNUSED_TMPVAR_OP_DATA_VAR)
				CREX_ASSIGN_OBJ_REF_SPEC_UNUSED_TMPVAR_OP_DATA_VAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ASSIGN_OBJ_REF_SPEC_UNUSED_TMPVAR_OP_DATA_CV):
				VM_TRACE(CREX_ASSIGN_OBJ_REF_SPEC_UNUSED_TMPVAR_OP_DATA_CV)
				CREX_ASSIGN_OBJ_REF_SPEC_UNUSED_TMPVAR_OP_DATA_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ROPE_INIT_SPEC_UNUSED_TMPVAR):
				VM_TRACE(CREX_ROPE_INIT_SPEC_UNUSED_TMPVAR)
				CREX_ROPE_INIT_SPEC_UNUSED_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FETCH_CLASS_SPEC_UNUSED_TMPVAR):
				VM_TRACE(CREX_FETCH_CLASS_SPEC_UNUSED_TMPVAR)
				CREX_FETCH_CLASS_SPEC_UNUSED_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_INIT_METHOD_CALL_SPEC_UNUSED_TMPVAR):
				VM_TRACE(CREX_INIT_METHOD_CALL_SPEC_UNUSED_TMPVAR)
				CREX_INIT_METHOD_CALL_SPEC_UNUSED_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_INIT_STATIC_METHOD_CALL_SPEC_UNUSED_TMPVAR):
				VM_TRACE(CREX_INIT_STATIC_METHOD_CALL_SPEC_UNUSED_TMPVAR)
				CREX_INIT_STATIC_METHOD_CALL_SPEC_UNUSED_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_INIT_ARRAY_SPEC_UNUSED_TMPVAR):
				VM_TRACE(CREX_INIT_ARRAY_SPEC_UNUSED_TMPVAR)
				CREX_INIT_ARRAY_SPEC_UNUSED_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_UNSET_OBJ_SPEC_UNUSED_TMPVAR):
				VM_TRACE(CREX_UNSET_OBJ_SPEC_UNUSED_TMPVAR)
				CREX_UNSET_OBJ_SPEC_UNUSED_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ISSET_ISEMPTY_PROP_OBJ_SPEC_UNUSED_TMPVAR):
				VM_TRACE(CREX_ISSET_ISEMPTY_PROP_OBJ_SPEC_UNUSED_TMPVAR)
				CREX_ISSET_ISEMPTY_PROP_OBJ_SPEC_UNUSED_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_YIELD_SPEC_UNUSED_TMPVAR):
				VM_TRACE(CREX_YIELD_SPEC_UNUSED_TMPVAR)
				CREX_YIELD_SPEC_UNUSED_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FETCH_CLASS_SPEC_UNUSED_UNUSED):
				VM_TRACE(CREX_FETCH_CLASS_SPEC_UNUSED_UNUSED)
				CREX_FETCH_CLASS_SPEC_UNUSED_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_INIT_STATIC_METHOD_CALL_SPEC_UNUSED_UNUSED):
				VM_TRACE(CREX_INIT_STATIC_METHOD_CALL_SPEC_UNUSED_UNUSED)
				CREX_INIT_STATIC_METHOD_CALL_SPEC_UNUSED_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_VERIFY_RETURN_TYPE_SPEC_UNUSED_UNUSED):
				VM_TRACE(CREX_VERIFY_RETURN_TYPE_SPEC_UNUSED_UNUSED)
				CREX_VERIFY_RETURN_TYPE_SPEC_UNUSED_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_VERIFY_NEVER_TYPE_SPEC_UNUSED_UNUSED):
				VM_TRACE(CREX_VERIFY_NEVER_TYPE_SPEC_UNUSED_UNUSED)
				CREX_VERIFY_NEVER_TYPE_SPEC_UNUSED_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_CHECK_FUNC_ARG_SPEC_UNUSED_UNUSED):
				VM_TRACE(CREX_CHECK_FUNC_ARG_SPEC_UNUSED_UNUSED)
				CREX_CHECK_FUNC_ARG_SPEC_UNUSED_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_CHECK_FUNC_ARG_SPEC_UNUSED_UNUSED_QUICK):
				VM_TRACE(CREX_CHECK_FUNC_ARG_SPEC_UNUSED_UNUSED_QUICK)
				CREX_CHECK_FUNC_ARG_SPEC_UNUSED_UNUSED_QUICK_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_CHECK_UNDEF_ARGS_SPEC_UNUSED_UNUSED):
				VM_TRACE(CREX_CHECK_UNDEF_ARGS_SPEC_UNUSED_UNUSED)
				CREX_CHECK_UNDEF_ARGS_SPEC_UNUSED_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_NEW_SPEC_UNUSED_UNUSED):
				VM_TRACE(CREX_NEW_SPEC_UNUSED_UNUSED)
				CREX_NEW_SPEC_UNUSED_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_INIT_ARRAY_SPEC_UNUSED_UNUSED):
				VM_TRACE(CREX_INIT_ARRAY_SPEC_UNUSED_UNUSED)
				CREX_INIT_ARRAY_SPEC_UNUSED_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_YIELD_SPEC_UNUSED_UNUSED):
				VM_TRACE(CREX_YIELD_SPEC_UNUSED_UNUSED)
				CREX_YIELD_SPEC_UNUSED_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FETCH_THIS_SPEC_UNUSED_UNUSED):
				VM_TRACE(CREX_FETCH_THIS_SPEC_UNUSED_UNUSED)
				CREX_FETCH_THIS_SPEC_UNUSED_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FETCH_GLOBALS_SPEC_UNUSED_UNUSED):
				VM_TRACE(CREX_FETCH_GLOBALS_SPEC_UNUSED_UNUSED)
				CREX_FETCH_GLOBALS_SPEC_UNUSED_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ISSET_ISEMPTY_THIS_SPEC_UNUSED_UNUSED):
				VM_TRACE(CREX_ISSET_ISEMPTY_THIS_SPEC_UNUSED_UNUSED)
				CREX_ISSET_ISEMPTY_THIS_SPEC_UNUSED_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_GET_CLASS_SPEC_UNUSED_UNUSED):
				VM_TRACE(CREX_GET_CLASS_SPEC_UNUSED_UNUSED)
				CREX_GET_CLASS_SPEC_UNUSED_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_GET_CALLED_CLASS_SPEC_UNUSED_UNUSED):
				VM_TRACE(CREX_GET_CALLED_CLASS_SPEC_UNUSED_UNUSED)
				CREX_GET_CALLED_CLASS_SPEC_UNUSED_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FUNC_NUM_ARGS_SPEC_UNUSED_UNUSED):
				VM_TRACE(CREX_FUNC_NUM_ARGS_SPEC_UNUSED_UNUSED)
				CREX_FUNC_NUM_ARGS_SPEC_UNUSED_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FUNC_GET_ARGS_SPEC_UNUSED_UNUSED):
				VM_TRACE(CREX_FUNC_GET_ARGS_SPEC_UNUSED_UNUSED)
				CREX_FUNC_GET_ARGS_SPEC_UNUSED_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_CALLABLE_CONVERT_SPEC_UNUSED_UNUSED):
				VM_TRACE(CREX_CALLABLE_CONVERT_SPEC_UNUSED_UNUSED)
				CREX_CALLABLE_CONVERT_SPEC_UNUSED_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ASSIGN_OBJ_OP_SPEC_UNUSED_CV):
				VM_TRACE(CREX_ASSIGN_OBJ_OP_SPEC_UNUSED_CV)
				CREX_ASSIGN_OBJ_OP_SPEC_UNUSED_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_PRE_INC_OBJ_SPEC_UNUSED_CV):
				VM_TRACE(CREX_PRE_INC_OBJ_SPEC_UNUSED_CV)
				CREX_PRE_INC_OBJ_SPEC_UNUSED_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_POST_INC_OBJ_SPEC_UNUSED_CV):
				VM_TRACE(CREX_POST_INC_OBJ_SPEC_UNUSED_CV)
				CREX_POST_INC_OBJ_SPEC_UNUSED_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FETCH_OBJ_R_SPEC_UNUSED_CV):
				VM_TRACE(CREX_FETCH_OBJ_R_SPEC_UNUSED_CV)
				CREX_FETCH_OBJ_R_SPEC_UNUSED_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FETCH_OBJ_W_SPEC_UNUSED_CV):
				VM_TRACE(CREX_FETCH_OBJ_W_SPEC_UNUSED_CV)
				CREX_FETCH_OBJ_W_SPEC_UNUSED_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FETCH_OBJ_RW_SPEC_UNUSED_CV):
				VM_TRACE(CREX_FETCH_OBJ_RW_SPEC_UNUSED_CV)
				CREX_FETCH_OBJ_RW_SPEC_UNUSED_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FETCH_OBJ_IS_SPEC_UNUSED_CV):
				VM_TRACE(CREX_FETCH_OBJ_IS_SPEC_UNUSED_CV)
				CREX_FETCH_OBJ_IS_SPEC_UNUSED_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FETCH_OBJ_FUNC_ARG_SPEC_UNUSED_CV):
				VM_TRACE(CREX_FETCH_OBJ_FUNC_ARG_SPEC_UNUSED_CV)
				CREX_FETCH_OBJ_FUNC_ARG_SPEC_UNUSED_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FETCH_OBJ_UNSET_SPEC_UNUSED_CV):
				VM_TRACE(CREX_FETCH_OBJ_UNSET_SPEC_UNUSED_CV)
				CREX_FETCH_OBJ_UNSET_SPEC_UNUSED_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ASSIGN_OBJ_SPEC_UNUSED_CV_OP_DATA_CONST):
				VM_TRACE(CREX_ASSIGN_OBJ_SPEC_UNUSED_CV_OP_DATA_CONST)
				CREX_ASSIGN_OBJ_SPEC_UNUSED_CV_OP_DATA_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ASSIGN_OBJ_SPEC_UNUSED_CV_OP_DATA_TMP):
				VM_TRACE(CREX_ASSIGN_OBJ_SPEC_UNUSED_CV_OP_DATA_TMP)
				CREX_ASSIGN_OBJ_SPEC_UNUSED_CV_OP_DATA_TMP_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ASSIGN_OBJ_SPEC_UNUSED_CV_OP_DATA_VAR):
				VM_TRACE(CREX_ASSIGN_OBJ_SPEC_UNUSED_CV_OP_DATA_VAR)
				CREX_ASSIGN_OBJ_SPEC_UNUSED_CV_OP_DATA_VAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ASSIGN_OBJ_SPEC_UNUSED_CV_OP_DATA_CV):
				VM_TRACE(CREX_ASSIGN_OBJ_SPEC_UNUSED_CV_OP_DATA_CV)
				CREX_ASSIGN_OBJ_SPEC_UNUSED_CV_OP_DATA_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ASSIGN_OBJ_REF_SPEC_UNUSED_CV_OP_DATA_VAR):
				VM_TRACE(CREX_ASSIGN_OBJ_REF_SPEC_UNUSED_CV_OP_DATA_VAR)
				CREX_ASSIGN_OBJ_REF_SPEC_UNUSED_CV_OP_DATA_VAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ASSIGN_OBJ_REF_SPEC_UNUSED_CV_OP_DATA_CV):
				VM_TRACE(CREX_ASSIGN_OBJ_REF_SPEC_UNUSED_CV_OP_DATA_CV)
				CREX_ASSIGN_OBJ_REF_SPEC_UNUSED_CV_OP_DATA_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ROPE_INIT_SPEC_UNUSED_CV):
				VM_TRACE(CREX_ROPE_INIT_SPEC_UNUSED_CV)
				CREX_ROPE_INIT_SPEC_UNUSED_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FETCH_CLASS_SPEC_UNUSED_CV):
				VM_TRACE(CREX_FETCH_CLASS_SPEC_UNUSED_CV)
				CREX_FETCH_CLASS_SPEC_UNUSED_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_INIT_METHOD_CALL_SPEC_UNUSED_CV):
				VM_TRACE(CREX_INIT_METHOD_CALL_SPEC_UNUSED_CV)
				CREX_INIT_METHOD_CALL_SPEC_UNUSED_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_INIT_STATIC_METHOD_CALL_SPEC_UNUSED_CV):
				VM_TRACE(CREX_INIT_STATIC_METHOD_CALL_SPEC_UNUSED_CV)
				CREX_INIT_STATIC_METHOD_CALL_SPEC_UNUSED_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_INIT_ARRAY_SPEC_UNUSED_CV):
				VM_TRACE(CREX_INIT_ARRAY_SPEC_UNUSED_CV)
				CREX_INIT_ARRAY_SPEC_UNUSED_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_UNSET_OBJ_SPEC_UNUSED_CV):
				VM_TRACE(CREX_UNSET_OBJ_SPEC_UNUSED_CV)
				CREX_UNSET_OBJ_SPEC_UNUSED_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ISSET_ISEMPTY_PROP_OBJ_SPEC_UNUSED_CV):
				VM_TRACE(CREX_ISSET_ISEMPTY_PROP_OBJ_SPEC_UNUSED_CV)
				CREX_ISSET_ISEMPTY_PROP_OBJ_SPEC_UNUSED_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_YIELD_SPEC_UNUSED_CV):
				VM_TRACE(CREX_YIELD_SPEC_UNUSED_CV)
				CREX_YIELD_SPEC_UNUSED_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_BOOL_NOT_SPEC_CV):
				VM_TRACE(CREX_BOOL_NOT_SPEC_CV)
				CREX_BOOL_NOT_SPEC_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_PRE_INC_SPEC_CV_RETVAL_UNUSED):
				VM_TRACE(CREX_PRE_INC_SPEC_CV_RETVAL_UNUSED)
				CREX_PRE_INC_SPEC_CV_RETVAL_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_PRE_INC_SPEC_CV_RETVAL_USED):
				VM_TRACE(CREX_PRE_INC_SPEC_CV_RETVAL_USED)
				CREX_PRE_INC_SPEC_CV_RETVAL_USED_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_PRE_DEC_SPEC_CV_RETVAL_UNUSED):
				VM_TRACE(CREX_PRE_DEC_SPEC_CV_RETVAL_UNUSED)
				CREX_PRE_DEC_SPEC_CV_RETVAL_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_PRE_DEC_SPEC_CV_RETVAL_USED):
				VM_TRACE(CREX_PRE_DEC_SPEC_CV_RETVAL_USED)
				CREX_PRE_DEC_SPEC_CV_RETVAL_USED_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_POST_INC_SPEC_CV):
				VM_TRACE(CREX_POST_INC_SPEC_CV)
				CREX_POST_INC_SPEC_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_POST_DEC_SPEC_CV):
				VM_TRACE(CREX_POST_DEC_SPEC_CV)
				CREX_POST_DEC_SPEC_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ECHO_SPEC_CV):
				VM_TRACE(CREX_ECHO_SPEC_CV)
				CREX_ECHO_SPEC_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_JMPC_SPEC_CV):
				VM_TRACE(CREX_JMPC_SPEC_CV)
				CREX_JMPC_SPEC_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_JMPNC_SPEC_CV):
				VM_TRACE(CREX_JMPNC_SPEC_CV)
				CREX_JMPNC_SPEC_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_JMPC_EX_SPEC_CV):
				VM_TRACE(CREX_JMPC_EX_SPEC_CV)
				CREX_JMPC_EX_SPEC_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_JMPNC_EX_SPEC_CV):
				VM_TRACE(CREX_JMPNC_EX_SPEC_CV)
				CREX_JMPNC_EX_SPEC_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_RETURN_SPEC_CV):
				VM_TRACE(CREX_RETURN_SPEC_CV)
{
	USE_OPLINE
	zval *retval_ptr;
	zval *return_value;

	retval_ptr = EX_VAR(opline->op1.var);
	return_value = EX(return_value);

	if (IS_CV == IS_CV && UNEXPECTED(C_TYPE_INFO_P(retval_ptr) == IS_UNDEF)) {
		SAVE_OPLINE();
		retval_ptr = ZVAL_UNDEFINED_OP1();
		if (return_value) {
			ZVAL_NULL(return_value);
		}
	} else if (!return_value) {
		if (IS_CV & (IS_VAR|IS_TMP_VAR)) {
			if (C_REFCOUNTED_P(retval_ptr) && !C_DELREF_P(retval_ptr)) {
				SAVE_OPLINE();
				rc_dtor_func(C_COUNTED_P(retval_ptr));
			}
		}
	} else {
		if ((IS_CV & (IS_CONST|IS_TMP_VAR))) {
			ZVAL_COPY_VALUE(return_value, retval_ptr);
			if (IS_CV == IS_CONST) {
				if (UNEXPECTED(C_OPT_REFCOUNTED_P(return_value))) {
					C_ADDREF_P(return_value);
				}
			}
		} else if (IS_CV == IS_CV) {
			do {
				if (C_OPT_REFCOUNTED_P(retval_ptr)) {
					if (EXPECTED(!C_OPT_ISREF_P(retval_ptr))) {
						if (EXPECTED(!(EX_CALL_INFO() & (CREX_CALL_CODE|CREX_CALL_OBSERVED)))) {
							crex_refcounted *ref = C_COUNTED_P(retval_ptr);
							ZVAL_COPY_VALUE(return_value, retval_ptr);
							if (GC_MAY_LEAK(ref)) {
								SAVE_OPLINE();
								gc_possible_root(ref);
							}
							ZVAL_NULL(retval_ptr);
							break;
						} else {
							C_ADDREF_P(retval_ptr);
						}
					} else {
						retval_ptr = C_REFVAL_P(retval_ptr);
						if (C_OPT_REFCOUNTED_P(retval_ptr)) {
							C_ADDREF_P(retval_ptr);
						}
					}
				}
				ZVAL_COPY_VALUE(return_value, retval_ptr);
			} while (0);
		} else /* if (IS_CV == IS_VAR) */ {
			if (UNEXPECTED(C_ISREF_P(retval_ptr))) {
				crex_refcounted *ref = C_COUNTED_P(retval_ptr);

				retval_ptr = C_REFVAL_P(retval_ptr);
				ZVAL_COPY_VALUE(return_value, retval_ptr);
				if (UNEXPECTED(GC_DELREF(ref) == 0)) {
					efree_size(ref, sizeof(crex_reference));
				} else if (C_OPT_REFCOUNTED_P(retval_ptr)) {
					C_ADDREF_P(retval_ptr);
				}
			} else {
				ZVAL_COPY_VALUE(return_value, retval_ptr);
			}
		}
	}



	goto crex_leave_helper_SPEC_LABEL;
}

			HYBRID_CASE(CREX_RETURN_BY_REF_SPEC_CV):
				VM_TRACE(CREX_RETURN_BY_REF_SPEC_CV)
				CREX_RETURN_BY_REF_SPEC_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_GENERATOR_RETURN_SPEC_CV):
				VM_TRACE(CREX_GENERATOR_RETURN_SPEC_CV)
				CREX_GENERATOR_RETURN_SPEC_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_THROW_SPEC_CV):
				VM_TRACE(CREX_THROW_SPEC_CV)
				CREX_THROW_SPEC_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_SEND_USER_SPEC_CV):
				VM_TRACE(CREX_SEND_USER_SPEC_CV)
				CREX_SEND_USER_SPEC_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_BOOL_SPEC_CV):
				VM_TRACE(CREX_BOOL_SPEC_CV)
				CREX_BOOL_SPEC_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_CLONE_SPEC_CV):
				VM_TRACE(CREX_CLONE_SPEC_CV)
				CREX_CLONE_SPEC_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_CAST_SPEC_CV):
				VM_TRACE(CREX_CAST_SPEC_CV)
				CREX_CAST_SPEC_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_INCLUDE_OR_EVAL_SPEC_CV):
				VM_TRACE(CREX_INCLUDE_OR_EVAL_SPEC_CV)
				CREX_INCLUDE_OR_EVAL_SPEC_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FE_RESET_R_SPEC_CV):
				VM_TRACE(CREX_FE_RESET_R_SPEC_CV)
				CREX_FE_RESET_R_SPEC_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FE_RESET_RW_SPEC_CV):
				VM_TRACE(CREX_FE_RESET_RW_SPEC_CV)
				CREX_FE_RESET_RW_SPEC_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_JMP_SET_SPEC_CV):
				VM_TRACE(CREX_JMP_SET_SPEC_CV)
				CREX_JMP_SET_SPEC_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_COALESCE_SPEC_CV):
				VM_TRACE(CREX_COALESCE_SPEC_CV)
				CREX_COALESCE_SPEC_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_JMP_NULL_SPEC_CV):
				VM_TRACE(CREX_JMP_NULL_SPEC_CV)
				CREX_JMP_NULL_SPEC_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_QM_ASSIGN_SPEC_CV):
				VM_TRACE(CREX_QM_ASSIGN_SPEC_CV)
				CREX_QM_ASSIGN_SPEC_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_YIELD_FROM_SPEC_CV):
				VM_TRACE(CREX_YIELD_FROM_SPEC_CV)
				CREX_YIELD_FROM_SPEC_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_STRLEN_SPEC_CV):
				VM_TRACE(CREX_STRLEN_SPEC_CV)
				CREX_STRLEN_SPEC_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_TYPE_CHECK_SPEC_CV):
				VM_TRACE(CREX_TYPE_CHECK_SPEC_CV)
				CREX_TYPE_CHECK_SPEC_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FETCH_CLASS_NAME_SPEC_CV):
				VM_TRACE(CREX_FETCH_CLASS_NAME_SPEC_CV)
				CREX_FETCH_CLASS_NAME_SPEC_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_BIND_STATIC_SPEC_CV):
				VM_TRACE(CREX_BIND_STATIC_SPEC_CV)
				CREX_BIND_STATIC_SPEC_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_BIND_INIT_STATIC_OR_JMP_SPEC_CV):
				VM_TRACE(CREX_BIND_INIT_STATIC_OR_JMP_SPEC_CV)
				CREX_BIND_INIT_STATIC_OR_JMP_SPEC_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_PRE_INC_LONG_NO_OVERFLOW_SPEC_CV_RETVAL_UNUSED):
				VM_TRACE(CREX_PRE_INC_LONG_NO_OVERFLOW_SPEC_CV_RETVAL_UNUSED)
				CREX_PRE_INC_LONG_NO_OVERFLOW_SPEC_CV_RETVAL_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_PRE_INC_LONG_NO_OVERFLOW_SPEC_CV_RETVAL_USED):
				VM_TRACE(CREX_PRE_INC_LONG_NO_OVERFLOW_SPEC_CV_RETVAL_USED)
				CREX_PRE_INC_LONG_NO_OVERFLOW_SPEC_CV_RETVAL_USED_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_PRE_INC_LONG_SPEC_CV_RETVAL_UNUSED):
				VM_TRACE(CREX_PRE_INC_LONG_SPEC_CV_RETVAL_UNUSED)
				CREX_PRE_INC_LONG_SPEC_CV_RETVAL_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_PRE_INC_LONG_SPEC_CV_RETVAL_USED):
				VM_TRACE(CREX_PRE_INC_LONG_SPEC_CV_RETVAL_USED)
				CREX_PRE_INC_LONG_SPEC_CV_RETVAL_USED_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_PRE_DEC_LONG_NO_OVERFLOW_SPEC_CV_RETVAL_UNUSED):
				VM_TRACE(CREX_PRE_DEC_LONG_NO_OVERFLOW_SPEC_CV_RETVAL_UNUSED)
				CREX_PRE_DEC_LONG_NO_OVERFLOW_SPEC_CV_RETVAL_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_PRE_DEC_LONG_NO_OVERFLOW_SPEC_CV_RETVAL_USED):
				VM_TRACE(CREX_PRE_DEC_LONG_NO_OVERFLOW_SPEC_CV_RETVAL_USED)
				CREX_PRE_DEC_LONG_NO_OVERFLOW_SPEC_CV_RETVAL_USED_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_PRE_DEC_LONG_SPEC_CV_RETVAL_UNUSED):
				VM_TRACE(CREX_PRE_DEC_LONG_SPEC_CV_RETVAL_UNUSED)
				CREX_PRE_DEC_LONG_SPEC_CV_RETVAL_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_PRE_DEC_LONG_SPEC_CV_RETVAL_USED):
				VM_TRACE(CREX_PRE_DEC_LONG_SPEC_CV_RETVAL_USED)
				CREX_PRE_DEC_LONG_SPEC_CV_RETVAL_USED_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_POST_INC_LONG_NO_OVERFLOW_SPEC_CV):
				VM_TRACE(CREX_POST_INC_LONG_NO_OVERFLOW_SPEC_CV)
				CREX_POST_INC_LONG_NO_OVERFLOW_SPEC_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_POST_INC_LONG_SPEC_CV):
				VM_TRACE(CREX_POST_INC_LONG_SPEC_CV)
				CREX_POST_INC_LONG_SPEC_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_POST_DEC_LONG_NO_OVERFLOW_SPEC_CV):
				VM_TRACE(CREX_POST_DEC_LONG_NO_OVERFLOW_SPEC_CV)
				CREX_POST_DEC_LONG_NO_OVERFLOW_SPEC_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_POST_DEC_LONG_SPEC_CV):
				VM_TRACE(CREX_POST_DEC_LONG_SPEC_CV)
				CREX_POST_DEC_LONG_SPEC_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_SEND_VAR_SIMPLE_SPEC_CV):
				VM_TRACE(CREX_SEND_VAR_SIMPLE_SPEC_CV)
				CREX_SEND_VAR_SIMPLE_SPEC_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_DIV_SPEC_CV_CONST):
				VM_TRACE(CREX_DIV_SPEC_CV_CONST)
				CREX_DIV_SPEC_CV_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_POW_SPEC_CV_CONST):
				VM_TRACE(CREX_POW_SPEC_CV_CONST)
				CREX_POW_SPEC_CV_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_CONCAT_SPEC_CV_CONST):
				VM_TRACE(CREX_CONCAT_SPEC_CV_CONST)
				CREX_CONCAT_SPEC_CV_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_IS_IDENTICAL_SPEC_CV_CONST):
				VM_TRACE(CREX_IS_IDENTICAL_SPEC_CV_CONST)
				CREX_IS_IDENTICAL_SPEC_CV_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_IS_NOT_IDENTICAL_SPEC_CV_CONST):
				VM_TRACE(CREX_IS_NOT_IDENTICAL_SPEC_CV_CONST)
				CREX_IS_NOT_IDENTICAL_SPEC_CV_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_IS_EQUAL_SPEC_CV_CONST):
				VM_TRACE(CREX_IS_EQUAL_SPEC_CV_CONST)
				CREX_IS_EQUAL_SPEC_CV_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_IS_EQUAL_SPEC_CV_CONST_JMPZ):
				VM_TRACE(CREX_IS_EQUAL_SPEC_CV_CONST_JMPZ)
				CREX_IS_EQUAL_SPEC_CV_CONST_JMPC_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_IS_EQUAL_SPEC_CV_CONST_JMPNZ):
				VM_TRACE(CREX_IS_EQUAL_SPEC_CV_CONST_JMPNZ)
				CREX_IS_EQUAL_SPEC_CV_CONST_JMPNC_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_IS_NOT_EQUAL_SPEC_CV_CONST):
				VM_TRACE(CREX_IS_NOT_EQUAL_SPEC_CV_CONST)
				CREX_IS_NOT_EQUAL_SPEC_CV_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_IS_NOT_EQUAL_SPEC_CV_CONST_JMPZ):
				VM_TRACE(CREX_IS_NOT_EQUAL_SPEC_CV_CONST_JMPZ)
				CREX_IS_NOT_EQUAL_SPEC_CV_CONST_JMPC_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_IS_NOT_EQUAL_SPEC_CV_CONST_JMPNZ):
				VM_TRACE(CREX_IS_NOT_EQUAL_SPEC_CV_CONST_JMPNZ)
				CREX_IS_NOT_EQUAL_SPEC_CV_CONST_JMPNC_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_SPACESHIP_SPEC_CV_CONST):
				VM_TRACE(CREX_SPACESHIP_SPEC_CV_CONST)
				CREX_SPACESHIP_SPEC_CV_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_BOOL_XOR_SPEC_CV_CONST):
				VM_TRACE(CREX_BOOL_XOR_SPEC_CV_CONST)
				CREX_BOOL_XOR_SPEC_CV_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ASSIGN_OBJ_OP_SPEC_CV_CONST):
				VM_TRACE(CREX_ASSIGN_OBJ_OP_SPEC_CV_CONST)
				CREX_ASSIGN_OBJ_OP_SPEC_CV_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ASSIGN_DIM_OP_SPEC_CV_CONST):
				VM_TRACE(CREX_ASSIGN_DIM_OP_SPEC_CV_CONST)
				CREX_ASSIGN_DIM_OP_SPEC_CV_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ASSIGN_OP_SPEC_CV_CONST):
				VM_TRACE(CREX_ASSIGN_OP_SPEC_CV_CONST)
				CREX_ASSIGN_OP_SPEC_CV_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_PRE_INC_OBJ_SPEC_CV_CONST):
				VM_TRACE(CREX_PRE_INC_OBJ_SPEC_CV_CONST)
				CREX_PRE_INC_OBJ_SPEC_CV_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_POST_INC_OBJ_SPEC_CV_CONST):
				VM_TRACE(CREX_POST_INC_OBJ_SPEC_CV_CONST)
				CREX_POST_INC_OBJ_SPEC_CV_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FETCH_DIM_R_SPEC_CV_CONST):
				VM_TRACE(CREX_FETCH_DIM_R_SPEC_CV_CONST)
				CREX_FETCH_DIM_R_SPEC_CV_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FETCH_DIM_W_SPEC_CV_CONST):
				VM_TRACE(CREX_FETCH_DIM_W_SPEC_CV_CONST)
				CREX_FETCH_DIM_W_SPEC_CV_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FETCH_DIM_RW_SPEC_CV_CONST):
				VM_TRACE(CREX_FETCH_DIM_RW_SPEC_CV_CONST)
				CREX_FETCH_DIM_RW_SPEC_CV_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FETCH_DIM_IS_SPEC_CV_CONST):
				VM_TRACE(CREX_FETCH_DIM_IS_SPEC_CV_CONST)
				CREX_FETCH_DIM_IS_SPEC_CV_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FETCH_DIM_FUNC_ARG_SPEC_CV_CONST):
				VM_TRACE(CREX_FETCH_DIM_FUNC_ARG_SPEC_CV_CONST)
				CREX_FETCH_DIM_FUNC_ARG_SPEC_CV_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FETCH_DIM_UNSET_SPEC_CV_CONST):
				VM_TRACE(CREX_FETCH_DIM_UNSET_SPEC_CV_CONST)
				CREX_FETCH_DIM_UNSET_SPEC_CV_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FETCH_OBJ_R_SPEC_CV_CONST):
				VM_TRACE(CREX_FETCH_OBJ_R_SPEC_CV_CONST)
				CREX_FETCH_OBJ_R_SPEC_CV_CONST_INLINE_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FETCH_OBJ_W_SPEC_CV_CONST):
				VM_TRACE(CREX_FETCH_OBJ_W_SPEC_CV_CONST)
				CREX_FETCH_OBJ_W_SPEC_CV_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FETCH_OBJ_RW_SPEC_CV_CONST):
				VM_TRACE(CREX_FETCH_OBJ_RW_SPEC_CV_CONST)
				CREX_FETCH_OBJ_RW_SPEC_CV_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FETCH_OBJ_IS_SPEC_CV_CONST):
				VM_TRACE(CREX_FETCH_OBJ_IS_SPEC_CV_CONST)
				CREX_FETCH_OBJ_IS_SPEC_CV_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FETCH_OBJ_FUNC_ARG_SPEC_CV_CONST):
				VM_TRACE(CREX_FETCH_OBJ_FUNC_ARG_SPEC_CV_CONST)
				CREX_FETCH_OBJ_FUNC_ARG_SPEC_CV_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FETCH_OBJ_UNSET_SPEC_CV_CONST):
				VM_TRACE(CREX_FETCH_OBJ_UNSET_SPEC_CV_CONST)
				CREX_FETCH_OBJ_UNSET_SPEC_CV_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ASSIGN_OBJ_SPEC_CV_CONST_OP_DATA_CONST):
				VM_TRACE(CREX_ASSIGN_OBJ_SPEC_CV_CONST_OP_DATA_CONST)
				CREX_ASSIGN_OBJ_SPEC_CV_CONST_OP_DATA_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ASSIGN_OBJ_SPEC_CV_CONST_OP_DATA_TMP):
				VM_TRACE(CREX_ASSIGN_OBJ_SPEC_CV_CONST_OP_DATA_TMP)
				CREX_ASSIGN_OBJ_SPEC_CV_CONST_OP_DATA_TMP_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ASSIGN_OBJ_SPEC_CV_CONST_OP_DATA_VAR):
				VM_TRACE(CREX_ASSIGN_OBJ_SPEC_CV_CONST_OP_DATA_VAR)
				CREX_ASSIGN_OBJ_SPEC_CV_CONST_OP_DATA_VAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ASSIGN_OBJ_SPEC_CV_CONST_OP_DATA_CV):
				VM_TRACE(CREX_ASSIGN_OBJ_SPEC_CV_CONST_OP_DATA_CV)
				CREX_ASSIGN_OBJ_SPEC_CV_CONST_OP_DATA_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ASSIGN_DIM_SPEC_CV_CONST_OP_DATA_CONST):
				VM_TRACE(CREX_ASSIGN_DIM_SPEC_CV_CONST_OP_DATA_CONST)
				CREX_ASSIGN_DIM_SPEC_CV_CONST_OP_DATA_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ASSIGN_DIM_SPEC_CV_CONST_OP_DATA_TMP):
				VM_TRACE(CREX_ASSIGN_DIM_SPEC_CV_CONST_OP_DATA_TMP)
				CREX_ASSIGN_DIM_SPEC_CV_CONST_OP_DATA_TMP_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ASSIGN_DIM_SPEC_CV_CONST_OP_DATA_VAR):
				VM_TRACE(CREX_ASSIGN_DIM_SPEC_CV_CONST_OP_DATA_VAR)
				CREX_ASSIGN_DIM_SPEC_CV_CONST_OP_DATA_VAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ASSIGN_DIM_SPEC_CV_CONST_OP_DATA_CV):
				VM_TRACE(CREX_ASSIGN_DIM_SPEC_CV_CONST_OP_DATA_CV)
				CREX_ASSIGN_DIM_SPEC_CV_CONST_OP_DATA_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ASSIGN_SPEC_CV_CONST_RETVAL_UNUSED):
				VM_TRACE(CREX_ASSIGN_SPEC_CV_CONST_RETVAL_UNUSED)
				CREX_ASSIGN_SPEC_CV_CONST_RETVAL_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ASSIGN_SPEC_CV_CONST_RETVAL_USED):
				VM_TRACE(CREX_ASSIGN_SPEC_CV_CONST_RETVAL_USED)
				CREX_ASSIGN_SPEC_CV_CONST_RETVAL_USED_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ASSIGN_OBJ_REF_SPEC_CV_CONST_OP_DATA_VAR):
				VM_TRACE(CREX_ASSIGN_OBJ_REF_SPEC_CV_CONST_OP_DATA_VAR)
				CREX_ASSIGN_OBJ_REF_SPEC_CV_CONST_OP_DATA_VAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ASSIGN_OBJ_REF_SPEC_CV_CONST_OP_DATA_CV):
				VM_TRACE(CREX_ASSIGN_OBJ_REF_SPEC_CV_CONST_OP_DATA_CV)
				CREX_ASSIGN_OBJ_REF_SPEC_CV_CONST_OP_DATA_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FAST_CONCAT_SPEC_CV_CONST):
				VM_TRACE(CREX_FAST_CONCAT_SPEC_CV_CONST)
				CREX_FAST_CONCAT_SPEC_CV_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_INIT_METHOD_CALL_SPEC_CV_CONST):
				VM_TRACE(CREX_INIT_METHOD_CALL_SPEC_CV_CONST)
				CREX_INIT_METHOD_CALL_SPEC_CV_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_SEND_VAR_SPEC_CV_CONST):
				VM_TRACE(CREX_SEND_VAR_SPEC_CV_CONST)
				CREX_SEND_VAR_SPEC_CV_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_SEND_REF_SPEC_CV_CONST):
				VM_TRACE(CREX_SEND_REF_SPEC_CV_CONST)
				CREX_SEND_REF_SPEC_CV_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_SEND_VAR_EX_SPEC_CV_CONST):
				VM_TRACE(CREX_SEND_VAR_EX_SPEC_CV_CONST)
				CREX_SEND_VAR_EX_SPEC_CV_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ADD_ARRAY_ELEMENT_SPEC_CV_CONST):
				VM_TRACE(CREX_ADD_ARRAY_ELEMENT_SPEC_CV_CONST)
				CREX_ADD_ARRAY_ELEMENT_SPEC_CV_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_INIT_ARRAY_SPEC_CV_CONST):
				VM_TRACE(CREX_INIT_ARRAY_SPEC_CV_CONST)
				CREX_INIT_ARRAY_SPEC_CV_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_UNSET_DIM_SPEC_CV_CONST):
				VM_TRACE(CREX_UNSET_DIM_SPEC_CV_CONST)
				CREX_UNSET_DIM_SPEC_CV_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_UNSET_OBJ_SPEC_CV_CONST):
				VM_TRACE(CREX_UNSET_OBJ_SPEC_CV_CONST)
				CREX_UNSET_OBJ_SPEC_CV_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ISSET_ISEMPTY_DIM_OBJ_SPEC_CV_CONST):
				VM_TRACE(CREX_ISSET_ISEMPTY_DIM_OBJ_SPEC_CV_CONST)
				CREX_ISSET_ISEMPTY_DIM_OBJ_SPEC_CV_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ISSET_ISEMPTY_PROP_OBJ_SPEC_CV_CONST):
				VM_TRACE(CREX_ISSET_ISEMPTY_PROP_OBJ_SPEC_CV_CONST)
				CREX_ISSET_ISEMPTY_PROP_OBJ_SPEC_CV_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ARRAY_KEY_EXISTS_SPEC_CV_CONST):
				VM_TRACE(CREX_ARRAY_KEY_EXISTS_SPEC_CV_CONST)
				CREX_ARRAY_KEY_EXISTS_SPEC_CV_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_INSTANCEOF_SPEC_CV_CONST):
				VM_TRACE(CREX_INSTANCEOF_SPEC_CV_CONST)
				CREX_INSTANCEOF_SPEC_CV_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_YIELD_SPEC_CV_CONST):
				VM_TRACE(CREX_YIELD_SPEC_CV_CONST)
				CREX_YIELD_SPEC_CV_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_BIND_GLOBAL_SPEC_CV_CONST):
				VM_TRACE(CREX_BIND_GLOBAL_SPEC_CV_CONST)
				CREX_BIND_GLOBAL_SPEC_CV_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_IN_ARRAY_SPEC_CV_CONST):
				VM_TRACE(CREX_IN_ARRAY_SPEC_CV_CONST)
				CREX_IN_ARRAY_SPEC_CV_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_IS_IDENTICAL_NOTHROW_SPEC_CV_CONST):
				VM_TRACE(CREX_IS_IDENTICAL_NOTHROW_SPEC_CV_CONST)
				CREX_IS_IDENTICAL_NOTHROW_SPEC_CV_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_IS_NOT_IDENTICAL_NOTHROW_SPEC_CV_CONST):
				VM_TRACE(CREX_IS_NOT_IDENTICAL_NOTHROW_SPEC_CV_CONST)
				CREX_IS_NOT_IDENTICAL_NOTHROW_SPEC_CV_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FETCH_DIM_R_INDEX_SPEC_CV_CONST):
				VM_TRACE(CREX_FETCH_DIM_R_INDEX_SPEC_CV_CONST)
				CREX_FETCH_DIM_R_INDEX_SPEC_CV_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FETCH_DIM_R_INDEX_SPEC_CV_TMPVARCV):
				VM_TRACE(CREX_FETCH_DIM_R_INDEX_SPEC_CV_TMPVARCV)
				CREX_FETCH_DIM_R_INDEX_SPEC_CV_TMPVARCV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_DIV_SPEC_CV_TMPVAR):
				VM_TRACE(CREX_DIV_SPEC_CV_TMPVAR)
				CREX_DIV_SPEC_CV_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_POW_SPEC_CV_TMPVAR):
				VM_TRACE(CREX_POW_SPEC_CV_TMPVAR)
				CREX_POW_SPEC_CV_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_CONCAT_SPEC_CV_TMPVAR):
				VM_TRACE(CREX_CONCAT_SPEC_CV_TMPVAR)
				CREX_CONCAT_SPEC_CV_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_IS_EQUAL_SPEC_CV_TMPVAR):
				VM_TRACE(CREX_IS_EQUAL_SPEC_CV_TMPVAR)
				CREX_IS_EQUAL_SPEC_CV_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_IS_EQUAL_SPEC_CV_TMPVAR_JMPZ):
				VM_TRACE(CREX_IS_EQUAL_SPEC_CV_TMPVAR_JMPZ)
				CREX_IS_EQUAL_SPEC_CV_TMPVAR_JMPC_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_IS_EQUAL_SPEC_CV_TMPVAR_JMPNZ):
				VM_TRACE(CREX_IS_EQUAL_SPEC_CV_TMPVAR_JMPNZ)
				CREX_IS_EQUAL_SPEC_CV_TMPVAR_JMPNC_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_IS_NOT_EQUAL_SPEC_CV_TMPVAR):
				VM_TRACE(CREX_IS_NOT_EQUAL_SPEC_CV_TMPVAR)
				CREX_IS_NOT_EQUAL_SPEC_CV_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_IS_NOT_EQUAL_SPEC_CV_TMPVAR_JMPZ):
				VM_TRACE(CREX_IS_NOT_EQUAL_SPEC_CV_TMPVAR_JMPZ)
				CREX_IS_NOT_EQUAL_SPEC_CV_TMPVAR_JMPC_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_IS_NOT_EQUAL_SPEC_CV_TMPVAR_JMPNZ):
				VM_TRACE(CREX_IS_NOT_EQUAL_SPEC_CV_TMPVAR_JMPNZ)
				CREX_IS_NOT_EQUAL_SPEC_CV_TMPVAR_JMPNC_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_SPACESHIP_SPEC_CV_TMPVAR):
				VM_TRACE(CREX_SPACESHIP_SPEC_CV_TMPVAR)
				CREX_SPACESHIP_SPEC_CV_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_BOOL_XOR_SPEC_CV_TMPVAR):
				VM_TRACE(CREX_BOOL_XOR_SPEC_CV_TMPVAR)
				CREX_BOOL_XOR_SPEC_CV_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ASSIGN_OBJ_OP_SPEC_CV_TMPVAR):
				VM_TRACE(CREX_ASSIGN_OBJ_OP_SPEC_CV_TMPVAR)
				CREX_ASSIGN_OBJ_OP_SPEC_CV_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ASSIGN_DIM_OP_SPEC_CV_TMPVAR):
				VM_TRACE(CREX_ASSIGN_DIM_OP_SPEC_CV_TMPVAR)
				CREX_ASSIGN_DIM_OP_SPEC_CV_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ASSIGN_OP_SPEC_CV_TMPVAR):
				VM_TRACE(CREX_ASSIGN_OP_SPEC_CV_TMPVAR)
				CREX_ASSIGN_OP_SPEC_CV_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_PRE_INC_OBJ_SPEC_CV_TMPVAR):
				VM_TRACE(CREX_PRE_INC_OBJ_SPEC_CV_TMPVAR)
				CREX_PRE_INC_OBJ_SPEC_CV_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_POST_INC_OBJ_SPEC_CV_TMPVAR):
				VM_TRACE(CREX_POST_INC_OBJ_SPEC_CV_TMPVAR)
				CREX_POST_INC_OBJ_SPEC_CV_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FETCH_DIM_R_SPEC_CV_TMPVAR):
				VM_TRACE(CREX_FETCH_DIM_R_SPEC_CV_TMPVAR)
				CREX_FETCH_DIM_R_SPEC_CV_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FETCH_DIM_W_SPEC_CV_TMPVAR):
				VM_TRACE(CREX_FETCH_DIM_W_SPEC_CV_TMPVAR)
				CREX_FETCH_DIM_W_SPEC_CV_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FETCH_DIM_RW_SPEC_CV_TMPVAR):
				VM_TRACE(CREX_FETCH_DIM_RW_SPEC_CV_TMPVAR)
				CREX_FETCH_DIM_RW_SPEC_CV_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FETCH_DIM_IS_SPEC_CV_TMPVAR):
				VM_TRACE(CREX_FETCH_DIM_IS_SPEC_CV_TMPVAR)
				CREX_FETCH_DIM_IS_SPEC_CV_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FETCH_DIM_FUNC_ARG_SPEC_CV_TMPVAR):
				VM_TRACE(CREX_FETCH_DIM_FUNC_ARG_SPEC_CV_TMPVAR)
				CREX_FETCH_DIM_FUNC_ARG_SPEC_CV_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FETCH_DIM_UNSET_SPEC_CV_TMPVAR):
				VM_TRACE(CREX_FETCH_DIM_UNSET_SPEC_CV_TMPVAR)
				CREX_FETCH_DIM_UNSET_SPEC_CV_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FETCH_OBJ_R_SPEC_CV_TMPVAR):
				VM_TRACE(CREX_FETCH_OBJ_R_SPEC_CV_TMPVAR)
				CREX_FETCH_OBJ_R_SPEC_CV_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FETCH_OBJ_W_SPEC_CV_TMPVAR):
				VM_TRACE(CREX_FETCH_OBJ_W_SPEC_CV_TMPVAR)
				CREX_FETCH_OBJ_W_SPEC_CV_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FETCH_OBJ_RW_SPEC_CV_TMPVAR):
				VM_TRACE(CREX_FETCH_OBJ_RW_SPEC_CV_TMPVAR)
				CREX_FETCH_OBJ_RW_SPEC_CV_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FETCH_OBJ_IS_SPEC_CV_TMPVAR):
				VM_TRACE(CREX_FETCH_OBJ_IS_SPEC_CV_TMPVAR)
				CREX_FETCH_OBJ_IS_SPEC_CV_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FETCH_OBJ_FUNC_ARG_SPEC_CV_TMPVAR):
				VM_TRACE(CREX_FETCH_OBJ_FUNC_ARG_SPEC_CV_TMPVAR)
				CREX_FETCH_OBJ_FUNC_ARG_SPEC_CV_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FETCH_OBJ_UNSET_SPEC_CV_TMPVAR):
				VM_TRACE(CREX_FETCH_OBJ_UNSET_SPEC_CV_TMPVAR)
				CREX_FETCH_OBJ_UNSET_SPEC_CV_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ASSIGN_OBJ_SPEC_CV_TMPVAR_OP_DATA_CONST):
				VM_TRACE(CREX_ASSIGN_OBJ_SPEC_CV_TMPVAR_OP_DATA_CONST)
				CREX_ASSIGN_OBJ_SPEC_CV_TMPVAR_OP_DATA_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ASSIGN_OBJ_SPEC_CV_TMPVAR_OP_DATA_TMP):
				VM_TRACE(CREX_ASSIGN_OBJ_SPEC_CV_TMPVAR_OP_DATA_TMP)
				CREX_ASSIGN_OBJ_SPEC_CV_TMPVAR_OP_DATA_TMP_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ASSIGN_OBJ_SPEC_CV_TMPVAR_OP_DATA_VAR):
				VM_TRACE(CREX_ASSIGN_OBJ_SPEC_CV_TMPVAR_OP_DATA_VAR)
				CREX_ASSIGN_OBJ_SPEC_CV_TMPVAR_OP_DATA_VAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ASSIGN_OBJ_SPEC_CV_TMPVAR_OP_DATA_CV):
				VM_TRACE(CREX_ASSIGN_OBJ_SPEC_CV_TMPVAR_OP_DATA_CV)
				CREX_ASSIGN_OBJ_SPEC_CV_TMPVAR_OP_DATA_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ASSIGN_DIM_SPEC_CV_TMPVAR_OP_DATA_CONST):
				VM_TRACE(CREX_ASSIGN_DIM_SPEC_CV_TMPVAR_OP_DATA_CONST)
				CREX_ASSIGN_DIM_SPEC_CV_TMPVAR_OP_DATA_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ASSIGN_DIM_SPEC_CV_TMPVAR_OP_DATA_TMP):
				VM_TRACE(CREX_ASSIGN_DIM_SPEC_CV_TMPVAR_OP_DATA_TMP)
				CREX_ASSIGN_DIM_SPEC_CV_TMPVAR_OP_DATA_TMP_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ASSIGN_DIM_SPEC_CV_TMPVAR_OP_DATA_VAR):
				VM_TRACE(CREX_ASSIGN_DIM_SPEC_CV_TMPVAR_OP_DATA_VAR)
				CREX_ASSIGN_DIM_SPEC_CV_TMPVAR_OP_DATA_VAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ASSIGN_DIM_SPEC_CV_TMPVAR_OP_DATA_CV):
				VM_TRACE(CREX_ASSIGN_DIM_SPEC_CV_TMPVAR_OP_DATA_CV)
				CREX_ASSIGN_DIM_SPEC_CV_TMPVAR_OP_DATA_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ASSIGN_OBJ_REF_SPEC_CV_TMPVAR_OP_DATA_VAR):
				VM_TRACE(CREX_ASSIGN_OBJ_REF_SPEC_CV_TMPVAR_OP_DATA_VAR)
				CREX_ASSIGN_OBJ_REF_SPEC_CV_TMPVAR_OP_DATA_VAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ASSIGN_OBJ_REF_SPEC_CV_TMPVAR_OP_DATA_CV):
				VM_TRACE(CREX_ASSIGN_OBJ_REF_SPEC_CV_TMPVAR_OP_DATA_CV)
				CREX_ASSIGN_OBJ_REF_SPEC_CV_TMPVAR_OP_DATA_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FAST_CONCAT_SPEC_CV_TMPVAR):
				VM_TRACE(CREX_FAST_CONCAT_SPEC_CV_TMPVAR)
				CREX_FAST_CONCAT_SPEC_CV_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_INIT_METHOD_CALL_SPEC_CV_TMPVAR):
				VM_TRACE(CREX_INIT_METHOD_CALL_SPEC_CV_TMPVAR)
				CREX_INIT_METHOD_CALL_SPEC_CV_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ADD_ARRAY_ELEMENT_SPEC_CV_TMPVAR):
				VM_TRACE(CREX_ADD_ARRAY_ELEMENT_SPEC_CV_TMPVAR)
				CREX_ADD_ARRAY_ELEMENT_SPEC_CV_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_INIT_ARRAY_SPEC_CV_TMPVAR):
				VM_TRACE(CREX_INIT_ARRAY_SPEC_CV_TMPVAR)
				CREX_INIT_ARRAY_SPEC_CV_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_UNSET_DIM_SPEC_CV_TMPVAR):
				VM_TRACE(CREX_UNSET_DIM_SPEC_CV_TMPVAR)
				CREX_UNSET_DIM_SPEC_CV_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_UNSET_OBJ_SPEC_CV_TMPVAR):
				VM_TRACE(CREX_UNSET_OBJ_SPEC_CV_TMPVAR)
				CREX_UNSET_OBJ_SPEC_CV_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ISSET_ISEMPTY_DIM_OBJ_SPEC_CV_TMPVAR):
				VM_TRACE(CREX_ISSET_ISEMPTY_DIM_OBJ_SPEC_CV_TMPVAR)
				CREX_ISSET_ISEMPTY_DIM_OBJ_SPEC_CV_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ISSET_ISEMPTY_PROP_OBJ_SPEC_CV_TMPVAR):
				VM_TRACE(CREX_ISSET_ISEMPTY_PROP_OBJ_SPEC_CV_TMPVAR)
				CREX_ISSET_ISEMPTY_PROP_OBJ_SPEC_CV_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ARRAY_KEY_EXISTS_SPEC_CV_TMPVAR):
				VM_TRACE(CREX_ARRAY_KEY_EXISTS_SPEC_CV_TMPVAR)
				CREX_ARRAY_KEY_EXISTS_SPEC_CV_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_YIELD_SPEC_CV_TMPVAR):
				VM_TRACE(CREX_YIELD_SPEC_CV_TMPVAR)
				CREX_YIELD_SPEC_CV_TMPVAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_IS_IDENTICAL_SPEC_CV_TMP):
				VM_TRACE(CREX_IS_IDENTICAL_SPEC_CV_TMP)
				CREX_IS_IDENTICAL_SPEC_CV_TMP_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_IS_NOT_IDENTICAL_SPEC_CV_TMP):
				VM_TRACE(CREX_IS_NOT_IDENTICAL_SPEC_CV_TMP)
				CREX_IS_NOT_IDENTICAL_SPEC_CV_TMP_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ASSIGN_SPEC_CV_TMP_RETVAL_UNUSED):
				VM_TRACE(CREX_ASSIGN_SPEC_CV_TMP_RETVAL_UNUSED)
				CREX_ASSIGN_SPEC_CV_TMP_RETVAL_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ASSIGN_SPEC_CV_TMP_RETVAL_USED):
				VM_TRACE(CREX_ASSIGN_SPEC_CV_TMP_RETVAL_USED)
				CREX_ASSIGN_SPEC_CV_TMP_RETVAL_USED_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_IS_IDENTICAL_SPEC_CV_VAR):
				VM_TRACE(CREX_IS_IDENTICAL_SPEC_CV_VAR)
				CREX_IS_IDENTICAL_SPEC_CV_VAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_IS_NOT_IDENTICAL_SPEC_CV_VAR):
				VM_TRACE(CREX_IS_NOT_IDENTICAL_SPEC_CV_VAR)
				CREX_IS_NOT_IDENTICAL_SPEC_CV_VAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ASSIGN_SPEC_CV_VAR_RETVAL_UNUSED):
				VM_TRACE(CREX_ASSIGN_SPEC_CV_VAR_RETVAL_UNUSED)
				CREX_ASSIGN_SPEC_CV_VAR_RETVAL_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ASSIGN_SPEC_CV_VAR_RETVAL_USED):
				VM_TRACE(CREX_ASSIGN_SPEC_CV_VAR_RETVAL_USED)
				CREX_ASSIGN_SPEC_CV_VAR_RETVAL_USED_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ASSIGN_REF_SPEC_CV_VAR):
				VM_TRACE(CREX_ASSIGN_REF_SPEC_CV_VAR)
				CREX_ASSIGN_REF_SPEC_CV_VAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_INSTANCEOF_SPEC_CV_VAR):
				VM_TRACE(CREX_INSTANCEOF_SPEC_CV_VAR)
				CREX_INSTANCEOF_SPEC_CV_VAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ASSIGN_DIM_OP_SPEC_CV_UNUSED):
				VM_TRACE(CREX_ASSIGN_DIM_OP_SPEC_CV_UNUSED)
				CREX_ASSIGN_DIM_OP_SPEC_CV_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FETCH_R_SPEC_CV_UNUSED):
				VM_TRACE(CREX_FETCH_R_SPEC_CV_UNUSED)
				CREX_FETCH_R_SPEC_CV_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FETCH_W_SPEC_CV_UNUSED):
				VM_TRACE(CREX_FETCH_W_SPEC_CV_UNUSED)
				CREX_FETCH_W_SPEC_CV_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FETCH_RW_SPEC_CV_UNUSED):
				VM_TRACE(CREX_FETCH_RW_SPEC_CV_UNUSED)
				CREX_FETCH_RW_SPEC_CV_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FETCH_FUNC_ARG_SPEC_CV_UNUSED):
				VM_TRACE(CREX_FETCH_FUNC_ARG_SPEC_CV_UNUSED)
				CREX_FETCH_FUNC_ARG_SPEC_CV_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FETCH_UNSET_SPEC_CV_UNUSED):
				VM_TRACE(CREX_FETCH_UNSET_SPEC_CV_UNUSED)
				CREX_FETCH_UNSET_SPEC_CV_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FETCH_IS_SPEC_CV_UNUSED):
				VM_TRACE(CREX_FETCH_IS_SPEC_CV_UNUSED)
				CREX_FETCH_IS_SPEC_CV_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FETCH_DIM_W_SPEC_CV_UNUSED):
				VM_TRACE(CREX_FETCH_DIM_W_SPEC_CV_UNUSED)
				CREX_FETCH_DIM_W_SPEC_CV_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FETCH_DIM_RW_SPEC_CV_UNUSED):
				VM_TRACE(CREX_FETCH_DIM_RW_SPEC_CV_UNUSED)
				CREX_FETCH_DIM_RW_SPEC_CV_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FETCH_DIM_FUNC_ARG_SPEC_CV_UNUSED):
				VM_TRACE(CREX_FETCH_DIM_FUNC_ARG_SPEC_CV_UNUSED)
				CREX_FETCH_DIM_FUNC_ARG_SPEC_CV_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ASSIGN_DIM_SPEC_CV_UNUSED_OP_DATA_CONST):
				VM_TRACE(CREX_ASSIGN_DIM_SPEC_CV_UNUSED_OP_DATA_CONST)
				CREX_ASSIGN_DIM_SPEC_CV_UNUSED_OP_DATA_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ASSIGN_DIM_SPEC_CV_UNUSED_OP_DATA_TMP):
				VM_TRACE(CREX_ASSIGN_DIM_SPEC_CV_UNUSED_OP_DATA_TMP)
				CREX_ASSIGN_DIM_SPEC_CV_UNUSED_OP_DATA_TMP_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ASSIGN_DIM_SPEC_CV_UNUSED_OP_DATA_VAR):
				VM_TRACE(CREX_ASSIGN_DIM_SPEC_CV_UNUSED_OP_DATA_VAR)
				CREX_ASSIGN_DIM_SPEC_CV_UNUSED_OP_DATA_VAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ASSIGN_DIM_SPEC_CV_UNUSED_OP_DATA_CV):
				VM_TRACE(CREX_ASSIGN_DIM_SPEC_CV_UNUSED_OP_DATA_CV)
				CREX_ASSIGN_DIM_SPEC_CV_UNUSED_OP_DATA_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_VERIFY_RETURN_TYPE_SPEC_CV_UNUSED):
				VM_TRACE(CREX_VERIFY_RETURN_TYPE_SPEC_CV_UNUSED)
				CREX_VERIFY_RETURN_TYPE_SPEC_CV_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_SEND_VAR_SPEC_CV_UNUSED):
				VM_TRACE(CREX_SEND_VAR_SPEC_CV_UNUSED)
				CREX_SEND_VAR_SPEC_CV_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_SEND_REF_SPEC_CV_UNUSED):
				VM_TRACE(CREX_SEND_REF_SPEC_CV_UNUSED)
				CREX_SEND_REF_SPEC_CV_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_SEND_VAR_EX_SPEC_CV_UNUSED):
				VM_TRACE(CREX_SEND_VAR_EX_SPEC_CV_UNUSED)
				CREX_SEND_VAR_EX_SPEC_CV_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_SEND_VAR_EX_SPEC_CV_UNUSED_QUICK):
				VM_TRACE(CREX_SEND_VAR_EX_SPEC_CV_UNUSED_QUICK)
				CREX_SEND_VAR_EX_SPEC_CV_UNUSED_QUICK_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ADD_ARRAY_ELEMENT_SPEC_CV_UNUSED):
				VM_TRACE(CREX_ADD_ARRAY_ELEMENT_SPEC_CV_UNUSED)
				CREX_ADD_ARRAY_ELEMENT_SPEC_CV_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_INIT_ARRAY_SPEC_CV_UNUSED):
				VM_TRACE(CREX_INIT_ARRAY_SPEC_CV_UNUSED)
				CREX_INIT_ARRAY_SPEC_CV_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_UNSET_CV_SPEC_CV_UNUSED):
				VM_TRACE(CREX_UNSET_CV_SPEC_CV_UNUSED)
				CREX_UNSET_CV_SPEC_CV_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_UNSET_VAR_SPEC_CV_UNUSED):
				VM_TRACE(CREX_UNSET_VAR_SPEC_CV_UNUSED)
				CREX_UNSET_VAR_SPEC_CV_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ISSET_ISEMPTY_CV_SPEC_CV_UNUSED_SET):
				VM_TRACE(CREX_ISSET_ISEMPTY_CV_SPEC_CV_UNUSED_SET)
				CREX_ISSET_ISEMPTY_CV_SPEC_CV_UNUSED_SET_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ISSET_ISEMPTY_CV_SPEC_CV_UNUSED_EMPTY):
				VM_TRACE(CREX_ISSET_ISEMPTY_CV_SPEC_CV_UNUSED_EMPTY)
				CREX_ISSET_ISEMPTY_CV_SPEC_CV_UNUSED_EMPTY_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ISSET_ISEMPTY_VAR_SPEC_CV_UNUSED):
				VM_TRACE(CREX_ISSET_ISEMPTY_VAR_SPEC_CV_UNUSED)
				CREX_ISSET_ISEMPTY_VAR_SPEC_CV_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_INSTANCEOF_SPEC_CV_UNUSED):
				VM_TRACE(CREX_INSTANCEOF_SPEC_CV_UNUSED)
				CREX_INSTANCEOF_SPEC_CV_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_YIELD_SPEC_CV_UNUSED):
				VM_TRACE(CREX_YIELD_SPEC_CV_UNUSED)
				CREX_YIELD_SPEC_CV_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_CHECK_VAR_SPEC_CV_UNUSED):
				VM_TRACE(CREX_CHECK_VAR_SPEC_CV_UNUSED)
				CREX_CHECK_VAR_SPEC_CV_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_MAKE_REF_SPEC_CV_UNUSED):
				VM_TRACE(CREX_MAKE_REF_SPEC_CV_UNUSED)
				CREX_MAKE_REF_SPEC_CV_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_COUNT_SPEC_CV_UNUSED):
				VM_TRACE(CREX_COUNT_SPEC_CV_UNUSED)
				CREX_COUNT_SPEC_CV_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_COUNT_ARRAY_SPEC_CV_UNUSED):
				VM_TRACE(CREX_COUNT_ARRAY_SPEC_CV_UNUSED)
				CREX_COUNT_ARRAY_SPEC_CV_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_GET_CLASS_SPEC_CV_UNUSED):
				VM_TRACE(CREX_GET_CLASS_SPEC_CV_UNUSED)
				CREX_GET_CLASS_SPEC_CV_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_GET_TYPE_SPEC_CV_UNUSED):
				VM_TRACE(CREX_GET_TYPE_SPEC_CV_UNUSED)
				CREX_GET_TYPE_SPEC_CV_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_SEND_VAR_EX_SIMPLE_SPEC_CV_UNUSED):
				VM_TRACE(CREX_SEND_VAR_EX_SIMPLE_SPEC_CV_UNUSED)
				CREX_SEND_VAR_EX_SIMPLE_SPEC_CV_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_DIV_SPEC_CV_CV):
				VM_TRACE(CREX_DIV_SPEC_CV_CV)
				CREX_DIV_SPEC_CV_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_POW_SPEC_CV_CV):
				VM_TRACE(CREX_POW_SPEC_CV_CV)
				CREX_POW_SPEC_CV_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_CONCAT_SPEC_CV_CV):
				VM_TRACE(CREX_CONCAT_SPEC_CV_CV)
				CREX_CONCAT_SPEC_CV_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_IS_IDENTICAL_SPEC_CV_CV):
				VM_TRACE(CREX_IS_IDENTICAL_SPEC_CV_CV)
				CREX_IS_IDENTICAL_SPEC_CV_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_IS_NOT_IDENTICAL_SPEC_CV_CV):
				VM_TRACE(CREX_IS_NOT_IDENTICAL_SPEC_CV_CV)
				CREX_IS_NOT_IDENTICAL_SPEC_CV_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_IS_EQUAL_SPEC_CV_CV):
				VM_TRACE(CREX_IS_EQUAL_SPEC_CV_CV)
				CREX_IS_EQUAL_SPEC_CV_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_IS_EQUAL_SPEC_CV_CV_JMPZ):
				VM_TRACE(CREX_IS_EQUAL_SPEC_CV_CV_JMPZ)
				CREX_IS_EQUAL_SPEC_CV_CV_JMPC_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_IS_EQUAL_SPEC_CV_CV_JMPNZ):
				VM_TRACE(CREX_IS_EQUAL_SPEC_CV_CV_JMPNZ)
				CREX_IS_EQUAL_SPEC_CV_CV_JMPNC_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_IS_NOT_EQUAL_SPEC_CV_CV):
				VM_TRACE(CREX_IS_NOT_EQUAL_SPEC_CV_CV)
				CREX_IS_NOT_EQUAL_SPEC_CV_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_IS_NOT_EQUAL_SPEC_CV_CV_JMPZ):
				VM_TRACE(CREX_IS_NOT_EQUAL_SPEC_CV_CV_JMPZ)
				CREX_IS_NOT_EQUAL_SPEC_CV_CV_JMPC_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_IS_NOT_EQUAL_SPEC_CV_CV_JMPNZ):
				VM_TRACE(CREX_IS_NOT_EQUAL_SPEC_CV_CV_JMPNZ)
				CREX_IS_NOT_EQUAL_SPEC_CV_CV_JMPNC_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_SPACESHIP_SPEC_CV_CV):
				VM_TRACE(CREX_SPACESHIP_SPEC_CV_CV)
				CREX_SPACESHIP_SPEC_CV_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_BOOL_XOR_SPEC_CV_CV):
				VM_TRACE(CREX_BOOL_XOR_SPEC_CV_CV)
				CREX_BOOL_XOR_SPEC_CV_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ASSIGN_OBJ_OP_SPEC_CV_CV):
				VM_TRACE(CREX_ASSIGN_OBJ_OP_SPEC_CV_CV)
				CREX_ASSIGN_OBJ_OP_SPEC_CV_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ASSIGN_DIM_OP_SPEC_CV_CV):
				VM_TRACE(CREX_ASSIGN_DIM_OP_SPEC_CV_CV)
				CREX_ASSIGN_DIM_OP_SPEC_CV_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ASSIGN_OP_SPEC_CV_CV):
				VM_TRACE(CREX_ASSIGN_OP_SPEC_CV_CV)
				CREX_ASSIGN_OP_SPEC_CV_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_PRE_INC_OBJ_SPEC_CV_CV):
				VM_TRACE(CREX_PRE_INC_OBJ_SPEC_CV_CV)
				CREX_PRE_INC_OBJ_SPEC_CV_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_POST_INC_OBJ_SPEC_CV_CV):
				VM_TRACE(CREX_POST_INC_OBJ_SPEC_CV_CV)
				CREX_POST_INC_OBJ_SPEC_CV_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FETCH_DIM_R_SPEC_CV_CV):
				VM_TRACE(CREX_FETCH_DIM_R_SPEC_CV_CV)
				CREX_FETCH_DIM_R_SPEC_CV_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FETCH_DIM_W_SPEC_CV_CV):
				VM_TRACE(CREX_FETCH_DIM_W_SPEC_CV_CV)
				CREX_FETCH_DIM_W_SPEC_CV_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FETCH_DIM_RW_SPEC_CV_CV):
				VM_TRACE(CREX_FETCH_DIM_RW_SPEC_CV_CV)
				CREX_FETCH_DIM_RW_SPEC_CV_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FETCH_DIM_IS_SPEC_CV_CV):
				VM_TRACE(CREX_FETCH_DIM_IS_SPEC_CV_CV)
				CREX_FETCH_DIM_IS_SPEC_CV_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FETCH_DIM_FUNC_ARG_SPEC_CV_CV):
				VM_TRACE(CREX_FETCH_DIM_FUNC_ARG_SPEC_CV_CV)
				CREX_FETCH_DIM_FUNC_ARG_SPEC_CV_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FETCH_DIM_UNSET_SPEC_CV_CV):
				VM_TRACE(CREX_FETCH_DIM_UNSET_SPEC_CV_CV)
				CREX_FETCH_DIM_UNSET_SPEC_CV_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FETCH_OBJ_R_SPEC_CV_CV):
				VM_TRACE(CREX_FETCH_OBJ_R_SPEC_CV_CV)
				CREX_FETCH_OBJ_R_SPEC_CV_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FETCH_OBJ_W_SPEC_CV_CV):
				VM_TRACE(CREX_FETCH_OBJ_W_SPEC_CV_CV)
				CREX_FETCH_OBJ_W_SPEC_CV_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FETCH_OBJ_RW_SPEC_CV_CV):
				VM_TRACE(CREX_FETCH_OBJ_RW_SPEC_CV_CV)
				CREX_FETCH_OBJ_RW_SPEC_CV_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FETCH_OBJ_IS_SPEC_CV_CV):
				VM_TRACE(CREX_FETCH_OBJ_IS_SPEC_CV_CV)
				CREX_FETCH_OBJ_IS_SPEC_CV_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FETCH_OBJ_FUNC_ARG_SPEC_CV_CV):
				VM_TRACE(CREX_FETCH_OBJ_FUNC_ARG_SPEC_CV_CV)
				CREX_FETCH_OBJ_FUNC_ARG_SPEC_CV_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FETCH_OBJ_UNSET_SPEC_CV_CV):
				VM_TRACE(CREX_FETCH_OBJ_UNSET_SPEC_CV_CV)
				CREX_FETCH_OBJ_UNSET_SPEC_CV_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ASSIGN_OBJ_SPEC_CV_CV_OP_DATA_CONST):
				VM_TRACE(CREX_ASSIGN_OBJ_SPEC_CV_CV_OP_DATA_CONST)
				CREX_ASSIGN_OBJ_SPEC_CV_CV_OP_DATA_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ASSIGN_OBJ_SPEC_CV_CV_OP_DATA_TMP):
				VM_TRACE(CREX_ASSIGN_OBJ_SPEC_CV_CV_OP_DATA_TMP)
				CREX_ASSIGN_OBJ_SPEC_CV_CV_OP_DATA_TMP_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ASSIGN_OBJ_SPEC_CV_CV_OP_DATA_VAR):
				VM_TRACE(CREX_ASSIGN_OBJ_SPEC_CV_CV_OP_DATA_VAR)
				CREX_ASSIGN_OBJ_SPEC_CV_CV_OP_DATA_VAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ASSIGN_OBJ_SPEC_CV_CV_OP_DATA_CV):
				VM_TRACE(CREX_ASSIGN_OBJ_SPEC_CV_CV_OP_DATA_CV)
				CREX_ASSIGN_OBJ_SPEC_CV_CV_OP_DATA_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ASSIGN_DIM_SPEC_CV_CV_OP_DATA_CONST):
				VM_TRACE(CREX_ASSIGN_DIM_SPEC_CV_CV_OP_DATA_CONST)
				CREX_ASSIGN_DIM_SPEC_CV_CV_OP_DATA_CONST_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ASSIGN_DIM_SPEC_CV_CV_OP_DATA_TMP):
				VM_TRACE(CREX_ASSIGN_DIM_SPEC_CV_CV_OP_DATA_TMP)
				CREX_ASSIGN_DIM_SPEC_CV_CV_OP_DATA_TMP_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ASSIGN_DIM_SPEC_CV_CV_OP_DATA_VAR):
				VM_TRACE(CREX_ASSIGN_DIM_SPEC_CV_CV_OP_DATA_VAR)
				CREX_ASSIGN_DIM_SPEC_CV_CV_OP_DATA_VAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ASSIGN_DIM_SPEC_CV_CV_OP_DATA_CV):
				VM_TRACE(CREX_ASSIGN_DIM_SPEC_CV_CV_OP_DATA_CV)
				CREX_ASSIGN_DIM_SPEC_CV_CV_OP_DATA_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ASSIGN_SPEC_CV_CV_RETVAL_UNUSED):
				VM_TRACE(CREX_ASSIGN_SPEC_CV_CV_RETVAL_UNUSED)
				CREX_ASSIGN_SPEC_CV_CV_RETVAL_UNUSED_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ASSIGN_SPEC_CV_CV_RETVAL_USED):
				VM_TRACE(CREX_ASSIGN_SPEC_CV_CV_RETVAL_USED)
				CREX_ASSIGN_SPEC_CV_CV_RETVAL_USED_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ASSIGN_REF_SPEC_CV_CV):
				VM_TRACE(CREX_ASSIGN_REF_SPEC_CV_CV)
				CREX_ASSIGN_REF_SPEC_CV_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ASSIGN_OBJ_REF_SPEC_CV_CV_OP_DATA_VAR):
				VM_TRACE(CREX_ASSIGN_OBJ_REF_SPEC_CV_CV_OP_DATA_VAR)
				CREX_ASSIGN_OBJ_REF_SPEC_CV_CV_OP_DATA_VAR_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ASSIGN_OBJ_REF_SPEC_CV_CV_OP_DATA_CV):
				VM_TRACE(CREX_ASSIGN_OBJ_REF_SPEC_CV_CV_OP_DATA_CV)
				CREX_ASSIGN_OBJ_REF_SPEC_CV_CV_OP_DATA_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_FAST_CONCAT_SPEC_CV_CV):
				VM_TRACE(CREX_FAST_CONCAT_SPEC_CV_CV)
				CREX_FAST_CONCAT_SPEC_CV_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_INIT_METHOD_CALL_SPEC_CV_CV):
				VM_TRACE(CREX_INIT_METHOD_CALL_SPEC_CV_CV)
				CREX_INIT_METHOD_CALL_SPEC_CV_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ADD_ARRAY_ELEMENT_SPEC_CV_CV):
				VM_TRACE(CREX_ADD_ARRAY_ELEMENT_SPEC_CV_CV)
				CREX_ADD_ARRAY_ELEMENT_SPEC_CV_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_INIT_ARRAY_SPEC_CV_CV):
				VM_TRACE(CREX_INIT_ARRAY_SPEC_CV_CV)
				CREX_INIT_ARRAY_SPEC_CV_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_UNSET_DIM_SPEC_CV_CV):
				VM_TRACE(CREX_UNSET_DIM_SPEC_CV_CV)
				CREX_UNSET_DIM_SPEC_CV_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_UNSET_OBJ_SPEC_CV_CV):
				VM_TRACE(CREX_UNSET_OBJ_SPEC_CV_CV)
				CREX_UNSET_OBJ_SPEC_CV_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ISSET_ISEMPTY_DIM_OBJ_SPEC_CV_CV):
				VM_TRACE(CREX_ISSET_ISEMPTY_DIM_OBJ_SPEC_CV_CV)
				CREX_ISSET_ISEMPTY_DIM_OBJ_SPEC_CV_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ISSET_ISEMPTY_PROP_OBJ_SPEC_CV_CV):
				VM_TRACE(CREX_ISSET_ISEMPTY_PROP_OBJ_SPEC_CV_CV)
				CREX_ISSET_ISEMPTY_PROP_OBJ_SPEC_CV_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_ARRAY_KEY_EXISTS_SPEC_CV_CV):
				VM_TRACE(CREX_ARRAY_KEY_EXISTS_SPEC_CV_CV)
				CREX_ARRAY_KEY_EXISTS_SPEC_CV_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_YIELD_SPEC_CV_CV):
				VM_TRACE(CREX_YIELD_SPEC_CV_CV)
				CREX_YIELD_SPEC_CV_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_IS_IDENTICAL_NOTHROW_SPEC_CV_CV):
				VM_TRACE(CREX_IS_IDENTICAL_NOTHROW_SPEC_CV_CV)
				CREX_IS_IDENTICAL_NOTHROW_SPEC_CV_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(CREX_IS_NOT_IDENTICAL_NOTHROW_SPEC_CV_CV):
				VM_TRACE(CREX_IS_NOT_IDENTICAL_NOTHROW_SPEC_CV_CV)
				CREX_IS_NOT_IDENTICAL_NOTHROW_SPEC_CV_CV_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK();
			HYBRID_CASE(HYBRID_HALT):
#ifdef CREX_VM_FP_GLOBAL_REG
				execute_data = vm_stack_data.orig_execute_data;
#endif
#ifdef CREX_VM_IP_GLOBAL_REG
				opline = vm_stack_data.orig_opline;
#endif
				return;
			HYBRID_DEFAULT:
				VM_TRACE(CREX_NULL)
				CREX_NULL_HANDLER(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
				HYBRID_BREAK(); /* Never reached */
#else
#ifdef CREX_VM_FP_GLOBAL_REG
			execute_data = vm_stack_data.orig_execute_data;
# ifdef CREX_VM_IP_GLOBAL_REG
			opline = vm_stack_data.orig_opline;
# endif
			return;
#else
			if (EXPECTED(ret > 0)) {
				execute_data = EG(current_execute_data);
				CREX_VM_LOOP_INTERRUPT_CHECK();
			} else {
# ifdef CREX_VM_IP_GLOBAL_REG
				opline = vm_stack_data.orig_opline;
# endif
				return;
			}
#endif
#endif
		}

	}
	crex_error_noreturn(E_CORE_ERROR, "Arrived at end of main loop which shouldn't happen");
}
#if (CREX_VM_KIND != CREX_VM_KIND_CALL) && (CREX_GCC_VERSION >= 4000) && !defined(__clang__)
# pragma GCC pop_options
#endif

CREX_API void crex_execute(crex_op_array *op_array, zval *return_value)
{
	crex_execute_data *execute_data;
	void *object_or_called_scope;
	uint32_t call_info;

	if (EG(exception) != NULL) {
		return;
	}

	object_or_called_scope = crex_get_this_object(EG(current_execute_data));
	if (EXPECTED(!object_or_called_scope)) {
		object_or_called_scope = crex_get_called_scope(EG(current_execute_data));
		call_info = CREX_CALL_TOP_CODE | CREX_CALL_HAS_SYMBOL_TABLE;
	} else {
		call_info = CREX_CALL_TOP_CODE | CREX_CALL_HAS_SYMBOL_TABLE | CREX_CALL_HAS_THIS;
	}
	execute_data = crex_vm_stack_push_call_frame(call_info,
		(crex_function*)op_array, 0, object_or_called_scope);
	if (EG(current_execute_data)) {
		execute_data->symbol_table = crex_rebuild_symbol_table();
	} else {
		execute_data->symbol_table = &EG(symbol_table);
	}
	EX(prev_execute_data) = EG(current_execute_data);
	i_init_code_execute_data(execute_data, op_array, return_value);
	CREX_OBSERVER_FCALL_BEGIN(execute_data);
	crex_execute_ex(execute_data);
	/* Observer end handlers are called from CREX_RETURN */
	crex_vm_stack_free_call_frame(execute_data);
}


void crex_vm_init(void)
{
	static const void * const labels[] = {
		CREX_NOP_SPEC_HANDLER,
		CREX_ADD_SPEC_CONST_CONST_HANDLER,
		CREX_ADD_SPEC_CONST_TMPVARCV_HANDLER,
		CREX_ADD_SPEC_CONST_TMPVARCV_HANDLER,
		CREX_NULL_HANDLER,
		CREX_ADD_SPEC_CONST_TMPVARCV_HANDLER,
		CREX_ADD_SPEC_TMPVARCV_CONST_HANDLER,
		CREX_ADD_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_ADD_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_NULL_HANDLER,
		CREX_ADD_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_ADD_SPEC_TMPVARCV_CONST_HANDLER,
		CREX_ADD_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_ADD_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_NULL_HANDLER,
		CREX_ADD_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_ADD_SPEC_TMPVARCV_CONST_HANDLER,
		CREX_ADD_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_ADD_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_NULL_HANDLER,
		CREX_ADD_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_SUB_SPEC_CONST_CONST_HANDLER,
		CREX_SUB_SPEC_CONST_TMPVARCV_HANDLER,
		CREX_SUB_SPEC_CONST_TMPVARCV_HANDLER,
		CREX_NULL_HANDLER,
		CREX_SUB_SPEC_CONST_TMPVARCV_HANDLER,
		CREX_SUB_SPEC_TMPVARCV_CONST_HANDLER,
		CREX_SUB_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_SUB_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_NULL_HANDLER,
		CREX_SUB_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_SUB_SPEC_TMPVARCV_CONST_HANDLER,
		CREX_SUB_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_SUB_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_NULL_HANDLER,
		CREX_SUB_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_SUB_SPEC_TMPVARCV_CONST_HANDLER,
		CREX_SUB_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_SUB_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_NULL_HANDLER,
		CREX_SUB_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_MUL_SPEC_CONST_CONST_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_MUL_SPEC_TMPVARCV_CONST_HANDLER,
		CREX_MUL_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_MUL_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_NULL_HANDLER,
		CREX_MUL_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_MUL_SPEC_TMPVARCV_CONST_HANDLER,
		CREX_MUL_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_MUL_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_NULL_HANDLER,
		CREX_MUL_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_MUL_SPEC_TMPVARCV_CONST_HANDLER,
		CREX_MUL_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_MUL_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_NULL_HANDLER,
		CREX_MUL_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_DIV_SPEC_CONST_CONST_HANDLER,
		CREX_DIV_SPEC_CONST_TMPVAR_HANDLER,
		CREX_DIV_SPEC_CONST_TMPVAR_HANDLER,
		CREX_NULL_HANDLER,
		CREX_DIV_SPEC_CONST_CV_HANDLER,
		CREX_DIV_SPEC_TMPVAR_CONST_HANDLER,
		CREX_DIV_SPEC_TMPVAR_TMPVAR_HANDLER,
		CREX_DIV_SPEC_TMPVAR_TMPVAR_HANDLER,
		CREX_NULL_HANDLER,
		CREX_DIV_SPEC_TMPVAR_CV_HANDLER,
		CREX_DIV_SPEC_TMPVAR_CONST_HANDLER,
		CREX_DIV_SPEC_TMPVAR_TMPVAR_HANDLER,
		CREX_DIV_SPEC_TMPVAR_TMPVAR_HANDLER,
		CREX_NULL_HANDLER,
		CREX_DIV_SPEC_TMPVAR_CV_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_DIV_SPEC_CV_CONST_HANDLER,
		CREX_DIV_SPEC_CV_TMPVAR_HANDLER,
		CREX_DIV_SPEC_CV_TMPVAR_HANDLER,
		CREX_NULL_HANDLER,
		CREX_DIV_SPEC_CV_CV_HANDLER,
		CREX_MOD_SPEC_CONST_CONST_HANDLER,
		CREX_MOD_SPEC_CONST_TMPVARCV_HANDLER,
		CREX_MOD_SPEC_CONST_TMPVARCV_HANDLER,
		CREX_NULL_HANDLER,
		CREX_MOD_SPEC_CONST_TMPVARCV_HANDLER,
		CREX_MOD_SPEC_TMPVARCV_CONST_HANDLER,
		CREX_MOD_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_MOD_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_NULL_HANDLER,
		CREX_MOD_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_MOD_SPEC_TMPVARCV_CONST_HANDLER,
		CREX_MOD_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_MOD_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_NULL_HANDLER,
		CREX_MOD_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_MOD_SPEC_TMPVARCV_CONST_HANDLER,
		CREX_MOD_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_MOD_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_NULL_HANDLER,
		CREX_MOD_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_SL_SPEC_CONST_CONST_HANDLER,
		CREX_SL_SPEC_CONST_TMPVARCV_HANDLER,
		CREX_SL_SPEC_CONST_TMPVARCV_HANDLER,
		CREX_NULL_HANDLER,
		CREX_SL_SPEC_CONST_TMPVARCV_HANDLER,
		CREX_SL_SPEC_TMPVARCV_CONST_HANDLER,
		CREX_SL_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_SL_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_NULL_HANDLER,
		CREX_SL_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_SL_SPEC_TMPVARCV_CONST_HANDLER,
		CREX_SL_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_SL_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_NULL_HANDLER,
		CREX_SL_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_SL_SPEC_TMPVARCV_CONST_HANDLER,
		CREX_SL_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_SL_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_NULL_HANDLER,
		CREX_SL_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_SR_SPEC_CONST_CONST_HANDLER,
		CREX_SR_SPEC_CONST_TMPVARCV_HANDLER,
		CREX_SR_SPEC_CONST_TMPVARCV_HANDLER,
		CREX_NULL_HANDLER,
		CREX_SR_SPEC_CONST_TMPVARCV_HANDLER,
		CREX_SR_SPEC_TMPVARCV_CONST_HANDLER,
		CREX_SR_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_SR_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_NULL_HANDLER,
		CREX_SR_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_SR_SPEC_TMPVARCV_CONST_HANDLER,
		CREX_SR_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_SR_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_NULL_HANDLER,
		CREX_SR_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_SR_SPEC_TMPVARCV_CONST_HANDLER,
		CREX_SR_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_SR_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_NULL_HANDLER,
		CREX_SR_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_NULL_HANDLER,
		CREX_CONCAT_SPEC_CONST_TMPVAR_HANDLER,
		CREX_CONCAT_SPEC_CONST_TMPVAR_HANDLER,
		CREX_NULL_HANDLER,
		CREX_CONCAT_SPEC_CONST_CV_HANDLER,
		CREX_CONCAT_SPEC_TMPVAR_CONST_HANDLER,
		CREX_CONCAT_SPEC_TMPVAR_TMPVAR_HANDLER,
		CREX_CONCAT_SPEC_TMPVAR_TMPVAR_HANDLER,
		CREX_NULL_HANDLER,
		CREX_CONCAT_SPEC_TMPVAR_CV_HANDLER,
		CREX_CONCAT_SPEC_TMPVAR_CONST_HANDLER,
		CREX_CONCAT_SPEC_TMPVAR_TMPVAR_HANDLER,
		CREX_CONCAT_SPEC_TMPVAR_TMPVAR_HANDLER,
		CREX_NULL_HANDLER,
		CREX_CONCAT_SPEC_TMPVAR_CV_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_CONCAT_SPEC_CV_CONST_HANDLER,
		CREX_CONCAT_SPEC_CV_TMPVAR_HANDLER,
		CREX_CONCAT_SPEC_CV_TMPVAR_HANDLER,
		CREX_NULL_HANDLER,
		CREX_CONCAT_SPEC_CV_CV_HANDLER,
		CREX_BW_OR_SPEC_CONST_CONST_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_BW_OR_SPEC_TMPVARCV_CONST_HANDLER,
		CREX_BW_OR_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_BW_OR_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_NULL_HANDLER,
		CREX_BW_OR_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_BW_OR_SPEC_TMPVARCV_CONST_HANDLER,
		CREX_BW_OR_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_BW_OR_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_NULL_HANDLER,
		CREX_BW_OR_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_BW_OR_SPEC_TMPVARCV_CONST_HANDLER,
		CREX_BW_OR_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_BW_OR_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_NULL_HANDLER,
		CREX_BW_OR_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_BW_AND_SPEC_CONST_CONST_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_BW_AND_SPEC_TMPVARCV_CONST_HANDLER,
		CREX_BW_AND_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_BW_AND_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_NULL_HANDLER,
		CREX_BW_AND_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_BW_AND_SPEC_TMPVARCV_CONST_HANDLER,
		CREX_BW_AND_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_BW_AND_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_NULL_HANDLER,
		CREX_BW_AND_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_BW_AND_SPEC_TMPVARCV_CONST_HANDLER,
		CREX_BW_AND_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_BW_AND_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_NULL_HANDLER,
		CREX_BW_AND_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_BW_XOR_SPEC_CONST_CONST_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_BW_XOR_SPEC_TMPVARCV_CONST_HANDLER,
		CREX_BW_XOR_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_BW_XOR_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_NULL_HANDLER,
		CREX_BW_XOR_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_BW_XOR_SPEC_TMPVARCV_CONST_HANDLER,
		CREX_BW_XOR_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_BW_XOR_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_NULL_HANDLER,
		CREX_BW_XOR_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_BW_XOR_SPEC_TMPVARCV_CONST_HANDLER,
		CREX_BW_XOR_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_BW_XOR_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_NULL_HANDLER,
		CREX_BW_XOR_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_POW_SPEC_CONST_CONST_HANDLER,
		CREX_POW_SPEC_CONST_TMPVAR_HANDLER,
		CREX_POW_SPEC_CONST_TMPVAR_HANDLER,
		CREX_NULL_HANDLER,
		CREX_POW_SPEC_CONST_CV_HANDLER,
		CREX_POW_SPEC_TMPVAR_CONST_HANDLER,
		CREX_POW_SPEC_TMPVAR_TMPVAR_HANDLER,
		CREX_POW_SPEC_TMPVAR_TMPVAR_HANDLER,
		CREX_NULL_HANDLER,
		CREX_POW_SPEC_TMPVAR_CV_HANDLER,
		CREX_POW_SPEC_TMPVAR_CONST_HANDLER,
		CREX_POW_SPEC_TMPVAR_TMPVAR_HANDLER,
		CREX_POW_SPEC_TMPVAR_TMPVAR_HANDLER,
		CREX_NULL_HANDLER,
		CREX_POW_SPEC_TMPVAR_CV_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_POW_SPEC_CV_CONST_HANDLER,
		CREX_POW_SPEC_CV_TMPVAR_HANDLER,
		CREX_POW_SPEC_CV_TMPVAR_HANDLER,
		CREX_NULL_HANDLER,
		CREX_POW_SPEC_CV_CV_HANDLER,
		CREX_BW_NOT_SPEC_CONST_HANDLER,
		CREX_BW_NOT_SPEC_TMPVARCV_HANDLER,
		CREX_BW_NOT_SPEC_TMPVARCV_HANDLER,
		CREX_NULL_HANDLER,
		CREX_BW_NOT_SPEC_TMPVARCV_HANDLER,
		CREX_BOOL_NOT_SPEC_CONST_HANDLER,
		CREX_BOOL_NOT_SPEC_TMPVAR_HANDLER,
		CREX_BOOL_NOT_SPEC_TMPVAR_HANDLER,
		CREX_NULL_HANDLER,
		CREX_BOOL_NOT_SPEC_CV_HANDLER,
		CREX_BOOL_XOR_SPEC_CONST_CONST_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_BOOL_XOR_SPEC_TMPVAR_CONST_HANDLER,
		CREX_BOOL_XOR_SPEC_TMPVAR_TMPVAR_HANDLER,
		CREX_BOOL_XOR_SPEC_TMPVAR_TMPVAR_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_BOOL_XOR_SPEC_TMPVAR_CONST_HANDLER,
		CREX_BOOL_XOR_SPEC_TMPVAR_TMPVAR_HANDLER,
		CREX_BOOL_XOR_SPEC_TMPVAR_TMPVAR_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_BOOL_XOR_SPEC_CV_CONST_HANDLER,
		CREX_BOOL_XOR_SPEC_CV_TMPVAR_HANDLER,
		CREX_BOOL_XOR_SPEC_CV_TMPVAR_HANDLER,
		CREX_NULL_HANDLER,
		CREX_BOOL_XOR_SPEC_CV_CV_HANDLER,
		CREX_IS_IDENTICAL_SPEC_CONST_CONST_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_IS_IDENTICAL_SPEC_TMP_CONST_HANDLER,
		CREX_IS_IDENTICAL_SPEC_TMP_TMP_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_IS_IDENTICAL_SPEC_VAR_CONST_HANDLER,
		CREX_IS_IDENTICAL_SPEC_VAR_TMP_HANDLER,
		CREX_IS_IDENTICAL_SPEC_VAR_VAR_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_IS_IDENTICAL_SPEC_CV_CONST_HANDLER,
		CREX_IS_IDENTICAL_SPEC_CV_TMP_HANDLER,
		CREX_IS_IDENTICAL_SPEC_CV_VAR_HANDLER,
		CREX_NULL_HANDLER,
		CREX_IS_IDENTICAL_SPEC_CV_CV_HANDLER,
		CREX_IS_NOT_IDENTICAL_SPEC_CONST_CONST_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_IS_NOT_IDENTICAL_SPEC_TMP_CONST_HANDLER,
		CREX_IS_NOT_IDENTICAL_SPEC_TMP_TMP_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_IS_NOT_IDENTICAL_SPEC_VAR_CONST_HANDLER,
		CREX_IS_NOT_IDENTICAL_SPEC_VAR_TMP_HANDLER,
		CREX_IS_NOT_IDENTICAL_SPEC_VAR_VAR_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_IS_NOT_IDENTICAL_SPEC_CV_CONST_HANDLER,
		CREX_IS_NOT_IDENTICAL_SPEC_CV_TMP_HANDLER,
		CREX_IS_NOT_IDENTICAL_SPEC_CV_VAR_HANDLER,
		CREX_NULL_HANDLER,
		CREX_IS_NOT_IDENTICAL_SPEC_CV_CV_HANDLER,
		CREX_IS_EQUAL_SPEC_CONST_CONST_HANDLER,
		CREX_IS_EQUAL_SPEC_CONST_CONST_HANDLER,
		CREX_IS_EQUAL_SPEC_CONST_CONST_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_IS_EQUAL_SPEC_TMPVAR_CONST_HANDLER,
		CREX_IS_EQUAL_SPEC_TMPVAR_CONST_JMPC_HANDLER,
		CREX_IS_EQUAL_SPEC_TMPVAR_CONST_JMPNC_HANDLER,
		CREX_IS_EQUAL_SPEC_TMPVAR_TMPVAR_HANDLER,
		CREX_IS_EQUAL_SPEC_TMPVAR_TMPVAR_JMPC_HANDLER,
		CREX_IS_EQUAL_SPEC_TMPVAR_TMPVAR_JMPNC_HANDLER,
		CREX_IS_EQUAL_SPEC_TMPVAR_TMPVAR_HANDLER,
		CREX_IS_EQUAL_SPEC_TMPVAR_TMPVAR_JMPC_HANDLER,
		CREX_IS_EQUAL_SPEC_TMPVAR_TMPVAR_JMPNC_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_IS_EQUAL_SPEC_TMPVAR_CONST_HANDLER,
		CREX_IS_EQUAL_SPEC_TMPVAR_CONST_JMPC_HANDLER,
		CREX_IS_EQUAL_SPEC_TMPVAR_CONST_JMPNC_HANDLER,
		CREX_IS_EQUAL_SPEC_TMPVAR_TMPVAR_HANDLER,
		CREX_IS_EQUAL_SPEC_TMPVAR_TMPVAR_JMPC_HANDLER,
		CREX_IS_EQUAL_SPEC_TMPVAR_TMPVAR_JMPNC_HANDLER,
		CREX_IS_EQUAL_SPEC_TMPVAR_TMPVAR_HANDLER,
		CREX_IS_EQUAL_SPEC_TMPVAR_TMPVAR_JMPC_HANDLER,
		CREX_IS_EQUAL_SPEC_TMPVAR_TMPVAR_JMPNC_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_IS_EQUAL_SPEC_CV_CONST_HANDLER,
		CREX_IS_EQUAL_SPEC_CV_CONST_JMPC_HANDLER,
		CREX_IS_EQUAL_SPEC_CV_CONST_JMPNC_HANDLER,
		CREX_IS_EQUAL_SPEC_CV_TMPVAR_HANDLER,
		CREX_IS_EQUAL_SPEC_CV_TMPVAR_JMPC_HANDLER,
		CREX_IS_EQUAL_SPEC_CV_TMPVAR_JMPNC_HANDLER,
		CREX_IS_EQUAL_SPEC_CV_TMPVAR_HANDLER,
		CREX_IS_EQUAL_SPEC_CV_TMPVAR_JMPC_HANDLER,
		CREX_IS_EQUAL_SPEC_CV_TMPVAR_JMPNC_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_IS_EQUAL_SPEC_CV_CV_HANDLER,
		CREX_IS_EQUAL_SPEC_CV_CV_JMPC_HANDLER,
		CREX_IS_EQUAL_SPEC_CV_CV_JMPNC_HANDLER,
		CREX_IS_NOT_EQUAL_SPEC_CONST_CONST_HANDLER,
		CREX_IS_NOT_EQUAL_SPEC_CONST_CONST_HANDLER,
		CREX_IS_NOT_EQUAL_SPEC_CONST_CONST_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_IS_NOT_EQUAL_SPEC_TMPVAR_CONST_HANDLER,
		CREX_IS_NOT_EQUAL_SPEC_TMPVAR_CONST_JMPC_HANDLER,
		CREX_IS_NOT_EQUAL_SPEC_TMPVAR_CONST_JMPNC_HANDLER,
		CREX_IS_NOT_EQUAL_SPEC_TMPVAR_TMPVAR_HANDLER,
		CREX_IS_NOT_EQUAL_SPEC_TMPVAR_TMPVAR_JMPC_HANDLER,
		CREX_IS_NOT_EQUAL_SPEC_TMPVAR_TMPVAR_JMPNC_HANDLER,
		CREX_IS_NOT_EQUAL_SPEC_TMPVAR_TMPVAR_HANDLER,
		CREX_IS_NOT_EQUAL_SPEC_TMPVAR_TMPVAR_JMPC_HANDLER,
		CREX_IS_NOT_EQUAL_SPEC_TMPVAR_TMPVAR_JMPNC_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_IS_NOT_EQUAL_SPEC_TMPVAR_CONST_HANDLER,
		CREX_IS_NOT_EQUAL_SPEC_TMPVAR_CONST_JMPC_HANDLER,
		CREX_IS_NOT_EQUAL_SPEC_TMPVAR_CONST_JMPNC_HANDLER,
		CREX_IS_NOT_EQUAL_SPEC_TMPVAR_TMPVAR_HANDLER,
		CREX_IS_NOT_EQUAL_SPEC_TMPVAR_TMPVAR_JMPC_HANDLER,
		CREX_IS_NOT_EQUAL_SPEC_TMPVAR_TMPVAR_JMPNC_HANDLER,
		CREX_IS_NOT_EQUAL_SPEC_TMPVAR_TMPVAR_HANDLER,
		CREX_IS_NOT_EQUAL_SPEC_TMPVAR_TMPVAR_JMPC_HANDLER,
		CREX_IS_NOT_EQUAL_SPEC_TMPVAR_TMPVAR_JMPNC_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_IS_NOT_EQUAL_SPEC_CV_CONST_HANDLER,
		CREX_IS_NOT_EQUAL_SPEC_CV_CONST_JMPC_HANDLER,
		CREX_IS_NOT_EQUAL_SPEC_CV_CONST_JMPNC_HANDLER,
		CREX_IS_NOT_EQUAL_SPEC_CV_TMPVAR_HANDLER,
		CREX_IS_NOT_EQUAL_SPEC_CV_TMPVAR_JMPC_HANDLER,
		CREX_IS_NOT_EQUAL_SPEC_CV_TMPVAR_JMPNC_HANDLER,
		CREX_IS_NOT_EQUAL_SPEC_CV_TMPVAR_HANDLER,
		CREX_IS_NOT_EQUAL_SPEC_CV_TMPVAR_JMPC_HANDLER,
		CREX_IS_NOT_EQUAL_SPEC_CV_TMPVAR_JMPNC_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_IS_NOT_EQUAL_SPEC_CV_CV_HANDLER,
		CREX_IS_NOT_EQUAL_SPEC_CV_CV_JMPC_HANDLER,
		CREX_IS_NOT_EQUAL_SPEC_CV_CV_JMPNC_HANDLER,
		CREX_IS_SMALLER_SPEC_CONST_CONST_HANDLER,
		CREX_IS_SMALLER_SPEC_CONST_CONST_HANDLER,
		CREX_IS_SMALLER_SPEC_CONST_CONST_HANDLER,
		CREX_IS_SMALLER_SPEC_CONST_TMPVARCV_HANDLER,
		CREX_IS_SMALLER_SPEC_CONST_TMPVARCV_JMPC_HANDLER,
		CREX_IS_SMALLER_SPEC_CONST_TMPVARCV_JMPNC_HANDLER,
		CREX_IS_SMALLER_SPEC_CONST_TMPVARCV_HANDLER,
		CREX_IS_SMALLER_SPEC_CONST_TMPVARCV_JMPC_HANDLER,
		CREX_IS_SMALLER_SPEC_CONST_TMPVARCV_JMPNC_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_IS_SMALLER_SPEC_CONST_TMPVARCV_HANDLER,
		CREX_IS_SMALLER_SPEC_CONST_TMPVARCV_JMPC_HANDLER,
		CREX_IS_SMALLER_SPEC_CONST_TMPVARCV_JMPNC_HANDLER,
		CREX_IS_SMALLER_SPEC_TMPVARCV_CONST_HANDLER,
		CREX_IS_SMALLER_SPEC_TMPVARCV_CONST_JMPC_HANDLER,
		CREX_IS_SMALLER_SPEC_TMPVARCV_CONST_JMPNC_HANDLER,
		CREX_IS_SMALLER_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_IS_SMALLER_SPEC_TMPVARCV_TMPVARCV_JMPC_HANDLER,
		CREX_IS_SMALLER_SPEC_TMPVARCV_TMPVARCV_JMPNC_HANDLER,
		CREX_IS_SMALLER_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_IS_SMALLER_SPEC_TMPVARCV_TMPVARCV_JMPC_HANDLER,
		CREX_IS_SMALLER_SPEC_TMPVARCV_TMPVARCV_JMPNC_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_IS_SMALLER_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_IS_SMALLER_SPEC_TMPVARCV_TMPVARCV_JMPC_HANDLER,
		CREX_IS_SMALLER_SPEC_TMPVARCV_TMPVARCV_JMPNC_HANDLER,
		CREX_IS_SMALLER_SPEC_TMPVARCV_CONST_HANDLER,
		CREX_IS_SMALLER_SPEC_TMPVARCV_CONST_JMPC_HANDLER,
		CREX_IS_SMALLER_SPEC_TMPVARCV_CONST_JMPNC_HANDLER,
		CREX_IS_SMALLER_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_IS_SMALLER_SPEC_TMPVARCV_TMPVARCV_JMPC_HANDLER,
		CREX_IS_SMALLER_SPEC_TMPVARCV_TMPVARCV_JMPNC_HANDLER,
		CREX_IS_SMALLER_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_IS_SMALLER_SPEC_TMPVARCV_TMPVARCV_JMPC_HANDLER,
		CREX_IS_SMALLER_SPEC_TMPVARCV_TMPVARCV_JMPNC_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_IS_SMALLER_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_IS_SMALLER_SPEC_TMPVARCV_TMPVARCV_JMPC_HANDLER,
		CREX_IS_SMALLER_SPEC_TMPVARCV_TMPVARCV_JMPNC_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_IS_SMALLER_SPEC_TMPVARCV_CONST_HANDLER,
		CREX_IS_SMALLER_SPEC_TMPVARCV_CONST_JMPC_HANDLER,
		CREX_IS_SMALLER_SPEC_TMPVARCV_CONST_JMPNC_HANDLER,
		CREX_IS_SMALLER_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_IS_SMALLER_SPEC_TMPVARCV_TMPVARCV_JMPC_HANDLER,
		CREX_IS_SMALLER_SPEC_TMPVARCV_TMPVARCV_JMPNC_HANDLER,
		CREX_IS_SMALLER_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_IS_SMALLER_SPEC_TMPVARCV_TMPVARCV_JMPC_HANDLER,
		CREX_IS_SMALLER_SPEC_TMPVARCV_TMPVARCV_JMPNC_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_IS_SMALLER_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_IS_SMALLER_SPEC_TMPVARCV_TMPVARCV_JMPC_HANDLER,
		CREX_IS_SMALLER_SPEC_TMPVARCV_TMPVARCV_JMPNC_HANDLER,
		CREX_IS_SMALLER_OR_EQUAL_SPEC_CONST_CONST_HANDLER,
		CREX_IS_SMALLER_OR_EQUAL_SPEC_CONST_CONST_HANDLER,
		CREX_IS_SMALLER_OR_EQUAL_SPEC_CONST_CONST_HANDLER,
		CREX_IS_SMALLER_OR_EQUAL_SPEC_CONST_TMPVARCV_HANDLER,
		CREX_IS_SMALLER_OR_EQUAL_SPEC_CONST_TMPVARCV_JMPC_HANDLER,
		CREX_IS_SMALLER_OR_EQUAL_SPEC_CONST_TMPVARCV_JMPNC_HANDLER,
		CREX_IS_SMALLER_OR_EQUAL_SPEC_CONST_TMPVARCV_HANDLER,
		CREX_IS_SMALLER_OR_EQUAL_SPEC_CONST_TMPVARCV_JMPC_HANDLER,
		CREX_IS_SMALLER_OR_EQUAL_SPEC_CONST_TMPVARCV_JMPNC_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_IS_SMALLER_OR_EQUAL_SPEC_CONST_TMPVARCV_HANDLER,
		CREX_IS_SMALLER_OR_EQUAL_SPEC_CONST_TMPVARCV_JMPC_HANDLER,
		CREX_IS_SMALLER_OR_EQUAL_SPEC_CONST_TMPVARCV_JMPNC_HANDLER,
		CREX_IS_SMALLER_OR_EQUAL_SPEC_TMPVARCV_CONST_HANDLER,
		CREX_IS_SMALLER_OR_EQUAL_SPEC_TMPVARCV_CONST_JMPC_HANDLER,
		CREX_IS_SMALLER_OR_EQUAL_SPEC_TMPVARCV_CONST_JMPNC_HANDLER,
		CREX_IS_SMALLER_OR_EQUAL_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_IS_SMALLER_OR_EQUAL_SPEC_TMPVARCV_TMPVARCV_JMPC_HANDLER,
		CREX_IS_SMALLER_OR_EQUAL_SPEC_TMPVARCV_TMPVARCV_JMPNC_HANDLER,
		CREX_IS_SMALLER_OR_EQUAL_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_IS_SMALLER_OR_EQUAL_SPEC_TMPVARCV_TMPVARCV_JMPC_HANDLER,
		CREX_IS_SMALLER_OR_EQUAL_SPEC_TMPVARCV_TMPVARCV_JMPNC_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_IS_SMALLER_OR_EQUAL_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_IS_SMALLER_OR_EQUAL_SPEC_TMPVARCV_TMPVARCV_JMPC_HANDLER,
		CREX_IS_SMALLER_OR_EQUAL_SPEC_TMPVARCV_TMPVARCV_JMPNC_HANDLER,
		CREX_IS_SMALLER_OR_EQUAL_SPEC_TMPVARCV_CONST_HANDLER,
		CREX_IS_SMALLER_OR_EQUAL_SPEC_TMPVARCV_CONST_JMPC_HANDLER,
		CREX_IS_SMALLER_OR_EQUAL_SPEC_TMPVARCV_CONST_JMPNC_HANDLER,
		CREX_IS_SMALLER_OR_EQUAL_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_IS_SMALLER_OR_EQUAL_SPEC_TMPVARCV_TMPVARCV_JMPC_HANDLER,
		CREX_IS_SMALLER_OR_EQUAL_SPEC_TMPVARCV_TMPVARCV_JMPNC_HANDLER,
		CREX_IS_SMALLER_OR_EQUAL_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_IS_SMALLER_OR_EQUAL_SPEC_TMPVARCV_TMPVARCV_JMPC_HANDLER,
		CREX_IS_SMALLER_OR_EQUAL_SPEC_TMPVARCV_TMPVARCV_JMPNC_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_IS_SMALLER_OR_EQUAL_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_IS_SMALLER_OR_EQUAL_SPEC_TMPVARCV_TMPVARCV_JMPC_HANDLER,
		CREX_IS_SMALLER_OR_EQUAL_SPEC_TMPVARCV_TMPVARCV_JMPNC_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_IS_SMALLER_OR_EQUAL_SPEC_TMPVARCV_CONST_HANDLER,
		CREX_IS_SMALLER_OR_EQUAL_SPEC_TMPVARCV_CONST_JMPC_HANDLER,
		CREX_IS_SMALLER_OR_EQUAL_SPEC_TMPVARCV_CONST_JMPNC_HANDLER,
		CREX_IS_SMALLER_OR_EQUAL_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_IS_SMALLER_OR_EQUAL_SPEC_TMPVARCV_TMPVARCV_JMPC_HANDLER,
		CREX_IS_SMALLER_OR_EQUAL_SPEC_TMPVARCV_TMPVARCV_JMPNC_HANDLER,
		CREX_IS_SMALLER_OR_EQUAL_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_IS_SMALLER_OR_EQUAL_SPEC_TMPVARCV_TMPVARCV_JMPC_HANDLER,
		CREX_IS_SMALLER_OR_EQUAL_SPEC_TMPVARCV_TMPVARCV_JMPNC_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_IS_SMALLER_OR_EQUAL_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_IS_SMALLER_OR_EQUAL_SPEC_TMPVARCV_TMPVARCV_JMPC_HANDLER,
		CREX_IS_SMALLER_OR_EQUAL_SPEC_TMPVARCV_TMPVARCV_JMPNC_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_ASSIGN_SPEC_VAR_CONST_RETVAL_UNUSED_HANDLER,
		CREX_ASSIGN_SPEC_VAR_CONST_RETVAL_USED_HANDLER,
		CREX_ASSIGN_SPEC_VAR_TMP_RETVAL_UNUSED_HANDLER,
		CREX_ASSIGN_SPEC_VAR_TMP_RETVAL_USED_HANDLER,
		CREX_ASSIGN_SPEC_VAR_VAR_RETVAL_UNUSED_HANDLER,
		CREX_ASSIGN_SPEC_VAR_VAR_RETVAL_USED_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_ASSIGN_SPEC_VAR_CV_RETVAL_UNUSED_HANDLER,
		CREX_ASSIGN_SPEC_VAR_CV_RETVAL_USED_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_ASSIGN_SPEC_CV_CONST_RETVAL_UNUSED_HANDLER,
		CREX_ASSIGN_SPEC_CV_CONST_RETVAL_USED_HANDLER,
		CREX_ASSIGN_SPEC_CV_TMP_RETVAL_UNUSED_HANDLER,
		CREX_ASSIGN_SPEC_CV_TMP_RETVAL_USED_HANDLER,
		CREX_ASSIGN_SPEC_CV_VAR_RETVAL_UNUSED_HANDLER,
		CREX_ASSIGN_SPEC_CV_VAR_RETVAL_USED_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_ASSIGN_SPEC_CV_CV_RETVAL_UNUSED_HANDLER,
		CREX_ASSIGN_SPEC_CV_CV_RETVAL_USED_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_ASSIGN_DIM_SPEC_VAR_CONST_OP_DATA_CONST_HANDLER,
		CREX_ASSIGN_DIM_SPEC_VAR_CONST_OP_DATA_TMP_HANDLER,
		CREX_ASSIGN_DIM_SPEC_VAR_CONST_OP_DATA_VAR_HANDLER,
		CREX_NULL_HANDLER,
		CREX_ASSIGN_DIM_SPEC_VAR_CONST_OP_DATA_CV_HANDLER,
		CREX_ASSIGN_DIM_SPEC_VAR_TMPVAR_OP_DATA_CONST_HANDLER,
		CREX_ASSIGN_DIM_SPEC_VAR_TMPVAR_OP_DATA_TMP_HANDLER,
		CREX_ASSIGN_DIM_SPEC_VAR_TMPVAR_OP_DATA_VAR_HANDLER,
		CREX_NULL_HANDLER,
		CREX_ASSIGN_DIM_SPEC_VAR_TMPVAR_OP_DATA_CV_HANDLER,
		CREX_ASSIGN_DIM_SPEC_VAR_TMPVAR_OP_DATA_CONST_HANDLER,
		CREX_ASSIGN_DIM_SPEC_VAR_TMPVAR_OP_DATA_TMP_HANDLER,
		CREX_ASSIGN_DIM_SPEC_VAR_TMPVAR_OP_DATA_VAR_HANDLER,
		CREX_NULL_HANDLER,
		CREX_ASSIGN_DIM_SPEC_VAR_TMPVAR_OP_DATA_CV_HANDLER,
		CREX_ASSIGN_DIM_SPEC_VAR_UNUSED_OP_DATA_CONST_HANDLER,
		CREX_ASSIGN_DIM_SPEC_VAR_UNUSED_OP_DATA_TMP_HANDLER,
		CREX_ASSIGN_DIM_SPEC_VAR_UNUSED_OP_DATA_VAR_HANDLER,
		CREX_NULL_HANDLER,
		CREX_ASSIGN_DIM_SPEC_VAR_UNUSED_OP_DATA_CV_HANDLER,
		CREX_ASSIGN_DIM_SPEC_VAR_CV_OP_DATA_CONST_HANDLER,
		CREX_ASSIGN_DIM_SPEC_VAR_CV_OP_DATA_TMP_HANDLER,
		CREX_ASSIGN_DIM_SPEC_VAR_CV_OP_DATA_VAR_HANDLER,
		CREX_NULL_HANDLER,
		CREX_ASSIGN_DIM_SPEC_VAR_CV_OP_DATA_CV_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_ASSIGN_DIM_SPEC_CV_CONST_OP_DATA_CONST_HANDLER,
		CREX_ASSIGN_DIM_SPEC_CV_CONST_OP_DATA_TMP_HANDLER,
		CREX_ASSIGN_DIM_SPEC_CV_CONST_OP_DATA_VAR_HANDLER,
		CREX_NULL_HANDLER,
		CREX_ASSIGN_DIM_SPEC_CV_CONST_OP_DATA_CV_HANDLER,
		CREX_ASSIGN_DIM_SPEC_CV_TMPVAR_OP_DATA_CONST_HANDLER,
		CREX_ASSIGN_DIM_SPEC_CV_TMPVAR_OP_DATA_TMP_HANDLER,
		CREX_ASSIGN_DIM_SPEC_CV_TMPVAR_OP_DATA_VAR_HANDLER,
		CREX_NULL_HANDLER,
		CREX_ASSIGN_DIM_SPEC_CV_TMPVAR_OP_DATA_CV_HANDLER,
		CREX_ASSIGN_DIM_SPEC_CV_TMPVAR_OP_DATA_CONST_HANDLER,
		CREX_ASSIGN_DIM_SPEC_CV_TMPVAR_OP_DATA_TMP_HANDLER,
		CREX_ASSIGN_DIM_SPEC_CV_TMPVAR_OP_DATA_VAR_HANDLER,
		CREX_NULL_HANDLER,
		CREX_ASSIGN_DIM_SPEC_CV_TMPVAR_OP_DATA_CV_HANDLER,
		CREX_ASSIGN_DIM_SPEC_CV_UNUSED_OP_DATA_CONST_HANDLER,
		CREX_ASSIGN_DIM_SPEC_CV_UNUSED_OP_DATA_TMP_HANDLER,
		CREX_ASSIGN_DIM_SPEC_CV_UNUSED_OP_DATA_VAR_HANDLER,
		CREX_NULL_HANDLER,
		CREX_ASSIGN_DIM_SPEC_CV_UNUSED_OP_DATA_CV_HANDLER,
		CREX_ASSIGN_DIM_SPEC_CV_CV_OP_DATA_CONST_HANDLER,
		CREX_ASSIGN_DIM_SPEC_CV_CV_OP_DATA_TMP_HANDLER,
		CREX_ASSIGN_DIM_SPEC_CV_CV_OP_DATA_VAR_HANDLER,
		CREX_NULL_HANDLER,
		CREX_ASSIGN_DIM_SPEC_CV_CV_OP_DATA_CV_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_ASSIGN_OBJ_SPEC_VAR_CONST_OP_DATA_CONST_HANDLER,
		CREX_ASSIGN_OBJ_SPEC_VAR_CONST_OP_DATA_TMP_HANDLER,
		CREX_ASSIGN_OBJ_SPEC_VAR_CONST_OP_DATA_VAR_HANDLER,
		CREX_NULL_HANDLER,
		CREX_ASSIGN_OBJ_SPEC_VAR_CONST_OP_DATA_CV_HANDLER,
		CREX_ASSIGN_OBJ_SPEC_VAR_TMPVAR_OP_DATA_CONST_HANDLER,
		CREX_ASSIGN_OBJ_SPEC_VAR_TMPVAR_OP_DATA_TMP_HANDLER,
		CREX_ASSIGN_OBJ_SPEC_VAR_TMPVAR_OP_DATA_VAR_HANDLER,
		CREX_NULL_HANDLER,
		CREX_ASSIGN_OBJ_SPEC_VAR_TMPVAR_OP_DATA_CV_HANDLER,
		CREX_ASSIGN_OBJ_SPEC_VAR_TMPVAR_OP_DATA_CONST_HANDLER,
		CREX_ASSIGN_OBJ_SPEC_VAR_TMPVAR_OP_DATA_TMP_HANDLER,
		CREX_ASSIGN_OBJ_SPEC_VAR_TMPVAR_OP_DATA_VAR_HANDLER,
		CREX_NULL_HANDLER,
		CREX_ASSIGN_OBJ_SPEC_VAR_TMPVAR_OP_DATA_CV_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_ASSIGN_OBJ_SPEC_VAR_CV_OP_DATA_CONST_HANDLER,
		CREX_ASSIGN_OBJ_SPEC_VAR_CV_OP_DATA_TMP_HANDLER,
		CREX_ASSIGN_OBJ_SPEC_VAR_CV_OP_DATA_VAR_HANDLER,
		CREX_NULL_HANDLER,
		CREX_ASSIGN_OBJ_SPEC_VAR_CV_OP_DATA_CV_HANDLER,
		CREX_ASSIGN_OBJ_SPEC_UNUSED_CONST_OP_DATA_CONST_HANDLER,
		CREX_ASSIGN_OBJ_SPEC_UNUSED_CONST_OP_DATA_TMP_HANDLER,
		CREX_ASSIGN_OBJ_SPEC_UNUSED_CONST_OP_DATA_VAR_HANDLER,
		CREX_NULL_HANDLER,
		CREX_ASSIGN_OBJ_SPEC_UNUSED_CONST_OP_DATA_CV_HANDLER,
		CREX_ASSIGN_OBJ_SPEC_UNUSED_TMPVAR_OP_DATA_CONST_HANDLER,
		CREX_ASSIGN_OBJ_SPEC_UNUSED_TMPVAR_OP_DATA_TMP_HANDLER,
		CREX_ASSIGN_OBJ_SPEC_UNUSED_TMPVAR_OP_DATA_VAR_HANDLER,
		CREX_NULL_HANDLER,
		CREX_ASSIGN_OBJ_SPEC_UNUSED_TMPVAR_OP_DATA_CV_HANDLER,
		CREX_ASSIGN_OBJ_SPEC_UNUSED_TMPVAR_OP_DATA_CONST_HANDLER,
		CREX_ASSIGN_OBJ_SPEC_UNUSED_TMPVAR_OP_DATA_TMP_HANDLER,
		CREX_ASSIGN_OBJ_SPEC_UNUSED_TMPVAR_OP_DATA_VAR_HANDLER,
		CREX_NULL_HANDLER,
		CREX_ASSIGN_OBJ_SPEC_UNUSED_TMPVAR_OP_DATA_CV_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_ASSIGN_OBJ_SPEC_UNUSED_CV_OP_DATA_CONST_HANDLER,
		CREX_ASSIGN_OBJ_SPEC_UNUSED_CV_OP_DATA_TMP_HANDLER,
		CREX_ASSIGN_OBJ_SPEC_UNUSED_CV_OP_DATA_VAR_HANDLER,
		CREX_NULL_HANDLER,
		CREX_ASSIGN_OBJ_SPEC_UNUSED_CV_OP_DATA_CV_HANDLER,
		CREX_ASSIGN_OBJ_SPEC_CV_CONST_OP_DATA_CONST_HANDLER,
		CREX_ASSIGN_OBJ_SPEC_CV_CONST_OP_DATA_TMP_HANDLER,
		CREX_ASSIGN_OBJ_SPEC_CV_CONST_OP_DATA_VAR_HANDLER,
		CREX_NULL_HANDLER,
		CREX_ASSIGN_OBJ_SPEC_CV_CONST_OP_DATA_CV_HANDLER,
		CREX_ASSIGN_OBJ_SPEC_CV_TMPVAR_OP_DATA_CONST_HANDLER,
		CREX_ASSIGN_OBJ_SPEC_CV_TMPVAR_OP_DATA_TMP_HANDLER,
		CREX_ASSIGN_OBJ_SPEC_CV_TMPVAR_OP_DATA_VAR_HANDLER,
		CREX_NULL_HANDLER,
		CREX_ASSIGN_OBJ_SPEC_CV_TMPVAR_OP_DATA_CV_HANDLER,
		CREX_ASSIGN_OBJ_SPEC_CV_TMPVAR_OP_DATA_CONST_HANDLER,
		CREX_ASSIGN_OBJ_SPEC_CV_TMPVAR_OP_DATA_TMP_HANDLER,
		CREX_ASSIGN_OBJ_SPEC_CV_TMPVAR_OP_DATA_VAR_HANDLER,
		CREX_NULL_HANDLER,
		CREX_ASSIGN_OBJ_SPEC_CV_TMPVAR_OP_DATA_CV_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_ASSIGN_OBJ_SPEC_CV_CV_OP_DATA_CONST_HANDLER,
		CREX_ASSIGN_OBJ_SPEC_CV_CV_OP_DATA_TMP_HANDLER,
		CREX_ASSIGN_OBJ_SPEC_CV_CV_OP_DATA_VAR_HANDLER,
		CREX_NULL_HANDLER,
		CREX_ASSIGN_OBJ_SPEC_CV_CV_OP_DATA_CV_HANDLER,
		CREX_ASSIGN_STATIC_PROP_SPEC_OP_DATA_CONST_HANDLER,
		CREX_ASSIGN_STATIC_PROP_SPEC_OP_DATA_TMP_HANDLER,
		CREX_ASSIGN_STATIC_PROP_SPEC_OP_DATA_VAR_HANDLER,
		CREX_NULL_HANDLER,
		CREX_ASSIGN_STATIC_PROP_SPEC_OP_DATA_CV_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_ASSIGN_OP_SPEC_VAR_CONST_HANDLER,
		CREX_ASSIGN_OP_SPEC_VAR_TMPVAR_HANDLER,
		CREX_ASSIGN_OP_SPEC_VAR_TMPVAR_HANDLER,
		CREX_NULL_HANDLER,
		CREX_ASSIGN_OP_SPEC_VAR_CV_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_ASSIGN_OP_SPEC_CV_CONST_HANDLER,
		CREX_ASSIGN_OP_SPEC_CV_TMPVAR_HANDLER,
		CREX_ASSIGN_OP_SPEC_CV_TMPVAR_HANDLER,
		CREX_NULL_HANDLER,
		CREX_ASSIGN_OP_SPEC_CV_CV_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_ASSIGN_DIM_OP_SPEC_VAR_CONST_HANDLER,
		CREX_ASSIGN_DIM_OP_SPEC_VAR_TMPVAR_HANDLER,
		CREX_ASSIGN_DIM_OP_SPEC_VAR_TMPVAR_HANDLER,
		CREX_ASSIGN_DIM_OP_SPEC_VAR_UNUSED_HANDLER,
		CREX_ASSIGN_DIM_OP_SPEC_VAR_CV_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_ASSIGN_DIM_OP_SPEC_CV_CONST_HANDLER,
		CREX_ASSIGN_DIM_OP_SPEC_CV_TMPVAR_HANDLER,
		CREX_ASSIGN_DIM_OP_SPEC_CV_TMPVAR_HANDLER,
		CREX_ASSIGN_DIM_OP_SPEC_CV_UNUSED_HANDLER,
		CREX_ASSIGN_DIM_OP_SPEC_CV_CV_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_ASSIGN_OBJ_OP_SPEC_VAR_CONST_HANDLER,
		CREX_ASSIGN_OBJ_OP_SPEC_VAR_TMPVAR_HANDLER,
		CREX_ASSIGN_OBJ_OP_SPEC_VAR_TMPVAR_HANDLER,
		CREX_NULL_HANDLER,
		CREX_ASSIGN_OBJ_OP_SPEC_VAR_CV_HANDLER,
		CREX_ASSIGN_OBJ_OP_SPEC_UNUSED_CONST_HANDLER,
		CREX_ASSIGN_OBJ_OP_SPEC_UNUSED_TMPVAR_HANDLER,
		CREX_ASSIGN_OBJ_OP_SPEC_UNUSED_TMPVAR_HANDLER,
		CREX_NULL_HANDLER,
		CREX_ASSIGN_OBJ_OP_SPEC_UNUSED_CV_HANDLER,
		CREX_ASSIGN_OBJ_OP_SPEC_CV_CONST_HANDLER,
		CREX_ASSIGN_OBJ_OP_SPEC_CV_TMPVAR_HANDLER,
		CREX_ASSIGN_OBJ_OP_SPEC_CV_TMPVAR_HANDLER,
		CREX_NULL_HANDLER,
		CREX_ASSIGN_OBJ_OP_SPEC_CV_CV_HANDLER,
		CREX_ASSIGN_STATIC_PROP_OP_SPEC_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_ASSIGN_REF_SPEC_VAR_VAR_HANDLER,
		CREX_NULL_HANDLER,
		CREX_ASSIGN_REF_SPEC_VAR_CV_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_ASSIGN_REF_SPEC_CV_VAR_HANDLER,
		CREX_NULL_HANDLER,
		CREX_ASSIGN_REF_SPEC_CV_CV_HANDLER,
		CREX_QM_ASSIGN_SPEC_CONST_HANDLER,
		CREX_QM_ASSIGN_SPEC_TMP_HANDLER,
		CREX_QM_ASSIGN_SPEC_VAR_HANDLER,
		CREX_NULL_HANDLER,
		CREX_QM_ASSIGN_SPEC_CV_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_ASSIGN_OBJ_REF_SPEC_VAR_CONST_OP_DATA_VAR_HANDLER,
		CREX_NULL_HANDLER,
		CREX_ASSIGN_OBJ_REF_SPEC_VAR_CONST_OP_DATA_CV_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_ASSIGN_OBJ_REF_SPEC_VAR_TMPVAR_OP_DATA_VAR_HANDLER,
		CREX_NULL_HANDLER,
		CREX_ASSIGN_OBJ_REF_SPEC_VAR_TMPVAR_OP_DATA_CV_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_ASSIGN_OBJ_REF_SPEC_VAR_TMPVAR_OP_DATA_VAR_HANDLER,
		CREX_NULL_HANDLER,
		CREX_ASSIGN_OBJ_REF_SPEC_VAR_TMPVAR_OP_DATA_CV_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_ASSIGN_OBJ_REF_SPEC_VAR_CV_OP_DATA_VAR_HANDLER,
		CREX_NULL_HANDLER,
		CREX_ASSIGN_OBJ_REF_SPEC_VAR_CV_OP_DATA_CV_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_ASSIGN_OBJ_REF_SPEC_UNUSED_CONST_OP_DATA_VAR_HANDLER,
		CREX_NULL_HANDLER,
		CREX_ASSIGN_OBJ_REF_SPEC_UNUSED_CONST_OP_DATA_CV_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_ASSIGN_OBJ_REF_SPEC_UNUSED_TMPVAR_OP_DATA_VAR_HANDLER,
		CREX_NULL_HANDLER,
		CREX_ASSIGN_OBJ_REF_SPEC_UNUSED_TMPVAR_OP_DATA_CV_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_ASSIGN_OBJ_REF_SPEC_UNUSED_TMPVAR_OP_DATA_VAR_HANDLER,
		CREX_NULL_HANDLER,
		CREX_ASSIGN_OBJ_REF_SPEC_UNUSED_TMPVAR_OP_DATA_CV_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_ASSIGN_OBJ_REF_SPEC_UNUSED_CV_OP_DATA_VAR_HANDLER,
		CREX_NULL_HANDLER,
		CREX_ASSIGN_OBJ_REF_SPEC_UNUSED_CV_OP_DATA_CV_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_ASSIGN_OBJ_REF_SPEC_CV_CONST_OP_DATA_VAR_HANDLER,
		CREX_NULL_HANDLER,
		CREX_ASSIGN_OBJ_REF_SPEC_CV_CONST_OP_DATA_CV_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_ASSIGN_OBJ_REF_SPEC_CV_TMPVAR_OP_DATA_VAR_HANDLER,
		CREX_NULL_HANDLER,
		CREX_ASSIGN_OBJ_REF_SPEC_CV_TMPVAR_OP_DATA_CV_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_ASSIGN_OBJ_REF_SPEC_CV_TMPVAR_OP_DATA_VAR_HANDLER,
		CREX_NULL_HANDLER,
		CREX_ASSIGN_OBJ_REF_SPEC_CV_TMPVAR_OP_DATA_CV_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_ASSIGN_OBJ_REF_SPEC_CV_CV_OP_DATA_VAR_HANDLER,
		CREX_NULL_HANDLER,
		CREX_ASSIGN_OBJ_REF_SPEC_CV_CV_OP_DATA_CV_HANDLER,
		CREX_ASSIGN_STATIC_PROP_REF_SPEC_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_PRE_INC_SPEC_VAR_RETVAL_UNUSED_HANDLER,
		CREX_PRE_INC_SPEC_VAR_RETVAL_USED_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_PRE_INC_SPEC_CV_RETVAL_UNUSED_HANDLER,
		CREX_PRE_INC_SPEC_CV_RETVAL_USED_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_PRE_DEC_SPEC_VAR_RETVAL_UNUSED_HANDLER,
		CREX_PRE_DEC_SPEC_VAR_RETVAL_USED_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_PRE_DEC_SPEC_CV_RETVAL_UNUSED_HANDLER,
		CREX_PRE_DEC_SPEC_CV_RETVAL_USED_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_POST_INC_SPEC_VAR_HANDLER,
		CREX_NULL_HANDLER,
		CREX_POST_INC_SPEC_CV_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_POST_DEC_SPEC_VAR_HANDLER,
		CREX_NULL_HANDLER,
		CREX_POST_DEC_SPEC_CV_HANDLER,
		CREX_PRE_INC_STATIC_PROP_SPEC_HANDLER,
		CREX_POST_INC_STATIC_PROP_SPEC_HANDLER,
		CREX_JMP_SPEC_HANDLER,
		CREX_JMPC_SPEC_CONST_HANDLER,
		CREX_JMPC_SPEC_TMPVAR_HANDLER,
		CREX_JMPC_SPEC_TMPVAR_HANDLER,
		CREX_NULL_HANDLER,
		CREX_JMPC_SPEC_CV_HANDLER,
		CREX_JMPNC_SPEC_CONST_HANDLER,
		CREX_JMPNC_SPEC_TMPVAR_HANDLER,
		CREX_JMPNC_SPEC_TMPVAR_HANDLER,
		CREX_NULL_HANDLER,
		CREX_JMPNC_SPEC_CV_HANDLER,
		CREX_JMPC_EX_SPEC_CONST_HANDLER,
		CREX_JMPC_EX_SPEC_TMPVAR_HANDLER,
		CREX_JMPC_EX_SPEC_TMPVAR_HANDLER,
		CREX_NULL_HANDLER,
		CREX_JMPC_EX_SPEC_CV_HANDLER,
		CREX_JMPNC_EX_SPEC_CONST_HANDLER,
		CREX_JMPNC_EX_SPEC_TMPVAR_HANDLER,
		CREX_JMPNC_EX_SPEC_TMPVAR_HANDLER,
		CREX_NULL_HANDLER,
		CREX_JMPNC_EX_SPEC_CV_HANDLER,
		CREX_CASE_SPEC_TMPVAR_CONST_HANDLER,
		CREX_CASE_SPEC_TMPVAR_TMPVAR_HANDLER,
		CREX_CASE_SPEC_TMPVAR_TMPVAR_HANDLER,
		CREX_NULL_HANDLER,
		CREX_CASE_SPEC_TMPVAR_CV_HANDLER,
		CREX_CHECK_VAR_SPEC_CV_UNUSED_HANDLER,
		CREX_SEND_VAR_NO_REF_EX_SPEC_VAR_CONST_HANDLER,
		CREX_SEND_VAR_NO_REF_EX_SPEC_VAR_CONST_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_SEND_VAR_NO_REF_EX_SPEC_VAR_UNUSED_HANDLER,
		CREX_SEND_VAR_NO_REF_EX_SPEC_VAR_UNUSED_QUICK_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_CAST_SPEC_CONST_HANDLER,
		CREX_CAST_SPEC_TMP_HANDLER,
		CREX_CAST_SPEC_VAR_HANDLER,
		CREX_NULL_HANDLER,
		CREX_CAST_SPEC_CV_HANDLER,
		CREX_BOOL_SPEC_CONST_HANDLER,
		CREX_BOOL_SPEC_TMPVAR_HANDLER,
		CREX_BOOL_SPEC_TMPVAR_HANDLER,
		CREX_NULL_HANDLER,
		CREX_BOOL_SPEC_CV_HANDLER,
		CREX_FAST_CONCAT_SPEC_CONST_CONST_HANDLER,
		CREX_FAST_CONCAT_SPEC_CONST_TMPVAR_HANDLER,
		CREX_FAST_CONCAT_SPEC_CONST_TMPVAR_HANDLER,
		CREX_NULL_HANDLER,
		CREX_FAST_CONCAT_SPEC_CONST_CV_HANDLER,
		CREX_FAST_CONCAT_SPEC_TMPVAR_CONST_HANDLER,
		CREX_FAST_CONCAT_SPEC_TMPVAR_TMPVAR_HANDLER,
		CREX_FAST_CONCAT_SPEC_TMPVAR_TMPVAR_HANDLER,
		CREX_NULL_HANDLER,
		CREX_FAST_CONCAT_SPEC_TMPVAR_CV_HANDLER,
		CREX_FAST_CONCAT_SPEC_TMPVAR_CONST_HANDLER,
		CREX_FAST_CONCAT_SPEC_TMPVAR_TMPVAR_HANDLER,
		CREX_FAST_CONCAT_SPEC_TMPVAR_TMPVAR_HANDLER,
		CREX_NULL_HANDLER,
		CREX_FAST_CONCAT_SPEC_TMPVAR_CV_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_FAST_CONCAT_SPEC_CV_CONST_HANDLER,
		CREX_FAST_CONCAT_SPEC_CV_TMPVAR_HANDLER,
		CREX_FAST_CONCAT_SPEC_CV_TMPVAR_HANDLER,
		CREX_NULL_HANDLER,
		CREX_FAST_CONCAT_SPEC_CV_CV_HANDLER,
		CREX_ROPE_INIT_SPEC_UNUSED_CONST_HANDLER,
		CREX_ROPE_INIT_SPEC_UNUSED_TMPVAR_HANDLER,
		CREX_ROPE_INIT_SPEC_UNUSED_TMPVAR_HANDLER,
		CREX_NULL_HANDLER,
		CREX_ROPE_INIT_SPEC_UNUSED_CV_HANDLER,
		CREX_ROPE_ADD_SPEC_TMP_CONST_HANDLER,
		CREX_ROPE_ADD_SPEC_TMP_TMPVAR_HANDLER,
		CREX_ROPE_ADD_SPEC_TMP_TMPVAR_HANDLER,
		CREX_NULL_HANDLER,
		CREX_ROPE_ADD_SPEC_TMP_CV_HANDLER,
		CREX_ROPE_END_SPEC_TMP_CONST_HANDLER,
		CREX_ROPE_END_SPEC_TMP_TMPVAR_HANDLER,
		CREX_ROPE_END_SPEC_TMP_TMPVAR_HANDLER,
		CREX_NULL_HANDLER,
		CREX_ROPE_END_SPEC_TMP_CV_HANDLER,
		CREX_BEGIN_SILENCE_SPEC_HANDLER,
		CREX_END_SILENCE_SPEC_TMP_HANDLER,
		CREX_INIT_FCALL_BY_NAME_SPEC_CONST_HANDLER,
		CREX_DO_FCALL_SPEC_RETVAL_UNUSED_HANDLER,
		CREX_DO_FCALL_SPEC_RETVAL_USED_HANDLER,
		CREX_DO_FCALL_SPEC_OBSERVER_HANDLER,
		CREX_DO_FCALL_SPEC_OBSERVER_HANDLER,
		CREX_INIT_FCALL_SPEC_CONST_HANDLER,
		CREX_RETURN_SPEC_CONST_HANDLER,
		CREX_RETURN_SPEC_OBSERVER_HANDLER,
		CREX_RETURN_SPEC_TMP_HANDLER,
		CREX_RETURN_SPEC_OBSERVER_HANDLER,
		CREX_RETURN_SPEC_VAR_HANDLER,
		CREX_RETURN_SPEC_OBSERVER_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_RETURN_SPEC_CV_HANDLER,
		CREX_RETURN_SPEC_OBSERVER_HANDLER,
		CREX_RECV_SPEC_UNUSED_HANDLER,
		CREX_RECV_INIT_SPEC_CONST_HANDLER,
		CREX_SEND_VAL_SPEC_CONST_CONST_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_SEND_VAL_SPEC_CONST_UNUSED_HANDLER,
		CREX_NULL_HANDLER,
		CREX_SEND_VAL_SPEC_TMPVAR_CONST_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_SEND_VAL_SPEC_TMPVAR_UNUSED_HANDLER,
		CREX_NULL_HANDLER,
		CREX_SEND_VAL_SPEC_TMPVAR_CONST_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_SEND_VAL_SPEC_TMPVAR_UNUSED_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_SEND_VAR_EX_SPEC_VAR_CONST_HANDLER,
		CREX_SEND_VAR_EX_SPEC_VAR_CONST_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_SEND_VAR_EX_SPEC_VAR_UNUSED_HANDLER,
		CREX_SEND_VAR_EX_SPEC_VAR_UNUSED_QUICK_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_SEND_VAR_EX_SPEC_CV_CONST_HANDLER,
		CREX_SEND_VAR_EX_SPEC_CV_CONST_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_SEND_VAR_EX_SPEC_CV_UNUSED_HANDLER,
		CREX_SEND_VAR_EX_SPEC_CV_UNUSED_QUICK_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_SEND_REF_SPEC_VAR_CONST_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_SEND_REF_SPEC_VAR_UNUSED_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_SEND_REF_SPEC_CV_CONST_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_SEND_REF_SPEC_CV_UNUSED_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NEW_SPEC_CONST_UNUSED_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NEW_SPEC_VAR_UNUSED_HANDLER,
		CREX_NEW_SPEC_UNUSED_UNUSED_HANDLER,
		CREX_NULL_HANDLER,
		CREX_INIT_NS_FCALL_BY_NAME_SPEC_CONST_HANDLER,
		CREX_FREE_SPEC_TMPVAR_HANDLER,
		CREX_INIT_ARRAY_SPEC_CONST_CONST_HANDLER,
		CREX_INIT_ARRAY_SPEC_CONST_TMPVAR_HANDLER,
		CREX_INIT_ARRAY_SPEC_CONST_TMPVAR_HANDLER,
		CREX_INIT_ARRAY_SPEC_CONST_UNUSED_HANDLER,
		CREX_INIT_ARRAY_SPEC_CONST_CV_HANDLER,
		CREX_INIT_ARRAY_SPEC_TMP_CONST_HANDLER,
		CREX_INIT_ARRAY_SPEC_TMP_TMPVAR_HANDLER,
		CREX_INIT_ARRAY_SPEC_TMP_TMPVAR_HANDLER,
		CREX_INIT_ARRAY_SPEC_TMP_UNUSED_HANDLER,
		CREX_INIT_ARRAY_SPEC_TMP_CV_HANDLER,
		CREX_INIT_ARRAY_SPEC_VAR_CONST_HANDLER,
		CREX_INIT_ARRAY_SPEC_VAR_TMPVAR_HANDLER,
		CREX_INIT_ARRAY_SPEC_VAR_TMPVAR_HANDLER,
		CREX_INIT_ARRAY_SPEC_VAR_UNUSED_HANDLER,
		CREX_INIT_ARRAY_SPEC_VAR_CV_HANDLER,
		CREX_INIT_ARRAY_SPEC_UNUSED_CONST_HANDLER,
		CREX_INIT_ARRAY_SPEC_UNUSED_TMPVAR_HANDLER,
		CREX_INIT_ARRAY_SPEC_UNUSED_TMPVAR_HANDLER,
		CREX_INIT_ARRAY_SPEC_UNUSED_UNUSED_HANDLER,
		CREX_INIT_ARRAY_SPEC_UNUSED_CV_HANDLER,
		CREX_INIT_ARRAY_SPEC_CV_CONST_HANDLER,
		CREX_INIT_ARRAY_SPEC_CV_TMPVAR_HANDLER,
		CREX_INIT_ARRAY_SPEC_CV_TMPVAR_HANDLER,
		CREX_INIT_ARRAY_SPEC_CV_UNUSED_HANDLER,
		CREX_INIT_ARRAY_SPEC_CV_CV_HANDLER,
		CREX_ADD_ARRAY_ELEMENT_SPEC_CONST_CONST_HANDLER,
		CREX_ADD_ARRAY_ELEMENT_SPEC_CONST_TMPVAR_HANDLER,
		CREX_ADD_ARRAY_ELEMENT_SPEC_CONST_TMPVAR_HANDLER,
		CREX_ADD_ARRAY_ELEMENT_SPEC_CONST_UNUSED_HANDLER,
		CREX_ADD_ARRAY_ELEMENT_SPEC_CONST_CV_HANDLER,
		CREX_ADD_ARRAY_ELEMENT_SPEC_TMP_CONST_HANDLER,
		CREX_ADD_ARRAY_ELEMENT_SPEC_TMP_TMPVAR_HANDLER,
		CREX_ADD_ARRAY_ELEMENT_SPEC_TMP_TMPVAR_HANDLER,
		CREX_ADD_ARRAY_ELEMENT_SPEC_TMP_UNUSED_HANDLER,
		CREX_ADD_ARRAY_ELEMENT_SPEC_TMP_CV_HANDLER,
		CREX_ADD_ARRAY_ELEMENT_SPEC_VAR_CONST_HANDLER,
		CREX_ADD_ARRAY_ELEMENT_SPEC_VAR_TMPVAR_HANDLER,
		CREX_ADD_ARRAY_ELEMENT_SPEC_VAR_TMPVAR_HANDLER,
		CREX_ADD_ARRAY_ELEMENT_SPEC_VAR_UNUSED_HANDLER,
		CREX_ADD_ARRAY_ELEMENT_SPEC_VAR_CV_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_ADD_ARRAY_ELEMENT_SPEC_CV_CONST_HANDLER,
		CREX_ADD_ARRAY_ELEMENT_SPEC_CV_TMPVAR_HANDLER,
		CREX_ADD_ARRAY_ELEMENT_SPEC_CV_TMPVAR_HANDLER,
		CREX_ADD_ARRAY_ELEMENT_SPEC_CV_UNUSED_HANDLER,
		CREX_ADD_ARRAY_ELEMENT_SPEC_CV_CV_HANDLER,
		CREX_INCLUDE_OR_EVAL_SPEC_CONST_HANDLER,
		CREX_INCLUDE_OR_EVAL_SPEC_OBSERVER_HANDLER,
		CREX_INCLUDE_OR_EVAL_SPEC_TMPVAR_HANDLER,
		CREX_INCLUDE_OR_EVAL_SPEC_OBSERVER_HANDLER,
		CREX_INCLUDE_OR_EVAL_SPEC_TMPVAR_HANDLER,
		CREX_INCLUDE_OR_EVAL_SPEC_OBSERVER_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_INCLUDE_OR_EVAL_SPEC_CV_HANDLER,
		CREX_INCLUDE_OR_EVAL_SPEC_OBSERVER_HANDLER,
		CREX_UNSET_VAR_SPEC_CONST_UNUSED_HANDLER,
		CREX_UNSET_VAR_SPEC_TMPVAR_UNUSED_HANDLER,
		CREX_UNSET_VAR_SPEC_TMPVAR_UNUSED_HANDLER,
		CREX_NULL_HANDLER,
		CREX_UNSET_VAR_SPEC_CV_UNUSED_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_UNSET_DIM_SPEC_VAR_CONST_HANDLER,
		CREX_UNSET_DIM_SPEC_VAR_TMPVAR_HANDLER,
		CREX_UNSET_DIM_SPEC_VAR_TMPVAR_HANDLER,
		CREX_NULL_HANDLER,
		CREX_UNSET_DIM_SPEC_VAR_CV_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_UNSET_DIM_SPEC_CV_CONST_HANDLER,
		CREX_UNSET_DIM_SPEC_CV_TMPVAR_HANDLER,
		CREX_UNSET_DIM_SPEC_CV_TMPVAR_HANDLER,
		CREX_NULL_HANDLER,
		CREX_UNSET_DIM_SPEC_CV_CV_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_UNSET_OBJ_SPEC_VAR_CONST_HANDLER,
		CREX_UNSET_OBJ_SPEC_VAR_TMPVAR_HANDLER,
		CREX_UNSET_OBJ_SPEC_VAR_TMPVAR_HANDLER,
		CREX_NULL_HANDLER,
		CREX_UNSET_OBJ_SPEC_VAR_CV_HANDLER,
		CREX_UNSET_OBJ_SPEC_UNUSED_CONST_HANDLER,
		CREX_UNSET_OBJ_SPEC_UNUSED_TMPVAR_HANDLER,
		CREX_UNSET_OBJ_SPEC_UNUSED_TMPVAR_HANDLER,
		CREX_NULL_HANDLER,
		CREX_UNSET_OBJ_SPEC_UNUSED_CV_HANDLER,
		CREX_UNSET_OBJ_SPEC_CV_CONST_HANDLER,
		CREX_UNSET_OBJ_SPEC_CV_TMPVAR_HANDLER,
		CREX_UNSET_OBJ_SPEC_CV_TMPVAR_HANDLER,
		CREX_NULL_HANDLER,
		CREX_UNSET_OBJ_SPEC_CV_CV_HANDLER,
		CREX_FE_RESET_R_SPEC_CONST_HANDLER,
		CREX_FE_RESET_R_SPEC_TMP_HANDLER,
		CREX_FE_RESET_R_SPEC_VAR_HANDLER,
		CREX_NULL_HANDLER,
		CREX_FE_RESET_R_SPEC_CV_HANDLER,
		CREX_FE_FETCH_R_SPEC_VAR_HANDLER,
		CREX_EXIT_SPEC_HANDLER,
		CREX_FETCH_R_SPEC_CONST_UNUSED_HANDLER,
		CREX_FETCH_R_SPEC_TMPVAR_UNUSED_HANDLER,
		CREX_FETCH_R_SPEC_TMPVAR_UNUSED_HANDLER,
		CREX_NULL_HANDLER,
		CREX_FETCH_R_SPEC_CV_UNUSED_HANDLER,
		CREX_FETCH_DIM_R_SPEC_CONST_CONST_HANDLER,
		CREX_FETCH_DIM_R_SPEC_CONST_TMPVAR_HANDLER,
		CREX_FETCH_DIM_R_SPEC_CONST_TMPVAR_HANDLER,
		CREX_NULL_HANDLER,
		CREX_FETCH_DIM_R_SPEC_CONST_CV_HANDLER,
		CREX_FETCH_DIM_R_SPEC_TMPVAR_CONST_HANDLER,
		CREX_FETCH_DIM_R_SPEC_TMPVAR_TMPVAR_HANDLER,
		CREX_FETCH_DIM_R_SPEC_TMPVAR_TMPVAR_HANDLER,
		CREX_NULL_HANDLER,
		CREX_FETCH_DIM_R_SPEC_TMPVAR_CV_HANDLER,
		CREX_FETCH_DIM_R_SPEC_TMPVAR_CONST_HANDLER,
		CREX_FETCH_DIM_R_SPEC_TMPVAR_TMPVAR_HANDLER,
		CREX_FETCH_DIM_R_SPEC_TMPVAR_TMPVAR_HANDLER,
		CREX_NULL_HANDLER,
		CREX_FETCH_DIM_R_SPEC_TMPVAR_CV_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_FETCH_DIM_R_SPEC_CV_CONST_HANDLER,
		CREX_FETCH_DIM_R_SPEC_CV_TMPVAR_HANDLER,
		CREX_FETCH_DIM_R_SPEC_CV_TMPVAR_HANDLER,
		CREX_NULL_HANDLER,
		CREX_FETCH_DIM_R_SPEC_CV_CV_HANDLER,
		CREX_FETCH_OBJ_R_SPEC_CONST_CONST_HANDLER,
		CREX_FETCH_OBJ_R_SPEC_CONST_TMPVAR_HANDLER,
		CREX_FETCH_OBJ_R_SPEC_CONST_TMPVAR_HANDLER,
		CREX_NULL_HANDLER,
		CREX_FETCH_OBJ_R_SPEC_CONST_CV_HANDLER,
		CREX_FETCH_OBJ_R_SPEC_TMPVAR_CONST_HANDLER,
		CREX_FETCH_OBJ_R_SPEC_TMPVAR_TMPVAR_HANDLER,
		CREX_FETCH_OBJ_R_SPEC_TMPVAR_TMPVAR_HANDLER,
		CREX_NULL_HANDLER,
		CREX_FETCH_OBJ_R_SPEC_TMPVAR_CV_HANDLER,
		CREX_FETCH_OBJ_R_SPEC_TMPVAR_CONST_HANDLER,
		CREX_FETCH_OBJ_R_SPEC_TMPVAR_TMPVAR_HANDLER,
		CREX_FETCH_OBJ_R_SPEC_TMPVAR_TMPVAR_HANDLER,
		CREX_NULL_HANDLER,
		CREX_FETCH_OBJ_R_SPEC_TMPVAR_CV_HANDLER,
		CREX_FETCH_OBJ_R_SPEC_UNUSED_CONST_HANDLER,
		CREX_FETCH_OBJ_R_SPEC_UNUSED_TMPVAR_HANDLER,
		CREX_FETCH_OBJ_R_SPEC_UNUSED_TMPVAR_HANDLER,
		CREX_NULL_HANDLER,
		CREX_FETCH_OBJ_R_SPEC_UNUSED_CV_HANDLER,
		CREX_FETCH_OBJ_R_SPEC_CV_CONST_HANDLER,
		CREX_FETCH_OBJ_R_SPEC_CV_TMPVAR_HANDLER,
		CREX_FETCH_OBJ_R_SPEC_CV_TMPVAR_HANDLER,
		CREX_NULL_HANDLER,
		CREX_FETCH_OBJ_R_SPEC_CV_CV_HANDLER,
		CREX_FETCH_W_SPEC_CONST_UNUSED_HANDLER,
		CREX_FETCH_W_SPEC_TMPVAR_UNUSED_HANDLER,
		CREX_FETCH_W_SPEC_TMPVAR_UNUSED_HANDLER,
		CREX_NULL_HANDLER,
		CREX_FETCH_W_SPEC_CV_UNUSED_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_FETCH_DIM_W_SPEC_VAR_CONST_HANDLER,
		CREX_FETCH_DIM_W_SPEC_VAR_TMPVAR_HANDLER,
		CREX_FETCH_DIM_W_SPEC_VAR_TMPVAR_HANDLER,
		CREX_FETCH_DIM_W_SPEC_VAR_UNUSED_HANDLER,
		CREX_FETCH_DIM_W_SPEC_VAR_CV_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_FETCH_DIM_W_SPEC_CV_CONST_HANDLER,
		CREX_FETCH_DIM_W_SPEC_CV_TMPVAR_HANDLER,
		CREX_FETCH_DIM_W_SPEC_CV_TMPVAR_HANDLER,
		CREX_FETCH_DIM_W_SPEC_CV_UNUSED_HANDLER,
		CREX_FETCH_DIM_W_SPEC_CV_CV_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_FETCH_OBJ_W_SPEC_VAR_CONST_HANDLER,
		CREX_FETCH_OBJ_W_SPEC_VAR_TMPVAR_HANDLER,
		CREX_FETCH_OBJ_W_SPEC_VAR_TMPVAR_HANDLER,
		CREX_NULL_HANDLER,
		CREX_FETCH_OBJ_W_SPEC_VAR_CV_HANDLER,
		CREX_FETCH_OBJ_W_SPEC_UNUSED_CONST_HANDLER,
		CREX_FETCH_OBJ_W_SPEC_UNUSED_TMPVAR_HANDLER,
		CREX_FETCH_OBJ_W_SPEC_UNUSED_TMPVAR_HANDLER,
		CREX_NULL_HANDLER,
		CREX_FETCH_OBJ_W_SPEC_UNUSED_CV_HANDLER,
		CREX_FETCH_OBJ_W_SPEC_CV_CONST_HANDLER,
		CREX_FETCH_OBJ_W_SPEC_CV_TMPVAR_HANDLER,
		CREX_FETCH_OBJ_W_SPEC_CV_TMPVAR_HANDLER,
		CREX_NULL_HANDLER,
		CREX_FETCH_OBJ_W_SPEC_CV_CV_HANDLER,
		CREX_FETCH_RW_SPEC_CONST_UNUSED_HANDLER,
		CREX_FETCH_RW_SPEC_TMPVAR_UNUSED_HANDLER,
		CREX_FETCH_RW_SPEC_TMPVAR_UNUSED_HANDLER,
		CREX_NULL_HANDLER,
		CREX_FETCH_RW_SPEC_CV_UNUSED_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_FETCH_DIM_RW_SPEC_VAR_CONST_HANDLER,
		CREX_FETCH_DIM_RW_SPEC_VAR_TMPVAR_HANDLER,
		CREX_FETCH_DIM_RW_SPEC_VAR_TMPVAR_HANDLER,
		CREX_FETCH_DIM_RW_SPEC_VAR_UNUSED_HANDLER,
		CREX_FETCH_DIM_RW_SPEC_VAR_CV_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_FETCH_DIM_RW_SPEC_CV_CONST_HANDLER,
		CREX_FETCH_DIM_RW_SPEC_CV_TMPVAR_HANDLER,
		CREX_FETCH_DIM_RW_SPEC_CV_TMPVAR_HANDLER,
		CREX_FETCH_DIM_RW_SPEC_CV_UNUSED_HANDLER,
		CREX_FETCH_DIM_RW_SPEC_CV_CV_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_FETCH_OBJ_RW_SPEC_VAR_CONST_HANDLER,
		CREX_FETCH_OBJ_RW_SPEC_VAR_TMPVAR_HANDLER,
		CREX_FETCH_OBJ_RW_SPEC_VAR_TMPVAR_HANDLER,
		CREX_NULL_HANDLER,
		CREX_FETCH_OBJ_RW_SPEC_VAR_CV_HANDLER,
		CREX_FETCH_OBJ_RW_SPEC_UNUSED_CONST_HANDLER,
		CREX_FETCH_OBJ_RW_SPEC_UNUSED_TMPVAR_HANDLER,
		CREX_FETCH_OBJ_RW_SPEC_UNUSED_TMPVAR_HANDLER,
		CREX_NULL_HANDLER,
		CREX_FETCH_OBJ_RW_SPEC_UNUSED_CV_HANDLER,
		CREX_FETCH_OBJ_RW_SPEC_CV_CONST_HANDLER,
		CREX_FETCH_OBJ_RW_SPEC_CV_TMPVAR_HANDLER,
		CREX_FETCH_OBJ_RW_SPEC_CV_TMPVAR_HANDLER,
		CREX_NULL_HANDLER,
		CREX_FETCH_OBJ_RW_SPEC_CV_CV_HANDLER,
		CREX_FETCH_IS_SPEC_CONST_UNUSED_HANDLER,
		CREX_FETCH_IS_SPEC_TMPVAR_UNUSED_HANDLER,
		CREX_FETCH_IS_SPEC_TMPVAR_UNUSED_HANDLER,
		CREX_NULL_HANDLER,
		CREX_FETCH_IS_SPEC_CV_UNUSED_HANDLER,
		CREX_FETCH_DIM_IS_SPEC_CONST_CONST_HANDLER,
		CREX_FETCH_DIM_IS_SPEC_CONST_TMPVAR_HANDLER,
		CREX_FETCH_DIM_IS_SPEC_CONST_TMPVAR_HANDLER,
		CREX_NULL_HANDLER,
		CREX_FETCH_DIM_IS_SPEC_CONST_CV_HANDLER,
		CREX_FETCH_DIM_IS_SPEC_TMPVAR_CONST_HANDLER,
		CREX_FETCH_DIM_IS_SPEC_TMPVAR_TMPVAR_HANDLER,
		CREX_FETCH_DIM_IS_SPEC_TMPVAR_TMPVAR_HANDLER,
		CREX_NULL_HANDLER,
		CREX_FETCH_DIM_IS_SPEC_TMPVAR_CV_HANDLER,
		CREX_FETCH_DIM_IS_SPEC_TMPVAR_CONST_HANDLER,
		CREX_FETCH_DIM_IS_SPEC_TMPVAR_TMPVAR_HANDLER,
		CREX_FETCH_DIM_IS_SPEC_TMPVAR_TMPVAR_HANDLER,
		CREX_NULL_HANDLER,
		CREX_FETCH_DIM_IS_SPEC_TMPVAR_CV_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_FETCH_DIM_IS_SPEC_CV_CONST_HANDLER,
		CREX_FETCH_DIM_IS_SPEC_CV_TMPVAR_HANDLER,
		CREX_FETCH_DIM_IS_SPEC_CV_TMPVAR_HANDLER,
		CREX_NULL_HANDLER,
		CREX_FETCH_DIM_IS_SPEC_CV_CV_HANDLER,
		CREX_FETCH_OBJ_IS_SPEC_CONST_CONST_HANDLER,
		CREX_FETCH_OBJ_IS_SPEC_CONST_TMPVAR_HANDLER,
		CREX_FETCH_OBJ_IS_SPEC_CONST_TMPVAR_HANDLER,
		CREX_NULL_HANDLER,
		CREX_FETCH_OBJ_IS_SPEC_CONST_CV_HANDLER,
		CREX_FETCH_OBJ_IS_SPEC_TMPVAR_CONST_HANDLER,
		CREX_FETCH_OBJ_IS_SPEC_TMPVAR_TMPVAR_HANDLER,
		CREX_FETCH_OBJ_IS_SPEC_TMPVAR_TMPVAR_HANDLER,
		CREX_NULL_HANDLER,
		CREX_FETCH_OBJ_IS_SPEC_TMPVAR_CV_HANDLER,
		CREX_FETCH_OBJ_IS_SPEC_TMPVAR_CONST_HANDLER,
		CREX_FETCH_OBJ_IS_SPEC_TMPVAR_TMPVAR_HANDLER,
		CREX_FETCH_OBJ_IS_SPEC_TMPVAR_TMPVAR_HANDLER,
		CREX_NULL_HANDLER,
		CREX_FETCH_OBJ_IS_SPEC_TMPVAR_CV_HANDLER,
		CREX_FETCH_OBJ_IS_SPEC_UNUSED_CONST_HANDLER,
		CREX_FETCH_OBJ_IS_SPEC_UNUSED_TMPVAR_HANDLER,
		CREX_FETCH_OBJ_IS_SPEC_UNUSED_TMPVAR_HANDLER,
		CREX_NULL_HANDLER,
		CREX_FETCH_OBJ_IS_SPEC_UNUSED_CV_HANDLER,
		CREX_FETCH_OBJ_IS_SPEC_CV_CONST_HANDLER,
		CREX_FETCH_OBJ_IS_SPEC_CV_TMPVAR_HANDLER,
		CREX_FETCH_OBJ_IS_SPEC_CV_TMPVAR_HANDLER,
		CREX_NULL_HANDLER,
		CREX_FETCH_OBJ_IS_SPEC_CV_CV_HANDLER,
		CREX_FETCH_FUNC_ARG_SPEC_CONST_UNUSED_HANDLER,
		CREX_FETCH_FUNC_ARG_SPEC_TMPVAR_UNUSED_HANDLER,
		CREX_FETCH_FUNC_ARG_SPEC_TMPVAR_UNUSED_HANDLER,
		CREX_NULL_HANDLER,
		CREX_FETCH_FUNC_ARG_SPEC_CV_UNUSED_HANDLER,
		CREX_FETCH_DIM_FUNC_ARG_SPEC_CONST_CONST_HANDLER,
		CREX_FETCH_DIM_FUNC_ARG_SPEC_CONST_TMPVAR_HANDLER,
		CREX_FETCH_DIM_FUNC_ARG_SPEC_CONST_TMPVAR_HANDLER,
		CREX_FETCH_DIM_FUNC_ARG_SPEC_CONST_UNUSED_HANDLER,
		CREX_FETCH_DIM_FUNC_ARG_SPEC_CONST_CV_HANDLER,
		CREX_FETCH_DIM_FUNC_ARG_SPEC_TMP_CONST_HANDLER,
		CREX_FETCH_DIM_FUNC_ARG_SPEC_TMP_TMPVAR_HANDLER,
		CREX_FETCH_DIM_FUNC_ARG_SPEC_TMP_TMPVAR_HANDLER,
		CREX_FETCH_DIM_FUNC_ARG_SPEC_TMP_UNUSED_HANDLER,
		CREX_FETCH_DIM_FUNC_ARG_SPEC_TMP_CV_HANDLER,
		CREX_FETCH_DIM_FUNC_ARG_SPEC_VAR_CONST_HANDLER,
		CREX_FETCH_DIM_FUNC_ARG_SPEC_VAR_TMPVAR_HANDLER,
		CREX_FETCH_DIM_FUNC_ARG_SPEC_VAR_TMPVAR_HANDLER,
		CREX_FETCH_DIM_FUNC_ARG_SPEC_VAR_UNUSED_HANDLER,
		CREX_FETCH_DIM_FUNC_ARG_SPEC_VAR_CV_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_FETCH_DIM_FUNC_ARG_SPEC_CV_CONST_HANDLER,
		CREX_FETCH_DIM_FUNC_ARG_SPEC_CV_TMPVAR_HANDLER,
		CREX_FETCH_DIM_FUNC_ARG_SPEC_CV_TMPVAR_HANDLER,
		CREX_FETCH_DIM_FUNC_ARG_SPEC_CV_UNUSED_HANDLER,
		CREX_FETCH_DIM_FUNC_ARG_SPEC_CV_CV_HANDLER,
		CREX_FETCH_OBJ_FUNC_ARG_SPEC_CONST_CONST_HANDLER,
		CREX_FETCH_OBJ_FUNC_ARG_SPEC_CONST_TMPVAR_HANDLER,
		CREX_FETCH_OBJ_FUNC_ARG_SPEC_CONST_TMPVAR_HANDLER,
		CREX_NULL_HANDLER,
		CREX_FETCH_OBJ_FUNC_ARG_SPEC_CONST_CV_HANDLER,
		CREX_FETCH_OBJ_FUNC_ARG_SPEC_TMP_CONST_HANDLER,
		CREX_FETCH_OBJ_FUNC_ARG_SPEC_TMP_TMPVAR_HANDLER,
		CREX_FETCH_OBJ_FUNC_ARG_SPEC_TMP_TMPVAR_HANDLER,
		CREX_NULL_HANDLER,
		CREX_FETCH_OBJ_FUNC_ARG_SPEC_TMP_CV_HANDLER,
		CREX_FETCH_OBJ_FUNC_ARG_SPEC_VAR_CONST_HANDLER,
		CREX_FETCH_OBJ_FUNC_ARG_SPEC_VAR_TMPVAR_HANDLER,
		CREX_FETCH_OBJ_FUNC_ARG_SPEC_VAR_TMPVAR_HANDLER,
		CREX_NULL_HANDLER,
		CREX_FETCH_OBJ_FUNC_ARG_SPEC_VAR_CV_HANDLER,
		CREX_FETCH_OBJ_FUNC_ARG_SPEC_UNUSED_CONST_HANDLER,
		CREX_FETCH_OBJ_FUNC_ARG_SPEC_UNUSED_TMPVAR_HANDLER,
		CREX_FETCH_OBJ_FUNC_ARG_SPEC_UNUSED_TMPVAR_HANDLER,
		CREX_NULL_HANDLER,
		CREX_FETCH_OBJ_FUNC_ARG_SPEC_UNUSED_CV_HANDLER,
		CREX_FETCH_OBJ_FUNC_ARG_SPEC_CV_CONST_HANDLER,
		CREX_FETCH_OBJ_FUNC_ARG_SPEC_CV_TMPVAR_HANDLER,
		CREX_FETCH_OBJ_FUNC_ARG_SPEC_CV_TMPVAR_HANDLER,
		CREX_NULL_HANDLER,
		CREX_FETCH_OBJ_FUNC_ARG_SPEC_CV_CV_HANDLER,
		CREX_FETCH_UNSET_SPEC_CONST_UNUSED_HANDLER,
		CREX_FETCH_UNSET_SPEC_TMPVAR_UNUSED_HANDLER,
		CREX_FETCH_UNSET_SPEC_TMPVAR_UNUSED_HANDLER,
		CREX_NULL_HANDLER,
		CREX_FETCH_UNSET_SPEC_CV_UNUSED_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_FETCH_DIM_UNSET_SPEC_VAR_CONST_HANDLER,
		CREX_FETCH_DIM_UNSET_SPEC_VAR_TMPVAR_HANDLER,
		CREX_FETCH_DIM_UNSET_SPEC_VAR_TMPVAR_HANDLER,
		CREX_NULL_HANDLER,
		CREX_FETCH_DIM_UNSET_SPEC_VAR_CV_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_FETCH_DIM_UNSET_SPEC_CV_CONST_HANDLER,
		CREX_FETCH_DIM_UNSET_SPEC_CV_TMPVAR_HANDLER,
		CREX_FETCH_DIM_UNSET_SPEC_CV_TMPVAR_HANDLER,
		CREX_NULL_HANDLER,
		CREX_FETCH_DIM_UNSET_SPEC_CV_CV_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_FETCH_OBJ_UNSET_SPEC_VAR_CONST_HANDLER,
		CREX_FETCH_OBJ_UNSET_SPEC_VAR_TMPVAR_HANDLER,
		CREX_FETCH_OBJ_UNSET_SPEC_VAR_TMPVAR_HANDLER,
		CREX_NULL_HANDLER,
		CREX_FETCH_OBJ_UNSET_SPEC_VAR_CV_HANDLER,
		CREX_FETCH_OBJ_UNSET_SPEC_UNUSED_CONST_HANDLER,
		CREX_FETCH_OBJ_UNSET_SPEC_UNUSED_TMPVAR_HANDLER,
		CREX_FETCH_OBJ_UNSET_SPEC_UNUSED_TMPVAR_HANDLER,
		CREX_NULL_HANDLER,
		CREX_FETCH_OBJ_UNSET_SPEC_UNUSED_CV_HANDLER,
		CREX_FETCH_OBJ_UNSET_SPEC_CV_CONST_HANDLER,
		CREX_FETCH_OBJ_UNSET_SPEC_CV_TMPVAR_HANDLER,
		CREX_FETCH_OBJ_UNSET_SPEC_CV_TMPVAR_HANDLER,
		CREX_NULL_HANDLER,
		CREX_FETCH_OBJ_UNSET_SPEC_CV_CV_HANDLER,
		CREX_FETCH_LIST_R_SPEC_CONST_CONST_HANDLER,
		CREX_FETCH_LIST_R_SPEC_CONST_TMPVAR_HANDLER,
		CREX_FETCH_LIST_R_SPEC_CONST_TMPVAR_HANDLER,
		CREX_NULL_HANDLER,
		CREX_FETCH_LIST_R_SPEC_CONST_CV_HANDLER,
		CREX_FETCH_LIST_R_SPEC_TMPVARCV_CONST_HANDLER,
		CREX_FETCH_LIST_R_SPEC_TMPVARCV_TMPVAR_HANDLER,
		CREX_FETCH_LIST_R_SPEC_TMPVARCV_TMPVAR_HANDLER,
		CREX_NULL_HANDLER,
		CREX_FETCH_LIST_R_SPEC_TMPVARCV_CV_HANDLER,
		CREX_FETCH_LIST_R_SPEC_TMPVARCV_CONST_HANDLER,
		CREX_FETCH_LIST_R_SPEC_TMPVARCV_TMPVAR_HANDLER,
		CREX_FETCH_LIST_R_SPEC_TMPVARCV_TMPVAR_HANDLER,
		CREX_NULL_HANDLER,
		CREX_FETCH_LIST_R_SPEC_TMPVARCV_CV_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_FETCH_LIST_R_SPEC_TMPVARCV_CONST_HANDLER,
		CREX_FETCH_LIST_R_SPEC_TMPVARCV_TMPVAR_HANDLER,
		CREX_FETCH_LIST_R_SPEC_TMPVARCV_TMPVAR_HANDLER,
		CREX_NULL_HANDLER,
		CREX_FETCH_LIST_R_SPEC_TMPVARCV_CV_HANDLER,
		CREX_FETCH_CONSTANT_SPEC_UNUSED_CONST_HANDLER,
		CREX_CHECK_FUNC_ARG_SPEC_UNUSED_CONST_HANDLER,
		CREX_CHECK_FUNC_ARG_SPEC_UNUSED_CONST_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_CHECK_FUNC_ARG_SPEC_UNUSED_UNUSED_HANDLER,
		CREX_CHECK_FUNC_ARG_SPEC_UNUSED_UNUSED_QUICK_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_EXT_STMT_SPEC_HANDLER,
		CREX_EXT_FCALL_BEGIN_SPEC_HANDLER,
		CREX_EXT_FCALL_END_SPEC_HANDLER,
		CREX_EXT_NOP_SPEC_HANDLER,
		CREX_TICKS_SPEC_HANDLER,
		CREX_SEND_VAR_NO_REF_SPEC_VAR_CONST_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_SEND_VAR_NO_REF_SPEC_VAR_UNUSED_HANDLER,
		CREX_NULL_HANDLER,
		CREX_CATCH_SPEC_CONST_HANDLER,
		CREX_THROW_SPEC_CONST_HANDLER,
		CREX_THROW_SPEC_TMPVAR_HANDLER,
		CREX_THROW_SPEC_TMPVAR_HANDLER,
		CREX_NULL_HANDLER,
		CREX_THROW_SPEC_CV_HANDLER,
		CREX_FETCH_CLASS_SPEC_UNUSED_CONST_HANDLER,
		CREX_FETCH_CLASS_SPEC_UNUSED_TMPVAR_HANDLER,
		CREX_FETCH_CLASS_SPEC_UNUSED_TMPVAR_HANDLER,
		CREX_FETCH_CLASS_SPEC_UNUSED_UNUSED_HANDLER,
		CREX_FETCH_CLASS_SPEC_UNUSED_CV_HANDLER,
		CREX_CLONE_SPEC_CONST_HANDLER,
		CREX_CLONE_SPEC_TMPVAR_HANDLER,
		CREX_CLONE_SPEC_TMPVAR_HANDLER,
		CREX_CLONE_SPEC_UNUSED_HANDLER,
		CREX_CLONE_SPEC_CV_HANDLER,
		CREX_RETURN_BY_REF_SPEC_CONST_HANDLER,
		CREX_RETURN_BY_REF_SPEC_OBSERVER_HANDLER,
		CREX_RETURN_BY_REF_SPEC_TMP_HANDLER,
		CREX_RETURN_BY_REF_SPEC_OBSERVER_HANDLER,
		CREX_RETURN_BY_REF_SPEC_VAR_HANDLER,
		CREX_RETURN_BY_REF_SPEC_OBSERVER_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_RETURN_BY_REF_SPEC_CV_HANDLER,
		CREX_RETURN_BY_REF_SPEC_OBSERVER_HANDLER,
		CREX_INIT_METHOD_CALL_SPEC_CONST_CONST_HANDLER,
		CREX_INIT_METHOD_CALL_SPEC_CONST_TMPVAR_HANDLER,
		CREX_INIT_METHOD_CALL_SPEC_CONST_TMPVAR_HANDLER,
		CREX_NULL_HANDLER,
		CREX_INIT_METHOD_CALL_SPEC_CONST_CV_HANDLER,
		CREX_INIT_METHOD_CALL_SPEC_TMPVAR_CONST_HANDLER,
		CREX_INIT_METHOD_CALL_SPEC_TMPVAR_TMPVAR_HANDLER,
		CREX_INIT_METHOD_CALL_SPEC_TMPVAR_TMPVAR_HANDLER,
		CREX_NULL_HANDLER,
		CREX_INIT_METHOD_CALL_SPEC_TMPVAR_CV_HANDLER,
		CREX_INIT_METHOD_CALL_SPEC_TMPVAR_CONST_HANDLER,
		CREX_INIT_METHOD_CALL_SPEC_TMPVAR_TMPVAR_HANDLER,
		CREX_INIT_METHOD_CALL_SPEC_TMPVAR_TMPVAR_HANDLER,
		CREX_NULL_HANDLER,
		CREX_INIT_METHOD_CALL_SPEC_TMPVAR_CV_HANDLER,
		CREX_INIT_METHOD_CALL_SPEC_UNUSED_CONST_HANDLER,
		CREX_INIT_METHOD_CALL_SPEC_UNUSED_TMPVAR_HANDLER,
		CREX_INIT_METHOD_CALL_SPEC_UNUSED_TMPVAR_HANDLER,
		CREX_NULL_HANDLER,
		CREX_INIT_METHOD_CALL_SPEC_UNUSED_CV_HANDLER,
		CREX_INIT_METHOD_CALL_SPEC_CV_CONST_HANDLER,
		CREX_INIT_METHOD_CALL_SPEC_CV_TMPVAR_HANDLER,
		CREX_INIT_METHOD_CALL_SPEC_CV_TMPVAR_HANDLER,
		CREX_NULL_HANDLER,
		CREX_INIT_METHOD_CALL_SPEC_CV_CV_HANDLER,
		CREX_INIT_STATIC_METHOD_CALL_SPEC_CONST_CONST_HANDLER,
		CREX_INIT_STATIC_METHOD_CALL_SPEC_CONST_TMPVAR_HANDLER,
		CREX_INIT_STATIC_METHOD_CALL_SPEC_CONST_TMPVAR_HANDLER,
		CREX_INIT_STATIC_METHOD_CALL_SPEC_CONST_UNUSED_HANDLER,
		CREX_INIT_STATIC_METHOD_CALL_SPEC_CONST_CV_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_INIT_STATIC_METHOD_CALL_SPEC_VAR_CONST_HANDLER,
		CREX_INIT_STATIC_METHOD_CALL_SPEC_VAR_TMPVAR_HANDLER,
		CREX_INIT_STATIC_METHOD_CALL_SPEC_VAR_TMPVAR_HANDLER,
		CREX_INIT_STATIC_METHOD_CALL_SPEC_VAR_UNUSED_HANDLER,
		CREX_INIT_STATIC_METHOD_CALL_SPEC_VAR_CV_HANDLER,
		CREX_INIT_STATIC_METHOD_CALL_SPEC_UNUSED_CONST_HANDLER,
		CREX_INIT_STATIC_METHOD_CALL_SPEC_UNUSED_TMPVAR_HANDLER,
		CREX_INIT_STATIC_METHOD_CALL_SPEC_UNUSED_TMPVAR_HANDLER,
		CREX_INIT_STATIC_METHOD_CALL_SPEC_UNUSED_UNUSED_HANDLER,
		CREX_INIT_STATIC_METHOD_CALL_SPEC_UNUSED_CV_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_ISSET_ISEMPTY_VAR_SPEC_CONST_UNUSED_HANDLER,
		CREX_ISSET_ISEMPTY_VAR_SPEC_TMPVAR_UNUSED_HANDLER,
		CREX_ISSET_ISEMPTY_VAR_SPEC_TMPVAR_UNUSED_HANDLER,
		CREX_NULL_HANDLER,
		CREX_ISSET_ISEMPTY_VAR_SPEC_CV_UNUSED_HANDLER,
		CREX_ISSET_ISEMPTY_DIM_OBJ_SPEC_CONST_CONST_HANDLER,
		CREX_ISSET_ISEMPTY_DIM_OBJ_SPEC_CONST_TMPVAR_HANDLER,
		CREX_ISSET_ISEMPTY_DIM_OBJ_SPEC_CONST_TMPVAR_HANDLER,
		CREX_NULL_HANDLER,
		CREX_ISSET_ISEMPTY_DIM_OBJ_SPEC_CONST_CV_HANDLER,
		CREX_ISSET_ISEMPTY_DIM_OBJ_SPEC_TMPVAR_CONST_HANDLER,
		CREX_ISSET_ISEMPTY_DIM_OBJ_SPEC_TMPVAR_TMPVAR_HANDLER,
		CREX_ISSET_ISEMPTY_DIM_OBJ_SPEC_TMPVAR_TMPVAR_HANDLER,
		CREX_NULL_HANDLER,
		CREX_ISSET_ISEMPTY_DIM_OBJ_SPEC_TMPVAR_CV_HANDLER,
		CREX_ISSET_ISEMPTY_DIM_OBJ_SPEC_TMPVAR_CONST_HANDLER,
		CREX_ISSET_ISEMPTY_DIM_OBJ_SPEC_TMPVAR_TMPVAR_HANDLER,
		CREX_ISSET_ISEMPTY_DIM_OBJ_SPEC_TMPVAR_TMPVAR_HANDLER,
		CREX_NULL_HANDLER,
		CREX_ISSET_ISEMPTY_DIM_OBJ_SPEC_TMPVAR_CV_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_ISSET_ISEMPTY_DIM_OBJ_SPEC_CV_CONST_HANDLER,
		CREX_ISSET_ISEMPTY_DIM_OBJ_SPEC_CV_TMPVAR_HANDLER,
		CREX_ISSET_ISEMPTY_DIM_OBJ_SPEC_CV_TMPVAR_HANDLER,
		CREX_NULL_HANDLER,
		CREX_ISSET_ISEMPTY_DIM_OBJ_SPEC_CV_CV_HANDLER,
		CREX_SEND_VAL_EX_SPEC_CONST_CONST_HANDLER,
		CREX_SEND_VAL_EX_SPEC_CONST_CONST_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_SEND_VAL_EX_SPEC_CONST_UNUSED_HANDLER,
		CREX_SEND_VAL_EX_SPEC_CONST_UNUSED_QUICK_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_SEND_VAL_EX_SPEC_TMP_CONST_HANDLER,
		CREX_SEND_VAL_EX_SPEC_TMP_CONST_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_SEND_VAL_EX_SPEC_TMP_UNUSED_HANDLER,
		CREX_SEND_VAL_EX_SPEC_TMP_UNUSED_QUICK_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_SEND_VAR_SPEC_VAR_CONST_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_SEND_VAR_SPEC_VAR_UNUSED_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_SEND_VAR_SPEC_CV_CONST_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_SEND_VAR_SPEC_CV_UNUSED_HANDLER,
		CREX_NULL_HANDLER,
		CREX_INIT_USER_CALL_SPEC_CONST_CONST_HANDLER,
		CREX_INIT_USER_CALL_SPEC_CONST_TMPVAR_HANDLER,
		CREX_INIT_USER_CALL_SPEC_CONST_TMPVAR_HANDLER,
		CREX_NULL_HANDLER,
		CREX_INIT_USER_CALL_SPEC_CONST_CV_HANDLER,
		CREX_SEND_ARRAY_SPEC_HANDLER,
		CREX_SEND_USER_SPEC_CONST_HANDLER,
		CREX_SEND_USER_SPEC_TMP_HANDLER,
		CREX_SEND_USER_SPEC_VAR_HANDLER,
		CREX_NULL_HANDLER,
		CREX_SEND_USER_SPEC_CV_HANDLER,
		CREX_STRLEN_SPEC_CONST_HANDLER,
		CREX_STRLEN_SPEC_TMPVAR_HANDLER,
		CREX_STRLEN_SPEC_TMPVAR_HANDLER,
		CREX_NULL_HANDLER,
		CREX_STRLEN_SPEC_CV_HANDLER,
		CREX_DEFINED_SPEC_CONST_HANDLER,
		CREX_TYPE_CHECK_SPEC_CONST_HANDLER,
		CREX_TYPE_CHECK_SPEC_TMPVAR_HANDLER,
		CREX_TYPE_CHECK_SPEC_TMPVAR_HANDLER,
		CREX_NULL_HANDLER,
		CREX_TYPE_CHECK_SPEC_CV_HANDLER,
		CREX_VERIFY_RETURN_TYPE_SPEC_CONST_UNUSED_HANDLER,
		CREX_VERIFY_RETURN_TYPE_SPEC_TMP_UNUSED_HANDLER,
		CREX_VERIFY_RETURN_TYPE_SPEC_VAR_UNUSED_HANDLER,
		CREX_VERIFY_RETURN_TYPE_SPEC_UNUSED_UNUSED_HANDLER,
		CREX_VERIFY_RETURN_TYPE_SPEC_CV_UNUSED_HANDLER,
		CREX_FE_RESET_RW_SPEC_CONST_HANDLER,
		CREX_FE_RESET_RW_SPEC_TMP_HANDLER,
		CREX_FE_RESET_RW_SPEC_VAR_HANDLER,
		CREX_NULL_HANDLER,
		CREX_FE_RESET_RW_SPEC_CV_HANDLER,
		CREX_FE_FETCH_RW_SPEC_VAR_HANDLER,
		CREX_FE_FREE_SPEC_TMPVAR_HANDLER,
		CREX_INIT_DYNAMIC_CALL_SPEC_CONST_HANDLER,
		CREX_INIT_DYNAMIC_CALL_SPEC_TMPVAR_HANDLER,
		CREX_INIT_DYNAMIC_CALL_SPEC_TMPVAR_HANDLER,
		CREX_NULL_HANDLER,
		CREX_INIT_DYNAMIC_CALL_SPEC_CV_HANDLER,
		CREX_DO_ICALL_SPEC_RETVAL_UNUSED_HANDLER,
		CREX_DO_ICALL_SPEC_RETVAL_USED_HANDLER,
		CREX_DO_ICALL_SPEC_OBSERVER_HANDLER,
		CREX_DO_ICALL_SPEC_OBSERVER_HANDLER,
		CREX_DO_UCALL_SPEC_RETVAL_UNUSED_HANDLER,
		CREX_DO_UCALL_SPEC_RETVAL_USED_HANDLER,
		CREX_DO_UCALL_SPEC_OBSERVER_HANDLER,
		CREX_DO_UCALL_SPEC_OBSERVER_HANDLER,
		CREX_DO_FCALL_BY_NAME_SPEC_RETVAL_UNUSED_HANDLER,
		CREX_DO_FCALL_BY_NAME_SPEC_RETVAL_USED_HANDLER,
		CREX_DO_FCALL_BY_NAME_SPEC_OBSERVER_HANDLER,
		CREX_DO_FCALL_BY_NAME_SPEC_OBSERVER_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_PRE_INC_OBJ_SPEC_VAR_CONST_HANDLER,
		CREX_PRE_INC_OBJ_SPEC_VAR_TMPVAR_HANDLER,
		CREX_PRE_INC_OBJ_SPEC_VAR_TMPVAR_HANDLER,
		CREX_NULL_HANDLER,
		CREX_PRE_INC_OBJ_SPEC_VAR_CV_HANDLER,
		CREX_PRE_INC_OBJ_SPEC_UNUSED_CONST_HANDLER,
		CREX_PRE_INC_OBJ_SPEC_UNUSED_TMPVAR_HANDLER,
		CREX_PRE_INC_OBJ_SPEC_UNUSED_TMPVAR_HANDLER,
		CREX_NULL_HANDLER,
		CREX_PRE_INC_OBJ_SPEC_UNUSED_CV_HANDLER,
		CREX_PRE_INC_OBJ_SPEC_CV_CONST_HANDLER,
		CREX_PRE_INC_OBJ_SPEC_CV_TMPVAR_HANDLER,
		CREX_PRE_INC_OBJ_SPEC_CV_TMPVAR_HANDLER,
		CREX_NULL_HANDLER,
		CREX_PRE_INC_OBJ_SPEC_CV_CV_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_POST_INC_OBJ_SPEC_VAR_CONST_HANDLER,
		CREX_POST_INC_OBJ_SPEC_VAR_TMPVAR_HANDLER,
		CREX_POST_INC_OBJ_SPEC_VAR_TMPVAR_HANDLER,
		CREX_NULL_HANDLER,
		CREX_POST_INC_OBJ_SPEC_VAR_CV_HANDLER,
		CREX_POST_INC_OBJ_SPEC_UNUSED_CONST_HANDLER,
		CREX_POST_INC_OBJ_SPEC_UNUSED_TMPVAR_HANDLER,
		CREX_POST_INC_OBJ_SPEC_UNUSED_TMPVAR_HANDLER,
		CREX_NULL_HANDLER,
		CREX_POST_INC_OBJ_SPEC_UNUSED_CV_HANDLER,
		CREX_POST_INC_OBJ_SPEC_CV_CONST_HANDLER,
		CREX_POST_INC_OBJ_SPEC_CV_TMPVAR_HANDLER,
		CREX_POST_INC_OBJ_SPEC_CV_TMPVAR_HANDLER,
		CREX_NULL_HANDLER,
		CREX_POST_INC_OBJ_SPEC_CV_CV_HANDLER,
		CREX_ECHO_SPEC_CONST_HANDLER,
		CREX_ECHO_SPEC_TMPVAR_HANDLER,
		CREX_ECHO_SPEC_TMPVAR_HANDLER,
		CREX_NULL_HANDLER,
		CREX_ECHO_SPEC_CV_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_INSTANCEOF_SPEC_TMPVAR_CONST_HANDLER,
		CREX_NULL_HANDLER,
		CREX_INSTANCEOF_SPEC_TMPVAR_VAR_HANDLER,
		CREX_INSTANCEOF_SPEC_TMPVAR_UNUSED_HANDLER,
		CREX_NULL_HANDLER,
		CREX_INSTANCEOF_SPEC_TMPVAR_CONST_HANDLER,
		CREX_NULL_HANDLER,
		CREX_INSTANCEOF_SPEC_TMPVAR_VAR_HANDLER,
		CREX_INSTANCEOF_SPEC_TMPVAR_UNUSED_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_INSTANCEOF_SPEC_CV_CONST_HANDLER,
		CREX_NULL_HANDLER,
		CREX_INSTANCEOF_SPEC_CV_VAR_HANDLER,
		CREX_INSTANCEOF_SPEC_CV_UNUSED_HANDLER,
		CREX_NULL_HANDLER,
		CREX_GENERATOR_CREATE_SPEC_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_MAKE_REF_SPEC_VAR_UNUSED_HANDLER,
		CREX_NULL_HANDLER,
		CREX_MAKE_REF_SPEC_CV_UNUSED_HANDLER,
		CREX_DECLARE_FUNCTION_SPEC_HANDLER,
		CREX_DECLARE_LAMBDA_FUNCTION_SPEC_CONST_HANDLER,
		CREX_DECLARE_CONST_SPEC_CONST_CONST_HANDLER,
		CREX_DECLARE_CLASS_SPEC_CONST_HANDLER,
		CREX_DECLARE_CLASS_DELAYED_SPEC_CONST_CONST_HANDLER,
		CREX_DECLARE_ANON_CLASS_SPEC_HANDLER,
		CREX_ADD_ARRAY_UNPACK_SPEC_HANDLER,
		CREX_ISSET_ISEMPTY_PROP_OBJ_SPEC_CONST_CONST_HANDLER,
		CREX_ISSET_ISEMPTY_PROP_OBJ_SPEC_CONST_TMPVAR_HANDLER,
		CREX_ISSET_ISEMPTY_PROP_OBJ_SPEC_CONST_TMPVAR_HANDLER,
		CREX_NULL_HANDLER,
		CREX_ISSET_ISEMPTY_PROP_OBJ_SPEC_CONST_CV_HANDLER,
		CREX_ISSET_ISEMPTY_PROP_OBJ_SPEC_TMPVAR_CONST_HANDLER,
		CREX_ISSET_ISEMPTY_PROP_OBJ_SPEC_TMPVAR_TMPVAR_HANDLER,
		CREX_ISSET_ISEMPTY_PROP_OBJ_SPEC_TMPVAR_TMPVAR_HANDLER,
		CREX_NULL_HANDLER,
		CREX_ISSET_ISEMPTY_PROP_OBJ_SPEC_TMPVAR_CV_HANDLER,
		CREX_ISSET_ISEMPTY_PROP_OBJ_SPEC_TMPVAR_CONST_HANDLER,
		CREX_ISSET_ISEMPTY_PROP_OBJ_SPEC_TMPVAR_TMPVAR_HANDLER,
		CREX_ISSET_ISEMPTY_PROP_OBJ_SPEC_TMPVAR_TMPVAR_HANDLER,
		CREX_NULL_HANDLER,
		CREX_ISSET_ISEMPTY_PROP_OBJ_SPEC_TMPVAR_CV_HANDLER,
		CREX_ISSET_ISEMPTY_PROP_OBJ_SPEC_UNUSED_CONST_HANDLER,
		CREX_ISSET_ISEMPTY_PROP_OBJ_SPEC_UNUSED_TMPVAR_HANDLER,
		CREX_ISSET_ISEMPTY_PROP_OBJ_SPEC_UNUSED_TMPVAR_HANDLER,
		CREX_NULL_HANDLER,
		CREX_ISSET_ISEMPTY_PROP_OBJ_SPEC_UNUSED_CV_HANDLER,
		CREX_ISSET_ISEMPTY_PROP_OBJ_SPEC_CV_CONST_HANDLER,
		CREX_ISSET_ISEMPTY_PROP_OBJ_SPEC_CV_TMPVAR_HANDLER,
		CREX_ISSET_ISEMPTY_PROP_OBJ_SPEC_CV_TMPVAR_HANDLER,
		CREX_NULL_HANDLER,
		CREX_ISSET_ISEMPTY_PROP_OBJ_SPEC_CV_CV_HANDLER,
		CREX_HANDLE_EXCEPTION_SPEC_HANDLER,
		CREX_USER_OPCODE_SPEC_HANDLER,
		CREX_ASSERT_CHECK_SPEC_HANDLER,
		CREX_JMP_SET_SPEC_CONST_HANDLER,
		CREX_JMP_SET_SPEC_TMP_HANDLER,
		CREX_JMP_SET_SPEC_VAR_HANDLER,
		CREX_NULL_HANDLER,
		CREX_JMP_SET_SPEC_CV_HANDLER,
		CREX_UNSET_CV_SPEC_CV_UNUSED_HANDLER,
		CREX_ISSET_ISEMPTY_CV_SPEC_CV_UNUSED_SET_HANDLER,
		CREX_ISSET_ISEMPTY_CV_SPEC_CV_UNUSED_EMPTY_HANDLER,
		CREX_FETCH_LIST_W_SPEC_VAR_CONST_HANDLER,
		CREX_FETCH_LIST_W_SPEC_VAR_TMPVAR_HANDLER,
		CREX_FETCH_LIST_W_SPEC_VAR_TMPVAR_HANDLER,
		CREX_NULL_HANDLER,
		CREX_FETCH_LIST_W_SPEC_VAR_CV_HANDLER,
		CREX_SEPARATE_SPEC_VAR_UNUSED_HANDLER,
		CREX_NULL_HANDLER,
		CREX_FETCH_CLASS_NAME_SPEC_TMPVAR_HANDLER,
		CREX_FETCH_CLASS_NAME_SPEC_TMPVAR_HANDLER,
		CREX_FETCH_CLASS_NAME_SPEC_UNUSED_HANDLER,
		CREX_FETCH_CLASS_NAME_SPEC_CV_HANDLER,
		CREX_CALL_TRAMPOLINE_SPEC_HANDLER,
		CREX_CALL_TRAMPOLINE_SPEC_OBSERVER_HANDLER,
		CREX_DISCARD_EXCEPTION_SPEC_HANDLER,
		CREX_YIELD_SPEC_CONST_CONST_HANDLER,
		CREX_YIELD_SPEC_CONST_TMPVAR_HANDLER,
		CREX_YIELD_SPEC_CONST_TMPVAR_HANDLER,
		CREX_YIELD_SPEC_CONST_UNUSED_HANDLER,
		CREX_YIELD_SPEC_CONST_CV_HANDLER,
		CREX_YIELD_SPEC_TMP_CONST_HANDLER,
		CREX_YIELD_SPEC_TMP_TMPVAR_HANDLER,
		CREX_YIELD_SPEC_TMP_TMPVAR_HANDLER,
		CREX_YIELD_SPEC_TMP_UNUSED_HANDLER,
		CREX_YIELD_SPEC_TMP_CV_HANDLER,
		CREX_YIELD_SPEC_VAR_CONST_HANDLER,
		CREX_YIELD_SPEC_VAR_TMPVAR_HANDLER,
		CREX_YIELD_SPEC_VAR_TMPVAR_HANDLER,
		CREX_YIELD_SPEC_VAR_UNUSED_HANDLER,
		CREX_YIELD_SPEC_VAR_CV_HANDLER,
		CREX_YIELD_SPEC_UNUSED_CONST_HANDLER,
		CREX_YIELD_SPEC_UNUSED_TMPVAR_HANDLER,
		CREX_YIELD_SPEC_UNUSED_TMPVAR_HANDLER,
		CREX_YIELD_SPEC_UNUSED_UNUSED_HANDLER,
		CREX_YIELD_SPEC_UNUSED_CV_HANDLER,
		CREX_YIELD_SPEC_CV_CONST_HANDLER,
		CREX_YIELD_SPEC_CV_TMPVAR_HANDLER,
		CREX_YIELD_SPEC_CV_TMPVAR_HANDLER,
		CREX_YIELD_SPEC_CV_UNUSED_HANDLER,
		CREX_YIELD_SPEC_CV_CV_HANDLER,
		CREX_GENERATOR_RETURN_SPEC_CONST_HANDLER,
		CREX_GENERATOR_RETURN_SPEC_OBSERVER_HANDLER,
		CREX_GENERATOR_RETURN_SPEC_TMP_HANDLER,
		CREX_GENERATOR_RETURN_SPEC_OBSERVER_HANDLER,
		CREX_GENERATOR_RETURN_SPEC_VAR_HANDLER,
		CREX_GENERATOR_RETURN_SPEC_OBSERVER_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_GENERATOR_RETURN_SPEC_CV_HANDLER,
		CREX_GENERATOR_RETURN_SPEC_OBSERVER_HANDLER,
		CREX_FAST_CALL_SPEC_HANDLER,
		CREX_FAST_RET_SPEC_HANDLER,
		CREX_RECV_VARIADIC_SPEC_UNUSED_HANDLER,
		CREX_SEND_UNPACK_SPEC_HANDLER,
		CREX_YIELD_FROM_SPEC_CONST_HANDLER,
		CREX_YIELD_FROM_SPEC_TMPVAR_HANDLER,
		CREX_YIELD_FROM_SPEC_TMPVAR_HANDLER,
		CREX_NULL_HANDLER,
		CREX_YIELD_FROM_SPEC_CV_HANDLER,
		CREX_COPY_TMP_SPEC_TMPVAR_UNUSED_HANDLER,
		CREX_BIND_GLOBAL_SPEC_CV_CONST_HANDLER,
		CREX_COALESCE_SPEC_CONST_HANDLER,
		CREX_COALESCE_SPEC_TMP_HANDLER,
		CREX_COALESCE_SPEC_VAR_HANDLER,
		CREX_NULL_HANDLER,
		CREX_COALESCE_SPEC_CV_HANDLER,
		CREX_SPACESHIP_SPEC_CONST_CONST_HANDLER,
		CREX_SPACESHIP_SPEC_CONST_TMPVAR_HANDLER,
		CREX_SPACESHIP_SPEC_CONST_TMPVAR_HANDLER,
		CREX_NULL_HANDLER,
		CREX_SPACESHIP_SPEC_CONST_CV_HANDLER,
		CREX_SPACESHIP_SPEC_TMPVAR_CONST_HANDLER,
		CREX_SPACESHIP_SPEC_TMPVAR_TMPVAR_HANDLER,
		CREX_SPACESHIP_SPEC_TMPVAR_TMPVAR_HANDLER,
		CREX_NULL_HANDLER,
		CREX_SPACESHIP_SPEC_TMPVAR_CV_HANDLER,
		CREX_SPACESHIP_SPEC_TMPVAR_CONST_HANDLER,
		CREX_SPACESHIP_SPEC_TMPVAR_TMPVAR_HANDLER,
		CREX_SPACESHIP_SPEC_TMPVAR_TMPVAR_HANDLER,
		CREX_NULL_HANDLER,
		CREX_SPACESHIP_SPEC_TMPVAR_CV_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_SPACESHIP_SPEC_CV_CONST_HANDLER,
		CREX_SPACESHIP_SPEC_CV_TMPVAR_HANDLER,
		CREX_SPACESHIP_SPEC_CV_TMPVAR_HANDLER,
		CREX_NULL_HANDLER,
		CREX_SPACESHIP_SPEC_CV_CV_HANDLER,
		CREX_FUNC_NUM_ARGS_SPEC_UNUSED_UNUSED_HANDLER,
		CREX_FUNC_GET_ARGS_SPEC_CONST_UNUSED_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_FUNC_GET_ARGS_SPEC_UNUSED_UNUSED_HANDLER,
		CREX_NULL_HANDLER,
		CREX_FETCH_STATIC_PROP_R_SPEC_HANDLER,
		CREX_FETCH_STATIC_PROP_W_SPEC_HANDLER,
		CREX_FETCH_STATIC_PROP_RW_SPEC_HANDLER,
		CREX_FETCH_STATIC_PROP_IS_SPEC_HANDLER,
		CREX_FETCH_STATIC_PROP_FUNC_ARG_SPEC_HANDLER,
		CREX_FETCH_STATIC_PROP_UNSET_SPEC_HANDLER,
		CREX_UNSET_STATIC_PROP_SPEC_HANDLER,
		CREX_ISSET_ISEMPTY_STATIC_PROP_SPEC_HANDLER,
		CREX_FETCH_CLASS_CONSTANT_SPEC_CONST_CONST_HANDLER,
		CREX_FETCH_CLASS_CONSTANT_SPEC_CONST_TMPVARCV_HANDLER,
		CREX_FETCH_CLASS_CONSTANT_SPEC_CONST_TMPVARCV_HANDLER,
		CREX_NULL_HANDLER,
		CREX_FETCH_CLASS_CONSTANT_SPEC_CONST_TMPVARCV_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_FETCH_CLASS_CONSTANT_SPEC_VAR_CONST_HANDLER,
		CREX_FETCH_CLASS_CONSTANT_SPEC_VAR_TMPVARCV_HANDLER,
		CREX_FETCH_CLASS_CONSTANT_SPEC_VAR_TMPVARCV_HANDLER,
		CREX_NULL_HANDLER,
		CREX_FETCH_CLASS_CONSTANT_SPEC_VAR_TMPVARCV_HANDLER,
		CREX_FETCH_CLASS_CONSTANT_SPEC_UNUSED_CONST_HANDLER,
		CREX_FETCH_CLASS_CONSTANT_SPEC_UNUSED_TMPVARCV_HANDLER,
		CREX_FETCH_CLASS_CONSTANT_SPEC_UNUSED_TMPVARCV_HANDLER,
		CREX_NULL_HANDLER,
		CREX_FETCH_CLASS_CONSTANT_SPEC_UNUSED_TMPVARCV_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_BIND_LEXICAL_SPEC_TMP_CV_HANDLER,
		CREX_BIND_STATIC_SPEC_CV_HANDLER,
		CREX_FETCH_THIS_SPEC_UNUSED_UNUSED_HANDLER,
		CREX_SEND_FUNC_ARG_SPEC_VAR_CONST_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_SEND_FUNC_ARG_SPEC_VAR_UNUSED_HANDLER,
		CREX_NULL_HANDLER,
		CREX_ISSET_ISEMPTY_THIS_SPEC_UNUSED_UNUSED_HANDLER,
		CREX_SWITCH_LONG_SPEC_CONST_CONST_HANDLER,
		CREX_SWITCH_LONG_SPEC_TMPVARCV_CONST_HANDLER,
		CREX_SWITCH_LONG_SPEC_TMPVARCV_CONST_HANDLER,
		CREX_NULL_HANDLER,
		CREX_SWITCH_LONG_SPEC_TMPVARCV_CONST_HANDLER,
		CREX_SWITCH_STRING_SPEC_CONST_CONST_HANDLER,
		CREX_SWITCH_STRING_SPEC_TMPVARCV_CONST_HANDLER,
		CREX_SWITCH_STRING_SPEC_TMPVARCV_CONST_HANDLER,
		CREX_NULL_HANDLER,
		CREX_SWITCH_STRING_SPEC_TMPVARCV_CONST_HANDLER,
		CREX_IN_ARRAY_SPEC_CONST_CONST_HANDLER,
		CREX_IN_ARRAY_SPEC_TMP_CONST_HANDLER,
		CREX_IN_ARRAY_SPEC_VAR_CONST_HANDLER,
		CREX_NULL_HANDLER,
		CREX_IN_ARRAY_SPEC_CV_CONST_HANDLER,
		CREX_COUNT_SPEC_CONST_UNUSED_HANDLER,
		CREX_COUNT_SPEC_TMPVAR_UNUSED_HANDLER,
		CREX_COUNT_SPEC_TMPVAR_UNUSED_HANDLER,
		CREX_NULL_HANDLER,
		CREX_COUNT_SPEC_CV_UNUSED_HANDLER,
		CREX_GET_CLASS_SPEC_CONST_UNUSED_HANDLER,
		CREX_GET_CLASS_SPEC_TMPVAR_UNUSED_HANDLER,
		CREX_GET_CLASS_SPEC_TMPVAR_UNUSED_HANDLER,
		CREX_GET_CLASS_SPEC_UNUSED_UNUSED_HANDLER,
		CREX_GET_CLASS_SPEC_CV_UNUSED_HANDLER,
		CREX_GET_CALLED_CLASS_SPEC_UNUSED_UNUSED_HANDLER,
		CREX_GET_TYPE_SPEC_CONST_UNUSED_HANDLER,
		CREX_GET_TYPE_SPEC_TMP_UNUSED_HANDLER,
		CREX_GET_TYPE_SPEC_VAR_UNUSED_HANDLER,
		CREX_NULL_HANDLER,
		CREX_GET_TYPE_SPEC_CV_UNUSED_HANDLER,
		CREX_ARRAY_KEY_EXISTS_SPEC_CONST_CONST_HANDLER,
		CREX_ARRAY_KEY_EXISTS_SPEC_CONST_TMPVAR_HANDLER,
		CREX_ARRAY_KEY_EXISTS_SPEC_CONST_TMPVAR_HANDLER,
		CREX_NULL_HANDLER,
		CREX_ARRAY_KEY_EXISTS_SPEC_CONST_CV_HANDLER,
		CREX_ARRAY_KEY_EXISTS_SPEC_TMPVAR_CONST_HANDLER,
		CREX_ARRAY_KEY_EXISTS_SPEC_TMPVAR_TMPVAR_HANDLER,
		CREX_ARRAY_KEY_EXISTS_SPEC_TMPVAR_TMPVAR_HANDLER,
		CREX_NULL_HANDLER,
		CREX_ARRAY_KEY_EXISTS_SPEC_TMPVAR_CV_HANDLER,
		CREX_ARRAY_KEY_EXISTS_SPEC_TMPVAR_CONST_HANDLER,
		CREX_ARRAY_KEY_EXISTS_SPEC_TMPVAR_TMPVAR_HANDLER,
		CREX_ARRAY_KEY_EXISTS_SPEC_TMPVAR_TMPVAR_HANDLER,
		CREX_NULL_HANDLER,
		CREX_ARRAY_KEY_EXISTS_SPEC_TMPVAR_CV_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_ARRAY_KEY_EXISTS_SPEC_CV_CONST_HANDLER,
		CREX_ARRAY_KEY_EXISTS_SPEC_CV_TMPVAR_HANDLER,
		CREX_ARRAY_KEY_EXISTS_SPEC_CV_TMPVAR_HANDLER,
		CREX_NULL_HANDLER,
		CREX_ARRAY_KEY_EXISTS_SPEC_CV_CV_HANDLER,
		CREX_MATCH_SPEC_CONST_CONST_HANDLER,
		CREX_MATCH_SPEC_TMPVARCV_CONST_HANDLER,
		CREX_MATCH_SPEC_TMPVARCV_CONST_HANDLER,
		CREX_NULL_HANDLER,
		CREX_MATCH_SPEC_TMPVARCV_CONST_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_CASE_STRICT_SPEC_TMP_CONST_HANDLER,
		CREX_CASE_STRICT_SPEC_TMP_TMP_HANDLER,
		CREX_CASE_STRICT_SPEC_TMP_VAR_HANDLER,
		CREX_NULL_HANDLER,
		CREX_CASE_STRICT_SPEC_TMP_CV_HANDLER,
		CREX_CASE_STRICT_SPEC_VAR_CONST_HANDLER,
		CREX_CASE_STRICT_SPEC_VAR_TMP_HANDLER,
		CREX_CASE_STRICT_SPEC_VAR_VAR_HANDLER,
		CREX_NULL_HANDLER,
		CREX_CASE_STRICT_SPEC_VAR_CV_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_MATCH_ERROR_SPEC_CONST_UNUSED_HANDLER,
		CREX_MATCH_ERROR_SPEC_TMPVARCV_UNUSED_HANDLER,
		CREX_MATCH_ERROR_SPEC_TMPVARCV_UNUSED_HANDLER,
		CREX_NULL_HANDLER,
		CREX_MATCH_ERROR_SPEC_TMPVARCV_UNUSED_HANDLER,
		CREX_JMP_NULL_SPEC_CONST_HANDLER,
		CREX_JMP_NULL_SPEC_TMP_HANDLER,
		CREX_JMP_NULL_SPEC_VAR_HANDLER,
		CREX_NULL_HANDLER,
		CREX_JMP_NULL_SPEC_CV_HANDLER,
		CREX_CHECK_UNDEF_ARGS_SPEC_UNUSED_UNUSED_HANDLER,
		CREX_FETCH_GLOBALS_SPEC_UNUSED_UNUSED_HANDLER,
		CREX_VERIFY_NEVER_TYPE_SPEC_UNUSED_UNUSED_HANDLER,
		CREX_CALLABLE_CONVERT_SPEC_UNUSED_UNUSED_HANDLER,
		CREX_BIND_INIT_STATIC_OR_JMP_SPEC_CV_HANDLER,
		CREX_RECV_NOTYPE_SPEC_HANDLER,
		CREX_NULL_HANDLER,
		CREX_COUNT_ARRAY_SPEC_TMPVAR_UNUSED_HANDLER,
		CREX_COUNT_ARRAY_SPEC_TMPVAR_UNUSED_HANDLER,
		CREX_NULL_HANDLER,
		CREX_COUNT_ARRAY_SPEC_CV_UNUSED_HANDLER,
		CREX_JMP_FORWARD_SPEC_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_ADD_LONG_NO_OVERFLOW_SPEC_TMPVARCV_CONST_HANDLER,
		CREX_ADD_LONG_NO_OVERFLOW_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_ADD_LONG_NO_OVERFLOW_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_NULL_HANDLER,
		CREX_ADD_LONG_NO_OVERFLOW_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_ADD_LONG_NO_OVERFLOW_SPEC_TMPVARCV_CONST_HANDLER,
		CREX_ADD_LONG_NO_OVERFLOW_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_ADD_LONG_NO_OVERFLOW_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_NULL_HANDLER,
		CREX_ADD_LONG_NO_OVERFLOW_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_ADD_LONG_NO_OVERFLOW_SPEC_TMPVARCV_CONST_HANDLER,
		CREX_ADD_LONG_NO_OVERFLOW_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_ADD_LONG_NO_OVERFLOW_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_NULL_HANDLER,
		CREX_ADD_LONG_NO_OVERFLOW_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_ADD_LONG_SPEC_TMPVARCV_CONST_HANDLER,
		CREX_ADD_LONG_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_ADD_LONG_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_NULL_HANDLER,
		CREX_ADD_LONG_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_ADD_LONG_SPEC_TMPVARCV_CONST_HANDLER,
		CREX_ADD_LONG_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_ADD_LONG_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_NULL_HANDLER,
		CREX_ADD_LONG_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_ADD_LONG_SPEC_TMPVARCV_CONST_HANDLER,
		CREX_ADD_LONG_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_ADD_LONG_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_NULL_HANDLER,
		CREX_ADD_LONG_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_ADD_DOUBLE_SPEC_TMPVARCV_CONST_HANDLER,
		CREX_ADD_DOUBLE_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_ADD_DOUBLE_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_NULL_HANDLER,
		CREX_ADD_DOUBLE_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_ADD_DOUBLE_SPEC_TMPVARCV_CONST_HANDLER,
		CREX_ADD_DOUBLE_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_ADD_DOUBLE_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_NULL_HANDLER,
		CREX_ADD_DOUBLE_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_ADD_DOUBLE_SPEC_TMPVARCV_CONST_HANDLER,
		CREX_ADD_DOUBLE_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_ADD_DOUBLE_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_NULL_HANDLER,
		CREX_ADD_DOUBLE_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_NULL_HANDLER,
		CREX_SUB_LONG_NO_OVERFLOW_SPEC_CONST_TMPVARCV_HANDLER,
		CREX_SUB_LONG_NO_OVERFLOW_SPEC_CONST_TMPVARCV_HANDLER,
		CREX_NULL_HANDLER,
		CREX_SUB_LONG_NO_OVERFLOW_SPEC_CONST_TMPVARCV_HANDLER,
		CREX_SUB_LONG_NO_OVERFLOW_SPEC_TMPVARCV_CONST_HANDLER,
		CREX_SUB_LONG_NO_OVERFLOW_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_SUB_LONG_NO_OVERFLOW_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_NULL_HANDLER,
		CREX_SUB_LONG_NO_OVERFLOW_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_SUB_LONG_NO_OVERFLOW_SPEC_TMPVARCV_CONST_HANDLER,
		CREX_SUB_LONG_NO_OVERFLOW_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_SUB_LONG_NO_OVERFLOW_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_NULL_HANDLER,
		CREX_SUB_LONG_NO_OVERFLOW_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_SUB_LONG_NO_OVERFLOW_SPEC_TMPVARCV_CONST_HANDLER,
		CREX_SUB_LONG_NO_OVERFLOW_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_SUB_LONG_NO_OVERFLOW_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_NULL_HANDLER,
		CREX_SUB_LONG_NO_OVERFLOW_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_NULL_HANDLER,
		CREX_SUB_LONG_SPEC_CONST_TMPVARCV_HANDLER,
		CREX_SUB_LONG_SPEC_CONST_TMPVARCV_HANDLER,
		CREX_NULL_HANDLER,
		CREX_SUB_LONG_SPEC_CONST_TMPVARCV_HANDLER,
		CREX_SUB_LONG_SPEC_TMPVARCV_CONST_HANDLER,
		CREX_SUB_LONG_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_SUB_LONG_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_NULL_HANDLER,
		CREX_SUB_LONG_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_SUB_LONG_SPEC_TMPVARCV_CONST_HANDLER,
		CREX_SUB_LONG_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_SUB_LONG_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_NULL_HANDLER,
		CREX_SUB_LONG_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_SUB_LONG_SPEC_TMPVARCV_CONST_HANDLER,
		CREX_SUB_LONG_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_SUB_LONG_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_NULL_HANDLER,
		CREX_SUB_LONG_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_NULL_HANDLER,
		CREX_SUB_DOUBLE_SPEC_CONST_TMPVARCV_HANDLER,
		CREX_SUB_DOUBLE_SPEC_CONST_TMPVARCV_HANDLER,
		CREX_NULL_HANDLER,
		CREX_SUB_DOUBLE_SPEC_CONST_TMPVARCV_HANDLER,
		CREX_SUB_DOUBLE_SPEC_TMPVARCV_CONST_HANDLER,
		CREX_SUB_DOUBLE_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_SUB_DOUBLE_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_NULL_HANDLER,
		CREX_SUB_DOUBLE_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_SUB_DOUBLE_SPEC_TMPVARCV_CONST_HANDLER,
		CREX_SUB_DOUBLE_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_SUB_DOUBLE_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_NULL_HANDLER,
		CREX_SUB_DOUBLE_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_SUB_DOUBLE_SPEC_TMPVARCV_CONST_HANDLER,
		CREX_SUB_DOUBLE_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_SUB_DOUBLE_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_NULL_HANDLER,
		CREX_SUB_DOUBLE_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_MUL_LONG_NO_OVERFLOW_SPEC_TMPVARCV_CONST_HANDLER,
		CREX_MUL_LONG_NO_OVERFLOW_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_MUL_LONG_NO_OVERFLOW_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_NULL_HANDLER,
		CREX_MUL_LONG_NO_OVERFLOW_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_MUL_LONG_NO_OVERFLOW_SPEC_TMPVARCV_CONST_HANDLER,
		CREX_MUL_LONG_NO_OVERFLOW_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_MUL_LONG_NO_OVERFLOW_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_NULL_HANDLER,
		CREX_MUL_LONG_NO_OVERFLOW_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_MUL_LONG_NO_OVERFLOW_SPEC_TMPVARCV_CONST_HANDLER,
		CREX_MUL_LONG_NO_OVERFLOW_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_MUL_LONG_NO_OVERFLOW_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_NULL_HANDLER,
		CREX_MUL_LONG_NO_OVERFLOW_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_MUL_LONG_SPEC_TMPVARCV_CONST_HANDLER,
		CREX_MUL_LONG_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_MUL_LONG_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_NULL_HANDLER,
		CREX_MUL_LONG_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_MUL_LONG_SPEC_TMPVARCV_CONST_HANDLER,
		CREX_MUL_LONG_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_MUL_LONG_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_NULL_HANDLER,
		CREX_MUL_LONG_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_MUL_LONG_SPEC_TMPVARCV_CONST_HANDLER,
		CREX_MUL_LONG_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_MUL_LONG_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_NULL_HANDLER,
		CREX_MUL_LONG_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_MUL_DOUBLE_SPEC_TMPVARCV_CONST_HANDLER,
		CREX_MUL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_MUL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_NULL_HANDLER,
		CREX_MUL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_MUL_DOUBLE_SPEC_TMPVARCV_CONST_HANDLER,
		CREX_MUL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_MUL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_NULL_HANDLER,
		CREX_MUL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_MUL_DOUBLE_SPEC_TMPVARCV_CONST_HANDLER,
		CREX_MUL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_MUL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_NULL_HANDLER,
		CREX_MUL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_IS_EQUAL_LONG_SPEC_TMPVARCV_CONST_HANDLER,
		CREX_IS_EQUAL_LONG_SPEC_TMPVARCV_CONST_JMPC_HANDLER,
		CREX_IS_EQUAL_LONG_SPEC_TMPVARCV_CONST_JMPNC_HANDLER,
		CREX_IS_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_IS_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPC_HANDLER,
		CREX_IS_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPNC_HANDLER,
		CREX_IS_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_IS_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPC_HANDLER,
		CREX_IS_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPNC_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_IS_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_IS_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPC_HANDLER,
		CREX_IS_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPNC_HANDLER,
		CREX_IS_EQUAL_LONG_SPEC_TMPVARCV_CONST_HANDLER,
		CREX_IS_EQUAL_LONG_SPEC_TMPVARCV_CONST_JMPC_HANDLER,
		CREX_IS_EQUAL_LONG_SPEC_TMPVARCV_CONST_JMPNC_HANDLER,
		CREX_IS_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_IS_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPC_HANDLER,
		CREX_IS_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPNC_HANDLER,
		CREX_IS_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_IS_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPC_HANDLER,
		CREX_IS_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPNC_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_IS_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_IS_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPC_HANDLER,
		CREX_IS_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPNC_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_IS_EQUAL_LONG_SPEC_TMPVARCV_CONST_HANDLER,
		CREX_IS_EQUAL_LONG_SPEC_TMPVARCV_CONST_JMPC_HANDLER,
		CREX_IS_EQUAL_LONG_SPEC_TMPVARCV_CONST_JMPNC_HANDLER,
		CREX_IS_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_IS_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPC_HANDLER,
		CREX_IS_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPNC_HANDLER,
		CREX_IS_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_IS_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPC_HANDLER,
		CREX_IS_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPNC_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_IS_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_IS_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPC_HANDLER,
		CREX_IS_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPNC_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_IS_EQUAL_DOUBLE_SPEC_TMPVARCV_CONST_HANDLER,
		CREX_IS_EQUAL_DOUBLE_SPEC_TMPVARCV_CONST_JMPC_HANDLER,
		CREX_IS_EQUAL_DOUBLE_SPEC_TMPVARCV_CONST_JMPNC_HANDLER,
		CREX_IS_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_IS_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPC_HANDLER,
		CREX_IS_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPNC_HANDLER,
		CREX_IS_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_IS_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPC_HANDLER,
		CREX_IS_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPNC_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_IS_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_IS_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPC_HANDLER,
		CREX_IS_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPNC_HANDLER,
		CREX_IS_EQUAL_DOUBLE_SPEC_TMPVARCV_CONST_HANDLER,
		CREX_IS_EQUAL_DOUBLE_SPEC_TMPVARCV_CONST_JMPC_HANDLER,
		CREX_IS_EQUAL_DOUBLE_SPEC_TMPVARCV_CONST_JMPNC_HANDLER,
		CREX_IS_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_IS_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPC_HANDLER,
		CREX_IS_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPNC_HANDLER,
		CREX_IS_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_IS_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPC_HANDLER,
		CREX_IS_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPNC_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_IS_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_IS_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPC_HANDLER,
		CREX_IS_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPNC_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_IS_EQUAL_DOUBLE_SPEC_TMPVARCV_CONST_HANDLER,
		CREX_IS_EQUAL_DOUBLE_SPEC_TMPVARCV_CONST_JMPC_HANDLER,
		CREX_IS_EQUAL_DOUBLE_SPEC_TMPVARCV_CONST_JMPNC_HANDLER,
		CREX_IS_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_IS_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPC_HANDLER,
		CREX_IS_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPNC_HANDLER,
		CREX_IS_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_IS_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPC_HANDLER,
		CREX_IS_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPNC_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_IS_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_IS_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPC_HANDLER,
		CREX_IS_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPNC_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_IS_NOT_EQUAL_LONG_SPEC_TMPVARCV_CONST_HANDLER,
		CREX_IS_NOT_EQUAL_LONG_SPEC_TMPVARCV_CONST_JMPC_HANDLER,
		CREX_IS_NOT_EQUAL_LONG_SPEC_TMPVARCV_CONST_JMPNC_HANDLER,
		CREX_IS_NOT_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_IS_NOT_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPC_HANDLER,
		CREX_IS_NOT_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPNC_HANDLER,
		CREX_IS_NOT_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_IS_NOT_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPC_HANDLER,
		CREX_IS_NOT_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPNC_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_IS_NOT_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_IS_NOT_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPC_HANDLER,
		CREX_IS_NOT_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPNC_HANDLER,
		CREX_IS_NOT_EQUAL_LONG_SPEC_TMPVARCV_CONST_HANDLER,
		CREX_IS_NOT_EQUAL_LONG_SPEC_TMPVARCV_CONST_JMPC_HANDLER,
		CREX_IS_NOT_EQUAL_LONG_SPEC_TMPVARCV_CONST_JMPNC_HANDLER,
		CREX_IS_NOT_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_IS_NOT_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPC_HANDLER,
		CREX_IS_NOT_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPNC_HANDLER,
		CREX_IS_NOT_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_IS_NOT_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPC_HANDLER,
		CREX_IS_NOT_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPNC_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_IS_NOT_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_IS_NOT_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPC_HANDLER,
		CREX_IS_NOT_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPNC_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_IS_NOT_EQUAL_LONG_SPEC_TMPVARCV_CONST_HANDLER,
		CREX_IS_NOT_EQUAL_LONG_SPEC_TMPVARCV_CONST_JMPC_HANDLER,
		CREX_IS_NOT_EQUAL_LONG_SPEC_TMPVARCV_CONST_JMPNC_HANDLER,
		CREX_IS_NOT_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_IS_NOT_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPC_HANDLER,
		CREX_IS_NOT_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPNC_HANDLER,
		CREX_IS_NOT_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_IS_NOT_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPC_HANDLER,
		CREX_IS_NOT_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPNC_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_IS_NOT_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_IS_NOT_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPC_HANDLER,
		CREX_IS_NOT_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPNC_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_IS_NOT_EQUAL_DOUBLE_SPEC_TMPVARCV_CONST_HANDLER,
		CREX_IS_NOT_EQUAL_DOUBLE_SPEC_TMPVARCV_CONST_JMPC_HANDLER,
		CREX_IS_NOT_EQUAL_DOUBLE_SPEC_TMPVARCV_CONST_JMPNC_HANDLER,
		CREX_IS_NOT_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_IS_NOT_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPC_HANDLER,
		CREX_IS_NOT_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPNC_HANDLER,
		CREX_IS_NOT_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_IS_NOT_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPC_HANDLER,
		CREX_IS_NOT_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPNC_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_IS_NOT_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_IS_NOT_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPC_HANDLER,
		CREX_IS_NOT_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPNC_HANDLER,
		CREX_IS_NOT_EQUAL_DOUBLE_SPEC_TMPVARCV_CONST_HANDLER,
		CREX_IS_NOT_EQUAL_DOUBLE_SPEC_TMPVARCV_CONST_JMPC_HANDLER,
		CREX_IS_NOT_EQUAL_DOUBLE_SPEC_TMPVARCV_CONST_JMPNC_HANDLER,
		CREX_IS_NOT_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_IS_NOT_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPC_HANDLER,
		CREX_IS_NOT_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPNC_HANDLER,
		CREX_IS_NOT_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_IS_NOT_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPC_HANDLER,
		CREX_IS_NOT_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPNC_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_IS_NOT_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_IS_NOT_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPC_HANDLER,
		CREX_IS_NOT_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPNC_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_IS_NOT_EQUAL_DOUBLE_SPEC_TMPVARCV_CONST_HANDLER,
		CREX_IS_NOT_EQUAL_DOUBLE_SPEC_TMPVARCV_CONST_JMPC_HANDLER,
		CREX_IS_NOT_EQUAL_DOUBLE_SPEC_TMPVARCV_CONST_JMPNC_HANDLER,
		CREX_IS_NOT_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_IS_NOT_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPC_HANDLER,
		CREX_IS_NOT_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPNC_HANDLER,
		CREX_IS_NOT_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_IS_NOT_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPC_HANDLER,
		CREX_IS_NOT_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPNC_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_IS_NOT_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_IS_NOT_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPC_HANDLER,
		CREX_IS_NOT_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPNC_HANDLER,
		CREX_IS_IDENTICAL_NOTHROW_SPEC_CV_CONST_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_IS_IDENTICAL_NOTHROW_SPEC_CV_CV_HANDLER,
		CREX_IS_NOT_IDENTICAL_NOTHROW_SPEC_CV_CONST_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_IS_NOT_IDENTICAL_NOTHROW_SPEC_CV_CV_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_IS_SMALLER_LONG_SPEC_CONST_TMPVARCV_HANDLER,
		CREX_IS_SMALLER_LONG_SPEC_CONST_TMPVARCV_JMPC_HANDLER,
		CREX_IS_SMALLER_LONG_SPEC_CONST_TMPVARCV_JMPNC_HANDLER,
		CREX_IS_SMALLER_LONG_SPEC_CONST_TMPVARCV_HANDLER,
		CREX_IS_SMALLER_LONG_SPEC_CONST_TMPVARCV_JMPC_HANDLER,
		CREX_IS_SMALLER_LONG_SPEC_CONST_TMPVARCV_JMPNC_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_IS_SMALLER_LONG_SPEC_CONST_TMPVARCV_HANDLER,
		CREX_IS_SMALLER_LONG_SPEC_CONST_TMPVARCV_JMPC_HANDLER,
		CREX_IS_SMALLER_LONG_SPEC_CONST_TMPVARCV_JMPNC_HANDLER,
		CREX_IS_SMALLER_LONG_SPEC_TMPVARCV_CONST_HANDLER,
		CREX_IS_SMALLER_LONG_SPEC_TMPVARCV_CONST_JMPC_HANDLER,
		CREX_IS_SMALLER_LONG_SPEC_TMPVARCV_CONST_JMPNC_HANDLER,
		CREX_IS_SMALLER_LONG_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_IS_SMALLER_LONG_SPEC_TMPVARCV_TMPVARCV_JMPC_HANDLER,
		CREX_IS_SMALLER_LONG_SPEC_TMPVARCV_TMPVARCV_JMPNC_HANDLER,
		CREX_IS_SMALLER_LONG_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_IS_SMALLER_LONG_SPEC_TMPVARCV_TMPVARCV_JMPC_HANDLER,
		CREX_IS_SMALLER_LONG_SPEC_TMPVARCV_TMPVARCV_JMPNC_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_IS_SMALLER_LONG_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_IS_SMALLER_LONG_SPEC_TMPVARCV_TMPVARCV_JMPC_HANDLER,
		CREX_IS_SMALLER_LONG_SPEC_TMPVARCV_TMPVARCV_JMPNC_HANDLER,
		CREX_IS_SMALLER_LONG_SPEC_TMPVARCV_CONST_HANDLER,
		CREX_IS_SMALLER_LONG_SPEC_TMPVARCV_CONST_JMPC_HANDLER,
		CREX_IS_SMALLER_LONG_SPEC_TMPVARCV_CONST_JMPNC_HANDLER,
		CREX_IS_SMALLER_LONG_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_IS_SMALLER_LONG_SPEC_TMPVARCV_TMPVARCV_JMPC_HANDLER,
		CREX_IS_SMALLER_LONG_SPEC_TMPVARCV_TMPVARCV_JMPNC_HANDLER,
		CREX_IS_SMALLER_LONG_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_IS_SMALLER_LONG_SPEC_TMPVARCV_TMPVARCV_JMPC_HANDLER,
		CREX_IS_SMALLER_LONG_SPEC_TMPVARCV_TMPVARCV_JMPNC_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_IS_SMALLER_LONG_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_IS_SMALLER_LONG_SPEC_TMPVARCV_TMPVARCV_JMPC_HANDLER,
		CREX_IS_SMALLER_LONG_SPEC_TMPVARCV_TMPVARCV_JMPNC_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_IS_SMALLER_LONG_SPEC_TMPVARCV_CONST_HANDLER,
		CREX_IS_SMALLER_LONG_SPEC_TMPVARCV_CONST_JMPC_HANDLER,
		CREX_IS_SMALLER_LONG_SPEC_TMPVARCV_CONST_JMPNC_HANDLER,
		CREX_IS_SMALLER_LONG_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_IS_SMALLER_LONG_SPEC_TMPVARCV_TMPVARCV_JMPC_HANDLER,
		CREX_IS_SMALLER_LONG_SPEC_TMPVARCV_TMPVARCV_JMPNC_HANDLER,
		CREX_IS_SMALLER_LONG_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_IS_SMALLER_LONG_SPEC_TMPVARCV_TMPVARCV_JMPC_HANDLER,
		CREX_IS_SMALLER_LONG_SPEC_TMPVARCV_TMPVARCV_JMPNC_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_IS_SMALLER_LONG_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_IS_SMALLER_LONG_SPEC_TMPVARCV_TMPVARCV_JMPC_HANDLER,
		CREX_IS_SMALLER_LONG_SPEC_TMPVARCV_TMPVARCV_JMPNC_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_IS_SMALLER_DOUBLE_SPEC_CONST_TMPVARCV_HANDLER,
		CREX_IS_SMALLER_DOUBLE_SPEC_CONST_TMPVARCV_JMPC_HANDLER,
		CREX_IS_SMALLER_DOUBLE_SPEC_CONST_TMPVARCV_JMPNC_HANDLER,
		CREX_IS_SMALLER_DOUBLE_SPEC_CONST_TMPVARCV_HANDLER,
		CREX_IS_SMALLER_DOUBLE_SPEC_CONST_TMPVARCV_JMPC_HANDLER,
		CREX_IS_SMALLER_DOUBLE_SPEC_CONST_TMPVARCV_JMPNC_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_IS_SMALLER_DOUBLE_SPEC_CONST_TMPVARCV_HANDLER,
		CREX_IS_SMALLER_DOUBLE_SPEC_CONST_TMPVARCV_JMPC_HANDLER,
		CREX_IS_SMALLER_DOUBLE_SPEC_CONST_TMPVARCV_JMPNC_HANDLER,
		CREX_IS_SMALLER_DOUBLE_SPEC_TMPVARCV_CONST_HANDLER,
		CREX_IS_SMALLER_DOUBLE_SPEC_TMPVARCV_CONST_JMPC_HANDLER,
		CREX_IS_SMALLER_DOUBLE_SPEC_TMPVARCV_CONST_JMPNC_HANDLER,
		CREX_IS_SMALLER_DOUBLE_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_IS_SMALLER_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPC_HANDLER,
		CREX_IS_SMALLER_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPNC_HANDLER,
		CREX_IS_SMALLER_DOUBLE_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_IS_SMALLER_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPC_HANDLER,
		CREX_IS_SMALLER_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPNC_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_IS_SMALLER_DOUBLE_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_IS_SMALLER_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPC_HANDLER,
		CREX_IS_SMALLER_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPNC_HANDLER,
		CREX_IS_SMALLER_DOUBLE_SPEC_TMPVARCV_CONST_HANDLER,
		CREX_IS_SMALLER_DOUBLE_SPEC_TMPVARCV_CONST_JMPC_HANDLER,
		CREX_IS_SMALLER_DOUBLE_SPEC_TMPVARCV_CONST_JMPNC_HANDLER,
		CREX_IS_SMALLER_DOUBLE_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_IS_SMALLER_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPC_HANDLER,
		CREX_IS_SMALLER_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPNC_HANDLER,
		CREX_IS_SMALLER_DOUBLE_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_IS_SMALLER_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPC_HANDLER,
		CREX_IS_SMALLER_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPNC_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_IS_SMALLER_DOUBLE_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_IS_SMALLER_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPC_HANDLER,
		CREX_IS_SMALLER_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPNC_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_IS_SMALLER_DOUBLE_SPEC_TMPVARCV_CONST_HANDLER,
		CREX_IS_SMALLER_DOUBLE_SPEC_TMPVARCV_CONST_JMPC_HANDLER,
		CREX_IS_SMALLER_DOUBLE_SPEC_TMPVARCV_CONST_JMPNC_HANDLER,
		CREX_IS_SMALLER_DOUBLE_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_IS_SMALLER_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPC_HANDLER,
		CREX_IS_SMALLER_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPNC_HANDLER,
		CREX_IS_SMALLER_DOUBLE_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_IS_SMALLER_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPC_HANDLER,
		CREX_IS_SMALLER_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPNC_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_IS_SMALLER_DOUBLE_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_IS_SMALLER_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPC_HANDLER,
		CREX_IS_SMALLER_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPNC_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_IS_SMALLER_OR_EQUAL_LONG_SPEC_CONST_TMPVARCV_HANDLER,
		CREX_IS_SMALLER_OR_EQUAL_LONG_SPEC_CONST_TMPVARCV_JMPC_HANDLER,
		CREX_IS_SMALLER_OR_EQUAL_LONG_SPEC_CONST_TMPVARCV_JMPNC_HANDLER,
		CREX_IS_SMALLER_OR_EQUAL_LONG_SPEC_CONST_TMPVARCV_HANDLER,
		CREX_IS_SMALLER_OR_EQUAL_LONG_SPEC_CONST_TMPVARCV_JMPC_HANDLER,
		CREX_IS_SMALLER_OR_EQUAL_LONG_SPEC_CONST_TMPVARCV_JMPNC_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_IS_SMALLER_OR_EQUAL_LONG_SPEC_CONST_TMPVARCV_HANDLER,
		CREX_IS_SMALLER_OR_EQUAL_LONG_SPEC_CONST_TMPVARCV_JMPC_HANDLER,
		CREX_IS_SMALLER_OR_EQUAL_LONG_SPEC_CONST_TMPVARCV_JMPNC_HANDLER,
		CREX_IS_SMALLER_OR_EQUAL_LONG_SPEC_TMPVARCV_CONST_HANDLER,
		CREX_IS_SMALLER_OR_EQUAL_LONG_SPEC_TMPVARCV_CONST_JMPC_HANDLER,
		CREX_IS_SMALLER_OR_EQUAL_LONG_SPEC_TMPVARCV_CONST_JMPNC_HANDLER,
		CREX_IS_SMALLER_OR_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_IS_SMALLER_OR_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPC_HANDLER,
		CREX_IS_SMALLER_OR_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPNC_HANDLER,
		CREX_IS_SMALLER_OR_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_IS_SMALLER_OR_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPC_HANDLER,
		CREX_IS_SMALLER_OR_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPNC_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_IS_SMALLER_OR_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_IS_SMALLER_OR_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPC_HANDLER,
		CREX_IS_SMALLER_OR_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPNC_HANDLER,
		CREX_IS_SMALLER_OR_EQUAL_LONG_SPEC_TMPVARCV_CONST_HANDLER,
		CREX_IS_SMALLER_OR_EQUAL_LONG_SPEC_TMPVARCV_CONST_JMPC_HANDLER,
		CREX_IS_SMALLER_OR_EQUAL_LONG_SPEC_TMPVARCV_CONST_JMPNC_HANDLER,
		CREX_IS_SMALLER_OR_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_IS_SMALLER_OR_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPC_HANDLER,
		CREX_IS_SMALLER_OR_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPNC_HANDLER,
		CREX_IS_SMALLER_OR_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_IS_SMALLER_OR_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPC_HANDLER,
		CREX_IS_SMALLER_OR_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPNC_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_IS_SMALLER_OR_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_IS_SMALLER_OR_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPC_HANDLER,
		CREX_IS_SMALLER_OR_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPNC_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_IS_SMALLER_OR_EQUAL_LONG_SPEC_TMPVARCV_CONST_HANDLER,
		CREX_IS_SMALLER_OR_EQUAL_LONG_SPEC_TMPVARCV_CONST_JMPC_HANDLER,
		CREX_IS_SMALLER_OR_EQUAL_LONG_SPEC_TMPVARCV_CONST_JMPNC_HANDLER,
		CREX_IS_SMALLER_OR_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_IS_SMALLER_OR_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPC_HANDLER,
		CREX_IS_SMALLER_OR_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPNC_HANDLER,
		CREX_IS_SMALLER_OR_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_IS_SMALLER_OR_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPC_HANDLER,
		CREX_IS_SMALLER_OR_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPNC_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_IS_SMALLER_OR_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_IS_SMALLER_OR_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPC_HANDLER,
		CREX_IS_SMALLER_OR_EQUAL_LONG_SPEC_TMPVARCV_TMPVARCV_JMPNC_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_CONST_TMPVARCV_HANDLER,
		CREX_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_CONST_TMPVARCV_JMPC_HANDLER,
		CREX_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_CONST_TMPVARCV_JMPNC_HANDLER,
		CREX_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_CONST_TMPVARCV_HANDLER,
		CREX_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_CONST_TMPVARCV_JMPC_HANDLER,
		CREX_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_CONST_TMPVARCV_JMPNC_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_CONST_TMPVARCV_HANDLER,
		CREX_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_CONST_TMPVARCV_JMPC_HANDLER,
		CREX_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_CONST_TMPVARCV_JMPNC_HANDLER,
		CREX_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_TMPVARCV_CONST_HANDLER,
		CREX_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_TMPVARCV_CONST_JMPC_HANDLER,
		CREX_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_TMPVARCV_CONST_JMPNC_HANDLER,
		CREX_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPC_HANDLER,
		CREX_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPNC_HANDLER,
		CREX_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPC_HANDLER,
		CREX_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPNC_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPC_HANDLER,
		CREX_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPNC_HANDLER,
		CREX_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_TMPVARCV_CONST_HANDLER,
		CREX_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_TMPVARCV_CONST_JMPC_HANDLER,
		CREX_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_TMPVARCV_CONST_JMPNC_HANDLER,
		CREX_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPC_HANDLER,
		CREX_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPNC_HANDLER,
		CREX_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPC_HANDLER,
		CREX_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPNC_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPC_HANDLER,
		CREX_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPNC_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_TMPVARCV_CONST_HANDLER,
		CREX_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_TMPVARCV_CONST_JMPC_HANDLER,
		CREX_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_TMPVARCV_CONST_JMPNC_HANDLER,
		CREX_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPC_HANDLER,
		CREX_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPNC_HANDLER,
		CREX_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPC_HANDLER,
		CREX_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPNC_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_HANDLER,
		CREX_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPC_HANDLER,
		CREX_IS_SMALLER_OR_EQUAL_DOUBLE_SPEC_TMPVARCV_TMPVARCV_JMPNC_HANDLER,
		CREX_PRE_INC_LONG_NO_OVERFLOW_SPEC_CV_RETVAL_UNUSED_HANDLER,
		CREX_PRE_INC_LONG_NO_OVERFLOW_SPEC_CV_RETVAL_USED_HANDLER,
		CREX_PRE_INC_LONG_SPEC_CV_RETVAL_UNUSED_HANDLER,
		CREX_PRE_INC_LONG_SPEC_CV_RETVAL_USED_HANDLER,
		CREX_PRE_DEC_LONG_NO_OVERFLOW_SPEC_CV_RETVAL_UNUSED_HANDLER,
		CREX_PRE_DEC_LONG_NO_OVERFLOW_SPEC_CV_RETVAL_USED_HANDLER,
		CREX_PRE_DEC_LONG_SPEC_CV_RETVAL_UNUSED_HANDLER,
		CREX_PRE_DEC_LONG_SPEC_CV_RETVAL_USED_HANDLER,
		CREX_POST_INC_LONG_NO_OVERFLOW_SPEC_CV_HANDLER,
		CREX_POST_INC_LONG_SPEC_CV_HANDLER,
		CREX_POST_DEC_LONG_NO_OVERFLOW_SPEC_CV_HANDLER,
		CREX_POST_DEC_LONG_SPEC_CV_HANDLER,
		CREX_QM_ASSIGN_LONG_SPEC_CONST_HANDLER,
		CREX_QM_ASSIGN_LONG_SPEC_TMPVARCV_HANDLER,
		CREX_QM_ASSIGN_LONG_SPEC_TMPVARCV_HANDLER,
		CREX_NULL_HANDLER,
		CREX_QM_ASSIGN_LONG_SPEC_TMPVARCV_HANDLER,
		CREX_QM_ASSIGN_DOUBLE_SPEC_CONST_HANDLER,
		CREX_QM_ASSIGN_DOUBLE_SPEC_TMPVARCV_HANDLER,
		CREX_QM_ASSIGN_DOUBLE_SPEC_TMPVARCV_HANDLER,
		CREX_NULL_HANDLER,
		CREX_QM_ASSIGN_DOUBLE_SPEC_TMPVARCV_HANDLER,
		CREX_QM_ASSIGN_NOREF_SPEC_CONST_HANDLER,
		CREX_QM_ASSIGN_NOREF_SPEC_TMPVARCV_HANDLER,
		CREX_QM_ASSIGN_NOREF_SPEC_TMPVARCV_HANDLER,
		CREX_NULL_HANDLER,
		CREX_QM_ASSIGN_NOREF_SPEC_TMPVARCV_HANDLER,
		CREX_NULL_HANDLER,
		CREX_FETCH_DIM_R_INDEX_SPEC_CONST_TMPVARCV_HANDLER,
		CREX_FETCH_DIM_R_INDEX_SPEC_CONST_TMPVARCV_HANDLER,
		CREX_NULL_HANDLER,
		CREX_FETCH_DIM_R_INDEX_SPEC_CONST_TMPVARCV_HANDLER,
		CREX_FETCH_DIM_R_INDEX_SPEC_TMPVAR_CONST_HANDLER,
		CREX_FETCH_DIM_R_INDEX_SPEC_TMPVAR_TMPVARCV_HANDLER,
		CREX_FETCH_DIM_R_INDEX_SPEC_TMPVAR_TMPVARCV_HANDLER,
		CREX_NULL_HANDLER,
		CREX_FETCH_DIM_R_INDEX_SPEC_TMPVAR_TMPVARCV_HANDLER,
		CREX_FETCH_DIM_R_INDEX_SPEC_TMPVAR_CONST_HANDLER,
		CREX_FETCH_DIM_R_INDEX_SPEC_TMPVAR_TMPVARCV_HANDLER,
		CREX_FETCH_DIM_R_INDEX_SPEC_TMPVAR_TMPVARCV_HANDLER,
		CREX_NULL_HANDLER,
		CREX_FETCH_DIM_R_INDEX_SPEC_TMPVAR_TMPVARCV_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_FETCH_DIM_R_INDEX_SPEC_CV_CONST_HANDLER,
		CREX_FETCH_DIM_R_INDEX_SPEC_CV_TMPVARCV_HANDLER,
		CREX_FETCH_DIM_R_INDEX_SPEC_CV_TMPVARCV_HANDLER,
		CREX_NULL_HANDLER,
		CREX_FETCH_DIM_R_INDEX_SPEC_CV_TMPVARCV_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_SEND_VAR_SIMPLE_SPEC_VAR_HANDLER,
		CREX_NULL_HANDLER,
		CREX_SEND_VAR_SIMPLE_SPEC_CV_HANDLER,
		CREX_NULL_HANDLER,
		CREX_NULL_HANDLER,
		CREX_SEND_VAR_EX_SIMPLE_SPEC_VAR_UNUSED_HANDLER,
		CREX_NULL_HANDLER,
		CREX_SEND_VAR_EX_SIMPLE_SPEC_CV_UNUSED_HANDLER,
		CREX_SEND_VAL_SIMPLE_SPEC_CONST_HANDLER,
		CREX_SEND_VAL_EX_SIMPLE_SPEC_CONST_HANDLER,
		CREX_FE_FETCH_R_SIMPLE_SPEC_VAR_CV_RETVAL_UNUSED_HANDLER,
		CREX_FE_FETCH_R_SIMPLE_SPEC_VAR_CV_RETVAL_USED_HANDLER,
		CREX_NULL_HANDLER
	};
	static const uint32_t specs[] = {
		0,
		1 | SPEC_RULE_OP1 | SPEC_RULE_OP2,
		26 | SPEC_RULE_OP1 | SPEC_RULE_OP2,
		51 | SPEC_RULE_OP1 | SPEC_RULE_OP2 | SPEC_RULE_COMMUTATIVE,
		76 | SPEC_RULE_OP1 | SPEC_RULE_OP2,
		101 | SPEC_RULE_OP1 | SPEC_RULE_OP2,
		126 | SPEC_RULE_OP1 | SPEC_RULE_OP2,
		151 | SPEC_RULE_OP1 | SPEC_RULE_OP2,
		176 | SPEC_RULE_OP1 | SPEC_RULE_OP2,
		201 | SPEC_RULE_OP1 | SPEC_RULE_OP2 | SPEC_RULE_COMMUTATIVE,
		226 | SPEC_RULE_OP1 | SPEC_RULE_OP2 | SPEC_RULE_COMMUTATIVE,
		251 | SPEC_RULE_OP1 | SPEC_RULE_OP2 | SPEC_RULE_COMMUTATIVE,
		276 | SPEC_RULE_OP1 | SPEC_RULE_OP2,
		301 | SPEC_RULE_OP1,
		306 | SPEC_RULE_OP1,
		311 | SPEC_RULE_OP1 | SPEC_RULE_OP2 | SPEC_RULE_COMMUTATIVE,
		336 | SPEC_RULE_OP1 | SPEC_RULE_OP2 | SPEC_RULE_COMMUTATIVE,
		361 | SPEC_RULE_OP1 | SPEC_RULE_OP2 | SPEC_RULE_COMMUTATIVE,
		386 | SPEC_RULE_OP1 | SPEC_RULE_OP2 | SPEC_RULE_SMART_BRANCH | SPEC_RULE_COMMUTATIVE,
		461 | SPEC_RULE_OP1 | SPEC_RULE_OP2 | SPEC_RULE_SMART_BRANCH | SPEC_RULE_COMMUTATIVE,
		536 | SPEC_RULE_OP1 | SPEC_RULE_OP2 | SPEC_RULE_SMART_BRANCH,
		611 | SPEC_RULE_OP1 | SPEC_RULE_OP2 | SPEC_RULE_SMART_BRANCH,
		686 | SPEC_RULE_OP1 | SPEC_RULE_OP2 | SPEC_RULE_RETVAL,
		736 | SPEC_RULE_OP1 | SPEC_RULE_OP2 | SPEC_RULE_OP_DATA,
		861 | SPEC_RULE_OP1 | SPEC_RULE_OP2 | SPEC_RULE_OP_DATA,
		986 | SPEC_RULE_OP_DATA,
		991 | SPEC_RULE_OP1 | SPEC_RULE_OP2,
		1016 | SPEC_RULE_OP1 | SPEC_RULE_OP2,
		1041 | SPEC_RULE_OP1 | SPEC_RULE_OP2,
		1066,
		1067 | SPEC_RULE_OP1 | SPEC_RULE_OP2,
		1092 | SPEC_RULE_OP1,
		1097 | SPEC_RULE_OP1 | SPEC_RULE_OP2 | SPEC_RULE_OP_DATA,
		1222,
		1223 | SPEC_RULE_OP1 | SPEC_RULE_RETVAL,
		1233 | SPEC_RULE_OP1 | SPEC_RULE_RETVAL,
		1243 | SPEC_RULE_OP1,
		1248 | SPEC_RULE_OP1,
		1253,
		1253,
		1254,
		1254,
		1255,
		1256 | SPEC_RULE_OP1,
		1261 | SPEC_RULE_OP1,
		3476,
		1266 | SPEC_RULE_OP1,
		1271 | SPEC_RULE_OP1,
		1276 | SPEC_RULE_OP2,
		1281,
		1282 | SPEC_RULE_OP2 | SPEC_RULE_QUICK_ARG,
		1292 | SPEC_RULE_OP1,
		1297 | SPEC_RULE_OP1,
		1302 | SPEC_RULE_OP1 | SPEC_RULE_OP2,
		1327 | SPEC_RULE_OP2,
		1332 | SPEC_RULE_OP2,
		1337 | SPEC_RULE_OP2,
		1342,
		1343,
		1344,
		1345 | SPEC_RULE_RETVAL | SPEC_RULE_OBSERVER,
		1349,
		1350 | SPEC_RULE_OP1 | SPEC_RULE_OBSERVER,
		1360,
		1361,
		1362 | SPEC_RULE_OP1 | SPEC_RULE_OP2,
		1387 | SPEC_RULE_OP1 | SPEC_RULE_OP2 | SPEC_RULE_QUICK_ARG,
		1437 | SPEC_RULE_OP1 | SPEC_RULE_OP2,
		1462 | SPEC_RULE_OP1,
		1467,
		1468,
		1469 | SPEC_RULE_OP1 | SPEC_RULE_OP2,
		1494 | SPEC_RULE_OP1 | SPEC_RULE_OP2,
		1519 | SPEC_RULE_OP1 | SPEC_RULE_OBSERVER,
		1529 | SPEC_RULE_OP1,
		1534 | SPEC_RULE_OP1 | SPEC_RULE_OP2,
		1559 | SPEC_RULE_OP1 | SPEC_RULE_OP2,
		1584 | SPEC_RULE_OP1,
		1589,
		1590,
		1591 | SPEC_RULE_OP1,
		1596 | SPEC_RULE_OP1 | SPEC_RULE_OP2,
		1621 | SPEC_RULE_OP1 | SPEC_RULE_OP2,
		1646 | SPEC_RULE_OP1,
		1651 | SPEC_RULE_OP1 | SPEC_RULE_OP2,
		1676 | SPEC_RULE_OP1 | SPEC_RULE_OP2,
		1701 | SPEC_RULE_OP1,
		1706 | SPEC_RULE_OP1 | SPEC_RULE_OP2,
		1731 | SPEC_RULE_OP1 | SPEC_RULE_OP2,
		1756 | SPEC_RULE_OP1,
		1761 | SPEC_RULE_OP1 | SPEC_RULE_OP2,
		1786 | SPEC_RULE_OP1 | SPEC_RULE_OP2,
		1811 | SPEC_RULE_OP1,
		1816 | SPEC_RULE_OP1 | SPEC_RULE_OP2,
		1841 | SPEC_RULE_OP1 | SPEC_RULE_OP2,
		1866 | SPEC_RULE_OP1,
		1871 | SPEC_RULE_OP1 | SPEC_RULE_OP2,
		1896 | SPEC_RULE_OP1 | SPEC_RULE_OP2,
		1921 | SPEC_RULE_OP1 | SPEC_RULE_OP2,
		1946,
		1947 | SPEC_RULE_OP2 | SPEC_RULE_QUICK_ARG,
		1957,
		1958,
		1959,
		1960,
		1961,
		1962 | SPEC_RULE_OP2,
		1967,
		1968 | SPEC_RULE_OP1,
		1973 | SPEC_RULE_OP2,
		1978 | SPEC_RULE_OP1,
		1983 | SPEC_RULE_OP1 | SPEC_RULE_OBSERVER,
		1993 | SPEC_RULE_OP1 | SPEC_RULE_OP2,
		2018 | SPEC_RULE_OP1 | SPEC_RULE_OP2,
		2043 | SPEC_RULE_OP1,
		2048 | SPEC_RULE_OP1 | SPEC_RULE_OP2,
		2073 | SPEC_RULE_OP1 | SPEC_RULE_OP2 | SPEC_RULE_QUICK_ARG,
		2123 | SPEC_RULE_OP1 | SPEC_RULE_OP2,
		2148 | SPEC_RULE_OP2,
		2153,
		2154 | SPEC_RULE_OP1,
		2159 | SPEC_RULE_OP1,
		2164,
		2165 | SPEC_RULE_OP1,
		2170 | SPEC_RULE_OP1,
		2175 | SPEC_RULE_OP1,
		2180,
		2181,
		2182 | SPEC_RULE_OP2,
		2187 | SPEC_RULE_RETVAL | SPEC_RULE_OBSERVER,
		2191 | SPEC_RULE_RETVAL | SPEC_RULE_OBSERVER,
		2195 | SPEC_RULE_RETVAL | SPEC_RULE_OBSERVER,
		2199 | SPEC_RULE_OP1 | SPEC_RULE_OP2,
		2199 | SPEC_RULE_OP1 | SPEC_RULE_OP2,
		2224 | SPEC_RULE_OP1 | SPEC_RULE_OP2,
		2224 | SPEC_RULE_OP1 | SPEC_RULE_OP2,
		2249 | SPEC_RULE_OP1,
		2254,
		2255 | SPEC_RULE_OP1 | SPEC_RULE_OP2,
		2280,
		2281 | SPEC_RULE_OP1,
		2286,
		2287,
		2288,
		2289,
		2290,
		2291,
		2292,
		2293 | SPEC_RULE_OP1 | SPEC_RULE_OP2,
		2318,
		2319,
		2320,
		2321 | SPEC_RULE_OP1,
		2326,
		2327 | SPEC_RULE_ISSET,
		2329 | SPEC_RULE_OP2,
		2334,
		2335 | SPEC_RULE_OP1,
		2340 | SPEC_RULE_OBSERVER,
		2342,
		2343 | SPEC_RULE_OP1 | SPEC_RULE_OP2,
		2368 | SPEC_RULE_OP1 | SPEC_RULE_OBSERVER,
		2378,
		2379,
		2380,
		2381,
		2382 | SPEC_RULE_OP1,
		2387,
		2388,
		2389 | SPEC_RULE_OP1,
		2394 | SPEC_RULE_OP1 | SPEC_RULE_OP2,
		2419,
		2420 | SPEC_RULE_OP1,
		2425,
		2426,
		2427,
		2428,
		2429,
		2430,
		2431,
		2432,
		2433 | SPEC_RULE_OP1 | SPEC_RULE_OP2,
		2458,
		2459,
		2460,
		2461 | SPEC_RULE_OP2,
		2466,
		2467 | SPEC_RULE_OP1,
		2472 | SPEC_RULE_OP1,
		2477 | SPEC_RULE_OP1,
		2482 | SPEC_RULE_OP1,
		2487 | SPEC_RULE_OP1,
		2492,
		2493 | SPEC_RULE_OP1,
		2498 | SPEC_RULE_OP1 | SPEC_RULE_OP2,
		2523 | SPEC_RULE_OP1,
		2528 | SPEC_RULE_OP1 | SPEC_RULE_OP2,
		2553 | SPEC_RULE_OP1,
		2558 | SPEC_RULE_OP1,
		2563,
		2564,
		2565,
		2566,
		2567,
		3476,
		3476,
		3476,
		3476,
		3476,
		3476,
		3476,
		3476,
		3476,
		3476,
		3476,
		3476,
		3476,
		3476,
		3476,
		3476,
		3476,
		3476,
		3476,
		3476,
		3476,
		3476,
		3476,
		3476,
		3476,
		3476,
		3476,
		3476,
		3476,
		3476,
		3476,
		3476,
		3476,
		3476,
		3476,
		3476,
		3476,
		3476,
		3476,
		3476,
		3476,
		3476,
		3476,
		3476,
		3476,
		3476,
		3476,
		3476,
		3476,
		3476,
		3476,
		3476,
	};
#if (CREX_VM_KIND == CREX_VM_KIND_HYBRID)
	crex_opcode_handler_funcs = labels;
	crex_spec_handlers = specs;
	execute_ex(NULL);
#else
	crex_opcode_handlers = labels;
	crex_handlers_count = sizeof(labels) / sizeof(void*);
	crex_spec_handlers = specs;
#endif
	VM_TRACE_START();
}

static HashTable *crex_handlers_table = NULL;

void crex_vm_dtor(void)
{
	VM_TRACE_END();
	if (crex_handlers_table) {
		crex_hash_destroy(crex_handlers_table);
		free(crex_handlers_table);
		crex_handlers_table = NULL;
	}
}

static void init_opcode_serialiser(void)
{
	int i;
	zval tmp;

	crex_handlers_table = malloc(sizeof(HashTable));
	crex_hash_init(crex_handlers_table, crex_handlers_count, NULL, NULL, 1);
	crex_hash_real_init(crex_handlers_table, 0);
	C_TYPE_INFO(tmp) = IS_LONG;
	for (i = 0; i < crex_handlers_count; i++) {
		C_LVAL(tmp) = i;
		crex_hash_index_add(crex_handlers_table, (crex_long)(uintptr_t)crex_opcode_handlers[i], &tmp);
	}
}

CREX_API void CREX_FASTCALL crex_serialize_opcode_handler(crex_op *op)
{
	zval *zv;

	if (!crex_handlers_table) {
		init_opcode_serialiser();
	}
	zv = crex_hash_index_find(crex_handlers_table, (crex_long)(uintptr_t)op->handler);
	CREX_ASSERT(zv != NULL);
	op->handler = (const void *)(uintptr_t)C_LVAL_P(zv);
}

CREX_API void CREX_FASTCALL crex_deserialize_opcode_handler(crex_op *op)
{
	op->handler = crex_opcode_handlers[(uintptr_t)op->handler];
}

CREX_API const void* CREX_FASTCALL crex_get_opcode_handler_func(const crex_op *op)
{
#if CREX_VM_KIND == CREX_VM_KIND_CALL
	return op->handler;
#elif CREX_VM_KIND == CREX_VM_KIND_HYBRID
	zval *zv;

	if (!crex_handlers_table) {
		init_opcode_serialiser();
	}
	zv = crex_hash_index_find(crex_handlers_table, (crex_long)(uintptr_t)op->handler);
	CREX_ASSERT(zv != NULL);
	return crex_opcode_handler_funcs[C_LVAL_P(zv)];
#else
	return NULL;
#endif
}

CREX_API const crex_op *crex_get_halt_op(void)
{
#if CREX_VM_KIND == CREX_VM_KIND_HYBRID
	return &hybrid_halt_op;
#else
	return NULL;
#endif
}

CREX_API int crex_vm_kind(void)
{
	return CREX_VM_KIND;
}

static uint32_t CREX_FASTCALL crex_vm_get_opcode_handler_idx(uint32_t spec, const crex_op* op)
{
	static const int crex_vm_decode[] = {
		_UNUSED_CODE, /* 0 = IS_UNUSED  */
		_CONST_CODE,  /* 1 = IS_CONST   */
		_TMP_CODE,    /* 2 = IS_TMP_VAR */
		_UNUSED_CODE, /* 3              */
		_VAR_CODE,    /* 4 = IS_VAR     */
		_UNUSED_CODE, /* 5              */
		_UNUSED_CODE, /* 6              */
		_UNUSED_CODE, /* 7              */
		_CV_CODE      /* 8 = IS_CV      */
	};
	uint32_t offset = 0;
	if (spec & SPEC_RULE_OP1) offset = offset * 5 + crex_vm_decode[op->op1_type];
	if (spec & SPEC_RULE_OP2) offset = offset * 5 + crex_vm_decode[op->op2_type];
	if (spec & SPEC_EXTRA_MASK) {
		if (spec & SPEC_RULE_RETVAL) {
			offset = offset * 2 + (op->result_type != IS_UNUSED);
			if ((spec & SPEC_RULE_OBSERVER) && CREX_OBSERVER_ENABLED) {
				offset += 2;
			}
		} else if (spec & SPEC_RULE_QUICK_ARG) {
			offset = offset * 2 + (op->op2.num <= MAX_ARG_FLAG_NUM);
		} else if (spec & SPEC_RULE_OP_DATA) {
			offset = offset * 5 + crex_vm_decode[(op + 1)->op1_type];
		} else if (spec & SPEC_RULE_ISSET) {
			offset = offset * 2 + (op->extended_value & CREX_ISEMPTY);
		} else if (spec & SPEC_RULE_SMART_BRANCH) {
			offset = offset * 3;
			if (op->result_type == (IS_SMART_BRANCH_JMPZ|IS_TMP_VAR)) {
				offset += 1;
			} else if (op->result_type == (IS_SMART_BRANCH_JMPNZ|IS_TMP_VAR)) {
				offset += 2;
			}
		} else if (spec & SPEC_RULE_OBSERVER) {
			offset = offset * 2;
			if (CREX_OBSERVER_ENABLED) {
				offset += 1;
			}
		}
	}
	return (spec & SPEC_START_MASK) + offset;
}

#if (CREX_VM_KIND != CREX_VM_KIND_HYBRID) || !CREX_VM_SPEC
static const void *crex_vm_get_opcode_handler(uint8_t opcode, const crex_op* op)
{
	return crex_opcode_handlers[crex_vm_get_opcode_handler_idx(crex_spec_handlers[opcode], op)];
}
#endif

#if CREX_VM_KIND == CREX_VM_KIND_HYBRID
static const void *crex_vm_get_opcode_handler_func(uint8_t opcode, const crex_op* op)
{
	uint32_t spec = crex_spec_handlers[opcode];
	return crex_opcode_handler_funcs[crex_vm_get_opcode_handler_idx(spec, op)];
}

#endif

CREX_API void CREX_FASTCALL crex_vm_set_opcode_handler(crex_op* op)
{
	uint8_t opcode = crex_user_opcodes[op->opcode];

	if (crex_spec_handlers[op->opcode] & SPEC_RULE_COMMUTATIVE) {
		if (op->op1_type < op->op2_type) {
			crex_swap_operands(op);
		}
	}
	op->handler = crex_opcode_handlers[crex_vm_get_opcode_handler_idx(crex_spec_handlers[opcode], op)];
}

CREX_API void CREX_FASTCALL crex_vm_set_opcode_handler_ex(crex_op* op, uint32_t op1_info, uint32_t op2_info, uint32_t res_info)
{
	uint8_t opcode = crex_user_opcodes[op->opcode];
	uint32_t spec = crex_spec_handlers[opcode];
	switch (opcode) {
		case CREX_ADD:
			if (res_info == MAY_BE_LONG && op1_info == MAY_BE_LONG && op2_info == MAY_BE_LONG) {
				if (op->op1_type == IS_CONST && op->op2_type == IS_CONST) {
					break;
				}
				spec = 2575 | SPEC_RULE_OP1 | SPEC_RULE_OP2 | SPEC_RULE_COMMUTATIVE;
				if (op->op1_type < op->op2_type) {
					crex_swap_operands(op);
				}
			} else if (op1_info == MAY_BE_LONG && op2_info == MAY_BE_LONG) {
				if (op->op1_type == IS_CONST && op->op2_type == IS_CONST) {
					break;
				}
				spec = 2600 | SPEC_RULE_OP1 | SPEC_RULE_OP2 | SPEC_RULE_COMMUTATIVE;
				if (op->op1_type < op->op2_type) {
					crex_swap_operands(op);
				}
			} else if (op1_info == MAY_BE_DOUBLE && op2_info == MAY_BE_DOUBLE) {
				if (op->op1_type == IS_CONST && op->op2_type == IS_CONST) {
					break;
				}
				spec = 2625 | SPEC_RULE_OP1 | SPEC_RULE_OP2 | SPEC_RULE_COMMUTATIVE;
				if (op->op1_type < op->op2_type) {
					crex_swap_operands(op);
				}
			}
			break;
		case CREX_SUB:
			if (res_info == MAY_BE_LONG && op1_info == MAY_BE_LONG && op2_info == MAY_BE_LONG) {
				if (op->op1_type == IS_CONST && op->op2_type == IS_CONST) {
					break;
				}
				spec = 2650 | SPEC_RULE_OP1 | SPEC_RULE_OP2;
			} else if (op1_info == MAY_BE_LONG && op2_info == MAY_BE_LONG) {
				if (op->op1_type == IS_CONST && op->op2_type == IS_CONST) {
					break;
				}
				spec = 2675 | SPEC_RULE_OP1 | SPEC_RULE_OP2;
			} else if (op1_info == MAY_BE_DOUBLE && op2_info == MAY_BE_DOUBLE) {
				if (op->op1_type == IS_CONST && op->op2_type == IS_CONST) {
					break;
				}
				spec = 2700 | SPEC_RULE_OP1 | SPEC_RULE_OP2;
			}
			break;
		case CREX_MUL:
			if (op->op1_type < op->op2_type) {
				crex_swap_operands(op);
			}
			if (res_info == MAY_BE_LONG && op1_info == MAY_BE_LONG && op2_info == MAY_BE_LONG) {
				if (op->op1_type == IS_CONST && op->op2_type == IS_CONST) {
					break;
				}
				spec = 2725 | SPEC_RULE_OP1 | SPEC_RULE_OP2 | SPEC_RULE_COMMUTATIVE;
			} else if (op1_info == MAY_BE_LONG && op2_info == MAY_BE_LONG) {
				if (op->op1_type == IS_CONST && op->op2_type == IS_CONST) {
					break;
				}
				spec = 2750 | SPEC_RULE_OP1 | SPEC_RULE_OP2 | SPEC_RULE_COMMUTATIVE;
			} else if (op1_info == MAY_BE_DOUBLE && op2_info == MAY_BE_DOUBLE) {
				if (op->op1_type == IS_CONST && op->op2_type == IS_CONST) {
					break;
				}
				spec = 2775 | SPEC_RULE_OP1 | SPEC_RULE_OP2 | SPEC_RULE_COMMUTATIVE;
			}
			break;
		case CREX_IS_IDENTICAL:
			if (op->op1_type < op->op2_type) {
				crex_swap_operands(op);
			}
			if (op1_info == MAY_BE_LONG && op2_info == MAY_BE_LONG) {
				if (op->op1_type == IS_CONST && op->op2_type == IS_CONST) {
					break;
				}
				spec = 2800 | SPEC_RULE_OP1 | SPEC_RULE_OP2 | SPEC_RULE_SMART_BRANCH | SPEC_RULE_COMMUTATIVE;
			} else if (op1_info == MAY_BE_DOUBLE && op2_info == MAY_BE_DOUBLE) {
				if (op->op1_type == IS_CONST && op->op2_type == IS_CONST) {
					break;
				}
				spec = 2875 | SPEC_RULE_OP1 | SPEC_RULE_OP2 | SPEC_RULE_SMART_BRANCH | SPEC_RULE_COMMUTATIVE;
			} else if (op->op1_type == IS_CV && (op->op2_type & (IS_CONST|IS_CV)) && !(op1_info & (MAY_BE_UNDEF|MAY_BE_REF)) && !(op2_info & (MAY_BE_UNDEF|MAY_BE_REF))) {
				spec = 3100 | SPEC_RULE_OP2 | SPEC_RULE_COMMUTATIVE;
			}
			break;
		case CREX_IS_NOT_IDENTICAL:
			if (op->op1_type < op->op2_type) {
				crex_swap_operands(op);
			}
			if (op1_info == MAY_BE_LONG && op2_info == MAY_BE_LONG) {
				if (op->op1_type == IS_CONST && op->op2_type == IS_CONST) {
					break;
				}
				spec = 2950 | SPEC_RULE_OP1 | SPEC_RULE_OP2 | SPEC_RULE_SMART_BRANCH | SPEC_RULE_COMMUTATIVE;
			} else if (op1_info == MAY_BE_DOUBLE && op2_info == MAY_BE_DOUBLE) {
				if (op->op1_type == IS_CONST && op->op2_type == IS_CONST) {
					break;
				}
				spec = 3025 | SPEC_RULE_OP1 | SPEC_RULE_OP2 | SPEC_RULE_SMART_BRANCH | SPEC_RULE_COMMUTATIVE;
			} else if (op->op1_type == IS_CV && (op->op2_type & (IS_CONST|IS_CV)) && !(op1_info & (MAY_BE_UNDEF|MAY_BE_REF)) && !(op2_info & (MAY_BE_UNDEF|MAY_BE_REF))) {
				spec = 3105 | SPEC_RULE_OP2 | SPEC_RULE_COMMUTATIVE;
			}
			break;
		case CREX_IS_EQUAL:
			if (op->op1_type < op->op2_type) {
				crex_swap_operands(op);
			}
			if (op1_info == MAY_BE_LONG && op2_info == MAY_BE_LONG) {
				if (op->op1_type == IS_CONST && op->op2_type == IS_CONST) {
					break;
				}
				spec = 2800 | SPEC_RULE_OP1 | SPEC_RULE_OP2 | SPEC_RULE_SMART_BRANCH | SPEC_RULE_COMMUTATIVE;
			} else if (op1_info == MAY_BE_DOUBLE && op2_info == MAY_BE_DOUBLE) {
				if (op->op1_type == IS_CONST && op->op2_type == IS_CONST) {
					break;
				}
				spec = 2875 | SPEC_RULE_OP1 | SPEC_RULE_OP2 | SPEC_RULE_SMART_BRANCH | SPEC_RULE_COMMUTATIVE;
			}
			break;
		case CREX_IS_NOT_EQUAL:
			if (op->op1_type < op->op2_type) {
				crex_swap_operands(op);
			}
			if (op1_info == MAY_BE_LONG && op2_info == MAY_BE_LONG) {
				if (op->op1_type == IS_CONST && op->op2_type == IS_CONST) {
					break;
				}
				spec = 2950 | SPEC_RULE_OP1 | SPEC_RULE_OP2 | SPEC_RULE_SMART_BRANCH | SPEC_RULE_COMMUTATIVE;
			} else if (op1_info == MAY_BE_DOUBLE && op2_info == MAY_BE_DOUBLE) {
				if (op->op1_type == IS_CONST && op->op2_type == IS_CONST) {
					break;
				}
				spec = 3025 | SPEC_RULE_OP1 | SPEC_RULE_OP2 | SPEC_RULE_SMART_BRANCH | SPEC_RULE_COMMUTATIVE;
			}
			break;
		case CREX_IS_SMALLER:
			if (op1_info == MAY_BE_LONG && op2_info == MAY_BE_LONG) {
				if (op->op1_type == IS_CONST && op->op2_type == IS_CONST) {
					break;
				}
				spec = 3110 | SPEC_RULE_OP1 | SPEC_RULE_OP2 | SPEC_RULE_SMART_BRANCH;
			} else if (op1_info == MAY_BE_DOUBLE && op2_info == MAY_BE_DOUBLE) {
				if (op->op1_type == IS_CONST && op->op2_type == IS_CONST) {
					break;
				}
				spec = 3185 | SPEC_RULE_OP1 | SPEC_RULE_OP2 | SPEC_RULE_SMART_BRANCH;
			}
			break;
		case CREX_IS_SMALLER_OR_EQUAL:
			if (op1_info == MAY_BE_LONG && op2_info == MAY_BE_LONG) {
				if (op->op1_type == IS_CONST && op->op2_type == IS_CONST) {
					break;
				}
				spec = 3260 | SPEC_RULE_OP1 | SPEC_RULE_OP2 | SPEC_RULE_SMART_BRANCH;
			} else if (op1_info == MAY_BE_DOUBLE && op2_info == MAY_BE_DOUBLE) {
				if (op->op1_type == IS_CONST && op->op2_type == IS_CONST) {
					break;
				}
				spec = 3335 | SPEC_RULE_OP1 | SPEC_RULE_OP2 | SPEC_RULE_SMART_BRANCH;
			}
			break;
		case CREX_QM_ASSIGN:
			if (op1_info == MAY_BE_LONG) {
				spec = 3422 | SPEC_RULE_OP1;
			} else if (op1_info == MAY_BE_DOUBLE) {
				spec = 3427 | SPEC_RULE_OP1;
			} else if ((op->op1_type == IS_CONST) ? !C_REFCOUNTED_P(RT_CONSTANT(op, op->op1)) : (!(op1_info & ((MAY_BE_ANY|MAY_BE_UNDEF)-(MAY_BE_NULL|MAY_BE_FALSE|MAY_BE_TRUE|MAY_BE_LONG|MAY_BE_DOUBLE))))) {
				spec = 3432 | SPEC_RULE_OP1;
			}
			break;
		case CREX_PRE_INC:
			if (res_info == MAY_BE_LONG && op1_info == MAY_BE_LONG) {
				spec = 3410 | SPEC_RULE_RETVAL;
			} else if (op1_info == MAY_BE_LONG) {
				spec = 3412 | SPEC_RULE_RETVAL;
			}
			break;
		case CREX_PRE_DEC:
			if (res_info == MAY_BE_LONG && op1_info == MAY_BE_LONG) {
				spec = 3414 | SPEC_RULE_RETVAL;
			} else if (op1_info == MAY_BE_LONG) {
				spec = 3416 | SPEC_RULE_RETVAL;
			}
			break;
		case CREX_POST_INC:
			if (res_info == MAY_BE_LONG && op1_info == MAY_BE_LONG) {
				spec = 3418;
			} else if (op1_info == MAY_BE_LONG) {
				spec = 3419;
			}
			break;
		case CREX_POST_DEC:
			if (res_info == MAY_BE_LONG && op1_info == MAY_BE_LONG) {
				spec = 3420;
			} else if (op1_info == MAY_BE_LONG) {
				spec = 3421;
			}
			break;
		case CREX_JMP:
			if (OP_JMP_ADDR(op, op->op1) > op) {
				spec = 2574;
			}
			break;
		case CREX_RECV:
			if (op->op2.num == MAY_BE_ANY) {
				spec = 2568;
			}
			break;
		case CREX_SEND_VAL:
			if (op->op1_type == IS_CONST && op->op2_type == IS_UNUSED && !C_REFCOUNTED_P(RT_CONSTANT(op, op->op1))) {
				spec = 3472;
			}
			break;
		case CREX_SEND_VAR_EX:
			if (op->op2_type == IS_UNUSED && op->op2.num <= MAX_ARG_FLAG_NUM && (op1_info & (MAY_BE_UNDEF|MAY_BE_REF)) == 0) {
				spec = 3467 | SPEC_RULE_OP1;
			}
			break;
		case CREX_FE_FETCH_R:
			if (op->op2_type == IS_CV && (op1_info & (MAY_BE_ANY|MAY_BE_REF)) == MAY_BE_ARRAY) {
				spec = 3474 | SPEC_RULE_RETVAL;
			}
			break;
		case CREX_FETCH_DIM_R:
			if (!(op2_info & (MAY_BE_UNDEF|MAY_BE_NULL|MAY_BE_STRING|MAY_BE_ARRAY|MAY_BE_OBJECT|MAY_BE_RESOURCE|MAY_BE_REF))) {
				if (op->op1_type == IS_CONST && op->op2_type == IS_CONST) {
					break;
				}
				spec = 3437 | SPEC_RULE_OP1 | SPEC_RULE_OP2;
			}
			break;
		case CREX_SEND_VAL_EX:
			if (op->op2_type == IS_UNUSED && op->op2.num <= MAX_ARG_FLAG_NUM && op->op1_type == IS_CONST && !C_REFCOUNTED_P(RT_CONSTANT(op, op->op1))) {
				spec = 3473;
			}
			break;
		case CREX_SEND_VAR:
			if (op->op2_type == IS_UNUSED && (op1_info & (MAY_BE_UNDEF|MAY_BE_REF)) == 0) {
				spec = 3462 | SPEC_RULE_OP1;
			}
			break;
		case CREX_COUNT:
			if ((op1_info & (MAY_BE_ANY|MAY_BE_UNDEF|MAY_BE_REF)) == MAY_BE_ARRAY) {
				spec = 2569 | SPEC_RULE_OP1;
			}
			break;
		case CREX_BW_OR:
		case CREX_BW_AND:
		case CREX_BW_XOR:
		case CREX_BOOL_XOR:
			if (op->op1_type < op->op2_type) {
				crex_swap_operands(op);
			}
			break;
		case CREX_USER_OPCODE:
			if (crex_spec_handlers[op->opcode] & SPEC_RULE_COMMUTATIVE) {
				if (op->op1_type < op->op2_type) {
					crex_swap_operands(op);
				}
			}
			break;
		default:
			break;
	}
	op->handler = crex_opcode_handlers[crex_vm_get_opcode_handler_idx(spec, op)];
}

CREX_API int CREX_FASTCALL crex_vm_call_opcode_handler(crex_execute_data* ex)
{
#if (CREX_VM_KIND == CREX_VM_KIND_HYBRID)
	opcode_handler_t handler;
#endif
	int ret;
#ifdef CREX_VM_IP_GLOBAL_REG
	const crex_op *orig_opline = opline;
#endif
#ifdef CREX_VM_FP_GLOBAL_REG
	crex_execute_data *orig_execute_data = execute_data;
	execute_data = ex;
#else
	crex_execute_data *execute_data = ex;
#endif

	LOAD_OPLINE();
#if defined(CREX_VM_FP_GLOBAL_REG) && defined(CREX_VM_IP_GLOBAL_REG)
#if (CREX_VM_KIND == CREX_VM_KIND_HYBRID)
	handler = (opcode_handler_t)crex_vm_get_opcode_handler_func(crex_user_opcodes[opline->opcode], opline);
	handler(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
	if (EXPECTED(opline != &hybrid_halt_op)) {
#else
	((opcode_handler_t)OPLINE->handler)(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
	if (EXPECTED(opline)) {
#endif
		ret = execute_data != ex ? (int)(execute_data->prev_execute_data != ex) + 1 : 0;
		SAVE_OPLINE();
	} else {
		ret = -1;
	}
#else
	ret = ((opcode_handler_t)OPLINE->handler)(CREX_OPCODE_HANDLER_ARGS_PASSTHRU);
	SAVE_OPLINE();
#endif
#ifdef CREX_VM_FP_GLOBAL_REG
	execute_data = orig_execute_data;
#endif
#ifdef CREX_VM_IP_GLOBAL_REG
	opline = orig_opline;
#endif
	return ret;
}

