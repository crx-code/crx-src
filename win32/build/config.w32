// vim:ft=javascript
// "Master" config file; think of it as a configure.ac
// equivalent.

ARG_WITH("verbosity", "Output verbosity, 0-2.", "1");
setup_verbosity();

ARG_WITH("toolset", "Toolset to use for the compilation, give: vs, clang, icc. " +
		"The only recommended and supported toolset for production use " +
		"is Visual Studio. Use others at your own risk.", "vs");
toolset_option_handle();

ARG_WITH('cygwin', 'Path to cygwin utilities on your system', '\\cygwin');

toolset_setup_compiler();

HOST_ARCH = toolset_host_arch();
TARGET_ARCH = toolset_target_arch();
// for compatible only
X64 = TARGET_ARCH != 'x86';
toolset_setup_arch();

toolset_setup_linker();
toolset_setup_project_tools();

// stick objects somewhere outside of the source tree
ARG_ENABLE('object-out-dir', 'Alternate location for binary objects during build', '');
object_out_dir_option_handle();

ARG_ENABLE('debug', 'Compile with debugging symbols', "no");
ARG_ENABLE('debug-pack', 'Release binaries with external debug symbols (--enable-debug must not be specified)', 'no');
if (CRX_DEBUG == "yes" && CRX_DEBUG_PACK == "yes") {
	ERROR("Use of both --enable-debug and --enable-debug-pack not allowed.");
}

if (CRX_DEBUG == "yes") {
	ADD_FLAG("CFLAGS"," /Wall ");
	ADD_FLAG("LDFLAGS", " /verbose ");
}

ARG_ENABLE('pgi', 'Generate PGO instrumented binaries', 'no');
ARG_WITH('pgo', 'Compile optimized binaries using training data from folder', 'no');
if (CRX_PGI == "yes" || CRX_PGO != "no") {
	PGOMGR = PATH_PROG('pgomgr', WshShell.Environment("Process").Item("PATH"));
	if (!PGOMGR) {
		ERROR("--enable-pgi and --with-pgo options can only be used if PGO capable compiler is present.");
	}
	if (CRX_PGI == "yes" && CRX_PGO != "no") {
		ERROR("Use of both --enable-pgi and --with-pgo not allowed.");
	}
}

ARG_ENABLE('zts', 'Thread safety', 'yes');
// Configures the hard-coded installation dir
ARG_WITH('prefix', 'where CRX will be installed', '');
if (CRX_PREFIX == '') {
	CRX_PREFIX = "C:\\crx";
	if (CRX_DEBUG == "yes")
		CRX_PREFIX += "\\debug";
}
DEFINE('CRX_PREFIX', CRX_PREFIX);

DEFINE("BASE_INCLUDES", "/I . /I main /I Crex /I TSRM /I ext ");

toolset_setup_common_cflags();

if (VS_TOOLSET) {
	ARG_WITH('mp', 'Tell Visual Studio use up to [n,auto,disable] processes for compilation', 'auto');
	var CRX_MP_DISABLED = true;

	if (CRX_MP != 'disable') {
		if(CRX_DEBUG == 'yes') {
			STDOUT.WriteLine('WARNING: Debug builds cannot be built using multi processing');
		} else {
			// no from disable-all
			if(CRX_MP == 'auto' || CRX_MP == 'no') {
				ADD_FLAG('CFLAGS', ' /MP ');
				CRX_MP_DISABLED = false;
			} else {
				if(parseInt(CRX_MP) != 0) {
					ADD_FLAG('CFLAGS', ' /MP'+ CRX_MP +' ');
					CRX_MP_DISABLED = false;
				} else {
					STDOUT.WriteLine('WARNING: Invalid argument for MP: ' + CRX_MP);
				}
			}
		}
	}

	if (!CRX_MP_DISABLED) {
		STDOUT.WriteLine('Enabling multi process build');
	}
}

// General link flags
toolset_setup_common_ldlags();

// General libs
toolset_setup_common_libs();

// Set some debug/release specific options
toolset_setup_build_mode();

setup_zts_stuff();

// CFLAGS, LDFLAGS and BUILD_DIR are defined
// Add compiler and link flags if PGO options are selected
if (CRX_DEBUG != "yes" && CRX_PGI == "yes") {
	ADD_FLAG("STATIC_EXT_CFLAGS", "/GL /O2");
	DEFINE("PGOPGD_DIR", "$(BUILD_DIR)");
}
else if (CRX_DEBUG != "yes" && CRX_PGO != "no") {
	ADD_FLAG("STATIC_EXT_CFLAGS", "/GL /O2");
	DEFINE("PGOPGD_DIR", ((CRX_PGO.length == 0 || CRX_PGO == "yes") ? "$(BUILD_DIR)" : CRX_PGO));
}

// Find the crx_build dir - it contains headers and libraries
// that we need
ARG_WITH('crx-build', 'Path to where you extracted the development libraries (http://wiki.crx.net/internals/windows/libs). Assumes that it is a sibling of this source dir (..\\deps) if not specified', 'no');
crx_build_option_handle();

ARG_WITH('extra-includes', 'Extra include path to use when building everything', '');
ARG_WITH('extra-libs', 'Extra library path to use when linking everything', '');

var crx_usual_include_suspects = CRX_CRX_BUILD+"\\include";
var crx_usual_lib_suspects = CRX_CRX_BUILD+"\\lib";

ADD_FLAG("CFLAGS", '/I "' + crx_usual_include_suspects + '" ');
ADD_FLAG("LDFLAGS", '/libpath:"' + crx_usual_lib_suspects + '" ');
ADD_FLAG("ARFLAGS", '/nologo /libpath:"' + crx_usual_lib_suspects + '" ');

probe_basic_headers();
add_extra_dirs();

//DEFINE("CRX_BUILD", CRX_CRX_BUILD);

ARG_WITH("analyzer", "Enable static analyzer. Pass vs for Visual Studio, clang for clang, cppcheck for Cppcheck, pvs for PVS-Studio", "no");
if (CRX_ANALYZER == "vs") {
	ADD_FLAG("CFLAGS", " /analyze ");
	ADD_FLAG("CFLAGS", " /wd6308 ");
} else if (CRX_ANALYZER == "clang") {
	var clang_cl = false;

	if (FSO.FileExists(PROGRAM_FILES + "\\LLVM\\bin\\clang-cl.exe")) {
		clang_cl = PROGRAM_FILES + "\\LLVM\\bin\\clang-cl.exe";
	} else if (FSO.FileExists(PROGRAM_FILESx86 + "\\LLVM\\bin\\clang-cl.exe")) {
		clang_cl = PROGRAM_FILESx86 + "\\LLVM\\bin\\clang-cl.exe";
	}

	if (!clang_cl) {
		if (false == PATH_PROG('clang-cl', null, 'CLANG_CL')) {
			WARNING("Couldn't find clang binaries, static analyze was disabled");
			CRX_ANALYZER = "no";
		}
	} else {
		DEFINE("CLANG_CL", clang_cl);
	}
} else if (CRX_ANALYZER == "cppcheck") {

	var cppcheck = false;

	if (FSO.FileExists(PROGRAM_FILES + "\\Cppcheck\\cppcheck.exe")) {
		cppcheck = PROGRAM_FILES + "\\Cppcheck\\cppcheck.exe";
	} else if (FSO.FileExists(PROGRAM_FILESx86 + "\\Cppcheck\\cppcheck.exe")) {
		cppcheck = PROGRAM_FILESx86 + "\\Cppcheck\\cppcheck.exe";
	}
	if (!cppcheck) {
		if (false == PATH_PROG('cppcheck', null, 'CPPCHECK')) {
			WARNING("Couldn't find Cppcheck binaries, static analyze was disabled");
			CRX_ANALYZER = "no";
		} else {
			cppcheck = get_define("CPPCHECK");
		}
	} else {
		DEFINE("CPPCHECK", cppcheck);
	}

	if (cppcheck) {
		var _tmp = execute(cppcheck + " --version").split(/ /)[1];
		var cppcheck_ver = [
			parseInt(_tmp.split(".")[0]),
			parseInt(_tmp.split(".")[1]),
		];
		if (cppcheck_ver[0] > 1 || cppcheck_ver[0] == 1 && cppcheck_ver[1] >= 77) {
			var build_dir = get_define("BUILD_DIR");
			var cppcheck_build_dir = build_dir + "\\cppcheck_build";
			if (!FSO.FolderExists(cppcheck_build_dir)) {
				FSO.CreateFolder(cppcheck_build_dir);
			}
			DEFINE("CPPCHECK_BUILD_DIR", cppcheck_build_dir);
		}
	}

} else if (CRX_ANALYZER == "pvs") {
	var pvs_studio = false;

	if (FSO.FileExists(PROGRAM_FILES + "\\PVS-Studio\\x64\\PVS-Studio.exe")) {
		pvs_studio = PROGRAM_FILES + "\\PVS-Studio\\x86\\PVS-Studio.exe";
	} else if (FSO.FileExists(PROGRAM_FILESx86 + "\\PVS-Studio\\x64\\PVS-Studio.exe")) {
		pvs_studio = PROGRAM_FILESx86 + "\\PVS-Studio\\x64\\PVS-Studio.exe";
	}

	if (!pvs_studio) {
		WARNING("Couldn't find PVS-Studio binaries, static analyze was disabled");
		CRX_ANALYZER = "no";
	} else {
		var pvscfg = FSO.CreateTextFile("PVS-Studio.conf", true);
		DEFINE("PVS_STUDIO", pvs_studio);

		pvscfg.WriteLine("exclude-path = " + VCINSTALLDIR);
		if (FSO.FolderExists(PROGRAM_FILESx86 + "\\windows kits\\")) {
			pvscfg.WriteLine("exclude-path = " + PROGRAM_FILESx86 + "\\windows kits\\");
		} else if (FSO.FolderExists(PROGRAM_FILES + "\\windows kits\\")) {
			pvscfg.WriteLine("exclude-path = " + PROGRAM_FILES + "\\windows kits\\");
		}
		pvscfg.WriteLine("vcinstalldir = " + VCINSTALLDIR);
		pvscfg.WriteLine("platform = " + (TARGET_ARCH == 'x86' ? 'Win32' : 'x64'));
		pvscfg.WriteLine("preprocessor = visualcpp");
		pvscfg.WriteLine("language = C");
		pvscfg.WriteLine("skip-cl-exe = no");
	}
} else {
	CRX_ANALYZER = "no"
}

STDOUT.WriteBlankLines(1);
STDOUT.WriteLine("Build dir: " + get_define('BUILD_DIR'));
STDOUT.WriteLine("CRX Core:  " + get_define('CRXDLL') + " and " + get_define('CRXLIB'));

ADD_SOURCES("Crex", "crex_language_parser.c crex_language_scanner.c \
	crex_ini_parser.c crex_ini_scanner.c crex_alloc.c crex_call_stack.c \
	crex_compile.c crex_constants.c crex_exceptions.c \
	crex_execute_API.c crex_highlight.c \
	crex_llist.c crex_vm_opcodes.c crex_opcode.c crex_operators.c crex_ptr_stack.c \
	crex_stack.c crex_variables.c crex.c crex_API.c crex_extensions.c \
	crex_hash.c crex_list.c crex_builtin_functions.c crex_attributes.c \
	crex_ini.c crex_sort.c crex_multibyte.c \
	crex_stream.c crex_iterators.c crex_interfaces.c crex_objects.c \
	crex_object_handlers.c crex_objects_API.c \
	crex_default_classes.c crex_execute.c crex_strtod.c crex_gc.c crex_closures.c crex_weakrefs.c \
	crex_float.c crex_string.c crex_generators.c crex_virtual_cwd.c crex_ast.c \
	crex_inheritance.c crex_smart_str.c crex_cpuinfo.c crex_observer.c crex_system_id.c \
	crex_enum.c crex_fibers.c crex_atomic.c crex_hrtime.c");
ADD_SOURCES("Crex\\Optimizer", "crex_optimizer.c pass1.c pass3.c optimize_func_calls.c block_pass.c optimize_temp_vars_5.c nop_removal.c compact_literals.c crex_cfg.c crex_dfg.c dfa_pass.c crex_ssa.c crex_inference.c crex_func_info.c crex_call_graph.c crex_dump.c escape_analysis.c compact_vars.c dce.c sccp.c scdf.c");

var CRX_ASSEMBLER = PATH_PROG({
	'x64': 'ML64',
	'x86': 'ML',
	'arm64': 'armasm64'
}[TARGET_ARCH]);
if (!CRX_ASSEMBLER) {
	ERROR("No assembler found, fiber cannot be built");
}
DEFINE('CRX_ASSEMBLER', CRX_ASSEMBLER);
DEFINE('FIBER_ASSEMBLER', CRX_ASSEMBLER);// for compatible

var FIBER_ASM_ARCH = {
	'x64': 'x86_64',
	'x86': 'i386',
	'arm64': 'arm64'
}[TARGET_ARCH];
DEFINE('FIBER_ASM_ARCH', FIBER_ASM_ARCH); // for compatible only

var FIBER_ASM_ABI = {
	'x64': 'x86_64_ms_pe_masm',
	'x86': 'i386_ms_pe_masm',
	'arm64': 'arm64_aapcs_pe_armasm'
}[TARGET_ARCH];
DEFINE('FIBER_ASM_ABI', FIBER_ASM_ABI);

if (TARGET_ARCH == 'arm64') {
	DEFINE('FIBER_ASM_FLAGS', '-nologo -machine ARM64 -o');
} else {
	DEFINE('FIBER_ASM_FLAGS', '/DBOOST_CONTEXT_EXPORT=EXPORT /nologo /c /Fo');
}

ADD_FLAG('ASM_OBJS', '$(BUILD_DIR)\\Crex\\jump_' + FIBER_ASM_ABI + '.obj $(BUILD_DIR)\\Crex\\make_' + FIBER_ASM_ABI + '.obj');

MFO.WriteLine('$(BUILD_DIR)\\Crex\\jump_' + FIBER_ASM_ABI + '.obj: Crex\\asm\\jump_' + FIBER_ASM_ABI + '.asm');
MFO.WriteLine('\t$(CRX_ASSEMBLER) $(FIBER_ASM_FLAGS) $(BUILD_DIR)\\Crex\\jump_$(FIBER_ASM_ABI).obj Crex\\asm\\jump_$(FIBER_ASM_ABI).asm');

MFO.WriteLine('$(BUILD_DIR)\\Crex\\make_' + FIBER_ASM_ABI + '.obj: Crex\\asm\\make_' + FIBER_ASM_ABI + '.asm');
MFO.WriteLine('\t$(CRX_ASSEMBLER) $(FIBER_ASM_FLAGS) $(BUILD_DIR)\\Crex\\make_$(FIBER_ASM_ABI).obj Crex\\asm\\make_$(FIBER_ASM_ABI).asm');

ADD_FLAG("CFLAGS_BD_CREX", "/D CREX_ENABLE_STATIC_TSRMLS_CACHE=1");
if (VS_TOOLSET && VCVERS >= 1914) {
	ADD_FLAG("CFLAGS_BD_CREX", "/d2FuncCache1");
}

/* XXX inspect this for other toolsets */
//AC_DEFINE('CREX_DVAL_TO_LVAL_CAST_OK', 1);

ADD_SOURCES("main", "main.c snprintf.c spprintf.c getopt.c fopen_wrappers.c \
	crx_ini_builder.c \
	crx_scandir.c crx_ini.c SAPI.c rfc1867.c crx_content_types.c strlcpy.c \
	strlcat.c reentrancy.c crx_variables.c crx_ticks.c network.c \
	crx_open_temporary_file.c output.c internal_functions.c \
	crx_syslog.c crx_odbc_utils.c safe_bcmp.c");
ADD_FLAG("CFLAGS_BD_MAIN", "/D CREX_ENABLE_STATIC_TSRMLS_CACHE=1");
if (VS_TOOLSET && VCVERS >= 1914) {
	ADD_FLAG("CFLAGS_BD_MAIN", "/d2FuncCache1");
}

AC_DEFINE('HAVE_STRNLEN', 1);

AC_DEFINE('CREX_CHECK_STACK_LIMIT', 1)

ADD_SOURCES("main/streams", "streams.c cast.c memory.c filter.c plain_wrapper.c \
	userspace.c transports.c xp_socket.c mmap.c glob_wrapper.c");
ADD_FLAG("CFLAGS_BD_MAIN_STREAMS", "/D CREX_ENABLE_STATIC_TSRMLS_CACHE=1");
if (VS_TOOLSET && VCVERS >= 1914) {
	ADD_FLAG("CFLAGS_BD_MAIN_STREAMS", "/d2FuncCache1");
}

ADD_SOURCES("win32", "dllmain.c glob.c readdir.c \
	registry.c select.c sendmail.c time.c winutil.c wsyslog.c globals.c \
	getrusage.c ftok.c ioutil.c codepage.c nice.c \
	inet.c fnmatch.c sockets.c console.c signal.c");

ADD_FLAG("CFLAGS_BD_WIN32", "/D CREX_ENABLE_STATIC_TSRMLS_CACHE=1");
if (VS_TOOLSET && VCVERS >= 1914) {
	ADD_FLAG("CFLAGS_BD_WIN32", "/d2FuncCache1");
}

CRX_INSTALL_HEADERS("", "Crex/ TSRM/ main/ main/streams/ win32/");
CRX_INSTALL_HEADERS("Crex/Optimizer", "crex_call_graph.h crex_cfg.h crex_dump.h crex_func_info.h crex_inference.h crex_optimizer.h crex_ssa.h");

STDOUT.WriteBlankLines(1);


/* Can we build with IPv6 support? */
ARG_ENABLE("ipv6", "Disable IPv6 support (default is turn it on if available)", "yes");

var main_network_has_ipv6 = 0;
if (CRX_IPV6 == "yes") {
	main_network_has_ipv6 = CHECK_HEADER_ADD_INCLUDE("wspiapi.h", "CFLAGS") ? 1 : 0;
}
if (main_network_has_ipv6) {
	STDOUT.WriteLine("Enabling IPv6 support");
	AC_DEFINE('HAVE_GAI_STRERROR', 1);
	AC_DEFINE('HAVE_IPV6', 1);
}

/* this allows up to 256 sockets to be select()ed in a single
 * call to select(), instead of the usual 64 */
ARG_ENABLE('fd-setsize', "Set maximum number of sockets for select(2)", "256");
ADD_FLAG("CFLAGS", "/D FD_SETSIZE=" + parseInt(CRX_FD_SETSIZE));

/* For snapshot builders, where can we find the additional
 * files that make up the snapshot template? */
ARG_WITH("snapshot-template", "Path to snapshot builder template dir", "no");

if (CRX_SNAPSHOT_TEMPLATE == "no") {
	/* default is as a sibling of the crx_build dir */
	if (FSO.FolderExists(CRX_CRX_BUILD + "\\template")) {
		CRX_SNAPSHOT_TEMPLATE = FSO.GetAbsolutePathName(CRX_CRX_BUILD + "\\template");
	} else if (FSO.FolderExists(CRX_CRX_BUILD + "\\..\\template")) {
		CRX_SNAPSHOT_TEMPLATE = FSO.GetAbsolutePathName(CRX_CRX_BUILD + "\\..\\template");
	}
}

DEFINE('SNAPSHOT_TEMPLATE', CRX_SNAPSHOT_TEMPLATE);

ARG_ENABLE("security-flags", "Disable the compiler security flags", "yes");
if (CRX_SECURITY_FLAGS == "yes") {
	ADD_FLAG("LDFLAGS", "/NXCOMPAT /DYNAMICBASE ");
}

if (CLANG_TOOLSET) {
	ARG_WITH("uncritical-warn-choke", "Disable some uncritical warnings", "yes");
	if (CRX_UNCRITICAL_WARN_CHOKE != "no") {
		ADD_FLAG("CFLAGS", "-Wno-ignored-attributes -Wno-deprecated-declarations -Wno-missing-braces " +
		"-Wno-logical-op-parentheses -Wno-msvc-include -Wno-invalid-source-encoding -Wno-unknown-pragmas " +
		"-Wno-unused-command-line-argument -Wno-unused-function -Wno-ignored-pragma-optimize");
	}

	ARG_ENABLE("sanitizer", "Enable ASan and UBSan extensions", "no");
	if (CRX_SANITIZER == "yes") {
		if (COMPILER_NUMERIC_VERSION < 500) {
			ERROR("Clang at least 5.0.0 required for sanitation plugins");
		}
		add_asan_opts("CFLAGS", "LIBS", "LDFLAGS");
	}
}

ARG_WITH("codegen-arch", "Architecture for code generation: ia32. Use --enable-native-intrinsics to enable SIMD optimizations.", "no");
toolset_setup_codegen_arch();

ARG_WITH("all-shared", "Force all the non obligatory extensions to be shared", "no");

// Config profiles (--with-config-profile=<name>) will save a certain config to crx-src/config.<name>.bat
// so that it can be executed like: cofig.<name> instead of a long list of parameters
//
// Note, nice as a name is disallowed and will generate a warning and skip saving
ARG_WITH('config-profile', 'Name of the configuration profile to save this to in crx-src/config.name.bat', 'no');

ARG_ENABLE("test-ini", "Enable automatic crx.ini generation. The test.ini will be put \
		into the build dir and used to automatically load the shared extensions.", "yes");

ARG_WITH("test-ini-ext-exclude", "Comma separated list of shared extensions to \
		be excluded from the test.ini", "no");

ARG_ENABLE("native-intrinsics", "Comma separated list of intrinsic optimizations to enable. \
	Available instruction set names are sse, sse2, sse3, ssse3, sse4.1, sse4.2, avx, avx2. \
	SSE and SSE2 are enabled by default. The best instruction set specified will \
	automatically enable all the older instruction sets. Note, that the produced binary \
	might not work properly, if the chosen instruction sets are not available on the target \
	processor.", "no");
toolset_setup_intrinsic_cflags();
